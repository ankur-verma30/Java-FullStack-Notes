Program❓
A Program is a set of instructions written in a programming language that tells the computer how to perform a specific task.
✅ For Example: Microsoft Word is a program that allows you to write and edit documents. It is a program that is used to create and edit documents.

Process❓
A process is an instance of a program that is being executed. When a program runs, the operating system creates a process to manage its execution.
When we open Microsoft Word, it becomes a process in the operating system.          

Thread❓
A thread is the smallesst unit of execution within a process. A process can have multiple threads, which share the same resources but can run independently.
A thread is a light-weight process that can be created and destroyed at runtime.
✅For Example: A we browser like Google Chrome might use multiple threads for different tabs, with each tab running in its own thread.

Multitasking❓
Multitasking is the ability of a computer to run multiple tasks or programs at the same time. On single-core CPUs, this is done through time-sharing, rapdily switching between tasks. On multi-core CPUs, this is done through parallelism, where multiple cores, true paralled execution occurs, with tasks distributed across the cores. The OS scheduler balances the load, ensuring efficient and resposive system performance.

It utilizes the capabilities of a CPU and its cores. When an OS performs multitasking, it can assign different tasks to different cores. This is mroe efficient than assigning all tasks to a single core.
✅For Example: We are browsing the internet while listening to music and dowloading files at the same time.

MultiThreading❓
Multithreading is a technique in which multiple threads of execution are created within a single process. Each thread is a separate execution path within the process.
Multithreading is used to improve the performance of a program by allowing it to execute multiple tasks concurrently.
✅For Example: A web browser can use mutlithreading by having seperate threads for rendering the page, running JavaScript, and handling user input. This makes the browser more resposive and efficient.

It enhances the efficiency of multitasking by breaking down individual tasks into smaller sub-tasks or threads. These threads can be processed simultaneously, making better use of the CPU's capabilities and resources.

📝In Single-Core System:
Both threads and processes are managed by the OS scheduler through time slicing ad context switching to create the illusion of simultaneous execution.
📝In Multi-Core System:
Both threads and processes can run in true parallelism, with tasks distributed across the cores to optimize performance.

🔷 Thread Creation Techniques

1. Using Thread Class

package p1;

public class World extends Thread {
	@Override
	public void run() {
		for (; ; ) {
			System.out.println(Thread.currentThread().getName());
		}
	}
}

package p1;

public class intro {

	public static void main(String[] args) {
		World w = new World();
		w.start();
		for (; ;) {
			System.out.println(Thread.currentThread().getName());
		}
	}

}
🔗 Steps:
➤ A new class World is created that extends Thread.
➤ The run method is overridden to define the code constitutes the new thread.
➤ start method is called to initiate the new thread.

2. Using Runnable Interface

package p1;

public class World implements Runnable {
    @Override
    public void run() {
        for (; ; ) {
            System.out.println(Thread.currentThread().getName());
        }
    }
}

package p1;

public class intro {

    public static void main(String[] args) {
        Thread t = new Thread(new World());
        t.start();
        for (; ;) {
            System.out.println(Thread.currentThread().getName());
        }
    }
}
🔗 Steps:
➤ A new class World is created that implements Runnable.
➤ The run method is overridden to define the code constitutes the new thread.
➤ A Thread object is created by passing an instance of the World class to the Thread constructor.
➤ The start method is called to initiate the new thread.


🔷 Thread Lifecycle
The lifecycle of a thread is Java consist of several states, which a thread can move through during its execution.
The lifecycle of a thread is as follows:

1. New: A new thread is created but not yet started.
2. Runnable: After the start method is called, the thread becomes runnable. It's ready to ru and is waiting for CPU time.
3. Running: The thread is in this state when it is executing.
4. Blocked/Waiting: A thread is in this state when it is  waiting for a resource or for another thread to perform an action.
5. Terminated: The thread has completed its execution.


🔷 Thread Methods in Java
🔄 start()
➤ Used to start a new thread of execution.
➤ Internally calls the run() method in a new call stack.
➤ Cannot call start() on the same thread object more than once → throws IllegalThreadStateException.

t1.start();  // starts execution of thread

🔄 run()
➤ Contains the code that will be executed by the thread.
➤ If run() is called directly (without start()), it will behave like a normal method → no new thread is created.

@Override
public void run() {
    System.out.println("Thread is running...");
}

🔄 sleep(milliseconds)
➤ ➤ Causes the currently executing thread to pause temporarily for a given time.
➤ ➤ Throws InterruptedException if another thread interrupts the sleeping one.
➤ ➤ Static method → belongs to the class, not an object.

Thread.sleep(1000);  // pauses current thread for 1 second

🔄 join()
➤ Allows one thread to wait for another thread to finish execution before continuing.
➤ Ensures sequential execution when required.
➤ Overloads:
    ✔️ join() → waits until thread finishes.
    ✔️ join(long millis) → waits for max specified time.

t1.join();  // main thread waits until t1 finishes

🔄 setPriority(int priority)
➤ Used to set priority of a thread.
➤ Range: 1 (MIN_PRIORITY) → 10 (MAX_PRIORITY), default = 5 (NORM_PRIORITY).
➤ Just a hint to the scheduler (not guaranteed).

t1.setPriority(Thread.MAX_PRIORITY);

👉 Naming Threads
A thread can be given a name by passing it in the constructor:

ThreadMethodDemo t1 = new ThreadMethodDemo("FirstThread");
System.out.println(t1.getName());  // prints: FirstThread

✅ Example with Priority + Name
package p1;

public class ThreadMethodDemo extends Thread {
    public ThreadMethodDemo(String name) {
        super(name);  // assigning thread name
    }

    public static void main(String[] args) {
        ThreadMethodDemo t1 = new ThreadMethodDemo("FirstThread");
        t1.setPriority(Thread.NORM_PRIORITY); // setting priority
        t1.start();
    }

    @Override
    public void run() {
        for(int i=1; i<=5; i++) {
            System.out.println(Thread.currentThread().getName() + 
                               " Priority: " + Thread.currentThread().getPriority() +
                               " Value: " + i);
        }
    }
}

🔄 interrupt()
➤ Used to interrupt a thread that is sleeping, waiting, or blocked.
➤ Sets the interrupt status flag of the thread.
➤ If the thread is in sleep() or join(), it will throw InterruptedException.

🔗 Method: t1.interrupt();

✅ Code Example:
package p1;

public class ThreadMethodDemo extends Thread {
    @Override
    public void run() {
        try {
            Thread.sleep(1000);   // thread goes to sleep for 1 second
            System.out.println("Thread is running...");
        } catch (Exception e) {
            System.out.println("Thread interrupted: " + e);
        }
    }

    public static void main(String[] args) {
        ThreadMethodDemo t1 = new ThreadMethodDemo();
        t1.start();       // starts the thread → calls run() in separate stack
        t1.interrupt();   // interrupts t1 immediately
    }
}

🔷 What Happens at Runtime?
➤ t1.start() → new thread is created, run() starts execution.
➤ Inside run(), thread executes → Thread.sleep(1000).
    ✔️ This puts the thread into TIMED_WAITING state.
➤ Meanwhile, the main thread calls t1.interrupt().
    ✔️ This sets the interrupt flag for t1.
    ✔️ Since t1 is currently sleeping, it immediately throws an InterruptedException.
➤ The exception is caught in the catch block →
Thread interrupted: java.lang.InterruptedException: sleep interrupted

🔷 Key Notes for Interview
➤ interrupt()
    ✔️ If a thread is sleeping, waiting, or blocked → InterruptedException is thrown.
    ✔️ If a thread is running normally (not in sleep/wait) → just sets interrupt flag, no exception.
➤ sleep() always needs to be inside a try-catch because it throws InterruptedException.
➤ Execution flow here:
start() → run() → sleep() → interrupt() → exception thrown → handled in catch.

🔄 Yield Method
A hint to the scheduler that the current thread is willing to yield its current use of a processor.

✅Example:
public class MyThread extends Thread {
    public MyThread(String name){
        super(name);
    }
    public static void main(String[] args) throws InterruptedException {
        MyThread  t1=new MyThread("First Thead");
        MyThread t2=new MyThread("Second Thread");
        t1.start();
        t2.start();

    }

    @Override
    public void run() {
       for(int i=0;i<5;i++){
           System.out.println(Thread.currentThread().getName()+ " is running");
           Thread.yield(); // --> tells or hints to the scheduler to give chance to another thread also, although scheduler is free to ignore the request
       }
    }
}

🔄 setDameon() Method
➤ This method is used to mark a thread as a daemon thread.
➤ Daemon means a thread that runs in the background and does not prevent the JVM from shutting down.
➤ By default, a thread is a user thread, which means it prevents the JVM from shutting down.
➤ If a thread is a daemon thread, it will not prevent the JVM from shutting down.

✅Example:
public class MyThread extends Thread {
    public MyThread(String name) {
        super(name);
    }

    public static void main(String[] args) throws InterruptedException {
        MyThread t1 = new MyThread("First Thead"); //user thread for the business logic
        t1.setDaemon(true);//daemon thread 
        t1.start();
        System.out.println("Main method execution completed");
    }

    @Override
    public void run() {
        while (true) {
            System.out.println("Hello World");
        }
    }
}

✅ Output:
Main method execution completed
Hello World
Hello World 
Hello World
...print Hello World few time and then stops as daemon thread is set to true


🔷 Synchronization
➤ Synchronization is a mechanism that ensures that only one thread can access a shared resource at a time.
➤ It is used to prevent concurrent access to a shared resource, such as a variable or object.
➤ It is implemented using the synchronized keyword.
➤ The synchronized keyword is used to define a block of code that is synchronized.
➤ Only one thread can access the synchronized block at a time.
➤ If multiple threads try to access the synchronized block at the same time, they will block until the first thread releases the lock.
➤ This prevents concurrent access to the shared resource and prevent race conditions and ensures that only one thread can access it at a time and attain mutual exclusion.

✅Example:
Counter.java
package com.corejava;

public class Counter {
    private int count = 0;

    public synchronized void increment() { //critical section
        Thread.yield(); 
        count++;
    }

    public int getCount() {
        return count;
    }
}

MyThread.java
package com.corejava;

public class MyThread extends Thread {
    private Counter counter;

    public MyThread(Counter counter){
        this.counter=counter;
    }

    @Override
    public void run(){
        for(int i=0;i<10000;i++){
            counter.increment();
        }
    }
}

Test.java
package com.corejava;

public class Test {
    public static void main(String[] args) {
        Counter counter = new Counter();
        MyThread myThread1=new MyThread(counter);
        MyThread myThread2 =new MyThread(counter);
        myThread1.start();
        myThread2.start();
        try{
            myThread1.join();
            myThread2.join();
        }catch (InterruptedException e){
           e.printStackTrace();
            System.out.println("Exception occured: "+e);
        }
        System.out.println(counter.getCount()); //Expected output: 2000, actual output: <2000
    }
}

➤ When you want to synchronized some part of the method not the whole method then use synchronized block instead of synchronized keyword on the method.
✅Example:
 public void increment() { 
       synchronized (this){
           Thread.yield();
           count++;
       }
       // Other code logic is written
    }


🔷 Locks    
Thread-safe mechanism that allows multiple threads to access a shared resource concurrently.

❓ Why Use Locks Instead of synchronized?
| Feature               | `synchronized`                                       | `Lock`                             |
| --------------------- | ---------------------------------------------------- | ---------------------------------- |
| Automatic release     | Yes (automatically released when method/block exits) | No (must manually call `unlock()`) |
| Try to acquire        | No                                                   | Yes (`tryLock()`)                  |
| Interruptible waiting | No                                                   | Yes (`lockInterruptibly()`)        |
| Fairness policy       | No                                                   | Yes (can create **fair locks**)    |
| Multiple conditions   | No                                                   | Yes (via `Condition` objects)      |

🔄 There are two types of locks:
    1️⃣ Intrinsic Locks (Monitor Locks):
        ➤ Used internally by the synchronized keyword.
        ➤ Every Java object has an intrinsic lock.
        ➤ Only one thread can hold it at a time.
        ➤ Automatically acquired and released.

    ✅ Use Case: When you want simple synchronization — e.g., synchronize a method or block.

    synchronized void print() {
    // intrinsic lock acquired on this object
    }

    2️⃣ Explicit Locks (ReentrantLock)
        ➤ Part of java.util.concurrent.locks package
        ➤ Must manually acquire and release
        ➤ More flexible than intrinsic locks
        ➤ Provides methods like tryLock(), lockInterruptibly(), isHeldByCurrentThread().

        ✅ Use Case:
        ➤ When you need:
        ➤ fair access to threads,
        ➤ interruptible locks, or
        ➤ timed waiting for a lock.

public interface Lock {
    void lock();
    void unlock();
    boolean tryLock();
    void lockInterruptibly() throws InterruptedException;
}

🔄 Lock Interface Methods use Case:
| Method                              | Description                                                         |
| ----------------------------------- | ------------------------------------------------------------------- |
| `lock()`                            | Acquires the lock, waits indefinitely if not available.             |
| `unlock()`                          | Releases the lock (should always be in `finally`).                  |
| `tryLock()`                         | Attempts to acquire lock immediately; returns `true` if successful. |
| `tryLock(long time, TimeUnit unit)` | Waits for the given time before giving up.                          |
| `lockInterruptibly()`               | Acquires lock but allows interruption while waiting.                |
| `isLocked()`                        | Checks if the lock is held by any thread.                           |

    3️⃣ ReentrantLock 
    🌟 Properties:
        ✔️ A thread can acquire the same lock multiple times without being blocked (hence “reentrant”) and it maintains a count.
        ✔️ Must call unlock() the same number of times it called lock(), every lock called must be paired with an unlock call.
        ✔️ Can be fair or unfair:
                ➤ Fair → threads acquire lock in order of request.
                ➤ Unfair → scheduler decides (default).


    4️⃣ ReentrantReadWriteLock
    ➤ Provides two locks:
        ✔️ Read Lock: can be held by multiple readers simultaneously if there’s no writer.
        ✔️ Write Lock: exclusive lock; only one thread can write at a time.

    ✅ Use Case: When reads are frequent and writes are rare → improves performance.

    🔗 Code Snippet:
    ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();
    Lock readLock = rwLock.readLock();
    Lock writeLock = rwLock.writeLock();

    readLock.lock();
    try {
       // multiple readers allowed
    } finally {
       readLock.unlock();
    }

    5️⃣ StampedLock (Java 8+)
    ➤ Offers better performance in high-concurrency environments.
    ➤ Provides three modes:
        ✔️ Write Lock
        ✔️ Read Lock
        ✔️ Optimistic Read (non-blocking, fastest)

    ➤ Returns a stamp (long value) used to unlock later.

    ✅ Use Case: When you need fast, optimistic read operations with low write contention.

    StampedLock lock = new StampedLock();
    long stamp = lock.tryOptimisticRead();
    if (!lock.validate(stamp)) {
        stamp = lock.readLock();
        try {
            // protected read
        } finally {
            lock.unlockRead(stamp);
        }
    }    


🔄 Best Practices
✅ Always call unlock() in a finally block.
✅ Prefer tryLock() to avoid deadlocks.
✅ Use ReentrantReadWriteLock for high read concurrency.
✅ Use StampedLock for performance-critical read-heavy systems.
✅ Avoid mixing synchronized and Lock on same object.