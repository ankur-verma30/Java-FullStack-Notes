Program❓
A Program is a set of instructions written in a programming language that tells the computer how to perform a specific task.
✅ For Example: Microsoft Word is a program that allows you to write and edit documents. It is a program that is used to create and edit documents.

Process❓
A process is an instance of a program that is being executed. When a program runs, the operating system creates a process to manage its execution.
When we open Microsoft Word, it becomes a process in the operating system.          

Thread❓
A thread is the smallesst unit of execution within a process. A process can have multiple threads, which share the same resources but can run independently.
A thread is a light-weight process that can be created and destroyed at runtime.
✅For Example: A we browser like Google Chrome might use multiple threads for different tabs, with each tab running in its own thread.

Multitasking❓
Multitasking is the ability of a computer to run multiple tasks or programs at the same time. On single-core CPUs, this is done through time-sharing, rapdily switching between tasks. On multi-core CPUs, this is done through parallelism, where multiple cores, true paralled execution occurs, with tasks distributed across the cores. The OS scheduler balances the load, ensuring efficient and resposive system performance.

It utilizes the capabilities of a CPU and its cores. When an OS performs multitasking, it can assign different tasks to different cores. This is mroe efficient than assigning all tasks to a single core.
✅For Example: We are browsing the internet while listening to music and dowloading files at the same time.

MultiThreading❓
Multithreading is a technique in which multiple threads of execution are created within a single process. Each thread is a separate execution path within the process.
Multithreading is used to improve the performance of a program by allowing it to execute multiple tasks concurrently.
✅For Example: A web browser can use mutlithreading by having seperate threads for rendering the page, running JavaScript, and handling user input. This makes the browser more resposive and efficient.

It enhances the efficiency of multitasking by breaking down individual tasks into smaller sub-tasks or threads. These threads can be processed simultaneously, making better use of the CPU's capabilities and resources.

📝In Single-Core System:
Both threads and processes are managed by the OS scheduler through time slicing ad context switching to create the illusion of simultaneous execution.
📝In Multi-Core System:
Both threads and processes can run in true parallelism, with tasks distributed across the cores to optimize performance.

🔷 Thread Creation Techniques

1. Using Thread Class

package p1;

public class World extends Thread {
	@Override
	public void run() {
		for (; ; ) {
			System.out.println(Thread.currentThread().getName());
		}
	}
}

package p1;

public class intro {

	public static void main(String[] args) {
		World w = new World();
		w.start();
		for (; ;) {
			System.out.println(Thread.currentThread().getName());
		}
	}

}
🔗 Steps:
➤ A new class World is created that extends Thread.
➤ The run method is overridden to define the code constitutes the new thread.
➤ start method is called to initiate the new thread.

2. Using Runnable Interface

package p1;

public class World implements Runnable {
    @Override
    public void run() {
        for (; ; ) {
            System.out.println(Thread.currentThread().getName());
        }
    }
}

package p1;

public class intro {

    public static void main(String[] args) {
        Thread t = new Thread(new World());
        t.start();
        for (; ;) {
            System.out.println(Thread.currentThread().getName());
        }
    }
}
🔗 Steps:
➤ A new class World is created that implements Runnable.
➤ The run method is overridden to define the code constitutes the new thread.
➤ A Thread object is created by passing an instance of the World class to the Thread constructor.
➤ The start method is called to initiate the new thread.


🔷 Thread Lifecycle
The lifecycle of a thread is Java consist of several states, which a thread can move through during its execution.
The lifecycle of a thread is as follows:

1. New: A new thread is created but not yet started.
2. Runnable: After the start method is called, the thread becomes runnable. It's ready to ru and is waiting for CPU time.
3. Running: The thread is in this state when it is executing.
4. Blocked/Waiting: A thread is in this state when it is  waiting for a resource or for another thread to perform an action.
5. Terminated: The thread has completed its execution.


🔷 Thread Methods in Java
🔄 start()
➤ Used to start a new thread of execution.
➤ Internally calls the run() method in a new call stack.
➤ Cannot call start() on the same thread object more than once → throws IllegalThreadStateException.

t1.start();  // starts execution of thread

🔄 run()
➤ Contains the code that will be executed by the thread.
➤ If run() is called directly (without start()), it will behave like a normal method → no new thread is created.

@Override
public void run() {
    System.out.println("Thread is running...");
}

🔄 sleep(milliseconds)
➤ ➤ Causes the currently executing thread to pause temporarily for a given time.
➤ ➤ Throws InterruptedException if another thread interrupts the sleeping one.
➤ ➤ Static method → belongs to the class, not an object.

Thread.sleep(1000);  // pauses current thread for 1 second

🔄 join()
➤ Allows one thread to wait for another thread to finish execution before continuing.
➤ Ensures sequential execution when required.
➤ Overloads:
    ✔️ join() → waits until thread finishes.
    ✔️ join(long millis) → waits for max specified time.

t1.join();  // main thread waits until t1 finishes

🔄 setPriority(int priority)
➤ Used to set priority of a thread.
➤ Range: 1 (MIN_PRIORITY) → 10 (MAX_PRIORITY), default = 5 (NORM_PRIORITY).
➤ Just a hint to the scheduler (not guaranteed).

t1.setPriority(Thread.MAX_PRIORITY);

👉 Naming Threads
A thread can be given a name by passing it in the constructor:

ThreadMethodDemo t1 = new ThreadMethodDemo("FirstThread");
System.out.println(t1.getName());  // prints: FirstThread

✅ Example with Priority + Name
package p1;

public class ThreadMethodDemo extends Thread {
    public ThreadMethodDemo(String name) {
        super(name);  // assigning thread name
    }

    public static void main(String[] args) {
        ThreadMethodDemo t1 = new ThreadMethodDemo("FirstThread");
        t1.setPriority(Thread.NORM_PRIORITY); // setting priority
        t1.start();
    }

    @Override
    public void run() {
        for(int i=1; i<=5; i++) {
            System.out.println(Thread.currentThread().getName() + 
                               " Priority: " + Thread.currentThread().getPriority() +
                               " Value: " + i);
        }
    }
}

🔄 interrupt()
➤ Used to interrupt a thread that is sleeping, waiting, or blocked.
➤ Sets the interrupt status flag of the thread.
➤ If the thread is in sleep() or join(), it will throw InterruptedException.

🔗 Method: t1.interrupt();

✅ Code Example:
package p1;

public class ThreadMethodDemo extends Thread {
    @Override
    public void run() {
        try {
            Thread.sleep(1000);   // thread goes to sleep for 1 second
            System.out.println("Thread is running...");
        } catch (Exception e) {
            System.out.println("Thread interrupted: " + e);
        }
    }

    public static void main(String[] args) {
        ThreadMethodDemo t1 = new ThreadMethodDemo();
        t1.start();       // starts the thread → calls run() in separate stack
        t1.interrupt();   // interrupts t1 immediately
    }
}

🔷 What Happens at Runtime?
➤ t1.start() → new thread is created, run() starts execution.
➤ Inside run(), thread executes → Thread.sleep(1000).
    ✔️ This puts the thread into TIMED_WAITING state.
➤ Meanwhile, the main thread calls t1.interrupt().
    ✔️ This sets the interrupt flag for t1.
    ✔️ Since t1 is currently sleeping, it immediately throws an InterruptedException.
➤ The exception is caught in the catch block →
Thread interrupted: java.lang.InterruptedException: sleep interrupted

🔷 Key Notes for Interview
➤ interrupt()
    ✔️ If a thread is sleeping, waiting, or blocked → InterruptedException is thrown.
    ✔️ If a thread is running normally (not in sleep/wait) → just sets interrupt flag, no exception.
➤ sleep() always needs to be inside a try-catch because it throws InterruptedException.
➤ Execution flow here:
start() → run() → sleep() → interrupt() → exception thrown → handled in catch.

🔄 Yield Method
A hint to the scheduler that the current thread is willing to yield its current use of a processor.

✅Example:
public class MyThread extends Thread {
    public MyThread(String name){
        super(name);
    }
    public static void main(String[] args) throws InterruptedException {
        MyThread  t1=new MyThread("First Thead");
        MyThread t2=new MyThread("Second Thread");
        t1.start();
        t2.start();

    }

    @Override
    public void run() {
       for(int i=0;i<5;i++){
           System.out.println(Thread.currentThread().getName()+ " is running");
           Thread.yield(); // --> tells or hints to the scheduler to give chance to another thread also, although scheduler is free to ignore the request
       }
    }
}

🔄 setDameon() Method
➤ This method is used to mark a thread as a daemon thread.
➤ Daemon means a thread that runs in the background and does not prevent the JVM from shutting down.
➤ By default, a thread is a user thread, which means it prevents the JVM from shutting down.
➤ If a thread is a daemon thread, it will not prevent the JVM from shutting down.

✅Example:
public class MyThread extends Thread {
    public MyThread(String name) {
        super(name);
    }

    public static void main(String[] args) throws InterruptedException {
        MyThread t1 = new MyThread("First Thead"); //user thread for the business logic
        t1.setDaemon(true);//daemon thread 
        t1.start();
        System.out.println("Main method execution completed");
    }

    @Override
    public void run() {
        while (true) {
            System.out.println("Hello World");
        }
    }
}

✅ Output:
Main method execution completed
Hello World
Hello World 
Hello World
...print Hello World few time and then stops as daemon thread is set to true


🔷 Synchronization
➤ Synchronization is a mechanism that ensures that only one thread can access a shared resource at a time.
➤ It is used to prevent concurrent access to a shared resource, such as a variable or object.
➤ It is implemented using the synchronized keyword.
➤ The synchronized keyword is used to define a block of code that is synchronized.
➤ Only one thread can access the synchronized block at a time.
➤ If multiple threads try to access the synchronized block at the same time, they will block until the first thread releases the lock.
➤ This prevents concurrent access to the shared resource and prevent race conditions and ensures that only one thread can access it at a time and attain mutual exclusion.

✅Example:
Counter.java
package com.corejava;

public class Counter {
    private int count = 0;

    public synchronized void increment() { //critical section
        Thread.yield(); 
        count++;
    }

    public int getCount() {
        return count;
    }
}

MyThread.java
package com.corejava;

public class MyThread extends Thread {
    private Counter counter;

    public MyThread(Counter counter){
        this.counter=counter;
    }

    @Override
    public void run(){
        for(int i=0;i<10000;i++){
            counter.increment();
        }
    }
}

Test.java
package com.corejava;

public class Test {
    public static void main(String[] args) {
        Counter counter = new Counter();
        MyThread myThread1=new MyThread(counter);
        MyThread myThread2 =new MyThread(counter);
        myThread1.start();
        myThread2.start();
        try{
            myThread1.join();
            myThread2.join();
        }catch (InterruptedException e){
           e.printStackTrace();
            System.out.println("Exception occured: "+e);
        }
        System.out.println(counter.getCount()); //Expected output: 2000, actual output: <2000
    }
}

➤ When you want to synchronized some part of the method not the whole method then use synchronized block instead of synchronized keyword on the method.
✅Example:
 public void increment() { 
       synchronized (this){
           Thread.yield();
           count++;
       }
       // Other code logic is written
    }


🔷 Locks    
Thread-safe mechanism that allows multiple threads to access a shared resource concurrently.

❓ Why Use Locks Instead of synchronized?
| Feature               | `synchronized`                                       | `Lock`                             |
| --------------------- | ---------------------------------------------------- | ---------------------------------- |
| Automatic release     | Yes (automatically released when method/block exits) | No (must manually call `unlock()`) |
| Try to acquire        | No                                                   | Yes (`tryLock()`)                  |
| Interruptible waiting | No                                                   | Yes (`lockInterruptibly()`)        |
| Fairness policy       | No                                                   | Yes (can create **fair locks**)    |
| Multiple conditions   | No                                                   | Yes (via `Condition` objects)      |

🔄 There are two types of locks:
    1️⃣ Intrinsic Locks (Monitor Locks):
        ➤ Used internally by the synchronized keyword.
        ➤ Every Java object has an intrinsic lock.
        ➤ Only one thread can hold it at a time.
        ➤ Automatically acquired and released.

    ✅ Use Case: When you want simple synchronization — e.g., synchronize a method or block.

    synchronized void print() {
    // intrinsic lock acquired on this object
    }

    2️⃣ Explicit Locks (ReentrantLock)
        ➤ Part of java.util.concurrent.locks package
        ➤ Must manually acquire and release
        ➤ More flexible than intrinsic locks
        ➤ Provides methods like tryLock(), lockInterruptibly(), isHeldByCurrentThread().

        ✅ Use Case:
        ➤ When you need:
        ➤ fair access to threads,
        ➤ interruptible locks, or
        ➤ timed waiting for a lock.

public interface Lock {
    void lock();
    void unlock();
    boolean tryLock();
    void lockInterruptibly() throws InterruptedException;
}

🔄 Lock Interface Methods use Case:
| Method                              | Description                                                         |
| ----------------------------------- | ------------------------------------------------------------------- |
| `lock()`                            | Acquires the lock, waits indefinitely if not available.             |
| `unlock()`                          | Releases the lock (should always be in `finally`).                  |
| `tryLock()`                         | Attempts to acquire lock immediately; returns `true` if successful. |
| `tryLock(long time, TimeUnit unit)` | Waits for the given time before giving up.                          |
| `lockInterruptibly()`               | Acquires lock but allows interruption while waiting.                |
| `isLocked()`                        | Checks if the lock is held by any thread.                           |

    3️⃣ ReentrantLock 
    🌟 Properties:
        ✔️ A thread can acquire the same lock multiple times without being blocked (hence “reentrant”) and it maintains a count.
        ✔️ Must call unlock() the same number of times it called lock(), every lock called must be paired with an unlock call.
        ✔️ Can be fair or unfair:
                ➤ Fair → threads acquire lock in order of request.
                ➤ Unfair → scheduler decides (default).


    4️⃣ ReentrantReadWriteLock
    ➤ Provides two locks:
        ✔️ Read Lock: can be held by multiple readers simultaneously if there’s no writer.
        ✔️ Write Lock: exclusive lock; only one thread can write at a time.

    ✅ Use Case: When reads are frequent and writes are rare → improves performance.

    🔗 Code Snippet:
    ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();
    Lock readLock = rwLock.readLock();
    Lock writeLock = rwLock.writeLock();

    readLock.lock();
    try {
       // multiple readers allowed
    } finally {
       readLock.unlock();
    }

    5️⃣ StampedLock (Java 8+)
    ➤ Offers better performance in high-concurrency environments.
    ➤ Provides three modes:
        ✔️ Write Lock
        ✔️ Read Lock
        ✔️ Optimistic Read (non-blocking, fastest)

    ➤ Returns a stamp (long value) used to unlock later.

    ✅ Use Case: When you need fast, optimistic read operations with low write contention.

    StampedLock lock = new StampedLock();
    long stamp = lock.tryOptimisticRead();
    if (!lock.validate(stamp)) {
        stamp = lock.readLock();
        try {
            // protected read
        } finally {
            lock.unlockRead(stamp);
        }
    }    

🔄 Best Practices
✅ Always call unlock() in a finally block.
✅ Prefer tryLock() to avoid deadlocks.
✅ Use ReentrantReadWriteLock for high read concurrency.
✅ Use StampedLock for performance-critical read-heavy systems.
✅ Avoid mixing synchronized and Lock on same object.


🔷 Locks' Fairness: Prevent Deadlocks
❓ What is Unfair Locking?
➤ By default, ReentrantLock uses an unfair policy, meaning:
➤ When multiple threads are waiting for the lock,
a new thread may “cut in line” and acquire the lock even if others have been waiting longer.
➤ The scheduler doesn’t strictly follow first come, first served (FCFS) order.
➤ This can cause thread starvation, but improves performance in some cases.

✅Example: Unfair Lock Demonstration
package com.corejava;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class UnfairLockExample {
    // Default constructor => unfair lock
    private final Lock unfairLock = new ReentrantLock();

    public void accessResource() {
        unfairLock.lock();
        try {
            System.out.println(Thread.currentThread().getName() + " acquired the lock");
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            unfairLock.unlock();
            System.out.println(Thread.currentThread().getName() + " released the lock");
        }
    }
}

package com.corejava;

public class Main {
    public static void main(String[] args) {
        UnfairLockExample unfairLockExample = new UnfairLockExample();

        Runnable task = () -> unfairLockExample.accessResource();

        Thread t1 = new Thread(task, "Thread 1");
        Thread t2 = new Thread(task, "Thread 2");
        Thread t3 = new Thread(task, "Thread 3");

        t1.start();
        t2.start();
        t3.start();
    }
}
✅Expected Output(May vary in each run):
Thread 2 acquired the lock
Thread 2 released the lock
Thread 3 acquired the lock
Thread 3 released the lock
Thread 1 acquired the lock
Thread 1 released the lock

👉 Next time when you run the code:
Thread 1 acquired the lock
Thread 1 released the lock
Thread 3 acquired the lock
Thread 3 released the lock
Thread 2 acquired the lock
Thread 2 released the lock

👉 There’s no guaranteed order — threads acquire the lock randomly even though Thread 1 started first.
👉 That’s the unfair behavior.

🆚 Fair vs Unfair Lock
If you want to make it fair, modify one line 👇

private final Lock fairLock = new ReentrantLock(true); // true = fair

✅Output with Fair Lock:
Thread 1 acquired the lock
Thread 2 acquired the lock
Thread 1 released the lock
Thread 2 released the lock
Thread 3 acquired the lock
Thread 3 released the lock
👉 Now the output follows Thread 1 → Thread 2 → Thread 3 (the order in which they started waiting).

➤ Thread 1 and Thread 2 both say “acquired the lock” before either released it.
➤ That’s actually not possible if both lines refer to the same critical section protected by the same lock, because only one thread can hold a ReentrantLock at a time.

➤ So, what really happens is:
    ✔️ Thread 1 acquires the lock and prints.
    ✔️ Before Thread 1 releases it, Thread 2 is blocked, waiting.
    ✔️ Once Thread 1 releases the lock, Thread 2 then acquires and prints.
    ✔️ But because of console I/O buffering, their print statements may appear out of strict order.
➤ So don’t rely solely on print order — small thread scheduling variations can cause misleading console sequences.


🔄 Disadvantages of synchronized in Java
1️⃣ No Flexibility / Limited Control
➤ Once a synchronized block or method starts, other threads must wait — no timeout, no try mechanism.
➤ You cannot check if a lock is available before trying to acquire it.
➤ Unlike ReentrantLock, you cannot interrupt a thread waiting for a synchronized lock.

✅ Example:
synchronized void print() { ... }  // waits indefinitely

2️⃣ Automatic Locking — No Manual Release
➤ Lock is automatically released when the method/block exits, even if you wanted to keep it longer.
➤ You cannot manually unlock() early like you can with Lock objects.

3️⃣ No Fairness Guarantee
➤ Thread scheduling is not fair — JVM does not guarantee FIFO order of thread execution.
➤ A thread that waits longer doesn’t necessarily get the lock next → can lead to thread starvation.

4️⃣ Cannot Try for Lock (No tryLock Equivalent)
➤ There’s no non-blocking attempt to acquire the lock.
➤ Threads either block indefinitely or wait till lock is free.

🆚 Compare with Lock API:
if (lock.tryLock()) {
   // proceed
} else {
   // do something else
}

5️⃣ Cannot Create Multiple Condition Variables
➤ synchronized provides only one intrinsic lock per object.
➤ You can use only one wait set per object (via wait(), notify(), notifyAll()).
➤ With Lock, you can create multiple Condition objects for fine-grained control.

6️⃣ No Timeout Option
➤ There’s no way to specify how long a thread should wait to acquire the lock.
➤ Threads can remain blocked indefinitely.

7️⃣ Can Cause Deadlock Easily
➤ If multiple synchronized blocks lock different objects in wrong order, threads can deadlock.
➤ Because synchronization is implicit and uninterruptible, recovery is difficult.

8️⃣ Lower Performance in High Contention
➤ When many threads compete for the same lock, context switching and blocking overhead increases.
➤ Modern alternatives (Lock, StampedLock, etc.) can be more scalable and non-blocking.

9️⃣ No Explicit Lock Information
➤ You can’t check:
    ✔️ whether a thread currently holds a lock,
    ✔️ how many times it has entered (no reentrancy info), or
    ✔️ if another thread is waiting.
➤ ReentrantLock provides such introspection methods (isLocked(), isHeldByCurrentThread(), etc.).

1️⃣0️⃣ Difficult Debugging
➤ Since locking and unlocking are automatic, it’s harder to trace where threads are blocking or waiting.
➤ Deadlocks or long wait times are tough to identify without specialized tools.


🔷 ReadWriteLock
A ReadWriteLock is a special kind of lock that maintains two separate locks:
👉 Read Lock – for read-only operations
👉 Write Lock – for write/update operations

❓ Why Use It:
➤ In many systems, read operations are more frequent than writes.
➤ If every thread used the same lock (like synchronized), even reads would block each other — reducing performance.

✅ ReadWriteLock allows multiple threads to read simultaneously,
🚫 but only one thread can write at a time, and no reader can read while a write is happening.

🔄 Rule of Thumb:
| Operation       | Can run in parallel? | Condition                            |
| --------------- | -------------------- | ------------------------------------ |
| Multiple Reads  | ✅ Yes                | As long as **no write** is happening |
| Read + Write    | ❌ No                 | Write locks block readers            |
| Multiple Writes | ❌ No                 | Only one writer at a time            |
| Write + Write   | ❌ No                 | Only one writer                      |

✅Example: ReadWriteCounter
package com.corejava;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class ReadWriteCounter {
    private int count=0;
    private  final ReadWriteLock rwlock=new ReentrantReadWriteLock();

    private final Lock readLock=rwlock.readLock();
    private final Lock writeLock=rwlock.writeLock();

    public void increment(){
        writeLock.lock();
        try{
            System.out.println(Thread.currentThread().getName()+" incremented");
            count++;
        }finally {
            writeLock.unlock();
        }
    }

    public int getCount(){
        readLock.lock();
        try{
            System.out.println("Count of the variable: "+count);
        }finally {
            readLock.unlock();
        }
        return count;
    }
}

1️⃣ Class Setup
➤ rwlock creates an object that provides two locks:
    ✔️ readLock() – allows concurrent reads.
    ✔️ writeLock() – exclusive lock for writing.
➤ count → shared resource being read/written by threads.

2️⃣ Write Operation (increment())
➤ writeLock.lock() → acquires exclusive access to count.
➤ While one thread holds the write lock:
    ❌ No other write thread can enter.
    ❌ No read thread can access count.
➤ Ensures atomicity and data consistency during modification.
➤ Finally block ensures unlock() always happens, even if an exception occurs.

3️⃣ Read Operation (getCount())
➤ readLock.lock() allows concurrent access to count if no write is active.
➤ Multiple threads can hold readLock simultaneously.
➤ When a write lock is requested, new readers must wait until the write finishes.

package com.corejava;

public class Main {
    public static void main(String[] args) throws InterruptedException {

        ReadWriteCounter counter=new ReadWriteCounter();
        Runnable readTask = () -> {
            for(int i=0;i<10;i++){
                System.out.println(Thread.currentThread().getName()+" read: "+counter.getCount() );
            }
        };

        Runnable writeTask= () -> {
            for(int i=0;i<10;i++){
                counter.increment();
            }
        };

        Thread writeThread=new Thread(writeTask,"Thread write1");
        Thread readThread1=new Thread(readTask,"Thread read1");
        Thread readThread2=new Thread(readTask,"Thread read2");

        writeThread.start();
        readThread1.start();
        readThread2.start();

        try {
            writeThread.join();
            readThread1.join();
            readThread2.join();
        } catch (InterruptedException e) {
           try {
               writeThread.interrupt();
               readThread1.interrupt();
               readThread2.interrupt();
           } catch (RuntimeException ex) {
               throw new RuntimeException(ex);
           }
        }

        System.out.println("Final count:"+ counter.getCount());
    }
}

4️⃣ Main Class Logic
➤ readTask → repeatedly reads the counter (10 times).
➤ writeTask → increments the counter (10 times).

5️⃣ Threads Creation
One write thread and two read threads.

6️⃣ Execution Flow
writeThread.start();
readThread1.start();
readThread2.start();

➤ All threads start together.
➤ When the write thread holds writeLock, readers wait.
➤ When write finishes, both read threads can read concurrently again.

7️⃣ Final Output
System.out.println("Final count:" + counter.getCount());
👉 After all threads finish, the final count should be 10 (since one writer increments 10 times).

❓ Why ReadWriteLock Is Better Here
| Aspect                   | `synchronized`     | `ReadWriteLock` |
| ------------------------ | ------------------ | --------------- |
| Multiple readers         | ❌ Block each other | ✅ Allowed       |
| Writer access            | Exclusive          | Exclusive       |
| Performance (read-heavy) | Lower              | Higher          |
| Fine-grained control     | Limited            | High            |


🔄 Use ReadWriteLock When
➤ Read operations are frequent.
➤ Write operations are infrequent but must be exclusive.
✅ Example scenarios:
    ✔️ Caching systems
    ✔️ Configuration reading
    ✔️ File metadata readers
    ✔️ In-memory database snapshots

🔁 Insights
✔️ Always unlock in finally block.
✔️ Don’t acquire both read and write lock in same thread (can deadlock).
✔️ Prefer ReentrantReadWriteLock for reentrancy (same thread can re-acquire lock safely).
✔️ Readers block writers, and writers block readers — but readers can share the lock.


🔷 Deadlock
➤ Deadlock is a situation when two or more threads are waiting for each other to release a lock.
➤ This can happen when two threads hold locks in opposite order, or when a thread acquires a lock and then waits for another thread to release it.
➤ In a deadlock, neither thread can proceed, and the program will be stuck in an infinite loop.

Deadlock typically occurs when four conditions are met simultaneously:
1️⃣ Mutal exclusion: Only one thread can access a shared resource at a time.
2️⃣ Hold and wait: A thread holds a lock and then waits for another thread to release it.
3️⃣ No preemption: A thread cannot be preempted by another thread.
4️⃣ Circular wait: Two threads are waiting for each other to release a lock.
👉 Deadlock can be prevented by ensuring that no thread holds a lock that another thread is waiting for.

✅Example:
package com.corejava;

class Pen{
    public synchronized void writeWithPenAndPaper(Paper paper){
        System.out.println(Thread.currentThread().getName()+ " is using pen "+this+" and trying to get paper"+ paper);
        paper.finishWriting();
    }

    public synchronized void finishWriting(){
        System.out.println(Thread.currentThread().getName()+ " finished using paper "+this);
    }
}

class Paper{
    public synchronized void writeWithPenAndPaper(Pen pen){
        System.out.println(Thread.currentThread().getName()+ " is using paper "+this+" and trying to get pen"+ pen);
        pen.finishWriting();
    }

    public synchronized void finishWriting(){
        System.out.println(Thread.currentThread().getName()+ " finished using paper "+this);
    }
}

class Task1 implements Runnable{
    private Pen pen;
    private Paper paper;
    public Task1(Pen pen,Paper paper){
        this.pen=pen;
        this.paper=paper;
    }
    @Override
    public void run() {
        pen.writeWithPenAndPaper(paper);
    }
}

class Task2 implements Runnable{
    private Pen pen;
    private Paper paper;
    public Task2(Pen pen,Paper paper){
        this.pen=pen;
        this.paper=paper;
    }
    @Override
    public void run() {
        paper.writeWithPenAndPaper(pen);
    }
}

public class DeadLockExample {
    public static void main(String[] args) {
        Pen pen =new Pen();
        Paper paper=new Paper();

        Thread thread1=new Thread(new Task1(pen,paper),"Thread-1");
        Thread thread2=new Thread(new Task2(pen,paper),"Thread-2");
        thread1.start();
        thread2.start();
    }
}
🔒 Step-by-step:
➤ Thread-1 locks Pen.
➤ It tries to call paper.finishWriting() — a synchronized method.
➤ To enter paper.finishWriting(), it must get Paper’s lock.
➤ But what if Thread-2 already holds the Paper lock? → Then Thread-1 waits forever.

➤ Thread-2 locks Paper.
➤ Then tries to call pen.finishWriting().
➤ To enter that method, it must acquire Pen’s lock.
➤ But Pen’s lock is already held by Thread-1.

To Resolve this problem, we need to ensure that no thread holds a lock that another thread is waiting for.

✅ Solution:
class Task2 implements Runnable{
    private Pen pen;
    private Paper paper;
    public Task2(Pen pen,Paper paper){
        this.pen=pen;
        this.paper=paper;
    }
    @Override
    public void run() {
        synchronized(pen){
        paper.writeWithPenAndPaper(pen);
        }
    }
}


🔷 Thread Communication
➤ In a multithreaded environment, threads can communicate with each other to accomplish a task.
➤ Without proper communication mechanisms, threads might end up in efficient busy-waiting states, leading to wastage of CPU resources and potential deadlocks.

❓ Why Thread Communication is Needed
❌ Without communication:
➤ Threads run independently, unaware of each other.
➤ They may perform redundant operations or wait inefficiently (busy-waiting).
➤ Leads to CPU wastage, race conditions, or deadlocks.
✅ With communication:
➤ One thread can signal another when a task is complete.
➤ Threads can wait, notify, and resume execution in a controlled order.

🔄 Methods (Used with synchronized)
| Method        | Description                                                               | Used By         |
| ------------- | ------------------------------------------------------------------------- | --------------- |
| `wait()`      | Causes current thread to **release the lock** and enter the waiting state | Consumer thread |
| `notify()`    | Wakes up **one** waiting thread                                           | Producer thread |
| `notifyAll()` | Wakes up **all** waiting threads                                          | Producer thread |

⚠️ These methods must be called inside a synchronized block or method, otherwise you’ll get an IllegalMonitorStateException.

✅ Basic Workflow (Producer–Consumer Example)
➤ Producer thread produces data (adds items to buffer).
➤ Consumer thread consumes data (removes items from buffer).
➤ Both need to coordinate:
    ✔️ Producer must wait if buffer is full.
    ✔️ Consumer must wait if buffer is empty.

🔗 Code implementation:
class SharedResource {
    private int data;
    private boolean available = false;

    public synchronized void produce(int value) {
        while (available) {
            try { wait(); } catch (InterruptedException e) { 
              Thread.currentThread().interrupt();
                }
        }
        data = value;
        System.out.println("Produced: " + data);
        available = true;
        notify(); //--> Wake up consumer
    }

    public synchronized void consume() {
        while (!available) {
            try { wait(); } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        System.out.println("Consumed: " + data);
        available = false;
        notify(); //--> Wake up producer
    }
}

public class ThreadCommunicationDemo {
    public static void main(String[] args) {
        SharedResource resource = new SharedResource();

        Thread producer = new Thread(() -> {
            for (int i = 1; i <= 5; i++) {
                resource.produce(i);
            }
        });

        Thread consumer = new Thread(() -> {
            for (int i = 1; i <= 5; i++) {
                resource.consume();
            }
        });

        producer.start();
        consumer.start();
    }
}

✅ Output:
Produced: 1
Consumed: 1
Produced: 2
Consumed: 2
Produced: 3
Consumed: 3
Produced: 4
Consumed: 4
Produced: 5
Consumed: 5

⚡ How It Works Internally
| Step | Action                           | Thread State            |
| ---- | -------------------------------- | ----------------------- |
| 1    | Thread enters synchronized block | Running                 |
| 2    | Calls `wait()`                   | Releases lock → Waiting |
| 3    | Another thread calls `notify()`  | Waiting thread wakes up |
| 4    | Waiting thread reacquires lock   | Runnable                |
| 5    | Resumes after `wait()`           | Running                 |

🚨 Important Rules
✔️ Must be inside a synchronized context.
synchronized(obj) { obj.wait(); }

✔️ The thread calling wait() releases the lock immediately.
✔️ notify()/notifyAll() do not release lock immediately —
they only wake waiting threads; the lock is released after synchronized block exits.
✔️ Always use while (not if) around wait() —
because of spurious wakeups (unexpected wake signals).


🔷 Thread Saftey
Thread safety means that a piece of code, class, or object can be safely used by multiple threads simultaneously without causing inconsistent or incorrect results.

❓ Why Thread Safety Is Needed
When multiple threads access and modify shared data (like variables, objects, files, or collections) without synchronization, problems occur.

💣 Common Thread Safety Problems
| Problem                | Description                                                                        |
| ---------------------- | ---------------------------------------------------------------------------------- |
| **Race Condition**     | Two or more threads modify shared data concurrently, causing unpredictable results |
| **Data Inconsistency** | Shared variable values become incorrect                                            |
| **Deadlock**           | Threads waiting indefinitely for each other’s locks                                |
| **Starvation**         | Some threads never get CPU time                                                    |
| **Visibility Issues**  | One thread’s updates not visible to another due to caching                         |

❌ Example (Non-thread-safe)
class Counter {
    private int count = 0;

    public void increment() {
        count++; // not atomic
    }

    public int getCount() {
        return count;
    }
}

public class Demo {
    public static void main(String[] args) throws InterruptedException {
        Counter c = new Counter();

        Thread t1 = new Thread(() -> { for (int i = 0; i < 1000; i++) c.increment(); });
        Thread t2 = new Thread(() -> { for (int i = 0; i < 1000; i++) c.increment(); });

        t1.start(); t2.start();
        t1.join(); t2.join();

        System.out.println("Final count: " + c.getCount());
    }
}

🔎 Output (inconsistent)
Final count: 1876   // sometimes 1980, sometimes 2000, etc.

❓ Why?
➤ count++ is not atomic — it performs:
    ✔️ Read value of count
    ✔️ Increment value
    ✔️ Write back
➤ Two threads can interleave in between these steps, leading to race conditions.

✅ How to Achieve Thread Safety
1️⃣ Use Synchronization
➤ Use synchronized keyword to ensure only one thread accesses a critical section at a time.

class SafeCounter {
    private int count = 0;

    public synchronized void increment() {
        count++;
    }

    public synchronized int getCount() {
        return count;
    }
}

2️⃣ Use Locks (java.util.concurrent.locks)
➤ ReentrantLock, ReadWriteLock give more flexibility and control than synchronized.

class SafeCounter {
    private int count = 0;
    private final Lock lock = new ReentrantLock();

    public void increment() {
        lock.lock();
        try { count++; } 
        finally { lock.unlock(); }
    }
}

3️⃣ Use Atomic Classes
➤ Classes like AtomicInteger, AtomicBoolean, AtomicReference perform atomic operations without explicit locks.

class AtomicCounter {
    private AtomicInteger count = new AtomicInteger(0);

    public void increment() {
        count.incrementAndGet();
    }

    public int getCount() {
        return count.get();
    }
}

4️⃣ Use Thread-safe Collections
➤ Use collections from java.util.concurrent package:
✔️ ConcurrentHashMap
✔️ CopyOnWriteArrayList
✔️ BlockingQueue
✔️ ConcurrentLinkedQueue
👉 These allow safe concurrent access without manual synchronization.

5️⃣ Use Immutable Objects
➤ If an object’s state cannot change, it’s automatically thread-safe.

final class Student {
    private final String name;
    private final int rollNo;

    public Student(String name, int rollNo) {
        this.name = name;
        this.rollNo = rollNo;
    }
}
👉 Immutable objects are naturally thread-safe because no thread can modify their state.

6️⃣ Use Volatile for Visibility
➤ The volatile keyword ensures changes made by one thread are immediately visible to others.
➤ But it does not make operations atomic.

private volatile boolean flag = true;


🔷 Thread Pool
➤ A Thread Pool is a pool (collection) of pre-created worker threads that can execute tasks concurrently.
➤ Instead of creating a new thread for every task (which is expensive), tasks are queued and executed by available threads in the pool.
➤ Once a thread completes a task, it is reused for another one — improving performance and resource utilization.

❓ Why Use a Thread Pool?
| Problem                                                        | How Thread Pool Solves It                |
| -------------------------------------------------------------- | ---------------------------------------- |
| Creating too many threads causes high memory and CPU overhead. | Pool reuses a limited number of threads. |
| Uncontrolled thread creation can crash the system.             | Pool size is fixed or managed.           |
| Thread creation/destruction per task is costly.                | Threads are reused efficiently.          |

🔄 Core Concepts
➤ Task – A unit of work (e.g., implementing Runnable or Callable).
➤ Worker Thread – Thread that takes tasks from the queue and executes them.
➤ Blocking Queue – Stores tasks waiting to be executed.
➤ Executor Framework – Provides thread pool management utilities.

🔄 Executor Framework (Java 5+)
Java introduced the java.util.concurrent package with the Executor Framework to simplify thread pool management.

🔄 Key Interfaces & Classes
| Component         | Description                                        |
| ----------------- | -------------------------------------------------- |
| `Executor`        | Base interface for executing tasks.                |
| `ExecutorService` | Manages thread lifecycle (submit, shutdown, etc.). |
| `Executors`       | Factory class providing ready-made thread pools.   |

🔄 Common Thread Pool Types (via Executors)
1️⃣ newFixedThreadPool(n)
➤ Fixed number of threads.
➤ Extra tasks wait in the queue.
✅ Best for: constant load, predictable number of threads.
ExecutorService pool = Executors.newFixedThreadPool(3);

2️⃣ newCachedThreadPool()
➤ Creates new threads as needed and reuses existing ones.
➤ Threads idle for 60s are terminated.
✅ Best for: many short-lived asynchronous tasks.
ExecutorService pool = Executors.newCachedThreadPool();

3️⃣ newSingleThreadExecutor()
Only one thread executes tasks sequentially.
✅ Best for: ensuring ordered execution.
ExecutorService pool = Executors.newSingleThreadExecutor();

4️⃣ newScheduledThreadPool(n)
Supports scheduling tasks after delay or periodically.
✅ Best for: background maintenance tasks.
ScheduledExecutorService pool = Executors.newScheduledThreadPool(2);

✅ Basic Example:
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadPoolExample {
    public static void main(String[] args) {
        ExecutorService pool = Executors.newFixedThreadPool(3); // 3 threads in pool

        for (int i = 1; i <= 5; i++) {
            int taskId = i;
            pool.execute(() -> {
                System.out.println(Thread.currentThread().getName() + " executing task " + taskId);
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            });
        }
        pool.shutdown(); // No new tasks accepted, wait for existing ones to finish
    }
}

✅ Output Example
pool-1-thread-1 executing task 1
pool-1-thread-2 executing task 2
pool-1-thread-3 executing task 3
pool-1-thread-1 executing task 4
pool-1-thread-2 executing task 5
👉 Notice that only 3 threads are created and reused for 5 tasks.

🔄 Advantages
➤ Reuses threads → saves CPU and memory.
➤ Prevents system overload from unbounded thread creation.
➤ Better performance and scalability.
➤ Simplifies task submission and lifecycle management.

🔄 Disadvantages
❌ Not suitable for tasks requiring long blocking I/O — threads may stay busy for long.
❌ Fixed pool can cause tasks to wait if all threads are busy.
❌ Harder to debug if tasks hang inside the pool.

🔄 Best Practices
➤ Always call shutdown() or shutdownNow() to stop accepting new tasks.
➤ Use bounded queues for better control.
➤ For large-scale systems, prefer ThreadPoolExecutor for custom configurations (core size, max size, queue size, etc.).
➤ Use submit() if you need to get a Future result from a task.