##############
ğŸ”· Programâ“
##############
A Program is a set of instructions written in a programming language that tells the computer how to perform a specific task.
âœ… For Example: Microsoft Word is a program that allows you to write and edit documents. It is a program that is used to create and edit documents.


#############
ğŸ”· Processâ“
#############
A process is an instance of a program that is being executed. When a program runs, the operating system creates a process to manage its execution.
When we open Microsoft Word, it becomes a process in the operating system.


#############
ğŸ”· Threadâ“
#############
A thread is the smallesst unit of execution within a process. A process can have multiple threads, which share the same resources but can run independently.
A thread is a light-weight process that can be created and destroyed at runtime.
âœ…For Example: A we browser like Google Chrome might use multiple threads for different tabs, with each tab running in its own thread.


###################
ğŸ”· Multitaskingâ“
###################
Multitasking is the ability of a computer to run multiple tasks or programs at the same time. On single-core CPUs, this is done through time-sharing, rapdily switching between tasks. On multi-core CPUs, this is done through parallelism, where multiple cores, true paralled execution occurs, with tasks distributed across the cores. The OS scheduler balances the load, ensuring efficient and resposive system performance.

It utilizes the capabilities of a CPU and its cores. When an OS performs multitasking, it can assign different tasks to different cores. This is more efficient than assigning all tasks to a single core.
âœ…For Example: We are browsing the internet while listening to music and dowloading files at the same time.


#####################
ğŸ”· MultiThreadingâ“
#####################
Multithreading is a technique in which multiple threads of execution are created within a single process. Each thread is a separate execution path within the process.
Multithreading is used to improve the performance of a program by allowing it to execute multiple tasks concurrently.

âœ…For Example: A web browser can use multithreading by having seperate threads for rendering the page, running JavaScript, and handling user input. This makes the browser more resposive and efficient.

It enhances the efficiency of multitasking by breaking down individual tasks into smaller sub-tasks or threads. These threads can be processed simultaneously, making better use of the CPU's capabilities and resources.

ğŸ“In Single-Core System: Both threads and processes are managed by the OS scheduler through time slicing ad context switching to create the illusion of simultaneous execution.
ğŸ“In Multi-Core System: Both threads and processes can run in true parallelism, with tasks distributed across the cores to optimize performance.


##################################
ğŸ”· Advantages of Multithreading
##################################
1ï¸âƒ£ Improved Performance / Better CPU Utilization
â¤ Threads run concurrently â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ utilize multiple cores.
â¤ Reduces CPU idle time.
â¤ Great for computational + IO workloads.

2ï¸âƒ£ Responsiveness
â¤ One thread can handle heavy tasks while UI/API stays responsive.
âœ… Example: Web server spins separate threads for each request.

3ï¸âƒ£ Resource Sharing
â¤ Threads share memory space â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ low overhead compared to processes.
â¤ Faster context switching.

4ï¸âƒ£ Scalability in Server Applications
â¤ Widely used in:
    âœ”ï¸ï¸ï¸Spring Boot APIs (Tomcat/Netty threads)
    âœ”ï¸Kafka consumers
    âœ”ï¸Database connection pools

5ï¸âƒ£ Simplified Modeling of Real-world Concurrency
â¤ Producerâ€“consumer
â¤ Readersâ€“writers
â¤ Background workers


############################################################
âŒ Disadvantages of Multithreading & How to Overcome Them
############################################################
1ï¸âƒ£ Race Conditions
â— Problem: Two threads access and modify shared data simultaneously â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ inconsistent data.
âœ… Fix:
â¤ Use synchronization (synchronized, locks)
â¤ Use Atomic classes (AtomicInteger, AtomicReference)
â¤ Use volatile (visibility guarantee)
â¤ Prefer immutable objects
â¤ Use thread-safe data structures (ConcurrentHashMap)


2ï¸âƒ£ Deadlocks
â— Problem: Two threads wait forever for each otherâ€™s lock â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ system hangs.
âœ… Fix:
â¤ Acquire locks in consistent global order
â¤ Use tryLock() with timeout (ReentrantLock)
â¤ Reduce lock scope (lock only necessary code)
â¤ Avoid nested locking
âœ… Better solution: Use lock-free algorithms if possible.


3ï¸âƒ£ Starvation
â— Problem: Lower-priority threads never get CPU time.
âœ… Fix:
â¤ Avoid thread priorities.
â¤ Use fair locks: new ReentrantLock(true)
â¤ Use thread pools instead of manual thread creation.


4ï¸âƒ£ Thread Interference
â— Problem: Threads overwrite each otherâ€™s computation.
âœ… Fix:
â¤ Wrap shared logic with:
â¤ synchronized
â¤ Lock frameworks
â¤ Atomic operations


5ï¸âƒ£ Increased Complexity
â— Problem: Writing & debugging concurrent code is harder.
âœ… Fix:
â¤ Prefer ExecutorService instead of creating threads manually.
â¤ Use CompletableFuture, Parallel Streams.
â¤ Use frameworks that manage concurrency (Spring Boot, Reactor, Akka).


6ï¸âƒ£ Context Switching Overhead
â— Problem: Too many threads â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ CPU wastes time switching instead of executing.
âœ… Fix:
â¤ Use thread pools (fixed-size) to limit thread count.
â¤ Use virtual threads (Project Loom) in modern Java.
â¤ Properly tune connection pools / executor pool sizes.


7ï¸âƒ£ Memory Overhead
â— Problem: Each thread has its own stack â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ high memory usage.
âœ… Fix:
â¤ Avoid creating unnecessary threads.
â¤ Use cached or fixed thread pools.
â¤ Use Virtual Threads (Loom) â€” almost zero-cost threads.


8ï¸âƒ£ Difficulty in Testing & Debugging
â— Problem: Concurrency bugs are non-deterministic.
âœ… Fix:
â¤ Use tools:
    âœ”ï¸ IntelliJ concurrency debugger
    âœ”ï¸ JProfiler
â¤ Use logging + Thread dumps
â¤ Design with immutability and clear thread boundaries


9ï¸âƒ£ Lower Performance in Some Cases
â— Problem:
Especially when:
    âœ”ï¸ Workloads are small.
    âœ”ï¸ Over-synchronization.
    âœ”ï¸ Many blocking operations.
âœ… Fix:
â¤ Use non-blocking algorithms (CAS operations).
â¤ Use parallelization only when beneficial.
â¤ Tune thread pool size based on:
    âœ”ï¸ CPU-bound â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ cores + 1
    âœ”ï¸ IO-bound â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ (cores * 2) or more


###############################
ğŸ”· Thread Creation Techniques
###############################
1ï¸âƒ£ Using Thread Class

public class World extends Thread {
	@Override
	public void run() {
		for (; ; ) {
			System.out.println(Thread.currentThread().getName());
		}
	}
}

public class intro {
	public static void main(String[] args) {
		World w = new World();
		w.start();
		for (; ;) {
			System.out.println(Thread.currentThread().getName());
		}
	}
}
ğŸ”— Steps:
â¤ A new class World is created that extends Thread.
â¤ The run method is overridden to define the code constitutes the new thread.
â¤ start method is called to initiate the new thread.


2ï¸âƒ£ Using Runnable Interface
public class World implements Runnable {
    @Override
    public void run() {
        for (; ; ) {
            System.out.println(Thread.currentThread().getName());
        }
    }
}

public class intro {
    public static void main(String[] args) {
        Thread t = new Thread(new World());
        t.start();
        for (; ;) {
            System.out.println(Thread.currentThread().getName());
        }
    }
}
ğŸ”„ Steps:
â¤ A new class World is created that implements Runnable.
â¤ The run method is overridden to define the code constitutes the new thread.
â¤ A Thread object is created by passing an instance of the World class to the Thread constructor.
â¤ The start method is called to initiate the new thread.


3ï¸âƒ£ Thread creating using Callable Interface + Future Task
â¤ You cannot directly pass Callable to Thread.
â¤ Callable must be wrapped inside a FutureTask.

ğŸ”„ Execution flow:
1ï¸âƒ£ Define Callable â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ work to be done
2ï¸âƒ£ Wrap in FutureTask â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ manages result
3ï¸âƒ£ Pass FutureTask to Thread â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ runs asynchronously
4ï¸âƒ£ Call future.get() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ retrieve output

import java.util.concurrent.Callable;
import java.util.concurrent.FutureTask;

public class CallableThreadExample {
    public static void main(String[] args) throws Exception {

        // Step 1: Define Callable
        Callable<Integer> task = () -> {
            System.out.println("Task executed by: " + Thread.currentThread().getName());
            Thread.sleep(1000);
            return 42; // return some result
        };

        // Step 2: Wrap in FutureTask
        FutureTask<Integer> futureTask = new FutureTask<>(task);

        // Step 3: Create and start thread
        Thread t = new Thread(futureTask);
        t.start();

        // Step 4: Get result (blocks until thread finishes)
        int result = futureTask.get();
        System.out.println("Result: " + result);
    }
}


#####################
ğŸ”· Thread Lifecycle
#####################
The lifecycle of a thread in Java consist of several states, which a thread can move through during its execution.
The lifecycle of a thread is as follows:
1ï¸âƒ£ New â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ A new thread is created but not yet started.
2ï¸âƒ£ Runnable â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ After the start method is called, the thread becomes runnable. It's ready to run and is waiting for CPU time.
3ï¸âƒ£ Running â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ The thread is in this state when it is executing.
4ï¸âƒ£ Blocked/Waiting â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ A thread is in this state when it is waiting for a resource or for another thread to perform an action.
5ï¸âƒ£ Terminated â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ The thread has completed its execution.


###################
ğŸ”· Thread Methods
###################
ğŸ”„ start()
â¤ Used to start a new thread of execution.
â¤ Internally calls the run() method in a new call stack.
â¤ Cannot call start() on the same thread object more than once â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ throws IllegalThreadStateException.
t1.start();  // starts execution of thread

ğŸ”„ run()
â¤ Contains the code that will be executed by the thread.
â¤ If run() is called directly (without start()), it will behave like a normal method â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ no new thread is created.

@Override
public void run() {
    System.out.println("Thread is running...");
}

ğŸ”„ sleep(milliseconds)
â¤ Causes the currently executing thread to pause temporarily for a given time.
â¤ Throws InterruptedException if another thread interrupts the sleeping one.
â¤ Static method â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ belongs to the class, not an object.


#############################################
ğŸ”· Difference between sleep and wait method
#############################################
| Feature                     | sleep()                          | wait()                                 |
| --------------------------- | -------------------------------- | -------------------------------------- |
| Method belongs to           | Thread class                     | Object class                           |
| Purpose                     | Pause execution for a fixed time | Release lock and wait for notification |
| Lock release                | âŒ Does not release lock         | âœ… Releases lock                      |
| Requires synchronized block | âŒ No                            | âœ… Yes                                |
| How it resumes              | Automatically after time expires | via notify() / notifyAll()             |
| Time-bound                  | Yes (mandatory or optional)      | Optional (wait() or wait(time))        |
| Thread state                | TIMED_WAITING                    | WAITING / TIMED_WAITING                |
| Can be interrupted          | Yes                              | Yes                                    |
| Throws exception            | InterruptedException             | InterruptedException                   |
| Used for                    | Delays, polling, retry logic     | Inter-thread communication             |
| Who controls wake-up        | JVM (timer-based)                | Another thread                         |
| Common misuse               | Used instead of wait/notify      | Used without synchronization           |
| Typical use case            | Pause execution                  | Producerâ€“Consumer                      |


ğŸ”„ join()
â¤ Allows one thread to wait for another thread to finish execution before continuing.
â¤ Ensures sequential execution when required.
â¤ Overloads:
    âœ”ï¸ join() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ waits until thread finishes.
    âœ”ï¸ join(long millis) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ waits for max specified time.
t1.join();  // main thread waits until t1 finishes


ğŸ”„ setPriority(int priority)
â¤ Used to set priority of a thread.
â¤ Range: 1 (MIN_PRIORITY) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ 10 (MAX_PRIORITY), default = 5 (NORM_PRIORITY).
â¤ Just a hint to the scheduler (not guaranteed).
t1.setPriority(Thread.MAX_PRIORITY);

ğŸ‘‰ Naming Threads
A thread can be given a name by passing it in the constructor:

ThreadMethodDemo t1 = new ThreadMethodDemo("FirstThread");
System.out.println(t1.getName());  // prints: FirstThread

âœ… Example with Priority + Name
public class ThreadMethodDemo extends Thread {
    public ThreadMethodDemo(String name) {
        super(name);  // assigning thread name
    }

    public static void main(String[] args) {
        ThreadMethodDemo t1 = new ThreadMethodDemo("FirstThread");
        t1.setPriority(Thread.NORM_PRIORITY); // setting priority
        t1.start();
    }

    @Override
    public void run() {
        for(int i=1; i<=5; i++) {
            System.out.println(Thread.currentThread().getName() + 
                               " Priority: " + Thread.currentThread().getPriority() +
                               " Value: " + i);
        }
    }
}

ğŸ”„ interrupt()
â¤ Used to interrupt a thread that is sleeping, waiting, or blocked.
â¤ Sets the interrupt status flag of the thread.
â¤ If the thread is in sleep() or join(), it will throw InterruptedException.
ğŸ”— Method: t1.interrupt();

âœ… Code Example:
public class ThreadMethodDemo extends Thread {
    @Override
    public void run() {
        try {
            Thread.sleep(1000);   // thread goes to sleep for 1 second
            System.out.println("Thread is running...");
        } catch (Exception e) {
            System.out.println("Thread interrupted: " + e);
        }
    }

    public static void main(String[] args) {
        ThreadMethodDemo t1 = new ThreadMethodDemo();
        t1.start();       // starts the thread â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ calls run() in separate stack
        t1.interrupt();   // interrupts t1 immediately
    }
}

ğŸ”· What Happens at Runtime?
â¤ t1.start() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ new thread is created, run() starts execution.
â¤ Inside run(), thread executes â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Thread.sleep(1000).
    âœ”ï¸ This puts the thread into TIMED_WAITING state.
â¤ Meanwhile, the main thread calls t1.interrupt().
    âœ”ï¸ This sets the interrupt flag for t1.
    âœ”ï¸ Since t1 is currently sleeping, it immediately throws an InterruptedException.
â¤ The exception is caught in the catch block â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶
Thread interrupted: java.lang.InterruptedException: sleep interrupted

ğŸ‘‰ Key Notes
â¤ interrupt()
    âœ”ï¸ If a thread is sleeping, waiting, or blocked â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ InterruptedException is thrown.
    âœ”ï¸ If a thread is running normally (not in sleep/wait) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ just sets interrupt flag, no exception.
â¤ sleep() always needs to be inside a try-catch because it throws InterruptedException.
â¤ Execution flow here:
start() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ run() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ sleep() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ interrupt() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ exception thrown â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ handled in catch.

ğŸ”„ Yield Method
A hint to the scheduler that the current thread is willing to yield its current use of a processor.

âœ…Example:
public class MyThread extends Thread {
    public MyThread(String name){
        super(name);
    }
    public static void main(String[] args) throws InterruptedException {
        MyThread t1=new MyThread("First Thead");
        MyThread t2=new MyThread("Second Thread");
        t1.start();
        t2.start();

    }

    @Override
    public void run() {
       for(int i=0;i<5;i++){
           System.out.println(Thread.currentThread().getName()+ " is running");
           Thread.yield(); // --> tells or hints to the scheduler to give chance to another thread also, although scheduler is free to ignore the request
       }
    }
}

ğŸ”„ setDameon() Method
â¤ This method is used to mark a thread as a daemon thread.
â¤ Daemon means a thread that runs in the background and does not prevent the JVM from shutting down.
â¤ By default, a thread is a user thread, which means it prevents the JVM from shutting down.
â¤ If a thread is a daemon thread, it will not prevent the JVM from shutting down.

âœ…Example:
public class MyThread extends Thread {
    public MyThread(String name) {
        super(name);
    }

    public static void main(String[] args) throws InterruptedException {
        MyThread t1 = new MyThread("First Thead"); //user thread for the business logic
        t1.setDaemon(true);//daemon thread
        t1.start();
        System.out.println("Main method execution completed");
    }

    @Override
    public void run() {
        while (true) {
            System.out.println("Hello World");
        }
    }
}

âœ… Output:
Main method execution completed
Hello World
Hello World
Hello World
...print Hello World few time and then stops as daemon thread is set to true


#####################
ğŸ”· Synchronization
#####################
â¤ Synchronization is a mechanism that ensures that only one thread can access a shared resource at a time.
â¤ It is used to prevent concurrent access to a shared resource, such as a variable or object.
â¤ It is implemented using the synchronized keyword.
â¤ The synchronized keyword is used to define a block of code that is synchronized.
â¤ If multiple threads try to access the synchronized block at the same time, they will block until the first thread releases the lock.
â¤ This prevents concurrent access to the shared resource and prevent race conditions and ensures that only one thread can access it at a time and attain mutual exclusion.
â¤ synchronized method accquire the lock on the object for instance methods and on the class for static methods.

âœ…Example:
public class Counter {
    private int count = 0;

    public synchronized void increment() { //critical section
        Thread.yield();
        count++;
    }

    public int getCount() {
        return count;
    }
}

public class MyThread extends Thread {
    private Counter counter;

    public MyThread(Counter counter){
        this.counter=counter;
    }

    @Override
    public void run(){
        for(int i=0;i<10000;i++){
            counter.increment();
        }
    }
}

public class Test {
    public static void main(String[] args) {
        Counter counter = new Counter();
        MyThread myThread1=new MyThread(counter);
        MyThread myThread2 =new MyThread(counter);
        myThread1.start();
        myThread2.start();
        try{
            myThread1.join();
            myThread2.join();
        }catch (InterruptedException e){
           e.printStackTrace();
            System.out.println("Exception occured: "+e);
        }
        System.out.println(counter.getCount()); //Expected output: 2000, actual output: <2000
    }
}


â¤ When you want to synchronized some part of the method not the whole method then use synchronized block instead of synchronized keyword on the method.
âœ…Example:
 public void increment() { 
       synchronized (this){
           Thread.yield();
           count++;
       }
       // Other code logic is written
    }

ğŸ” What synchronized does NOT do
âŒ No fairness guarantee
âŒ No deadlock prevention
âŒ No interruption support
âŒ No timeout mechanism

ğŸ” Common Problems
ğŸ”„ Deadlock
Thread 1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Lock A â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Lock B
Thread 2 â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Lock B â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Lock A

ğŸ”„ Performance Overhead
â¤ Thread blocking
â¤ Context switching
â¤ Monitor contention

ğŸ” Best Practices
â¤ Synchronize only critical sections
â¤ Avoid synchronizing large methods
â¤ Prefer private lock objects

private final Object lock = new Object();

â¤ Avoid locking on:
    âœ”ï¸ this
    âœ”ï¸ String literals

ğŸ” When to use synchronized
â¤ Simple thread safety
â¤ Low contention
â¤ Legacy code


################
ğŸ”· Class Lock
################
A class lock is a lock associated with the Class object of a class, not with any individual object.

â¤ Every Java class has exactly one Class object
â¤ That Class object has one monitor lock
â¤ This lock is called class lock

ğŸ” How Class Lock is Acquired
A class lock is acquired in two ways:

1ï¸âƒ£ static synchronized method
public static synchronized void method() {
    // class lock acquired
}

2ï¸âƒ£ synchronized(ClassName.class)
synchronized (MyClass.class) {
    // class lock acquired
}
ğŸ‘‰ Both use the same class-level monitor.


ğŸ” Internal Working of Class lock
â¤ JVM creates one Class object per loaded class
â¤ That Class object has a monitor
â¤ When a thread enters:
    âœ”ï¸ static synchronized method
    âœ”ï¸ synchronized(ClassName.class)
â¤ It locks the Class object
â¤ No other thread can enter any class-locked code of that class


ğŸ” Class Lock ğŸ†š  Object Lock
| Feature            | Object Lock                            | Class Lock            |
| ------------------ | -------------------------------------- | --------------------- |
| Lock applies to    | Single object                          | Entire class          |
| Created by         | synchronized instance method / block | static synchronized |
| Lock owner         | Object instance                        | Class object        |
| Threads blocked    | Only for same object                   | Across all objects    |
| Parallel execution | Allowed on different objects           | âŒ Not allowed         |


âœ… Class Lock Example
class Counter {
    public static synchronized void increment() {
        // class lock
    }
}
ğŸ‘‰ Only one thread in entire JVM can execute this at a time

âœ… Code Example Showing Class Lock Behavior
class Printer {
    public static synchronized void print() {
        System.out.println(Thread.currentThread().getName() + " printing...");
        try { Thread.sleep(1000); } catch (Exception e) {}
    }
}

public class Test {
    public static void main(String[] args) {
        new Thread(Printer::print).start();
        new Thread(Printer::print).start();
    }
}
Output (Serialized):
Thread-0 printing...
Thread-1 printing...
ğŸ‘‰ Second thread waits for the class lock.

ğŸ”„ When Should You Use Class Lock?
â¤ Protecting static variables
â¤ Synchronizing access to shared global resources
â¤ Enforcing one-thread-at-a-time across all instances

âŒ Avoid Class Lock When
â¤ High concurrency is required
â¤ Lock scope is unnecessarily large
â¤ Only instance data is being modified

âœ”ï¸ object lock and class lock coexist independently.


##########
ğŸ”· Locks
##########
Thread-safe mechanism that allows multiple threads to access a shared resource concurrently.

â“ Why Use Locks Instead of synchronized?
| Feature               | synchronized                                       | Lock                             |
| --------------------- | ---------------------------------------------------- | ---------------------------------- |
| Automatic release     | Yes (automatically released when method/block exits) | No (must manually call unlock()) |
| Try to acquire        | No                                                   | Yes (tryLock())                  |
| Interruptible waiting | No                                                   | Yes (lockInterruptibly())        |
| Fairness policy       | No                                                   | Yes (can create fair locks)    |
| Multiple conditions   | No                                                   | Yes (via Condition objects)      |

ğŸ”„ There are two types of locks:
    1ï¸âƒ£ Intrinsic Locks (Monitor Locks):
        â¤ Used internally by the synchronized keyword.
        â¤ Every Java object has an intrinsic lock.
        â¤ Only one thread can hold it at a time.
        â¤ Automatically acquired and released.

    âœ… Use Case: When you want simple synchronization â€” e.g., synchronize a method or block.

    synchronized void print() {
    // intrinsic lock acquired on this object
    }

    2ï¸âƒ£ Explicit Locks (ReentrantLock)
        â¤ Part of java.util.concurrent.locks package
        â¤ Must manually acquire and release
        â¤ More flexible than intrinsic locks
        â¤ Provides methods like tryLock(), lockInterruptibly(), isHeldByCurrentThread().

        âœ… Use Case:
        â¤ When you need:
        â¤ fair access to threads,
        â¤ interruptible locks, or
        â¤ timed waiting for a lock.

public interface Lock {
    void lock();
    void unlock();
    boolean tryLock();
    void lockInterruptibly() throws InterruptedException;
}

ğŸ”„ Lock Interface Methods use Case:
| Method                              | Description                                                         |
| ----------------------------------- | ------------------------------------------------------------------- |
| lock()                            | Acquires the lock, waits indefinitely if not available.             |
| unlock()                          | Releases the lock (should always be in finally).                  |
| tryLock()                         | Attempts to acquire lock immediately; returns true if successful. |
| tryLock(long time, TimeUnit unit) | Waits for the given time before giving up.                          |
| lockInterruptibly()               | Acquires lock but allows interruption while waiting.                |
| isLocked()                        | Checks if the lock is held by any thread.                           |

    3ï¸âƒ£ ReentrantLock 
    ğŸŒŸ Properties:
        âœ”ï¸ A thread can acquire the same lock multiple times without being blocked (hence â€œreentrantâ€) and it maintains a count.
        âœ”ï¸ Must call unlock() the same number of times it called lock(), every lock called must be paired with an unlock call.
        âœ”ï¸ Can be fair or unfair:
                â¤ Fair â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ threads acquire lock in order of request.
                â¤ Unfair â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ scheduler decides (default).


    4ï¸âƒ£ ReentrantReadWriteLock
    â¤ Provides two locks:
        âœ”ï¸ Read Lock: can be held by multiple readers simultaneously if thereâ€™s no writer.
        âœ”ï¸ Write Lock: exclusive lock; only one thread can write at a time.

    âœ… Use Case: When reads are frequent and writes are rare â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ improves performance.

    ğŸ”— Code Snippet:
    ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();
    Lock readLock = rwLock.readLock();
    Lock writeLock = rwLock.writeLock();

    readLock.lock();
    try {
       // multiple readers allowed
    } finally {
       readLock.unlock();
    }

    5ï¸âƒ£ StampedLock (Java 8+)
    â¤ Offers better performance in high-concurrency environments.
    â¤ Provides three modes:
        âœ”ï¸ Write Lock
        âœ”ï¸ Read Lock
        âœ”ï¸ Optimistic Read (non-blocking, fastest)

    â¤ Returns a stamp (long value) used to unlock later.

    âœ… Use Case: When you need fast, optimistic read operations with low write contention.

    StampedLock lock = new StampedLock();
    long stamp = lock.tryOptimisticRead();
    if (!lock.validate(stamp)) {
        stamp = lock.readLock();
        try {
            // protected read
        } finally {
            lock.unlockRead(stamp);
        }
    }    

ğŸ”„ Best Practices
âœ… Always call unlock() in a finally block.
âœ… Prefer tryLock() to avoid deadlocks.
âœ… Use ReentrantReadWriteLock for high read concurrency.
âœ… Use StampedLock for performance-critical read-heavy systems.
âœ… Avoid mixing synchronized and Lock on same object.


ğŸ”· Locks' Fairness: Prevent Deadlocks
â“ What is Unfair Locking?
â¤ By default, ReentrantLock uses an unfair policy, meaning:
â¤ When multiple threads are waiting for the lock,
a new thread may â€œcut in lineâ€ and acquire the lock even if others have been waiting longer.
â¤ The scheduler doesnâ€™t strictly follow first come, first served (FCFS) order.
â¤ This can cause thread starvation, but improves performance in some cases.

âœ…Example: Unfair Lock Demonstration
package com.corejava;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class UnfairLockExample {
    // Default constructor => unfair lock
    private final Lock unfairLock = new ReentrantLock();

    public void accessResource() {
        unfairLock.lock();
        try {
            System.out.println(Thread.currentThread().getName() + " acquired the lock");
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            unfairLock.unlock();
            System.out.println(Thread.currentThread().getName() + " released the lock");
        }
    }
}

package com.corejava;

public class Main {
    public static void main(String[] args) {
        UnfairLockExample unfairLockExample = new UnfairLockExample();

        Runnable task = () -> unfairLockExample.accessResource();

        Thread t1 = new Thread(task, "Thread 1");
        Thread t2 = new Thread(task, "Thread 2");
        Thread t3 = new Thread(task, "Thread 3");

        t1.start();
        t2.start();
        t3.start();
    }
}
âœ…Expected Output(May vary in each run):
Thread 2 acquired the lock
Thread 2 released the lock
Thread 3 acquired the lock
Thread 3 released the lock
Thread 1 acquired the lock
Thread 1 released the lock

ğŸ‘‰ Next time when you run the code:
Thread 1 acquired the lock
Thread 1 released the lock
Thread 3 acquired the lock
Thread 3 released the lock
Thread 2 acquired the lock
Thread 2 released the lock

ğŸ‘‰ Thereâ€™s no guaranteed order â€” threads acquire the lock randomly even though Thread 1 started first.
ğŸ‘‰ Thatâ€™s the unfair behavior.

ğŸ†š Fair vs Unfair Lock
If you want to make it fair, modify one line ğŸ‘‡

private final Lock fairLock = new ReentrantLock(true); // true = fair

âœ…Output with Fair Lock:
Thread 1 acquired the lock
Thread 2 acquired the lock
Thread 1 released the lock
Thread 2 released the lock
Thread 3 acquired the lock
Thread 3 released the lock
ğŸ‘‰ Now the output follows Thread 1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Thread 2 â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Thread 3 (the order in which they started waiting).

â¤ Thread 1 and Thread 2 both say â€œacquired the lockâ€ before either released it.
â¤ Thatâ€™s actually not possible if both lines refer to the same critical section protected by the same lock, because only one thread can hold a ReentrantLock at a time.

â¤ So, what really happens is:
    âœ”ï¸ Thread 1 acquires the lock and prints.
    âœ”ï¸ Before Thread 1 releases it, Thread 2 is blocked, waiting.
    âœ”ï¸ Once Thread 1 releases the lock, Thread 2 then acquires and prints.
    âœ”ï¸ But because of console I/O buffering, their print statements may appear out of strict order.
â¤ So donâ€™t rely solely on print order â€” small thread scheduling variations can cause misleading console sequences.


ğŸ”„ Disadvantages of synchronized in Java
1ï¸âƒ£ No Flexibility / Limited Control
â¤ Once a synchronized block or method starts, other threads must wait â€” no timeout, no try mechanism.
â¤ You cannot check if a lock is available before trying to acquire it.
â¤ Unlike ReentrantLock, you cannot interrupt a thread waiting for a synchronized lock.

âœ… Example:
synchronized void print() { ... }  // waits indefinitely

2ï¸âƒ£ Automatic Locking â€” No Manual Release
â¤ Lock is automatically released when the method/block exits, even if you wanted to keep it longer.
â¤ You cannot manually unlock() early like you can with Lock objects.

3ï¸âƒ£ No Fairness Guarantee
â¤ Thread scheduling is not fair â€” JVM does not guarantee FIFO order of thread execution.
â¤ A thread that waits longer doesnâ€™t necessarily get the lock next â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ can lead to thread starvation.

4ï¸âƒ£ Cannot Try for Lock (No tryLock Equivalent)
â¤ Thereâ€™s no non-blocking attempt to acquire the lock.
â¤ Threads either block indefinitely or wait till lock is free.

ğŸ†š Compare with Lock API:
if (lock.tryLock()) {
   // proceed
} else {
   // do something else
}

5ï¸âƒ£ Cannot Create Multiple Condition Variables
â¤ synchronized provides only one intrinsic lock per object.
â¤ You can use only one wait set per object (via wait(), notify(), notifyAll()).
â¤ With Lock, you can create multiple Condition objects for fine-grained control.

6ï¸âƒ£ No Timeout Option
â¤ Thereâ€™s no way to specify how long a thread should wait to acquire the lock.
â¤ Threads can remain blocked indefinitely.

7ï¸âƒ£ Can Cause Deadlock Easily
â¤ If multiple synchronized blocks lock different objects in wrong order, threads can deadlock.
â¤ Because synchronization is implicit and uninterruptible, recovery is difficult.

8ï¸âƒ£ Lower Performance in High Contention
â¤ When many threads compete for the same lock, context switching and blocking overhead increases.
â¤ Modern alternatives (Lock, StampedLock, etc.) can be more scalable and non-blocking.

9ï¸âƒ£ No Explicit Lock Information
â¤ You canâ€™t check:
    âœ”ï¸ whether a thread currently holds a lock,
    âœ”ï¸ how many times it has entered (no reentrancy info), or
    âœ”ï¸ if another thread is waiting.
â¤ ReentrantLock provides such introspection methods (isLocked(), isHeldByCurrentThread(), etc.).

1ï¸âƒ£0ï¸âƒ£ Difficult Debugging
â¤ Since locking and unlocking are automatic, itâ€™s harder to trace where threads are blocking or waiting.
â¤ Deadlocks or long wait times are tough to identify without specialized tools.


############################
ğŸ”· ReadWriteLock Interface
############################
A ReadWriteLock is a special kind of lock that maintains two separate locks:
ğŸ‘‰ Read Lock â€“ for read-only operations
ğŸ‘‰ Write Lock â€“ for write/update operations

â“ Why Use It:
â¤ In many systems, read operations are more frequent than writes.
â¤ If every thread used the same lock (like synchronized), even reads would block each other â€” reducing performance.

âœ… ReadWriteLock allows multiple threads to read simultaneously,
ğŸš« but only one thread can write at a time, and no reader can read while a write is happening.

ğŸ”„ Rule of Thumb:
| Operation       | Can run in parallel? | Condition                            |
| --------------- | -------------------- | ------------------------------------ |
| Multiple Reads  | âœ… Yes                | As long as no write is happening |
| Read + Write    | âŒ No                 | Write locks block readers            |
| Multiple Writes | âŒ No                 | Only one writer at a time            |
| Write + Write   | âŒ No                 | Only one writer                      |

âœ…Example: ReadWriteCounter
package com.corejava;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class ReadWriteCounter {
    private int count=0;
    private  final ReadWriteLock rwlock=new ReentrantReadWriteLock();

    private final Lock readLock=rwlock.readLock();
    private final Lock writeLock=rwlock.writeLock();

    public void increment(){
        writeLock.lock();
        try{
            System.out.println(Thread.currentThread().getName()+" incremented");
            count++;
        }finally {
            writeLock.unlock();
        }
    }

    public int getCount(){
        readLock.lock();
        try{
            System.out.println("Count of the variable: "+count);
        }finally {
            readLock.unlock();
        }
        return count;
    }
}

1ï¸âƒ£ Class Setup
â¤ rwlock creates an object that provides two locks:
    âœ”ï¸ readLock() â€“ allows concurrent reads.
    âœ”ï¸ writeLock() â€“ exclusive lock for writing.
â¤ count â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ shared resource being read/written by threads.

2ï¸âƒ£ Write Operation (increment())
â¤ writeLock.lock() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ acquires exclusive access to count.
â¤ While one thread holds the write lock:
    âŒ No other write thread can enter.
    âŒ No read thread can access count.
â¤ Ensures atomicity and data consistency during modification.
â¤ Finally block ensures unlock() always happens, even if an exception occurs.

3ï¸âƒ£ Read Operation (getCount())
â¤ readLock.lock() allows concurrent access to count if no write is active.
â¤ Multiple threads can hold readLock simultaneously.
â¤ When a write lock is requested, new readers must wait until the write finishes.

package com.corejava;

public class Main {
    public static void main(String[] args) throws InterruptedException {

        ReadWriteCounter counter=new ReadWriteCounter();
        Runnable readTask = () -> {
            for(int i=0;i<10;i++){
                System.out.println(Thread.currentThread().getName()+" read: "+counter.getCount() );
            }
        };

        Runnable writeTask= () -> {
            for(int i=0;i<10;i++){
                counter.increment();
            }
        };

        Thread writeThread=new Thread(writeTask,"Thread write1");
        Thread readThread1=new Thread(readTask,"Thread read1");
        Thread readThread2=new Thread(readTask,"Thread read2");

        writeThread.start();
        readThread1.start();
        readThread2.start();

        try {
            writeThread.join();
            readThread1.join();
            readThread2.join();
        } catch (InterruptedException e) {
           try {
               writeThread.interrupt();
               readThread1.interrupt();
               readThread2.interrupt();
           } catch (RuntimeException ex) {
               throw new RuntimeException(ex);
           }
        }

        System.out.println("Final count:"+ counter.getCount());
    }
}

4ï¸âƒ£ Main Class Logic
â¤ readTask â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ repeatedly reads the counter (10 times).
â¤ writeTask â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ increments the counter (10 times).

5ï¸âƒ£ Threads Creation
One write thread and two read threads.

6ï¸âƒ£ Execution Flow
writeThread.start();
readThread1.start();
readThread2.start();

â¤ All threads start together.
â¤ When the write thread holds writeLock, readers wait.
â¤ When write finishes, both read threads can read concurrently again.

7ï¸âƒ£ Final Output
System.out.println("Final count:" + counter.getCount());
ğŸ‘‰ After all threads finish, the final count should be 10 (since one writer increments 10 times).

â“ Why ReadWriteLock Is Better Here
| Aspect                   | synchronized     | ReadWriteLock |
| ------------------------ | ------------------ | --------------- |
| Multiple readers         | âŒ Block each other | âœ… Allowed       |
| Writer access            | Exclusive          | Exclusive       |
| Performance (read-heavy) | Lower              | Higher          |
| Fine-grained control     | Limited            | High            |


ğŸ”„ Use ReadWriteLock When
â¤ Read operations are frequent.
â¤ Write operations are infrequent but must be exclusive.
âœ… Example scenarios:
    âœ”ï¸ Caching systems
    âœ”ï¸ Configuration reading
    âœ”ï¸ File metadata readers
    âœ”ï¸ In-memory database snapshots

ğŸ” Insights
âœ”ï¸ Always unlock in finally block.
âœ”ï¸ Donâ€™t acquire both read and write lock in same thread (can deadlock).
âœ”ï¸ Prefer ReentrantReadWriteLock for reentrancy (same thread can re-acquire lock safely).
âœ”ï¸ Readers block writers, and writers block readers â€” but readers can share the lock.

#############
ğŸ”· Deadlock
#############
â¤ Deadlock is a situation when two or more threads are waiting for each other to release a lock.
â¤ This can happen when two threads hold locks in opposite order, or when a thread acquires a lock and then waits for another thread to release it.
â¤ In a deadlock, neither thread can proceed, and the program will be stuck in an infinite loop.

Deadlock typically occurs when four conditions are met simultaneously:
1ï¸âƒ£ Mutal exclusion: Only one thread can access a shared resource at a time.
2ï¸âƒ£ Hold and wait: A thread holds a lock and then waits for another thread to release it.
3ï¸âƒ£ No preemption: A thread cannot be preempted by another thread.
4ï¸âƒ£ Circular wait: Two threads are waiting for each other to release a lock.
ğŸ‘‰ Deadlock can be prevented by ensuring that no thread holds a lock that another thread is waiting for.

âœ…Example:
package com.corejava;

class Pen{
    public synchronized void writeWithPenAndPaper(Paper paper){
        System.out.println(Thread.currentThread().getName()+ " is using pen "+this+" and trying to get paper"+ paper);
        paper.finishWriting();
    }

    public synchronized void finishWriting(){
        System.out.println(Thread.currentThread().getName()+ " finished using paper "+this);
    }
}

class Paper{
    public synchronized void writeWithPenAndPaper(Pen pen){
        System.out.println(Thread.currentThread().getName()+ " is using paper "+this+" and trying to get pen"+ pen);
        pen.finishWriting();
    }

    public synchronized void finishWriting(){
        System.out.println(Thread.currentThread().getName()+ " finished using paper "+this);
    }
}

class Task1 implements Runnable{
    private Pen pen;
    private Paper paper;
    public Task1(Pen pen,Paper paper){
        this.pen=pen;
        this.paper=paper;
    }
    @Override
    public void run() {
        pen.writeWithPenAndPaper(paper);
    }
}

class Task2 implements Runnable{
    private Pen pen;
    private Paper paper;
    public Task2(Pen pen,Paper paper){
        this.pen=pen;
        this.paper=paper;
    }
    @Override
    public void run() {
        paper.writeWithPenAndPaper(pen);
    }
}

public class DeadLockExample {
    public static void main(String[] args) {
        Pen pen =new Pen();
        Paper paper=new Paper();

        Thread thread1=new Thread(new Task1(pen,paper),"Thread-1");
        Thread thread2=new Thread(new Task2(pen,paper),"Thread-2");
        thread1.start();
        thread2.start();
    }
}
ğŸ”’ Step-by-step:
â¤ Thread-1 locks Pen.
â¤ It tries to call paper.finishWriting() â€” a synchronized method.
â¤ To enter paper.finishWriting(), it must get Paperâ€™s lock.
â¤ But what if Thread-2 already holds the Paper lock? â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Then Thread-1 waits forever.

â¤ Thread-2 locks Paper.
â¤ Then tries to call pen.finishWriting().
â¤ To enter that method, it must acquire Penâ€™s lock.
â¤ But Penâ€™s lock is already held by Thread-1.

To Resolve this problem, we need to ensure that no thread holds a lock that another thread is waiting for.

âœ… Solution:
class Task2 implements Runnable{
    private Pen pen;
    private Paper paper;
    public Task2(Pen pen,Paper paper){
        this.pen=pen;
        this.paper=paper;
    }
    @Override
    public void run() {
        synchronized(pen){
        paper.writeWithPenAndPaper(pen);
        }
    }
}

####################
ğŸ”·tryLock() method
####################
â¤ tryLock() is a non-blocking lock acquisition method
â¤ Part of java.util.concurrent.locks.Lock (e.g., ReentrantLock)
â¤ Returns true if lock is acquired, false otherwise
â¤ Thread does not wait if the lock is unavailable

ğŸ”„ How tryLock() Prevents Deadlock
âœ… tryLock() Solution
â¤ Thread attempts to acquire lock
â¤ If lock not available â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ backs off instead of waiting
â¤ Breaks circular wait, hence prevents deadlock


ğŸ”„ Deadlock vs tryLock()
Without tryLock()
â¤ Thread A holds Lock1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ waits for Lock2
â¤ Thread B holds Lock2 â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ waits for Lock1

âŒ Deadlock
â¤ With tryLock()
â¤ Thread A tries Lock2 â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ fails â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ releases Lock1
â¤ Thread B proceeds
âœ… No deadlock


#####################################
ğŸ”· Semaphore (Concurrency Control)
#####################################
â¤ A Semaphore is a synchronization primitive
â¤ Used to control access to a limited number of resources
â¤ Maintains a counter (permits)
â¤ Threads must acquire a permit before accessing the resource
â¤ Permit is released after use

ğŸ“¦ Package (Java): java.util.concurrent.Semaphore

ğŸ”„ Why Semaphore is Needed?
When multiple threads want to access a finite resource

âœ… Examples:
    âœ”ï¸ Database connection pool
    âœ”ï¸ Thread pool size control
    âœ”ï¸ Printer pool
    âœ”ï¸ API rate limiting


ğŸ”„ Types of Semaphore
1ï¸âƒ£ Binary Semaphore
â¤ Permits = 1
â¤ Works like a mutex
â¤ Only one thread allowed at a time

2ï¸âƒ£ Counting Semaphore
â¤ Permits > 1
â¤ Allows limited parallel access


ğŸ”„ Working of Semaphores
Semaphore has an internal counter
1ï¸âƒ£ acquire():
    âœ”ï¸ If counter > 0 â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ decrement and proceed
    âœ”ï¸ If counter = 0 â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ thread blocks
2ï¸âƒ£ release():
    âœ”ï¸ Increment counter
    âœ”ï¸ Wake up one waiting thread


ğŸ”„ Important Methods
1ï¸âƒ£ acquire() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ blocks until permit available
2ï¸âƒ£ tryAcquire() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ non-blocking
3ï¸âƒ£ release() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ returns permit
4ï¸âƒ£ availablePermits() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ remaining permits


ğŸ”„ Real-World Use Case: Database Connection Pool
ğŸ‘‰ Problem:
    âœ”ï¸ Only 3 DB connections available
    âœ”ï¸ 10 threads want DB access
    âœ”ï¸ More than 3 connections â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ DB crash
âœ… Solution: Use Semaphore(3)


âœ… Java Code Example (Counting Semaphore)
import java.util.concurrent.Semaphore;

class Database {

    private static final Semaphore semaphore = new Semaphore(3);

    public static void accessDatabase(int userId) {
        try {
            semaphore.acquire(); // request permit
            System.out.println("User " + userId + " acquired DB connection");

            Thread.sleep(2000); // simulate DB work

        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            semaphore.release(); // return permit
            System.out.println("User " + userId + " released DB connection");
        }
    }
}

public class SemaphoreDemo {
    public static void main(String[] args) {

        for (int i = 1; i <= 10; i++) {
            int userId = i;
            new Thread(() -> Database.accessDatabase(userId)).start();
        }
    }
}

âœ… Output Behavior
â¤ At most 3 users access DB at the same time
â¤ Others wait until a permit is released
â¤ Prevents resource exhaustion


ğŸ”„ Semaphore with tryAcquire() (Deadlock-Safe)
if (semaphore.tryAcquire()) {
    try {
        // access resource
    } finally {
        semaphore.release();
    }
} else {
    System.out.println("Resource busy, try later");
}
âœ”ï¸ Avoids blocking
âœ”ï¸ Useful in high-availability systems

ğŸ”„ Fair vs Unfair Semaphore
Semaphore semaphore = new Semaphore(3, true); // fair
â¤ Fair = true
    âœ”ï¸ FIFO order
    âœ”ï¸ Slower

â¤ Fair = false (default)
    âœ”ï¸ Higher throughput
    âœ”ï¸ Possible starvation


âœ… Advantages of Semaphore
â¤ Controls access to limited resources: Ideal for DB connections, thread pools, printers
â¤ Supports multiple permits: Allows controlled parallelism (unlike mutex)
â¤ Prevents resource exhaustion: Limits number of concurrent threads
â¤ Flexible usage: Can be binary or counting semaphore
â¤ Non-blocking options: tryAcquire() helps avoid deadlocks
â¤ Language & OS level concept: Widely supported across systems


âŒ Disadvantages of Semaphore
â¤ No ownership concept: Any thread can release â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ error-prone
â¤ Hard to debug: Permit leaks cause hidden deadlocks
â¤ Risk of forgetting release(): Leads to thread starvation
â¤ Not reentrant: Same thread cannot re-acquire safely
â¤ No atomicity guarantee: Not suitable for compound operations
â¤ Overuse reduces readability: Complex logic compared to locks


#########################
ğŸ”· Thread Communication
#########################
â¤ In a multithreaded environment, threads can communicate with each other to accomplish a task.
â¤ Without proper communication mechanisms, threads might end up in efficient busy-waiting states, leading to wastage of CPU resources and potential deadlocks.

â“ Why Thread Communication is Needed
âŒ Without communication:
â¤ Threads run independently, unaware of each other.
â¤ They may perform redundant operations or wait inefficiently (busy-waiting).
â¤ Leads to CPU wastage, race conditions, or deadlocks.
âœ… With communication:
â¤ One thread can signal another when a task is complete.
â¤ Threads can wait, notify, and resume execution in a controlled order.

ğŸ”„ Methods (Used with synchronized)
| Method        | Description                                                               | Used By         |
| ------------- | ------------------------------------------------------------------------- | --------------- |
| wait()      | Causes current thread to release the lock and enter the waiting state | Consumer thread |
| notify()    | Wakes up one waiting thread                                           | Producer thread |
| notifyAll() | Wakes up all waiting threads                                          | Producer thread |

âš ï¸ These methods must be called inside a synchronized block or method, otherwise youâ€™ll get an IllegalMonitorStateException.

âœ… Basic Workflow (Producerâ€“Consumer Example)
â¤ Producer thread produces data (adds items to buffer).
â¤ Consumer thread consumes data (removes items from buffer).
â¤ Both need to coordinate:
    âœ”ï¸ï¸ Producer must wait if buffer is full.
    âœ”ï¸ï¸ Consumer must wait if buffer is empty.

ğŸ”— Code implementation:
class SharedResource {
    private int data;
    private boolean available = false;

    public synchronized void produce(int value) {
        while (available) {
            try { wait(); } catch (InterruptedException e) { 
              Thread.currentThread().interrupt();
                }
        }
        data = value;
        System.out.println("Produced: " + data);
        available = true;
        notify(); //--> Wake up consumer
    }

    public synchronized void consume() {
        while (!available) {
            try { wait(); } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        System.out.println("Consumed: " + data);
        available = false;
        notify(); //--> Wake up producer
    }
}

public class ThreadCommunicationDemo {
    public static void main(String[] args) {
        SharedResource resource = new SharedResource();

        Thread producer = new Thread(() -> {
            for (int i = 1; i <= 5; i++) {
                resource.produce(i);
            }
        });

        Thread consumer = new Thread(() -> {
            for (int i = 1; i <= 5; i++) {
                resource.consume();
            }
        });

        producer.start();
        consumer.start();
    }
}

âœ… Output:
Produced: 1
Consumed: 1
Produced: 2
Consumed: 2
Produced: 3
Consumed: 3
Produced: 4
Consumed: 4
Produced: 5
Consumed: 5

âš¡ How It Works Internally
| Step | Action                           | Thread State            |
| ---- | -------------------------------- | ----------------------- |
| 1    | Thread enters synchronized block | Running                 |
| 2    | Calls wait()                   | Releases lock â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Waiting |
| 3    | Another thread calls notify()  | Waiting thread wakes up |
| 4    | Waiting thread reacquires lock   | Runnable                |
| 5    | Resumes after wait()           | Running                 |

ğŸš¨ Important Rules
âœ”ï¸ Must be inside a synchronized context.
synchronized(obj) { obj.wait(); }

âœ”ï¸ The thread calling wait() releases the lock immediately.
âœ”ï¸ notify()/notifyAll() do not release lock immediately â€”
they only wake waiting threads; the lock is released after synchronized block exits.
âœ”ï¸ Always use while (not if) around wait() â€”
because of spurious wakeups (unexpected wake signals).


ğŸ”· Thread Saftey
Thread safety means that a piece of code, class, or object can be safely used by multiple threads simultaneously without causing inconsistent or incorrect results.

â“ Why Thread Safety Is Needed
When multiple threads access and modify shared data (like variables, objects, files, or collections) without synchronization, problems occur.

ğŸ’£ Common Thread Safety Problems
| Problem                | Description                                                                        |
| ---------------------- | ---------------------------------------------------------------------------------- |
| Race Condition     | Two or more threads modify shared data concurrently, causing unpredictable results |
| Data Inconsistency | Shared variable values become incorrect                                            |
| Deadlock           | Threads waiting indefinitely for each otherâ€™s locks                                |
| Starvation         | Some threads never get CPU time                                                    |
| Visibility Issues  | One threadâ€™s updates not visible to another due to caching                         |

âŒ Example (Non-thread-safe)
class Counter {
    private int count = 0;

    public void increment() {
        count++; // not atomic
    }

    public int getCount() {
        return count;
    }
}

public class Demo {
    public static void main(String[] args) throws InterruptedException {
        Counter c = new Counter();

        Thread t1 = new Thread(() -> { for (int i = 0; i < 1000; i++) c.increment(); });
        Thread t2 = new Thread(() -> { for (int i = 0; i < 1000; i++) c.increment(); });

        t1.start(); t2.start();
        t1.join(); t2.join();

        System.out.println("Final count: " + c.getCount());
    }
}

ğŸ” Output (inconsistent)
Final count: 1876   // sometimes 1980, sometimes 2000, etc.

â“ Why?
â¤ count++ is not atomic â€” it performs:
    âœ”ï¸ Read value of count
    âœ”ï¸ Increment value
    âœ”ï¸ Write back
â¤ Two threads can interleave in between these steps, leading to race conditions.

âœ… How to Achieve Thread Safety
1ï¸âƒ£ Use Synchronization
â¤ Use synchronized keyword to ensure only one thread accesses a critical section at a time.

class SafeCounter {
    private int count = 0;

    public synchronized void increment() {
        count++;
    }

    public synchronized int getCount() {
        return count;
    }
}

2ï¸âƒ£ Use Locks (java.util.concurrent.locks)
â¤ ReentrantLock, ReadWriteLock give more flexibility and control than synchronized.

class SafeCounter {
    private int count = 0;
    private final Lock lock = new ReentrantLock();

    public void increment() {
        lock.lock();
        try { count++; } 
        finally { lock.unlock(); }
    }
}

3ï¸âƒ£ Use Atomic Classes
â¤ Classes like AtomicInteger, AtomicBoolean, AtomicReference perform atomic operations without explicit locks.

class AtomicCounter {
    private AtomicInteger count = new AtomicInteger(0);

    public void increment() {
        count.incrementAndGet();
    }

    public int getCount() {
        return count.get();
    }
}

4ï¸âƒ£ Use Thread-safe Collections
â¤ Use collections from java.util.concurrent package:
âœ”ï¸ ConcurrentHashMap
âœ”ï¸ CopyOnWriteArrayList
âœ”ï¸ BlockingQueue
âœ”ï¸ ConcurrentLinkedQueue
ğŸ‘‰ These allow safe concurrent access without manual synchronization.

5ï¸âƒ£ Use Immutable Objects
â¤ If an objectâ€™s state cannot change, itâ€™s automatically thread-safe.

final class Student {
    private final String name;
    private final int rollNo;

    public Student(String name, int rollNo) {
        this.name = name;
        this.rollNo = rollNo;
    }
}
ğŸ‘‰ Immutable objects are naturally thread-safe because no thread can modify their state.

#####################
6ï¸âƒ£ Volatile Keyword
#####################
â¤ volatile ensures visibility of a variable across threads
â¤ Any write to a volatile variable is immediately written to main memory
â¤ Any read of a volatile variable is always read from main memory
â¤ Prevents instruction reordering for that variable
â¤ Does NOT provide atomicity or full thread safety


ğŸ”„ Problem Without volatile (Visibility Issue)
âŒ What can go wrong?
â¤ One thread updates a variable
â¤ Another thread never sees the updated value
â¤ Happens due to CPU cache + instruction reordering

âŒ Code WITHOUT volatile (May run forever)
class VolatileDemoWithout {

    private static boolean stop = false; // NOT volatile

    public static void main(String[] args) throws InterruptedException {

        Thread worker = new Thread(() -> {
            System.out.println("Worker thread started...");
            while (!stop) {
                // busy wait
            }
            System.out.println("Worker thread stopped!");
        });

        worker.start();

        Thread.sleep(1000); // main thread waits
        stop = true;        // update flag
        System.out.println("Main thread updated stop = true");
    }
}
âš ï¸ What may happen?
â¤ Program never terminates
â¤ Worker thread keeps reading cached stop = false
â¤ Update from main thread not visible


âœ… Correct Code WITH volatile
class VolatileDemoWith {

    private static volatile boolean stop = false; // VOLATILE

    public static void main(String[] args) throws InterruptedException {

        Thread worker = new Thread(() -> {
            System.out.println("Worker thread started...");
            while (!stop) {
                // busy wait
            }
            System.out.println("Worker thread stopped!");
        });

        worker.start();

        Thread.sleep(1000); // main thread waits
        stop = true;        // update flag
        System.out.println("Main thread updated stop = true");
    }
}
ğŸ” What volatile FIXES
âœ”ï¸ Guarantees
    â¤ Visibility: changes made by one thread are immediately visible to others
    â¤ Prevents instruction reordering (for that variable)

âŒ What volatile DOES NOT guarantee
âŒ Atomicity
âŒ Thread safety for compound operations


ğŸ”„ Memory-Level Explanation
ğŸ‘‰ Without volatile
Main Thread      CPU Cache       Worker Thread
stop = true  ->  NOT flushed  ->  still sees stop = false

ğŸ‘‰ With volatile
Main Thread      Main Memory     Worker Thread
stop = true  ->  written       ->  reads updated value
ğŸ‘‰ volatile forces read/write directly from main memory, not CPU cache.


â“ Is volatile thread-safe?
ğŸ‘‰ NO
Example âŒ:
volatile int count = 0;
count++; // NOT atomic

âœ”ï¸ Correct alternative:
1ï¸âƒ£ AtomicInteger
2ï¸âƒ£ synchronized


âœ… When to Use volatile
âœ”ï¸ Use when:
    â¤ One thread writes, others only read
    â¤ Flag variables (stop, status, shutdown)
    â¤ No compound operations

âŒ Avoid when:
    â¤ Multiple threads modify value
    â¤ Increment/decrement logic needed


#################
ğŸ”· Thread Pool
#################
â¤ A Thread Pool is a pool (collection) of pre-created worker threads that can execute tasks concurrently.
â¤ Instead of creating a new thread for every task (which is expensive), tasks are queued and executed by available threads in the pool.
â¤ Once a thread completes a task, it is reused for another one â€” improving performance and resource utilization.

â“ Why Use a Thread Pool?
| Problem                                                        | How Thread Pool Solves It                |
| -------------------------------------------------------------- | ---------------------------------------- |
| Creating too many threads causes high memory and CPU overhead. | Pool reuses a limited number of threads. |
| Uncontrolled thread creation can crash the system.             | Pool size is fixed or managed.           |
| Thread creation/destruction per task is costly.                | Threads are reused efficiently.          |

ğŸ”„ Core Concepts
â¤ Task â€“ A unit of work (e.g., implementing Runnable or Callable).
â¤ Worker Thread â€“ Thread that takes tasks from the queue and executes them.
â¤ Blocking Queue â€“ Stores tasks waiting to be executed.
â¤ Executor Framework â€“ Provides thread pool management utilities.


ğŸ”· Executor Framework (Java 5+)
â¤ Java introduced the java.util.concurrent package with the Executor Framework to simplify thread management and the development of concurrent applications.
â¤ It abstracts many low-level complexities of creating, starting, and managing threads manually.

ğŸ”„ Why Executor Framework Was Introduced

Before the Executor Framework, developers had to manually handle:
| Problem                          | Description                                                                   |
| -------------------------------- | ----------------------------------------------------------------------------- |
| 1ï¸âƒ£ Manual Thread Management | Manually creating, starting, and stopping threads increased code complexity.  |
| 2ï¸âƒ£ Resource Management      | Threads consumed heavy system resources if not properly reused or terminated. |
| 3ï¸âƒ£ Scalability              | Handling large numbers of tasks with individual threads was inefficient.      |
| 4ï¸âƒ£ Thread Reuse             | Threads could not be easily reused once terminated.                           |
| 5ï¸âƒ£ Error Handling           | Managing task exceptions and states manually was cumbersome.                  |

ğŸ”„ Key Interfaces & Classes in Executor Framework
| Component                       | Description                                                                                                               |
| ------------------------------- | ------------------------------------------------------------------------------------------------------------------------- |
| Executor                  | Base interface for executing submitted tasks.                                                                             |
| ExecutorService           | Extends Executor to manage the lifecycle of tasks â€” includes methods like submit(), shutdown(), invokeAll(), etc. |
| ScheduledExecutorService  | Extends ExecutorService to schedule commands to run after a delay or periodically.                                      |
| Executors (Utility Class) | Provides factory methods to create various pre-configured thread pools.                                                   |


ğŸ”„ Common Thread Pool Types (via Executors)
1ï¸âƒ£ newFixedThreadPool(n)
â¤ Creates a pool of fixed number of threads.
â¤ If all threads are busy, extra tasks wait in the queue(LinkedBlockingQueue).

âœ… Best for: constant load, predictable number of threads.
ExecutorService pool = Executors.newFixedThreadPool(3);

âœ…Example 1: Fixed Thread Pool
package com.executorframework;

import java.util.concurrent.*;

public class Main {
    public static void main(String[] args) {
        long startTime = System.currentTimeMillis();

        ExecutorService executor = Executors.newFixedThreadPool(2);

        for (int i = 1; i <= 10; i++) {
            int finalI = i;
            executor.submit(() -> {
                long result = factorial(finalI);
                System.out.println("Factorial of " + finalI + " is " + result);
            });
        }

        executor.shutdown();
        try {
            executor.awaitTermination(1, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        long endTime = System.currentTimeMillis();
        System.out.println("Time taken: " + (endTime - startTime));
    }

    private static long factorial(int n) {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return (n <= 1) ? 1 : n * factorial(n - 1);
    }
}
ğŸ‘‰ Only 2 threads are created and reused for 10 tasks.

âœ…Example 2:Using Future to Get Result from Callable
package com.executorframework;

import java.util.concurrent.*;

public class Main {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newSingleThreadExecutor();
        Future<Integer> future = executorService.submit(() -> 42);

        try {
            System.out.println(future.get());
            if (future.isDone()) {
                System.out.println("Task completed successfully");
            }
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }
        executorService.shutdown();
    }
}



| Feature                           |   Runnable                                  | Callable                                                                          |
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
| Package                           | java.lang                                 | java.util.concurrent                                                            |
| Method to Implement               | void run()                                | V call()                                                                        |
| Return Type                       | Does not return any result                  | Returns a result of type V                                                      |
| Checked Exception Handling        | Cannot throw checked exceptions             | Can throw checked exceptions                                                      |
| Usage                             | when you donâ€™t need a result from a thread  | Used when you need a result or to handle exceptions                               |
| Result Retrieval                  | No direct way to get a result               | Returns a result via Future.get()                                               |
| Thread Execution                  | Passed to Thread or Executor            | Submitted to ExecutorService using submit()                                   |
| Introduced In                     | Java 1.0                                    | Java 5 (as part of java.util.concurrent)                                        |
| Example Interface Declaration     | public interface Runnable { void run(); } | public interface Callable<V> { V call() throws Exception; }                     |
| Typical Use Case                  | Background tasks like logging, cleanup, etc.| Computation tasks needing a result, like fetching data or performing calculations |


âœ… Example: Callable vs Runnable
package com.executorframework;

import java.util.concurrent.*;

public class Main {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newSingleThreadExecutor();

        // Runnable cannot return a result
        // Runnable runnable = () -> 42; âŒ Error

        Callable<Integer> callable = () -> 42; // âœ… Callable can return a result
        Future<Integer> future = executorService.submit(callable);

        try {
            System.out.println(future.get());
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }
        executorService.shutdown();
    }
}


ğŸ”„ invokeAll() Method
Executes a collection of tasks and returns a list of Futures when all are complete.

package com.executorframework;

import java.util.*;
import java.util.concurrent.*;

public class Main {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newFixedThreadPool(2);

        Callable<Integer> c1 = () -> { System.out.println("Callable1 gives 2"); return 2; };
        Callable<Integer> c2 = () -> { System.out.println("Callable2 gives 4"); return 4; };
        Callable<Integer> c3 = () -> { System.out.println("Callable3 gives 6"); return 6; };

        List<Callable<Integer>> callables = Arrays.asList(c1, c2, c3);

        try {
            List<Future<Integer>> futures = executorService.invokeAll(callables);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("Hello world"); // Main thread waits until all tasks complete
        executorService.shutdown();
    }
}

ğŸ”„ Another Variant: invokeAll(Collection, timeout, unit)
â¤ Cancels remaining tasks if timeout expires.
â¤ Returns null for incomplete tasks.
â¤ Throws CancellationException for cancelled tasks.


ğŸ”„ Other Common Methods
| Method                      | Description                                                             |
| --------------------------- | ----------------------------------------------------------------------- |
| invokeAny()               | Runs multiple tasks but returns the result of first successful one.     |
| submit()                  | Submits a Runnable/Callable and returns a Future.                       |
| Future.get()              | Waits for the task to complete and returns result.                      |
| Future.isDone()           | Checks if task completed or cancelled.                                  |
| Future.cancel()           | Attempts to cancel execution.                                           |
| Future.get(timeout, unit) | Waits for a limited time, else throws TimeoutException.                 |


2ï¸âƒ£ newCachedThreadPool()
â¤ It creates a thread pool that grows and shrinks dynamically
â¤ Threads are created when needed
â¤ Idle threads are reused
â¤ If a thread stays idle for 60 seconds, it is destroyed

ğŸ‘‰ Best for:
    âœ”ï¸ï¸ Short-lived
    âœ”ï¸ Asynchronous
    âœ”ï¸ Bursty tasks (many tasks for a short time)

âœ…Example:
You have multiple independent tasks coming at unpredictable times
(e.g., API calls, background jobs, async processing)

âœ… Code Example
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class CachedThreadPoolExample {

    public static void main(String[] args) {

        ExecutorService executor = Executors.newCachedThreadPool();

        for (int i = 1; i <= 10; i++) {
            int taskId = i;

            executor.submit(() -> {
                System.out.println(
                    "Task " + taskId + 
                    " executed by " + Thread.currentThread().getName()
                );

                try {
                    Thread.sleep(1000); // simulate short task
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            });
        }

        executor.shutdown();
    }
}

ğŸ”„ Internal Working
1ï¸âƒ£ First task arrives â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ new thread created
2ï¸âƒ£ Next tasks arrive quickly â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ more threads created
3ï¸âƒ£ Tasks finish
4ï¸âƒ£ Threads become idle
5ï¸âƒ£ Idle threads:
    âœ”ï¸ Reused if new tasks come within 60 seconds
    âœ”ï¸ Destroyed if idle for 60 seconds

âœ… Output:
Task 1 executed by pool-1-thread-1
Task 2 executed by pool-1-thread-2
Task 3 executed by pool-1-thread-3
...
âœ”ï¸ Youâ€™ll see different thread names, because the pool grows as needed.

ğŸ”„ Real-Life Use Case
âœ… Example: Hospital System
ExecutorService executor = Executors.newCachedThreadPool();

executor.execute(() -> processPatientReport());
executor.execute(() -> sendBillingNotification());
executor.execute(() -> generateAuditLogs());

âœ”ï¸ Tasks are short
âœ”ï¸ Arrive unpredictably
âœ”ï¸ No fixed thread limit needed


âš ï¸ Warning 
newCachedThreadPool() has NO upper limit on threads

âŒ If tasks are:
    âœ”ï¸ Long-running
    âœ”ï¸ Blocking (DB, API calls)
    âœ”ï¸ Heavy load
â¡ï¸ It can create too many threads â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ OutOfMemoryError


ğŸ”„ When to Use vs Avoid
âœ… Use When
    âœ”ï¸ Tasks are short-lived
    âœ”ï¸ Load is bursty
    âœ”ï¸ Async background jobs

âŒ Avoid When
    âœ”ï¸ Heavy DB calls
    âœ”ï¸ Long-running CPU tasks
    âœ”ï¸ You need strict thread control


3ï¸âƒ£ newSingleThreadExecutor()
â¤ Creates exactly ONE worker thread
â¤ Tasks are executed one by one
â¤ Order is guaranteed
â¤ If the thread crashes, Executor creates a new one
 

ğŸ”„ When to Use
â¤ Logging
â¤ File writing
â¤ Audit trails
â¤ Sequential business rules
â¤ Any task where order matters

âœ… Example 1: Basic Usage
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class SingleThreadExecutorExample {

    public static void main(String[] args) {

        ExecutorService executor =
                Executors.newSingleThreadExecutor();

        executor.submit(() -> System.out.println("Task 1"));
        executor.submit(() -> System.out.println("Task 2"));
        executor.submit(() -> System.out.println("Task 3"));

        executor.shutdown();
    }
}
âœ… Output (Always Same Order)
Task 1
Task 2
Task 3
â¤ Even on a multi-core system.


âœ… Example 2: Real-World Logging Scenario
ExecutorService loggerExecutor =
        Executors.newSingleThreadExecutor();

public void logEvent(String message) {
    loggerExecutor.submit(() -> {
        System.out.println("LOG: " + message +
                " | Thread: " + Thread.currentThread().getName());
    });
}

â“ Why Single Thread?
â¤ Prevents log corruption
â¤ Maintains exact order
â¤ Avoids synchronization complexity


ğŸ”„ Internal Working
â¤ Uses:
âœ”ï¸ 1 core thread
âœ”ï¸ Unbounded LinkedBlockingQueue
â¤ Tasks wait in queue if thread is busy
â¤ No parallel execution â€” ever

âš ï¸ Important Caveat
âŒ If one task blocks or hangs
â¡ï¸ All following tasks are blocked
âœ”ï¸ Best for short, non-blocking tasks


4ï¸âƒ£ newScheduledThreadPool(n)
Supports scheduling tasks after delay or periodically.
âœ… Best for: background maintenance tasks.
ScheduledExecutorService pool = Executors.newScheduledThreadPool(2);

âœ… Example 1 â€” One-shot Task After Delay
ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
scheduler.schedule(() -> System.out.println("Task executed after 5 seconds delay!"), 5, TimeUnit.SECONDS);
scheduler.shutdown();
System.out.println("Main thread continues...");

âœ…Example 1:
  public static void main(String[] args) {
       ScheduledExecutorService scheduler=Executors.newScheduledThreadPool(1);
       scheduler.schedule(()-> System.out.println("Task executed after 5 seconds delay!"),5, TimeUnit.SECONDS);
       scheduler.shutdown();
        System.out.println("Main thread is doing something else");
    }


âœ… Example 2 â€” Periodic Task (Fixed Rate)
ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
scheduler.scheduleAtFixedRate(() -> System.out.println("Task executed every 5 seconds!"),
        5, 5, TimeUnit.SECONDS);
Thread.sleep(10000);
scheduler.shutdown();


âœ… Example 3 â€” Periodic Task (Fixed Delay)
ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
scheduler.scheduleWithFixedDelay(() -> System.out.println("Task executed after every 5-second delay!"),
        5, 5, TimeUnit.SECONDS);
Thread.sleep(10000);
scheduler.shutdown();

â¤ Difference:
    âœ”ï¸ scheduleAtFixedRate() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ runs periodically regardless of task duration (may overlap).
    âœ”ï¸ scheduleWithFixedDelay() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ waits for task completion + delay before next execution (no overlap)


ğŸ”„ Advantages of Executor Framework
âœ… Reuses threads â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ reduces CPU and memory overhead.
âœ… Prevents overload by controlling number of concurrent threads.
âœ… Improves performance and scalability.
âœ… Simplifies task lifecycle management.
âœ… Provides better error and result handling with Future.


ğŸ”„ Disadvantages
âŒ Not ideal for long blocking I/O tasks.
âŒ Fixed pool can delay tasks if all threads are busy.
âŒ Debugging hung or slow tasks can be harder.


ğŸ”„ Best Practices
âš¡ Always call shutdown() or shutdownNow() to release resources.
âš¡ Use bounded queues to prevent overload.
âš¡ For large-scale systems, prefer ThreadPoolExecutor for advanced configurations.
âš¡ Use submit() for tasks needing results.
âš¡ Handle InterruptedException properly inside tasks.

#######################
ğŸ”· ThreadPoolExecutor
#######################
ThreadPoolExecutor is a core Java concurrency framework class used to manage and execute a pool of threads efficiently instead of creating a new thread for every task.

ğŸ”„ It belongs to:
java.util.concurrent.ThreadPoolExecutor


ğŸ”„ Why Do We Need ThreadPoolExecutor?
Creating a new thread for every task:
âŒ Is expensive
âŒ Causes performance degradation
âŒ Can lead to OutOfMemoryError (too many threads)

ThreadPoolExecutor solves this by:
â™»ï¸ Reusing threads
ğŸ¯ Controlling concurrency
âš–ï¸ Managing task queues
ğŸš¦ Handling overload gracefully

ğŸ”„ High-Level Working
Tasks are submitted (as Runnable or Callable)
Executor:
    âœ”ï¸ Uses existing threads, or
    âœ”ï¸ Creates new threads (up to a limit), or
    âœ”ï¸ Queues tasks, or
    âœ”ï¸ Rejects tasks (based on configuration)


ğŸ”„ Core Components
1ï¸âƒ£ Core Pool Size
âœ”ï¸ Minimum number of threads to keep alive
âœ”ï¸ Created eagerly when tasks arrive

2ï¸âƒ£ Maximum Pool Size
âœ”ï¸ Maximum number of threads allowed

3ï¸âƒ£ Work Queue
âœ”ï¸ Holds tasks waiting for execution
âœ”ï¸ Examples:
    â¡ LinkedBlockingQueue
    â¡ ArrayBlockingQueue
        â¡ SynchronousQueue

4ï¸âƒ£ Keep Alive Time
âœ”ï¸ Time for which extra threads (beyond core size) stay alive when idle

5ï¸âƒ£ Tread Factory
âœ”ï¸ Creates new threads
âœ”ï¸ Useful for:
    â¡ Naming threads
    â¡ Setting priority
        â¡ Custom behavior

6ï¸âƒ£ Rejected Execution Handler
âœ”ï¸ Decides what happens when:
    â¡ Queue is full AND
    â¡ Max threads reached


ğŸ”„ Constructor
ThreadPoolExecutor(
    int corePoolSize,
    int maximumPoolSize,
    long keepAliveTime,
    TimeUnit unit,
    BlockingQueue<Runnable> workQueue,
    ThreadFactory threadFactory,
    RejectedExecutionHandler handler
)


ğŸ”„ Task Handling Algorithm (Step-by-Step)
When a task is submitted:

1ï¸âƒ£ If current threads < corePoolSize
â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Create a new thread

2ï¸âƒ£ Else if queue is NOT full
â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Put task into queue

3ï¸âƒ£ Else if current threads < maximumPoolSize
â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Create a new thread

4ï¸âƒ£ Else
â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Reject the task


ğŸ”„ Rejection Policies
| Policy                  | Behavior                            |
| ----------------------- | ----------------------------------- |
| AbortPolicy (default) | Throws RejectedExecutionException |
| CallerRunsPolicy      | Caller thread runs the task         |
| DiscardPolicy         | Silently drops task                 |
| DiscardOldestPolicy   | Drops oldest task in queue          |


ğŸ”„ Commonly Used Factory Methods
(Internally use ThreadPoolExecutor)

Executors.newFixedThreadPool(n)
Executors.newCachedThreadPool()
Executors.newSingleThreadExecutor()
Executors.newScheduledThreadPool(n)


ğŸ”„ Advantages
âœ… Better performance
âœ… Controlled resource usage
âœ… Thread reuse
âœ… Configurable behavior
âœ… Safer than manual thread management


ğŸ”„ Real-World Use Cases
â¤ Handling HTTP requests in servers
â¤ Background job processing
â¤ Asynchronous event handling
â¤ Parallel CPU / I/O tasks


âœ… Code implementation
import java.util.concurrent.*;

public class ThreadPoolExecutorDemo {

    public static void main(String[] args) {

        // 1ï¸âƒ£ Create ThreadPoolExecutor
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
                2,                          // corePoolSize
                4,                          // maximumPoolSize
                10,                         // keepAliveTime
                TimeUnit.SECONDS,
                new ArrayBlockingQueue<>(2),// workQueue
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.AbortPolicy() // rejection policy
        );

        // 2ï¸âƒ£ Submit tasks
        for (int i = 1; i <= 6; i++) {
            final int taskId = i;

            executor.execute(() -> {
                System.out.println(
                        "Task " + taskId +
                        " executed by " +
                        Thread.currentThread().getName()
                );

                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            });
        }

        // 3ï¸âƒ£ Shutdown executor
        executor.shutdown();
    }
}
How This Code Works
ThreadPool Configuration
corePoolSize      = 2
maximumPoolSize   = 4
queue capacity    = 2

ğŸ”„ Task Flow
1ï¸âƒ£ First 2 tasks â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ new threads created
2ï¸âƒ£ Next 2 tasks â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ placed in queue
3ï¸âƒ£ Next 2 tasks â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ new threads (up to max = 4)
4ï¸âƒ£ Any further tasks â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ RejectedExecutionException


################################
ThreadPoolExecutor ğŸ†š Executor
################################
| Aspect             | Executor               | ThreadPoolExecutor          |
| ------------------ | ---------------------- | --------------------------- |
| Type               | Interface              | Concrete Class              |
| Level              | High-level abstraction | Low-level, detailed control |
| Thread Management  | âŒ No                   | âœ… Yes                       |
| Pool Configuration | âŒ No                   | âœ… Yes                       |
| Queue Control      | âŒ No                   | âœ… Yes                       |
| Rejection Policy   | âŒ No                   | âœ… Yes                       |
| Lifecycle Methods  | âŒ No                   | âœ… Yes                       |
| Production Usage   | âŒ Rare                 | âœ… Common                    |


âœ… Relationship Between Them
Executor (interface)
        â†‘
ExecutorService (interface)
        â†‘
AbstractExecutorService (abstract class)
        â†‘
ThreadPoolExecutor (class)

ğŸ‘‰ ThreadPoolExecutor IS AN Executor, but with much more power


ğŸ”„ Real-World Analogy
1ï¸âƒ£ Executor
"I don't care how you do it â€” just run this task."

2ï¸âƒ£ ThreadPoolExecutor
"Run this task using:
â¤ 5 core threads
â¤ Max 10 threads
â¤ A bounded queue
â¤ Reject if overloaded
â¤ Shut down gracefully"


ğŸ”„ When to Use What?
âœ”ï¸ Use Executor
â¤ When you want abstraction
â¤ When you donâ€™t care about implementation
â¤ For simple frameworks / libraries

âœ”ï¸ Use ThreadPoolExecutor
â¤ Production systems
â¤ Performance-critical apps
â¤ High-load servers
â¤ When resource control matters

######################
ğŸ”· Future Interface
######################
â¤ Future is part of java.util.concurrent and represents the result of an asynchronous computation.
â¤ Future = a placeholder for a result that will be available in the future

When you submit a task to an executor:
â¤ The task runs in the background
â¤ You immediately get a Future object
â¤ You can later:
    âœ”ï¸ Check if the task is done
    âœ”ï¸ Get the result
    âœ”ï¸ Cancel the task


ğŸ”„ Why Do We Need Future?
Without Future:
    âœ”ï¸ You either block the main thread
    âœ”ï¸ Or you have no way to know when a background task finishes

With Future:
    âœ”ï¸ You continue doing other work
    âœ”ï¸ Retrieve the result only when needed


ğŸ”„ Real-World Analogy: Hospital Example
âœ”ï¸ You give a blood sample to the lab.
âœ”ï¸ Lab gives you a receipt
âœ”ï¸ You continue with other activities
âœ”ï¸ Later, you use the receipt to collect the report

ğŸ“Œ That receipt = Future
ğŸ“Œ Report = Result
ğŸ“Œ Lab test = Async task


ğŸ”„ Basic Flow of Future
1ï¸âƒ£ Submit task to Executor
2ï¸âƒ£ Task runs asynchronously
3ï¸âƒ£ Future object is returned immediately
4ï¸âƒ£ Use future.get() to fetch result (blocks if not ready)


ğŸ”„ Simple Example
ExecutorService executor = Executors.newSingleThreadExecutor();

Future<Integer> future = executor.submit(() -> {
    Thread.sleep(2000);  // Simulate heavy task
    return 42;
});

System.out.println("Doing other work...");

Integer result = future.get();  // blocks until ready
System.out.println("Result: " + result);

executor.shutdown();

âœ… Output Flow:
Doing other work...
(wait 2 seconds)
Result: 42


ğŸ”„ Key Methods of Future Interface
| Method               | Purpose                  |
| -------------------- | ------------------------ |
| get()              | Waits and returns result |
| get(timeout, unit) | Waits up to timeout      |
| isDone()           | Checks if task finished  |
| cancel(true/false) | Cancels execution        |
| isCancelled()      | Checks cancellation      |


ğŸ”„ Real-World Problem Example (Backend System)
In a Hospital Management System, when a patient books an appointment:
    âœ”ï¸ Fetch doctor availability (DB)
    âœ”ï¸ Calculate billing
    âœ”ï¸ Send notification
These are independent tasks.

âŒ Without Future
    âœ”ï¸ Tasks run sequentially
    âœ”ï¸ High latency


âœ… With Future
ExecutorService executor = Executors.newFixedThreadPool(3);

Future<Boolean> availability =
        executor.submit(() -> checkDoctorAvailability());

Future<Double> bill =
        executor.submit(() -> calculateBilling());

Future<Void> notification =
        executor.submit(() -> sendNotification());

if (availability.get()) {
    System.out.println("Appointment confirmed");
}

System.out.println("Bill Amount: " + bill.get());

executor.shutdown();

ğŸ‘‰ Benefits
    âœ”ï¸ Faster response
    âœ”ï¸ Better resource utilization
    âœ”ï¸ Clean async control


ğŸ”„ Limitations
âŒ Future.get() is blocking
âŒ No chaining of tasks
âŒ No callback support
âŒ Hard to combine multiple Futures

ğŸ“Œ Because of these, Java introduced:
â¡ï¸ CompletableFuture

ğŸ”„ Future vs CompletableFuture
Future allows asynchronous execution, but CompletableFuture enables non-blocking, reactive, and composable async programming.

ğŸ”„ When to Use Future
âœ… Simple async task
âœ… Need result later
âœ… Basic background processing
âŒ Complex async flows
âŒ Multiple dependent tasks



#####################################
ğŸ”·CountDownLatch (Java Concurrency)
##################################### 
â¤ CountDownLatch is a synchronization aid
â¤ Allows one or more threads to wait until a set of operations complete
â¤ Works using a counter
â¤ Threads wait until the counter reaches zero

ğŸ“¦ Package: java.util.concurrent.CountDownLatch


ğŸ” Why Do We Need CountDownLatch?
â¤ To coordinate threads
â¤ To ensure:
    âœ”ï¸ Main thread waits for worker threads
    âœ”ï¸ A task starts only after prerequisites finish
â¤ Avoids manual wait() / notify() complexity

ğŸ” How CountDownLatch Works
â¤ Latch initialized with a count
â¤ Each completed task calls countDown()
â¤ Waiting threads call await()
â¤ When count becomes 0:
    âœ”ï¸ All waiting threads are released
    âœ”ï¸ Latch becomes inactive (cannot be reused)

ğŸ” Important Methods
â¤ await() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ blocks until count reaches zero
â¤ await(timeout, unit) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ waits with timeout
â¤ countDown() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ decreases count by 1
â¤ getCount() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ current count


ğŸ” Internal Working
â¤ Internally uses AQS (AbstractQueuedSynchronizer)
â¤ await() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ thread goes into wait queue
â¤ countDown() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ releases threads when count == 0
â¤ One-time use only


ğŸ” Simple Real-World Analogy
A race where the referee waits for all runners to reach the start line before blowing the whistle.


ğŸ” Use Cases of CountDownLatch
â¤ Wait for multiple services to start
â¤ Main thread waits for worker threads
â¤ Parallel computation result aggregation
â¤ Testing & benchmarking (wait for async tasks)


ğŸ” Code Example 1ï¸âƒ£: Main Thread Waiting for Workers
â— Problem
â¤ 3 worker threads doing independent tasks
â¤ Main thread must wait until all finish


âœ… Java Code
import java.util.concurrent.CountDownLatch;

class Worker implements Runnable {

    private CountDownLatch latch;
    private int workerId;

    Worker(CountDownLatch latch, int workerId) {
        this.latch = latch;
        this.workerId = workerId;
    }

    @Override
    public void run() {
        try {
            System.out.println("Worker " + workerId + " started work");
            Thread.sleep(2000); // simulate task
            System.out.println("Worker " + workerId + " finished work");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            latch.countDown(); // signal completion
        }
    }
}

public class CountDownLatchDemo {
    public static void main(String[] args) throws InterruptedException {

        int workers = 3;
        CountDownLatch latch = new CountDownLatch(workers);

        for (int i = 1; i <= workers; i++) {
            new Thread(new Worker(latch, i)).start();
        }

        latch.await(); // wait for all workers
        System.out.println("All workers completed. Main thread proceeding...");
    }
}
âœ… Output Behavior
â¤ Main thread blocks
â¤ Workers run in parallel
â¤ When last worker calls countDown()
â¤ Main thread resumes execution


ğŸ” Code Example 2ï¸âƒ£: Service Startup Dependency
â— Problem: App should start only after DB, Cache, MQ are ready

âœ… Java Code
import java.util.concurrent.CountDownLatch;

class Service implements Runnable {

    private String serviceName;
    private CountDownLatch latch;

    Service(String serviceName, CountDownLatch latch) {
        this.serviceName = serviceName;
        this.latch = latch;
    }

    @Override
    public void run() {
        try {
            System.out.println(serviceName + " starting...");
            Thread.sleep(1500);
            System.out.println(serviceName + " started");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            latch.countDown();
        }
    }
}

public class ApplicationStartup {
    public static void main(String[] args) throws InterruptedException {

        CountDownLatch latch = new CountDownLatch(3);

        new Thread(new Service("Database Service", latch)).start();
        new Thread(new Service("Cache Service", latch)).start();
        new Thread(new Service("Message Queue", latch)).start();

        latch.await();
        System.out.println("All services are up. Application started!");
    }
}

ğŸ” Key Characteristics 
âœ”ï¸ One-time use
âœ”ï¸ Multiple threads can wait
âœ”ï¸ Thread-safe
âŒ Cannot reset
âŒ Not reusable

ğŸ” CountDownLatch vs join()
| Aspect           | CountDownLatch | Thread.join() |
| ---------------- | -------------- | ------------- |
| Multiple threads | âœ… Yes         | âŒ No        |
| Timeout support  | âœ… Yes         | âœ… Yes       |
| Flexibility      | High           | Low           |
| Reusability      | âŒ No         | N/A            |


ğŸ” CountDownLatch vs CyclicBarrier
| Feature   | CountDownLatch  | CyclicBarrier             |
| --------- | --------------- | ------------------------- |
| Reusable  | âŒ No            | âœ… Yes                     |
| Trigger   | Count reaches 0 | All threads reach barrier |
| Direction | Workers â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ main  | Peer threads              |
| Use case  | Waiting         | Synchronization           |


ğŸ” Common Mistakes
âŒ Forgetting countDown()
âŒ Expecting reuse
âŒ Confusing with CyclicBarrier
âŒ Using for mutual exclusion


ğŸ”„ When to Use / Avoid
âœ” Use When
â¤ One-time synchronization
â¤ Startup dependency
â¤ Main waits for workers

âŒ Avoid When
â¤ Reusable synchronization needed
â¤ Bidirectional thread coordination



##########################
ğŸ”· Atomicity vs Volatile
########################## 
â¤ volatile ensures visibility,
â¤ AtomicInteger ensures atomicity + visibility.

âŒ volatile Does NOT Ensure Atomicity
âŒ Code Using volatile
class VolatileCounter {

    private static volatile int count = 0;

    public static void main(String[] args) throws InterruptedException {

        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                count++; // NOT atomic
            }
        });

        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                count++; // NOT atomic
            }
        });

        t1.start();
        t2.start();

        t1.join();
        t2.join();

        System.out.println("Final count: " + count);
    }
}
âœ… Expected Output
2000

âŒ Actual Output
< 2000

â— Why?
    âœ”ï¸ count++ = 3 steps
    âœ”ï¸ Read value
    âœ”ï¸ Increment
    âœ”ï¸ Write back
â¤ volatile only makes step 1 & 3 visible â€”
â¤ steps are NOT atomic


ğŸ”„ AtomicInteger
â¤ AtomicInteger is a thread-safe integer wrapper
â¤ Part of java.util.concurrent.atomic
â¤ Supports lock-free, atomic operations
â¤ Used when multiple threads update a shared integer


ğŸ”„ Why Do We Need AtomicInteger?
â¤ Normal int operations like count++ are NOT atomic
â¤ synchronized â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ blocking + context switching
â¤ AtomicInteger â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ high performance, non-blocking


ğŸ”„ Core Concept 
â¤ Uses CAS (Compare-And-Swap) at hardware level
â¤ Operation succeeds only if expected value matches
â¤ If CAS fails â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ operation retries automatically
â¤ No locks, no blocking

ğŸ”„ Example Problem Without AtomicInteger
int count = 0;
count++; // NOT thread-safe

â¤ Multiple threads â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ race condition
â¤ Lost updates


âœ… Correct Solution Using AtomicInteger
AtomicInteger count = new AtomicInteger(0);
count.incrementAndGet(); // atomic

ğŸ”„ Important Methods
â¤ incrementAndGet()
â¤ getAndIncrement()
â¤ decrementAndGet()
â¤ compareAndSet(expected, update)
â¤ get(), set()

ğŸ”„ AtomicInteger vs volatile
â¤ volatile â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ visibility only
â¤ AtomicInteger â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ visibility + atomicity


ğŸ”„ Real-World Use Cases
â¤ Request counters
â¤ Hit counters
â¤ Thread-safe metrics
â¤ Rate limiting
â¤ Sequence generators

ğŸ”„ Advantages
âœ”ï¸ Lock-free
âœ”ï¸ High performance
âœ”ï¸ No deadlock
âœ”ï¸ Scales well under contention

ğŸ”„ Limitations
âŒ Only single-variable atomicity
âŒ Complex logic still needs locks
âŒ CAS spinning under heavy contention


âš ï¸  Trap
âŒ Using AtomicInteger for compound multi-variable operations
âœ”ï¸ Use locks for consistency across multiple fields



##################
ğŸ”· CyclicBarrier
##################
â¤ CyclicBarrier is a synchronization aid
â¤ Allows a fixed number of threads to wait for each other
â¤ All threads must reach a common barrier point
â¤ Once reached â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ all threads are released together
â¤ Barrier is reusable (cyclic)
ğŸ“¦ Package: java.util.concurrent.CyclicBarrier


ğŸ”„ Why Do We Need CyclicBarrier?
â¤ To synchronize peer threads
â¤ To ensure all threads complete a phase before moving to the next
â¤ Ideal for multi-phase parallel algorithms


ğŸ”„ Core Concept
â¤ Barrier initialized with number of parties
â¤ Each thread calls await()
â¤ When last thread arrives:
    âœ”ï¸ Barrier opens
    âœ”ï¸ Optional barrier action executes
    âœ”ï¸ Barrier resets automatically


ğŸ”„ Important Methods
â¤ await() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ wait until all parties arrive
â¤ await(timeout, unit) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ timed wait
â¤ getNumberWaiting() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ waiting threads
â¤ getParties() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ total parties
â¤ isBroken() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ barrier status
â¤ reset() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ manual reset


ğŸ”„ Barrier Action 
â¤ Runnable executed once
â¤ Runs by last arriving thread
â¤ Used for:
    âœ”ï¸ Aggregation
    âœ”ï¸ Logging
    âœ”ï¸ State updates

ğŸ”„ Code Example 1: Simple CyclicBarrier
ğŸ¯ Problem: 3 threads must start work together

âœ… Java Code
import java.util.concurrent.CyclicBarrier;

class Task implements Runnable {

    private CyclicBarrier barrier;
    private int taskId;

    Task(CyclicBarrier barrier, int taskId) {
        this.barrier = barrier;
        this.taskId = taskId;
    }

    @Override
    public void run() {
        try {
            System.out.println("Task " + taskId + " is ready");
            barrier.await(); // wait for others

            System.out.println("Task " + taskId + " started execution");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

public class CyclicBarrierDemo {
    public static void main(String[] args) {

        CyclicBarrier barrier = new CyclicBarrier(3);

        for (int i = 1; i <= 3; i++) {
            new Thread(new Task(barrier, i)).start();
        }
    }
}
Output Behavior
â¤ All threads print "ready"
â¤ Execution starts only after all reach barrier
â¤ Threads proceed simultaneously


ğŸ”„ Code Example 2: Multi-Phase Execution (Cyclic Nature)
ğŸ¯ Problem
â¤ 3 threads execute 2 phases
â¤ Phase 2 starts only after Phase 1 finishes


âœ… Java Code
import java.util.concurrent.CyclicBarrier;

class Worker implements Runnable {

    private CyclicBarrier barrier;
    private int id;

    Worker(CyclicBarrier barrier, int id) {
        this.barrier = barrier;
        this.id = id;
    }

    @Override
    public void run() {
        try {
            System.out.println("Worker " + id + " - Phase 1");
            Thread.sleep(1000);
            barrier.await(); // end of phase 1

            System.out.println("Worker " + id + " - Phase 2");
            Thread.sleep(1000);
            barrier.await(); // end of phase 2

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

public class MultiPhaseDemo {
    public static void main(String[] args) {

        CyclicBarrier barrier = new CyclicBarrier(3,
                () -> System.out.println("---- All threads reached barrier ----"));

        for (int i = 1; i <= 3; i++) {
            new Thread(new Worker(barrier, i)).start();
        }
    }
}

ğŸ”„ Barrier Action Output
---- All threads reached barrier ----
Printed twice (after each phase)


ğŸ”„ Broken Barrier Concept
â¤ If a thread:
    âœ”ï¸ Is interrupted
    âœ”ï¸ Times out
â¤ Barrier enters broken state
â¤ All waiting threads get BrokenBarrierException

if (barrier.isBroken()) {
    System.out.println("Barrier is broken");
}

ğŸ”„ CyclicBarrier vs CountDownLatch
| Feature        | CyclicBarrier     | CountDownLatch  |
| -------------- | ----------------- | --------------- |
| Reusable       | âœ… Yes            | âŒ No          |
| Direction      | Peer-to-peer      | Worker â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ main   |
| Trigger        | All threads reach | Count reaches 0 |
| Barrier action | âœ… Yes           | âŒ No           |


ğŸ”„ Common Mistakes
âŒ Expecting reuse from CountDownLatch
âŒ Forgetting same number of threads as parties
âŒ Ignoring broken barrier handling
âŒ Using CyclicBarrier for mutual exclusion


ğŸ”¥ When to Use / Avoid
âœ”ï¸ Use When
â¤ Multi-phase computation
â¤ Parallel algorithms
â¤ Simulation steps

âŒ Avoid When
â¤ One-time waiting
â¤ Main thread coordination
â¤ Resource locking


################################
ğŸ”· Fork/Join Framework in Java
################################
â¤ A parallel execution framework introduced in Java 7
â¤ Designed for divide-and-conquer problems
â¤ Breaks a large task into smaller subtasks (fork)
â¤ Combines results of subtasks (join)
â¤ Optimized for CPU-bound, recursive tasks

ğŸ“¦ Package: java.util.concurrent.forkjoin

ğŸ”„ Why Fork/Join is Needed?
â¤ Traditional thread pools:
    âœ”ï¸ Poor for recursive parallelism
â¤ Fork/Join:
    âœ”ï¸ Efficient task splitting
    âœ”ï¸ Automatic load balancing
    âœ”ï¸ Minimal thread creation overhead


ğŸ”„ Core Components
1ï¸âƒ£ ForkJoinPool
â¤ Specialized thread pool
â¤ Uses worker threads
â¤ Default size = number of CPU cores

ForkJoinPool pool = new ForkJoinPool();


2ï¸âƒ£ ForkJoinTask
â¤ Base abstract class
â¤ Represents a parallel task

Subclasses:
â¤ RecursiveTask<V> â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ returns result
â¤ RecursiveAction â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ no result


ğŸ”„ How Fork/Join Works
ğŸ”„ Work-Stealing Algorithm
â¤ Each worker thread has its own deque
â¤ Threads push tasks to their own queue
â¤ Idle threads steal tasks from others
â¤ Ensures maximum CPU utilization

ğŸ”„ Fork/Join Execution Flow
â¤ Task checks if problem is small enough
â¤ If yes â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ solve directly
â¤ If no:
    âœ”ï¸ Split task into subtasks
    âœ”ï¸ fork() subtasks
    âœ”ï¸ join() results


ğŸ”„ Code Example 1: RecursiveTask (Sum of Array)
ğŸ¯ Problem: Compute sum of array elements in parallel

âœ… Java Code
import java.util.concurrent.RecursiveTask;
import java.util.concurrent.ForkJoinPool;

class ArraySumTask extends RecursiveTask<Long> {

    private static final int THRESHOLD = 5;
    private int[] arr;
    private int start, end;

    ArraySumTask(int[] arr, int start, int end) {
        this.arr = arr;
        this.start = start;
        this.end = end;
    }

    @Override
    protected Long compute() {
        if (end - start <= THRESHOLD) {
            long sum = 0;
            for (int i = start; i < end; i++) {
                sum += arr[i];
            }
            return sum;
        }

        int mid = (start + end) / 2;

        ArraySumTask left = new ArraySumTask(arr, start, mid);
        ArraySumTask right = new ArraySumTask(arr, mid, end);

        left.fork();                  // fork left task
        long rightResult = right.compute(); // compute right
        long leftResult = left.join();       // join left

        return leftResult + rightResult;
    }
}

public class ForkJoinDemo {
    public static void main(String[] args) {

        int[] arr = {1,2,3,4,5,6,7,8,9,10};

        ForkJoinPool pool = new ForkJoinPool();
        long result = pool.invoke(new ArraySumTask(arr, 0, arr.length));

        System.out.println("Sum = " + result);
    }
}


ğŸ”„ Code Example 2: RecursiveAction (No Return)
import java.util.concurrent.RecursiveAction;

class PrintTask extends RecursiveAction {

    private int start, end;

    PrintTask(int start, int end) {
        this.start = start;
        this.end = end;
    }

    @Override
    protected void compute() {
        if (end - start <= 3) {
            System.out.println(Thread.currentThread().getName()
                    + " printing " + start + " to " + end);
            return;
        }

        int mid = (start + end) / 2;
        invokeAll(
            new PrintTask(start, mid),
            new PrintTask(mid, end)
        );
    }
}

ğŸ”„ Fork/Join Best Practices (Interview Gold)
âœ”ï¸ Use for CPU-bound tasks
âœ”ï¸ Choose correct threshold
âœ”ï¸ Prefer invokeAll() for simplicity
âŒ Avoid blocking I/O inside tasks
âŒ Avoid synchronized blocks


ğŸ”„ Fork/Join vs ExecutorService
| Aspect         | Fork/Join          | ExecutorService   |
| -------------- | ------------------ | ----------------- |
| Best for       | Recursive tasks    | Independent tasks |
| Load balancing | Work stealing      | Limited           |
| Task type      | Divide-and-conquer | Flat tasks        |
| Blocking I/O   | âŒ Bad              | âœ… OK              |


ğŸ”„ Common Interview Traps
âŒ Using Fork/Join for I/O tasks
âŒ Very small thresholds (overhead)
âŒ Forgetting join()
âŒ Creating too many subtasks


ğŸ”„ Where Fork/Join is Used Internally
â¤ Java Streams (parallelStream())
â¤ Arrays.parallelSort()
â¤ CompletableFuture (internals)


#########################
ğŸ”· ThreadLocal Variable
#########################
â¤ ThreadLocal provides thread-confined variables
â¤ Each thread gets its own independent copy of a variable
â¤ Changes made by one thread are not visible to others
â¤ Used to avoid synchronization for per-thread state

ğŸ“¦ Package: java.lang.ThreadLocal


ğŸ”„ Why Do We Need ThreadLocal?
â¤ To store thread-specific data safely
â¤ Avoids using synchronized
â¤ Common in:
    âœ”ï¸ User session data
    âœ”ï¸ Transaction context
    âœ”ï¸ Request IDs
    âœ”ï¸ DateFormat / SimpleDateFormat


ğŸ”„ Core Concept
â¤ Internally, each Thread has a ThreadLocalMap
â¤ Map stores:
    âœ”ï¸ Key â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ ThreadLocal object
    âœ”ï¸ Value â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ thread-specific value
â¤ Same ThreadLocal â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ different value per thread


âœ… Example
class ThreadLocalDemo {

    private static ThreadLocal<Integer> threadLocal =
            ThreadLocal.withInitial(() -> 0);

    public static void main(String[] args) {

        Runnable task = () -> {
            int value = threadLocal.get();
            value += 1;
            threadLocal.set(value);

            System.out.println(Thread.currentThread().getName()
                    + " value = " + threadLocal.get());
        };

        new Thread(task, "Thread-A").start();
        new Thread(task, "Thread-B").start();
    }
}
âœ… Output
Thread-A value = 1
Thread-B value = 1

âœ”ï¸ No shared state
âœ”ï¸ No synchronization


ğŸ”„ Real-World Use Case: User Request Context
class UserContext {
    static ThreadLocal<String> userId = new ThreadLocal<>();
}

class Service {
    static void process(String uid) {
        UserContext.userId.set(uid);
        System.out.println("User = " + UserContext.userId.get());
        UserContext.userId.remove(); // IMPORTANT
    }
}

ğŸ”„ Important Methods
â¤ get() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ returns threadâ€™s value
â¤ set(value) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ sets threadâ€™s value
â¤ remove() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ clears value (critical!)
â¤ withInitial() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ default value


ğŸ”„ ThreadLocal vs Shared Variable
| Feature         | ThreadLocal    | Normal Variable |
| --------------- | ------------   | --------------- |
| Shared          | âŒ No         | âœ… Yes          |
| Synchronization | âŒ Not needed | âœ… Required     |
| Visibility      | Thread-only    | Cross-thread    |


ğŸ”„ Memory Leak Risk
âŒ Problem
â¤ In thread pools, threads are reused
â¤ ThreadLocal values stay attached to thread
â¤ Causes memory leaks

âœ… Solution
threadLocal.remove();
âœ”ï¸ Always call remove() in finally


ğŸ”„ ThreadLocal vs volatile
â¤ volatile â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ shared variable, visibility
â¤ ThreadLocal â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ no sharing at all


ğŸ”„ Common Traps
âŒ Assuming ThreadLocal is thread-safe sharing
âŒ Forgetting remove() in thread pools
âŒ Using ThreadLocal as cache


ğŸ”„ When to Use / Avoid
âœ”ï¸ Use When
â¤ Per-thread state
â¤ Request/session context
â¤ Non-thread-safe utilities

âŒ Avoid When
â¤ Data must be shared
â¤ Long-lived thread pools without cleanup



#####################################
ğŸ”· Pessimistic vs Optimistic locking
#####################################
1ï¸âƒ£ Pessimistic Locking
â¤ Assumes conflicts are likely
â¤ Locks data before access
â¤ Other threads/transactions must wait
â¤ Common in high-contention systems

ğŸ”„ How It Works
â¤ Thread acquires lock
â¤ Performs operation
â¤ Releases lock
â¤ Others proceed

âœ… Java Example (Pessimistic)
class PessimisticCounter {

    private int count = 0;

    public synchronized void increment() {
        count++; // exclusive access
    }

    public int getCount() {
        return count;
    }
}
âœ”ï¸ Safe
âŒ Blocking
âŒ Risk of deadlock


2ï¸âƒ£ Optimistic Locking
â¤ Assumes conflicts are rare
â¤ No lock while reading
â¤ Checks for conflicts before updating
â¤ If conflict â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ retry


ğŸ”„ How It Works
â¤ Read value + version
â¤ Modify locally
â¤ Update only if version unchanged
â¤ Else retry


âœ… Java Example (Optimistic)
import java.util.concurrent.atomic.AtomicInteger;

class OptimisticCounter {

    private AtomicInteger count = new AtomicInteger(0);

    public void increment() {
        count.incrementAndGet(); // CAS-based
    }

    public int getCount() {
        return count.get();
    }
}
âœ”ï¸ Non-blocking
âœ”ï¸ High throughput
âŒ Possible retries


ğŸ”„ Core Differences
| Aspect      | Pessimistic Lock                | Optimistic Lock |
| ----------- | ------------------------------- | --------------- |
| Assumption  | Conflicts likely                | Conflicts rare  |
| Locking     | Before access                   | At update time  |
| Blocking    | Yes                             | No              |
| Deadlock    | Possible                        | Not possible    |
| Performance | Lower under contention          | Higher          |
| Examples    | synchronized, ReentrantLock | CAS, versioning |


ğŸ”„ Database Perspective
â¤ Pessimistic: SELECT ... FOR UPDATE
â¤ Optimistic: Version column (@Version in JPA)

 
ğŸ”„ When to Use What
âœ”ï¸ Use Pessimistic When
â¤ High contention
â¤ Critical consistency
â¤ Short transactions

âœ”ï¸ Use Optimistic When
â¤ Low contention
â¤ Read-heavy systems
â¤ High scalability needed


âš ï¸ Common Traps
âŒ Thinking optimistic lock always faster
âŒ Using pessimistic locks in read-heavy systems
âŒ Ignoring retry cost in optimistic locking
