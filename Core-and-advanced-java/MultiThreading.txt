Program❓
A Program is a set of instructions written in a programming language that tells the computer how to perform a specific task.
✅ For Example: Microsoft Word is a program that allows you to write and edit documents. It is a program that is used to create and edit documents.

Process❓
A process is an instance of a program that is being executed. When a program runs, the operating system creates a process to manage its execution.
When we open Microsoft Word, it becomes a process in the operating system.          

Thread❓
A thread is the smallesst unit of execution within a process. A process can have multiple threads, which share the same resources but can run independently.
A thread is a light-weight process that can be created and destroyed at runtime.
✅For Example: A we browser like Google Chrome might use multiple threads for different tabs, with each tab running in its own thread.

Multitasking❓
Multitasking is the ability of a computer to run multiple tasks or programs at the same time. On single-core CPUs, this is done through time-sharing, rapdily switching between tasks. On multi-core CPUs, this is done through parallelism, where multiple cores, true paralled execution occurs, with tasks distributed across the cores. The OS scheduler balances the load, ensuring efficient and resposive system performance.

It utilizes the capabilities of a CPU and its cores. When an OS performs multitasking, it can assign different tasks to different cores. This is mroe efficient than assigning all tasks to a single core.
✅For Example: We are browsing the internet while listening to music and dowloading files at the same time.

MultiThreading❓
Multithreading is a technique in which multiple threads of execution are created within a single process. Each thread is a separate execution path within the process.
Multithreading is used to improve the performance of a program by allowing it to execute multiple tasks concurrently.
✅For Example: A web browser can use mutlithreading by having seperate threads for rendering the page, running JavaScript, and handling user input. This makes the browser more resposive and efficient.

It enhances the efficiency of multitasking by breaking down individual tasks into smaller sub-tasks or threads. These threads can be processed simultaneously, making better use of the CPU's capabilities and resources.

📝In Single-Core System:
Both threads and processes are managed by the OS scheduler through time slicing ad context switching to create the illusion of simultaneous execution.
📝In Multi-Core System:
Both threads and processes can run in true parallelism, with tasks distributed across the cores to optimize performance.

🔷 Thread Creation Techniques

1. Using Thread Class

package p1;

public class World extends Thread {
	@Override
	public void run() {
		for (; ; ) {
			System.out.println(Thread.currentThread().getName());
		}
	}
}

package p1;

public class intro {

	public static void main(String[] args) {
		World w = new World();
		w.start();
		for (; ;) {
			System.out.println(Thread.currentThread().getName());
		}
	}

}
🔗 Steps:
➤ A new class World is created that extends Thread.
➤ The run method is overridden to define the code constitutes the new thread.
➤ start method is called to initiate the new thread.

2. Using Runnable Interface

package p1;

public class World implements Runnable {
    @Override
    public void run() {
        for (; ; ) {
            System.out.println(Thread.currentThread().getName());
        }
    }
}

package p1;

public class intro {

    public static void main(String[] args) {
        Thread t = new Thread(new World());
        t.start();
        for (; ;) {
            System.out.println(Thread.currentThread().getName());
        }
    }
}
🔗 Steps:
➤ A new class World is created that implements Runnable.
➤ The run method is overridden to define the code constitutes the new thread.
➤ A Thread object is created by passing an instance of the World class to the Thread constructor.
➤ The start method is called to initiate the new thread.


🔷 Thread Lifecycle
The lifecycle of a thread is Java consist of several states, which a thread can move through during its execution.
The lifecycle of a thread is as follows:

1. New: A new thread is created but not yet started.
2. Runnable: After the start method is called, the thread becomes runnable. It's ready to ru and is waiting for CPU time.
3. Running: The thread is in this state when it is executing.
4. Blocked/Waiting: A thread is in this state when it is  waiting for a resource or for another thread to perform an action.
5. Terminated: The thread has completed its execution.


🔷 Thread Methods in Java
🔄 start()
➤ Used to start a new thread of execution.
➤ Internally calls the run() method in a new call stack.
➤ Cannot call start() on the same thread object more than once → throws IllegalThreadStateException.

t1.start();  // starts execution of thread

🔄 run()
➤ Contains the code that will be executed by the thread.
➤ If run() is called directly (without start()), it will behave like a normal method → no new thread is created.

@Override
public void run() {
    System.out.println("Thread is running...");
}

🔄 sleep(milliseconds)
➤ ➤ Causes the currently executing thread to pause temporarily for a given time.
➤ ➤ Throws InterruptedException if another thread interrupts the sleeping one.
➤ ➤ Static method → belongs to the class, not an object.

Thread.sleep(1000);  // pauses current thread for 1 second

🔄 join()
➤ Allows one thread to wait for another thread to finish execution before continuing.
➤ Ensures sequential execution when required.
➤ Overloads:
    ✔️ join() → waits until thread finishes.
    ✔️ join(long millis) → waits for max specified time.

t1.join();  // main thread waits until t1 finishes

🔄 setPriority(int priority)
➤ Used to set priority of a thread.
➤ Range: 1 (MIN_PRIORITY) → 10 (MAX_PRIORITY), default = 5 (NORM_PRIORITY).
➤ Just a hint to the scheduler (not guaranteed).

t1.setPriority(Thread.MAX_PRIORITY);

👉 Naming Threads
A thread can be given a name by passing it in the constructor:

ThreadMethodDemo t1 = new ThreadMethodDemo("FirstThread");
System.out.println(t1.getName());  // prints: FirstThread

✅ Example with Priority + Name
package p1;

public class ThreadMethodDemo extends Thread {
    public ThreadMethodDemo(String name) {
        super(name);  // assigning thread name
    }

    public static void main(String[] args) {
        ThreadMethodDemo t1 = new ThreadMethodDemo("FirstThread");
        t1.setPriority(Thread.NORM_PRIORITY); // setting priority
        t1.start();
    }

    @Override
    public void run() {
        for(int i=1; i<=5; i++) {
            System.out.println(Thread.currentThread().getName() + 
                               " Priority: " + Thread.currentThread().getPriority() +
                               " Value: " + i);
        }
    }
}

🔄 interrupt()
➤ Used to interrupt a thread that is sleeping, waiting, or blocked.
➤ Sets the interrupt status flag of the thread.
➤ If the thread is in sleep() or join(), it will throw InterruptedException.

🔗 Method: t1.interrupt();

✅ Code Example:
package p1;

public class ThreadMethodDemo extends Thread {
    @Override
    public void run() {
        try {
            Thread.sleep(1000);   // thread goes to sleep for 1 second
            System.out.println("Thread is running...");
        } catch (Exception e) {
            System.out.println("Thread interrupted: " + e);
        }
    }

    public static void main(String[] args) {
        ThreadMethodDemo t1 = new ThreadMethodDemo();
        t1.start();       // starts the thread → calls run() in separate stack
        t1.interrupt();   // interrupts t1 immediately
    }
}

🔷 What Happens at Runtime?
➤ t1.start() → new thread is created, run() starts execution.
➤ Inside run(), thread executes → Thread.sleep(1000).
    ✔️ This puts the thread into TIMED_WAITING state.
➤ Meanwhile, the main thread calls t1.interrupt().
    ✔️ This sets the interrupt flag for t1.
    ✔️ Since t1 is currently sleeping, it immediately throws an InterruptedException.
➤ The exception is caught in the catch block →
Thread interrupted: java.lang.InterruptedException: sleep interrupted

🔷 Key Notes for Interview
➤ interrupt()
    ✔️ If a thread is sleeping, waiting, or blocked → InterruptedException is thrown.
    ✔️ If a thread is running normally (not in sleep/wait) → just sets interrupt flag, no exception.
➤ sleep() always needs to be inside a try-catch because it throws InterruptedException.
➤ Execution flow here:
start() → run() → sleep() → interrupt() → exception thrown → handled in catch.

🔄 Yield Method
A hint to the scheduler that the current thread is willing to yield its current use of a processor.

✅Example:
public class MyThread extends Thread {
    public MyThread(String name){
        super(name);
    }
    public static void main(String[] args) throws InterruptedException {
        MyThread  t1=new MyThread("First Thead");
        MyThread t2=new MyThread("Second Thread");
        t1.start();
        t2.start();

    }

    @Override
    public void run() {
       for(int i=0;i<5;i++){
           System.out.println(Thread.currentThread().getName()+ " is running");
           Thread.yield(); // --> tells or hints to the scheduler to give chance to another thread also, although scheduler is free to ignore the request
       }
    }
}

🔄 setDameon() Method
➤ This method is used to mark a thread as a daemon thread.
➤ Daemon means a thread that runs in the background and does not prevent the JVM from shutting down.
➤ By default, a thread is a user thread, which means it prevents the JVM from shutting down.
➤ If a thread is a daemon thread, it will not prevent the JVM from shutting down.

✅Example:
public class MyThread extends Thread {
    public MyThread(String name) {
        super(name);
    }

    public static void main(String[] args) throws InterruptedException {
        MyThread t1 = new MyThread("First Thead"); //user thread for the business logic
        t1.setDaemon(true);//daemon thread 
        t1.start();
        System.out.println("Main method execution completed");
    }

    @Override
    public void run() {
        while (true) {
            System.out.println("Hello World");
        }
    }
}

✅ Output:
Main method execution completed
Hello World
Hello World 
Hello World
...print Hello World few time and then stops as daemon thread is set to true


🔷 Synchronization
➤ Synchronization is a mechanism that ensures that only one thread can access a shared resource at a time.
➤ It is used to prevent concurrent access to a shared resource, such as a variable or object.
➤ It is implemented using the synchronized keyword.
➤ The synchronized keyword is used to define a block of code that is synchronized.
➤ Only one thread can access the synchronized block at a time.
➤ If multiple threads try to access the synchronized block at the same time, they will block until the first thread releases the lock.
➤ This prevents concurrent access to the shared resource and prevent race conditions and ensures that only one thread can access it at a time and attain mutual exclusion.

✅Example:
Counter.java
package com.corejava;

public class Counter {
    private int count = 0;

    public synchronized void increment() { //critical section
        Thread.yield(); 
        count++;
    }

    public int getCount() {
        return count;
    }
}

MyThread.java
package com.corejava;

public class MyThread extends Thread {
    private Counter counter;

    public MyThread(Counter counter){
        this.counter=counter;
    }

    @Override
    public void run(){
        for(int i=0;i<10000;i++){
            counter.increment();
        }
    }
}

Test.java
package com.corejava;

public class Test {
    public static void main(String[] args) {
        Counter counter = new Counter();
        MyThread myThread1=new MyThread(counter);
        MyThread myThread2 =new MyThread(counter);
        myThread1.start();
        myThread2.start();
        try{
            myThread1.join();
            myThread2.join();
        }catch (InterruptedException e){
           e.printStackTrace();
            System.out.println("Exception occured: "+e);
        }
        System.out.println(counter.getCount()); //Expected output: 2000, actual output: <2000
    }
}

➤ When you want to synchronized some part of the method not the whole method then use synchronized block instead of synchronized keyword on the method.
✅Example:
 public void increment() { 
       synchronized (this){
           Thread.yield();
           count++;
       }
       // Other code logic is written
    }


🔷 Locks    
Thread-safe mechanism that allows multiple threads to access a shared resource concurrently.

❓ Why Use Locks Instead of synchronized?
| Feature               | `synchronized`                                       | `Lock`                             |
| --------------------- | ---------------------------------------------------- | ---------------------------------- |
| Automatic release     | Yes (automatically released when method/block exits) | No (must manually call `unlock()`) |
| Try to acquire        | No                                                   | Yes (`tryLock()`)                  |
| Interruptible waiting | No                                                   | Yes (`lockInterruptibly()`)        |
| Fairness policy       | No                                                   | Yes (can create **fair locks**)    |
| Multiple conditions   | No                                                   | Yes (via `Condition` objects)      |

🔄 There are two types of locks:
    1️⃣ Intrinsic Locks (Monitor Locks):
        ➤ Used internally by the synchronized keyword.
        ➤ Every Java object has an intrinsic lock.
        ➤ Only one thread can hold it at a time.
        ➤ Automatically acquired and released.

    ✅ Use Case: When you want simple synchronization — e.g., synchronize a method or block.

    synchronized void print() {
    // intrinsic lock acquired on this object
    }

    2️⃣ Explicit Locks (ReentrantLock)
        ➤ Part of java.util.concurrent.locks package
        ➤ Must manually acquire and release
        ➤ More flexible than intrinsic locks
        ➤ Provides methods like tryLock(), lockInterruptibly(), isHeldByCurrentThread().

        ✅ Use Case:
        ➤ When you need:
        ➤ fair access to threads,
        ➤ interruptible locks, or
        ➤ timed waiting for a lock.

public interface Lock {
    void lock();
    void unlock();
    boolean tryLock();
    void lockInterruptibly() throws InterruptedException;
}

🔄 Lock Interface Methods use Case:
| Method                              | Description                                                         |
| ----------------------------------- | ------------------------------------------------------------------- |
| `lock()`                            | Acquires the lock, waits indefinitely if not available.             |
| `unlock()`                          | Releases the lock (should always be in `finally`).                  |
| `tryLock()`                         | Attempts to acquire lock immediately; returns `true` if successful. |
| `tryLock(long time, TimeUnit unit)` | Waits for the given time before giving up.                          |
| `lockInterruptibly()`               | Acquires lock but allows interruption while waiting.                |
| `isLocked()`                        | Checks if the lock is held by any thread.                           |

    3️⃣ ReentrantLock 
    🌟 Properties:
        ✔️ A thread can acquire the same lock multiple times without being blocked (hence “reentrant”) and it maintains a count.
        ✔️ Must call unlock() the same number of times it called lock(), every lock called must be paired with an unlock call.
        ✔️ Can be fair or unfair:
                ➤ Fair → threads acquire lock in order of request.
                ➤ Unfair → scheduler decides (default).


    4️⃣ ReentrantReadWriteLock
    ➤ Provides two locks:
        ✔️ Read Lock: can be held by multiple readers simultaneously if there’s no writer.
        ✔️ Write Lock: exclusive lock; only one thread can write at a time.

    ✅ Use Case: When reads are frequent and writes are rare → improves performance.

    🔗 Code Snippet:
    ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();
    Lock readLock = rwLock.readLock();
    Lock writeLock = rwLock.writeLock();

    readLock.lock();
    try {
       // multiple readers allowed
    } finally {
       readLock.unlock();
    }

    5️⃣ StampedLock (Java 8+)
    ➤ Offers better performance in high-concurrency environments.
    ➤ Provides three modes:
        ✔️ Write Lock
        ✔️ Read Lock
        ✔️ Optimistic Read (non-blocking, fastest)

    ➤ Returns a stamp (long value) used to unlock later.

    ✅ Use Case: When you need fast, optimistic read operations with low write contention.

    StampedLock lock = new StampedLock();
    long stamp = lock.tryOptimisticRead();
    if (!lock.validate(stamp)) {
        stamp = lock.readLock();
        try {
            // protected read
        } finally {
            lock.unlockRead(stamp);
        }
    }    

🔄 Best Practices
✅ Always call unlock() in a finally block.
✅ Prefer tryLock() to avoid deadlocks.
✅ Use ReentrantReadWriteLock for high read concurrency.
✅ Use StampedLock for performance-critical read-heavy systems.
✅ Avoid mixing synchronized and Lock on same object.


🔷 Locks' Fairness: Prevent Deadlocks
❓ What is Unfair Locking?
➤ By default, ReentrantLock uses an unfair policy, meaning:
➤ When multiple threads are waiting for the lock,
a new thread may “cut in line” and acquire the lock even if others have been waiting longer.
➤ The scheduler doesn’t strictly follow first come, first served (FCFS) order.
➤ This can cause thread starvation, but improves performance in some cases.

✅Example: Unfair Lock Demonstration
package com.corejava;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class UnfairLockExample {
    // Default constructor => unfair lock
    private final Lock unfairLock = new ReentrantLock();

    public void accessResource() {
        unfairLock.lock();
        try {
            System.out.println(Thread.currentThread().getName() + " acquired the lock");
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            unfairLock.unlock();
            System.out.println(Thread.currentThread().getName() + " released the lock");
        }
    }
}

package com.corejava;

public class Main {
    public static void main(String[] args) {
        UnfairLockExample unfairLockExample = new UnfairLockExample();

        Runnable task = () -> unfairLockExample.accessResource();

        Thread t1 = new Thread(task, "Thread 1");
        Thread t2 = new Thread(task, "Thread 2");
        Thread t3 = new Thread(task, "Thread 3");

        t1.start();
        t2.start();
        t3.start();
    }
}
✅Expected Output(May vary in each run):
Thread 2 acquired the lock
Thread 2 released the lock
Thread 3 acquired the lock
Thread 3 released the lock
Thread 1 acquired the lock
Thread 1 released the lock

👉 Next time when you run the code:
Thread 1 acquired the lock
Thread 1 released the lock
Thread 3 acquired the lock
Thread 3 released the lock
Thread 2 acquired the lock
Thread 2 released the lock

👉 There’s no guaranteed order — threads acquire the lock randomly even though Thread 1 started first.
👉 That’s the unfair behavior.

🆚 Fair vs Unfair Lock
If you want to make it fair, modify one line 👇

private final Lock fairLock = new ReentrantLock(true); // true = fair

✅Output with Fair Lock:
Thread 1 acquired the lock
Thread 2 acquired the lock
Thread 1 released the lock
Thread 2 released the lock
Thread 3 acquired the lock
Thread 3 released the lock
👉 Now the output follows Thread 1 → Thread 2 → Thread 3 (the order in which they started waiting).

➤ Thread 1 and Thread 2 both say “acquired the lock” before either released it.
➤ That’s actually not possible if both lines refer to the same critical section protected by the same lock, because only one thread can hold a ReentrantLock at a time.

➤ So, what really happens is:
    ✔️ Thread 1 acquires the lock and prints.
    ✔️ Before Thread 1 releases it, Thread 2 is blocked, waiting.
    ✔️ Once Thread 1 releases the lock, Thread 2 then acquires and prints.
    ✔️ But because of console I/O buffering, their print statements may appear out of strict order.
➤ So don’t rely solely on print order — small thread scheduling variations can cause misleading console sequences.


🔄 Disadvantages of synchronized in Java
1️⃣ No Flexibility / Limited Control
➤ Once a synchronized block or method starts, other threads must wait — no timeout, no try mechanism.
➤ You cannot check if a lock is available before trying to acquire it.
➤ Unlike ReentrantLock, you cannot interrupt a thread waiting for a synchronized lock.

✅ Example:
synchronized void print() { ... }  // waits indefinitely

2️⃣ Automatic Locking — No Manual Release
➤ Lock is automatically released when the method/block exits, even if you wanted to keep it longer.
➤ You cannot manually unlock() early like you can with Lock objects.

3️⃣ No Fairness Guarantee
➤ Thread scheduling is not fair — JVM does not guarantee FIFO order of thread execution.
➤ A thread that waits longer doesn’t necessarily get the lock next → can lead to thread starvation.

4️⃣ Cannot Try for Lock (No tryLock Equivalent)
➤ There’s no non-blocking attempt to acquire the lock.
➤ Threads either block indefinitely or wait till lock is free.

🆚 Compare with Lock API:
if (lock.tryLock()) {
   // proceed
} else {
   // do something else
}

5️⃣ Cannot Create Multiple Condition Variables
➤ synchronized provides only one intrinsic lock per object.
➤ You can use only one wait set per object (via wait(), notify(), notifyAll()).
➤ With Lock, you can create multiple Condition objects for fine-grained control.

6️⃣ No Timeout Option
➤ There’s no way to specify how long a thread should wait to acquire the lock.
➤ Threads can remain blocked indefinitely.

7️⃣ Can Cause Deadlock Easily
➤ If multiple synchronized blocks lock different objects in wrong order, threads can deadlock.
➤ Because synchronization is implicit and uninterruptible, recovery is difficult.

8️⃣ Lower Performance in High Contention
➤ When many threads compete for the same lock, context switching and blocking overhead increases.
➤ Modern alternatives (Lock, StampedLock, etc.) can be more scalable and non-blocking.

9️⃣ No Explicit Lock Information
➤ You can’t check:
    ✔️ whether a thread currently holds a lock,
    ✔️ how many times it has entered (no reentrancy info), or
    ✔️ if another thread is waiting.
➤ ReentrantLock provides such introspection methods (isLocked(), isHeldByCurrentThread(), etc.).

1️⃣0️⃣ Difficult Debugging
➤ Since locking and unlocking are automatic, it’s harder to trace where threads are blocking or waiting.
➤ Deadlocks or long wait times are tough to identify without specialized tools.


🔷 ReadWriteLock
A ReadWriteLock is a special kind of lock that maintains two separate locks:
👉 Read Lock – for read-only operations
👉 Write Lock – for write/update operations

❓ Why Use It:
➤ In many systems, read operations are more frequent than writes.
➤ If every thread used the same lock (like synchronized), even reads would block each other — reducing performance.

✅ ReadWriteLock allows multiple threads to read simultaneously,
🚫 but only one thread can write at a time, and no reader can read while a write is happening.

🔄 Rule of Thumb:
| Operation       | Can run in parallel? | Condition                            |
| --------------- | -------------------- | ------------------------------------ |
| Multiple Reads  | ✅ Yes                | As long as **no write** is happening |
| Read + Write    | ❌ No                 | Write locks block readers            |
| Multiple Writes | ❌ No                 | Only one writer at a time            |
| Write + Write   | ❌ No                 | Only one writer                      |

✅Example: ReadWriteCounter
package com.corejava;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class ReadWriteCounter {
    private int count=0;
    private  final ReadWriteLock rwlock=new ReentrantReadWriteLock();

    private final Lock readLock=rwlock.readLock();
    private final Lock writeLock=rwlock.writeLock();

    public void increment(){
        writeLock.lock();
        try{
            System.out.println(Thread.currentThread().getName()+" incremented");
            count++;
        }finally {
            writeLock.unlock();
        }
    }

    public int getCount(){
        readLock.lock();
        try{
            System.out.println("Count of the variable: "+count);
        }finally {
            readLock.unlock();
        }
        return count;
    }
}

1️⃣ Class Setup
➤ rwlock creates an object that provides two locks:
    ✔️ readLock() – allows concurrent reads.
    ✔️ writeLock() – exclusive lock for writing.
➤ count → shared resource being read/written by threads.

2️⃣ Write Operation (increment())
➤ writeLock.lock() → acquires exclusive access to count.
➤ While one thread holds the write lock:
    ❌ No other write thread can enter.
    ❌ No read thread can access count.
➤ Ensures atomicity and data consistency during modification.
➤ Finally block ensures unlock() always happens, even if an exception occurs.

3️⃣ Read Operation (getCount())
➤ readLock.lock() allows concurrent access to count if no write is active.
➤ Multiple threads can hold readLock simultaneously.
➤ When a write lock is requested, new readers must wait until the write finishes.

package com.corejava;

public class Main {
    public static void main(String[] args) throws InterruptedException {

        ReadWriteCounter counter=new ReadWriteCounter();
        Runnable readTask = () -> {
            for(int i=0;i<10;i++){
                System.out.println(Thread.currentThread().getName()+" read: "+counter.getCount() );
            }
        };

        Runnable writeTask= () -> {
            for(int i=0;i<10;i++){
                counter.increment();
            }
        };

        Thread writeThread=new Thread(writeTask,"Thread write1");
        Thread readThread1=new Thread(readTask,"Thread read1");
        Thread readThread2=new Thread(readTask,"Thread read2");

        writeThread.start();
        readThread1.start();
        readThread2.start();

        try {
            writeThread.join();
            readThread1.join();
            readThread2.join();
        } catch (InterruptedException e) {
           try {
               writeThread.interrupt();
               readThread1.interrupt();
               readThread2.interrupt();
           } catch (RuntimeException ex) {
               throw new RuntimeException(ex);
           }
        }

        System.out.println("Final count:"+ counter.getCount());
    }
}

4️⃣ Main Class Logic
➤ readTask → repeatedly reads the counter (10 times).
➤ writeTask → increments the counter (10 times).

5️⃣ Threads Creation
One write thread and two read threads.

6️⃣ Execution Flow
writeThread.start();
readThread1.start();
readThread2.start();

➤ All threads start together.
➤ When the write thread holds writeLock, readers wait.
➤ When write finishes, both read threads can read concurrently again.

7️⃣ Final Output
System.out.println("Final count:" + counter.getCount());
👉 After all threads finish, the final count should be 10 (since one writer increments 10 times).

❓ Why ReadWriteLock Is Better Here
| Aspect                   | `synchronized`     | `ReadWriteLock` |
| ------------------------ | ------------------ | --------------- |
| Multiple readers         | ❌ Block each other | ✅ Allowed       |
| Writer access            | Exclusive          | Exclusive       |
| Performance (read-heavy) | Lower              | Higher          |
| Fine-grained control     | Limited            | High            |


🔄 Use ReadWriteLock When
➤ Read operations are frequent.
➤ Write operations are infrequent but must be exclusive.
✅ Example scenarios:
    ✔️ Caching systems
    ✔️ Configuration reading
    ✔️ File metadata readers
    ✔️ In-memory database snapshots

🔁 Insights
✔️ Always unlock in finally block.
✔️ Don’t acquire both read and write lock in same thread (can deadlock).
✔️ Prefer ReentrantReadWriteLock for reentrancy (same thread can re-acquire lock safely).
✔️ Readers block writers, and writers block readers — but readers can share the lock.


🔷 Deadlock