############
ğŸ”· Java 11
############

================================================================================
Feature 1ï¸âƒ£: var in Lambda Parameters (local variable type inference in lambdas)
================================================================================
Java 11 introduced Local-Variable Syntax for Lambda Parameters, extending the var keyword (from Java 10) to lambda expressions. This enables type inference for lambda parameters, making code more concise while maintaining readability.

ğŸ”„ Key Benefits
â¤ Consistency: Matches local variable syntax (var x) -> ...
â¤ Annotations: Add annotations directly to parameters like (@NonNull var x)
â¤ Cleaner code: Reduces verbosity in functional interfaces

âœ… Code Examples
Before Java 11 (verbose or implicit):

âœ”ï¸ Explicit types
BinaryOperator<Integer> add = (Integer a, Integer b) -> a + b;

âœ”ï¸ Implicit (no types) - works but can't add annotations
BinaryOperator<Integer> add2 = (a, b) -> a + b;
Java 11 with var (clean + annotatable):


âœ… Example:
import javax.annotation.Nonnull;

Works perfectly - compiler infers Integer
BinaryOperator<Integer> add = (var a, var b) -> a + b;

Add annotations easily!
BinaryOperator<Integer> safeAdd = (@Nonnull var a, @Nonnull var b) -> a + b;

public class LambdaVarDemo {
    public static void main(String[] args) {
        System.out.println(add.apply(10, 20)); â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ 30
        System.out.println(safeAdd.apply(15, 25)); â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ 40
    }
}

ğŸ”„ Strict Rules (Java 11+ only)
âœ… VALID
(var x) -> x * 2
(var a, var b) -> a + b

âŒ INVALID - Mixing var + implicit
(var a, b) -> a + b   Compilation error


âŒ INVALID - Mixing var + explicit types
(var a, String b) -> a + b   Compilation error


âŒ INVALID - Single var without parentheses
var x -> x * 2   Compilation error - needs (var x)
Primary use case: Adding annotations to lambda parameters without explicit types, perfect for Spring Boot @RequestParam validators or @NonNull checks in your microservices projects.


================================
Feature 2ï¸âƒ£: Standard Library
================================
1ï¸âƒ£ New String Methods â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ isBlank(), lines(), strip(), stripLeading(), stripTrailing(), repeat(n)

2ï¸âƒ£ New Files Methods
â¤ Files.readString(Path)
â¤ Files.writeString(Path, String)

3ï¸âƒ£ New Optional Method â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Optional.isEmpty()


====================================================================================================================================
Feature 3ï¸âƒ£: Running Java Without Compilation â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Single-file source execution â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ java Hello.java (no javac needed)
====================================================================================================================================
Java 11 introduced Launch Single-File Source-Code Programs (JEP 330), allowing direct execution of .java source files without explicit javac compilation. The source compiles in-memory and runs immediatelyâ€”no .class files generated on disk.

Purpose: Bridge gap between scripting languages (Python/Node: python script.py) and Java's traditional compile-run model.

ğŸ”„ How It Works
When you run java Hello.java, Java launcher:
1ï¸âƒ£ Detects .java extension (or --source flag)
2ï¸âƒ£ Compiles source in memory only
3ï¸âƒ£ Executes first class with main() method
ğŸ‘‰ Passes command-line args normally

âœ… Code Examples
Simple Hello World:

// Hello.java
public class Hello {
    public static void main(String[] args) {
        System.out.println("Hello " + (args.length > 0 ? args[0] : "World") + "!");
    }
}

ğŸ”— bash
java Hello.java Ankur
# Output: Hello Ankur!


ğŸ”„ Multiple Classes (First class = entry point):
// Calculator.java
public class Calculator {
    public static void main(String[] args) {
        MathUtils utils = new MathUtils();
        System.out.printf("Sum: %.2f%n", utils.sum(10, 20, 30));
    }
}

class MathUtils {
    public double sum(double... values) {
        return java.util.Arrays.stream(values).sum();
    }
}

ğŸ”— bash
java Calculator.java
# Output: Sum: 60.00


ğŸ”„ Key Rules & Options
Auto-Detection:
ğŸ”— bash
java MyProgram.java arg1 arg2  # .java = source mode
java --source 11 script arg1    # Force source mode


ğŸ”„ Class Name â‰  File Name (OK!):
// Main.java (class MyApp)
class MyApp {
    public static void main(String[] args) { /* ... */ }
}
java Main.java  # Works! Uses first class


âœ… Benefits of Single-File Execution
â¤ Script-like simplicity â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ java Hello.java vs javac Hello.java && java Hello
â¤ No bytecode clutter â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ In-memory compilation = clean directories
â¤ Rapid prototyping â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Test algorithms/DS instantly
â¤ Learning/Teaching â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Beginners skip compilation step
â¤ CI/CD friendly â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ One-liner builds in pipelines


ğŸš« Limitations:
âŒ Single file only (no --class-path multi-file)
âŒ First class must have public static void main
âŒ No .class outputâ€”purely in-memory


############
ğŸ”· Java 17
############

===========================
Feature 1ï¸âƒ£: Sealed Classes
============================
Purpose: Restrict inheritance hierarchy to known, explicit subclasses for better modeling, exhaustive pattern matching, and client code optimization.

ğŸ”„ Syntax 
sealed class Shape           // Restricts who can extend
    permits Circle, Square { }  // Explicit whitelist

final class Circle extends Shape { }     // âœ… No further extension
non-sealed class Square extends Shape { } // âœ… Can be extended
sealed class Rectangle extends Shape     // âœ… Further restricts
    permits FilledRect { }


ğŸ”„ Inheritance Options for Subclasses
| Modifier   | Meaning                         | Use Case                 |
| ---------- | ------------------------------- | ------------------------ |
| final      | Cannot be extended              | Leaf nodes (Circle)      |
| sealed     | Restricts further (own permits) | Intermediate (Rectangle) |
| non-sealed | Open to extension               | Flexible nodes (Square)  |


âœ… Example
// Shape.java - Single file for demo
sealed interface Vehicle permits Car, Truck { 
    String getRegNo();
}

final record Car(String regNo, int seats) implements Vehicle {
    public String getRegNo() { return regNo; }
}

non-sealed record Truck(String regNo, int load) implements Vehicle {
    public String getRegNo() { return regNo; }
}

public class Demo {
    public static void main(String[] args) {
        Vehicle[] vehicles = { 
            new Car("KA123", 4), 
            new Truck("KA456", 5000) 
        };
        
        // Exhaustive switch (compiler verifies)
        for (Vehicle v : vehicles) {
            String type = switch (v) {
                case Car c -> "Car: " + c.seats() + " seats";
                case Truck t -> "Truck: " + t.load() + "kg";
            };
            System.out.println(type);
        }
    }
}

ğŸ”„ Real-World Benefits for Spring Boot
1ï¸âƒ£ Domain Models
sealed class OrderStatus permits Pending, Shipped, Delivered { }
final class Pending extends OrderStatus { }
final class Delivered extends OrderStatus {
    LocalDateTime deliveredAt;
}


2ï¸âƒ£ API Response Types
sealed interface ApiResponse permits Success, Error { }
final record Success<T>(T data) implements ApiResponse { }
final record Error(String message) implements ApiResponse { }


=====================
Feature 2ï¸âƒ£: Records
=====================
Records are a special final class for immutable data carriers that auto-generate boilerplate code, replacing verbose POJOs/DTOs.

ğŸ”„ Syntax
public record Person(String name, int age) { }

ğŸ”„ Compiler generates
â¤ Private final fields â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ private final String name; private final int age;
â¤ Canonical constructor
â¤ Accessor methods: name(), age(), equals(), hashCode(), toString()


âœ… Example
// Records.java - Single file demo
record Point(int x, int y) { }
record Circle(Point center, int radius) { }

record Order(String id, double amount, String status) {
    // Custom validation constructor
    public Order {
        if (amount < 0) throw new IllegalArgumentException("Amount can't be negative");
    }
    
    // Custom method
    public boolean isHighValue() {
        return amount > 1000;
    }
}

public class Demo {
    public static void main(String[] args) {
        Point p1 = new Point(10, 20);
        Point p2 = new Point(10, 20);
        
        System.out.println(p1);        // Point[x=10, y=20]
        System.out.println(p1.equals(p2)); // true
        System.out.println(p1.hashCode() == p2.hashCode()); // true
        
        Order order = new Order("ORD-123", 1500.0, "SHIPPED");
        System.out.println(order.isHighValue()); // true
    }
}


ğŸ”„ Auto-Generated Methods
| Method                 | Implementation           |
| ---------------------- | ------------------------ |
| Point(int x, int y)    | Canonical constructor    |
| int x(), int y()       | Accessors (not getters!) |
| boolean equals(Object) | Compares all components  |
| int hashCode()         | Hash of all components   |
| String toString()      | Point[x=10, y=20]        |


ğŸ”„ Key Features
â¤ Immutable - All fields final
â¤ Compact - 1 line vs 50-line POJO
â¤ Thread-safe by design
â¤ Works with Sealed Classes & Pattern Matching
â¤ Implements java.lang.Record


ğŸ”„ Use Cases
1ï¸âƒ£ DTOs / API Responses:
record ApiResponse<T>(boolean success, T data, String message) { }
@GetMapping("/users/{id}")
public ApiResponse<User> getUser(@PathVariable Long id) {
    return new ApiResponse<>(true, userService.find(id), "Success");
}


2ï¸âƒ£ Spring Boot with JPA:
record CreateUserRequest(@NotBlank String name, @Email String email) { }

@PutMapping("/users")
public ResponseEntity<User> updateUser(@Valid @RequestBody CreateUserRequest req) {
    // Auto-validated, immutable DTO
}


3ï¸âƒ£ Event Sourcing / Domain Events:
sealed interface DomainEvent permits UserCreated, OrderPlaced { }
record UserCreated(String userId, LocalDateTime timestamp) implements DomainEvent { }
record OrderPlaced(String orderId, BigDecimal amount) implements DomainEvent { }


ğŸ”„ Advanced Features
1ï¸âƒ£ Custom Constructor (Validation):
record Product(String name, double price) {
    public Product {
        if (price <= 0) throw new IllegalArgumentException("Invalid price");
    }
}

2ï¸âƒ£ Static Members:
record Temperature(double celsius) {
    public static Temperature fromFahrenheit(double f) {
        return new Temperature((f - 32) * 5.0 / 9.0);
    }
}


ğŸ”„ Benefits
âœ… 80% less code for data classes
âœ… Zero bugs in equals/hashCode/toString
âœ… Immutable = thread-safe
âœ… Pattern matching ready
âœ… JSON serialization friendly


ğŸ”„ Limitations
âŒ Final - Cannot extend other classes
âŒ No setters - Immutable only
âŒ No instance fields beyond components
âŒ No static initializers
âŒ Limited inheritance (interfaces only)


ğŸ”„ vs Traditional POJO (50 lines â†’ 1 line)
// âŒ OLD POJO (50 lines)
class Point {
    private final int x, y;
    public Point(int x, int y) { this.x = x; this.y = y; }
    public int getX() { return x; }
    public int getY() { return y; }
    public boolean equals(Object o) { /* 20 lines */ }
    public int hashCode() { /* 10 lines */ }
    public String toString() { /* 5 lines */ }
}

// âœ… NEW RECORD (1 line)
record Point(int x, int y) { }


========================================================
Feature 2ï¸âƒ£: New Random Generator API (java.util.random)
========================================================
â¤ Replaces: Legacy java.util.Random / ThreadLocalRandom
â¤ Package: java.util.random.*
â¤ Core: RandomGenerator interface + RandomGeneratorFactory

â“ Why Introduced
Old Random was:
â¤ Single algorithm (LCG)
â¤ Poor parallel performance
â¤ No Stream API integration
â¤ Limited statistical quality

New API: Multiple high-quality algorithms, splittable, stream-friendly.

Factory API (Main Entry Point)
// Get available algorithms
RandomGeneratorFactory.all().forEach(System.out::println);
// [L32X64MixRandom, XORWOW, L64X128MixRandom, ...]

// By name (17 built-in algorithms)
RandomGenerator rng1 = RandomGeneratorFactory.of("L64X128MixRandom").create(42L);
RandomGenerator rng2 = RandomGenerator.of("Random").create(); // Default

// Default (fastest jumpable)
RandomGenerator rng3 = RandomGenerator.getDefault();


âœ… Example
import java.util.random.*;

public class RandomDemo {
    public static void main(String[] args) {
        RandomGenerator rng = RandomGenerator.of("L64X128MixRandom").create(12345L);
        
        // 1. Basic usage
        System.out.println("Random int: " + rng.nextInt(1, 100));
        
        // 2. Stream generation
        rng.ints(5, 1, 10)
           .forEach(i -> System.out.print(i + " "));
        System.out.println();
        
        // 3. Splittable - Perfect for parallel processing
        var children = rng.splits(3);
        children.forEach(r -> 
            System.out.println(r.nextLong(1000))
        );
    }
}

âœ… Output
Random int: 73
7 3 9 2 6
847
392
156

ğŸ‘‰ Key Points
â¤ Same seed = same output every run
â¤ Splittable: Children get independent but derived state
â¤ L64X128MixRandom: High-quality, fast, 192-bit internal state
