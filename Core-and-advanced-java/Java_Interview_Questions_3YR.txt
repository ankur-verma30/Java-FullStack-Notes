============================================================
  JAVA INTERVIEW QUESTIONS - 3 YEAR EXPERIENCE LEVEL
  Topics: Core Java | Collections | Spring Boot | Hibernate | SQL
  Total Questions: 250+
  Includes: Scenario-Based | Trap Questions | Production Issues | Core Concepts
============================================================


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 SECTION 1: CORE JAVA (Questions 1-60)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

--- 1.1 Object-Oriented Concepts & Traps ---

Q1. [TRAP] You have two classes A and B. B extends A. Both have a static method with the same signature.
    You create a reference: A obj = new B();
    obj.staticMethod() is called. Which class's method gets executed and WHY?
    âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Trap: Static methods are resolved at COMPILE TIME (static binding), not runtime.
      So A's method runs. Polymorphism does NOT apply to static methods.


Q2. [SCENARIO] You override equals() in your custom class but forget to override hashCode().
    You put objects into a HashSet. You create two objects with the same field values.
    Will the HashSet treat them as duplicates? WHY or WHY NOT?
    âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ If hashCode() is not overridden, two equal objects may have different hash codes,
      so HashSet puts them in different buckets â†’ duplicates exist in the Set.


Q3. [TRAP] What happens when you override a method and change the return type to a subclass type?
    Is this valid? What is this called?
    âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ This is called COVARIANT RETURN TYPE. It is valid in Java.
      The overriding method can return a subtype of the original return type.


Q4. [SCENARIO] Class A has a constructor that calls an overridable method foo(). Class B extends A and overrides foo().
    You do: new B(); What happens when foo() is called inside A's constructor?
    âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ B's version of foo() is called, but B's fields are NOT yet initialized at that point.
      This causes unexpected behavior / NullPointerException. Classic production bug.

ğŸ”— Code Explanation:
class A {

    A() {
        System.out.println("A constructor started");
        foo(); ----------> // Calling overridable method inside constructor (BAD PRACTICE)
        System.out.println("A constructor ended");
    }

    void foo() {
        System.out.println("A foo()");
    }
}

class B extends A {

    private String message = "Hello from B"; // <-- not initialized when A() calls foo()

    B() {
        System.out.println("B constructor started");
        System.out.println("B constructor ended");
    }

    @Override
    void foo() {
        System.out.println("B foo() called");
        System.out.println("message length = " + message.length()); 
        // ğŸ’¥ message is null here -> NullPointerException
    }
}

public class Main {
    public static void main(String[] args) {
        new B();
    }
}


Q5. [TRAP] Can you override a private method?
    âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ NO. Private methods are not inherited. If you write the same signature in a child class,
      it is method HIDING, not overriding. @Override annotation will cause a compile error.


Q6. [SCENARIO] You have:
    class Parent { String greet() { return "Parent"; } }
    class Child extends Parent { String greet() { return "Child"; } }
    Parent p = new Child();
    System.out.println(p.greet());
    âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Prints "Child". This is runtime polymorphism (dynamic dispatch).


Q7. [TRAP] Difference between abstract class and interface. Can an abstract class have a constructor?
    âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ YES. Abstract classes CAN have constructors. They are called via super() by child classes.
      Interfaces cannot have constructors (prior to Java 8 default methods, they had no body at all).

Even though you cannot create an object directly of an abstract class, its constructor is used to initialize the abstract class part when a child class object is created.

â“ Why does an abstract class need a constructor?
When you do: new Child();

Java internally does:
	âœ”ï¸ Call Abstract class constructor
	âœ”ï¸ Then call Child class constructor

So abstract class constructor helps to:
	âœ”ï¸ initialize common fields
	âœ”ï¸ enforce initialization rules
	âœ”ï¸ run shared setup logic

âœ… Example Code
abstract class A {
    A() {
        System.out.println("Abstract class constructor called");
    }
}

class B extends A {
    B() {
        System.out.println("Child class constructor called");
    }
}

public class Main {
    public static void main(String[] args) {
        B obj = new B();
    }
}
âœ… Output
Abstract class constructor called
Child class constructor called


Q8. [SCENARIO] You have an interface with a default method and a class implementing two interfaces
    both having the same default method signature. What happens?
    âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ COMPILE ERROR. The class MUST override the method and explicitly choose which one to call
      using InterfaceName.super.methodName().

Q9. [TRAP] What is the difference between method overloading and overriding in terms of binding?
    âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Overloading = Static/Compile-time binding (resolved by parameter types at compile time)
       Overriding = Dynamic/Runtime binding (resolved by actual object type at runtime)

Q10. [SCENARIO] You have a final class. Someone tries to extend it in a production codebase.
     What error do they get? Why do you make a class final?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Compile error: "cannot inherit from final class". Final classes are made final to prevent
       unintended subclassing that could break contract or security (e.g., String class).


--- 1.2 String & Memory Traps ---

Q11. [TRAP] String s1 = "hello"; String s2 = "hello"; String s3 = new String("hello");
     s1 == s2 â†’ ? s1 == s3 â†’ ? s1.equals(s3) â†’ ?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ s1 == s2 â†’ TRUE (same reference from String Pool)
       s1 == s3 â†’ FALSE (s3 is a new object on heap)
       s1.equals(s3) â†’ TRUE (content comparison)


Q12. [TRAP] String s = "hello"; s += " world"; How many String objects are created?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ "hello" (1), " world" (1), "hello world" (1 via StringBuilder internally) = 3 objects.
       The original "hello" reference is lost because now s becomes hello world. Strings are IMMUTABLE. 


Q13. [SCENARIO] In a production app, you are concatenating strings inside a loop 10,000 times.
     What performance issue arises? What is the fix?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Creates thousands of temporary String objects â†’ excessive GC pressure.
       Fix: Use StringBuilder or StringBuffer (StringBuffer is thread-safe but slower).


Q14. [TRAP] What does String.intern() do? When would you use it?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ intern() returns a reference to the string from the String Pool.
       If the string already exists in the pool, it returns that reference.
       Used to save memory when you have many duplicate strings (e.g., from user input).
       But misuse can cause OutOfMemoryError in the PermGen/Metaspace area.


Q15. [TRAP] StringBuilder vs StringBuffer - when does thread safety actually matter?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ StringBuffer is synchronized (thread-safe) but slower.
       StringBuilder is NOT thread-safe but faster.
       In 99% of cases, use StringBuilder. Only use StringBuffer if the same instance
       is shared across threads (which is rare in practice).

--- 1.3 Exception Handling Traps ---

Q16. [TRAP] What happens if you have a return statement in both try and finally blocks?
     finally { return "finally"; }
     try { return "try"; }
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ The finally block's return OVERRIDES the try block's return.
       "finally" is returned. This is a well-known trap and bad practice.


Q17. [SCENARIO] You have: try { } catch (Exception e) { } catch (RuntimeException e) { }
     Does this compile?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ NO. RuntimeException is a subclass of Exception.
       Catch blocks must be ordered from most specific to most general.
       Compiler will say "exception already caught".


Q18. [TRAP] Difference between checked and unchecked exceptions. Give production examples.
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Checked: Must be declared or caught. Example: IOException, SQLException.
       Unchecked: Not required. Example: NullPointerException, IllegalArgumentException.
       Production trap: Wrapping checked exceptions in unchecked ones can hide errors.


Q19. [SCENARIO] You catch an exception and log it, but the catch block itself throws an exception.
     What happens to the original exception?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ The original exception is LOST. The new exception propagates up.
       Best practice: Use addSuppressed() or log before rethrowing.

âŒ Example: Original Exception is LOST
public class Main {
    public static void main(String[] args) {
        try {
            int x = 10 / 0; // Original exception (ArithmeticException)
        } catch (Exception e) {
            System.out.println("Logging exception: " + e.getMessage());

            // âŒ Catch block throws another exception
            String s = null;
            System.out.println(s.length()); // New exception (NullPointerException)
        }
    }
}
âœ… Output will show only:
ArithmeticException was logged...
NullPointerException stack trace

ğŸ‘‰ The program crashes with NullPointerException
and the original ArithmeticException stack trace is gone.

âœ… Best Practice 1ï¸âƒ£: Log and Rethrow SAME Exception (Safest)
try {
    int x = 10 / 0;
} catch (Exception e) {
    System.out.println("Error occurred: " + e); // log it
    throw e; // rethrow original exception
}
âœ”ï¸ Original exception stays.


âœ… Best Practice #2: Wrap exception (Preserve cause)
try {
    int x = 10 / 0;
} catch (Exception e) {
    throw new RuntimeException("Something failed in calculation", e);
}
âœ… Now the original exception is preserved as the cause.


â­ Best Practice #3: addSuppressed() (What you asked)
âœ… Meaning of suppressed exception
â¤ Sometimes: You want to throw a new exception
â¤ BUT also want to keep the original exception
â¤ So you attach the original exception as a suppressed exception.

âœ… Example using addSuppressed()
public class Main {
    public static void main(String[] args) {
        try {
            try {
                int x = 10 / 0; // Original exception
            } catch (Exception original) {

                // Suppose something fails while handling/logging
                Exception newException = new RuntimeException("Failure while handling exception");

                // âœ… Attach original exception so it is NOT lost
                newException.addSuppressed(original);

                throw newException; // propagate new exception
            }
        } catch (Exception e) {
            e.printStackTrace(); // will show suppressed exceptions too
        }
    }
}
âœ… Output will include:
RuntimeException stack trace
Suppressed: ArithmeticException stack trace
So original is NOT lost âœ…


â“ When is addSuppressed() actually used in real life?
Mostly in cases like:
1ï¸âƒ£ Resource closing failure
Example: you throw exception in try, and then closing DB connection also fails.
Java automatically uses suppressed exceptions in try-with-resources.
2ï¸âƒ£ You want to throw a custom exception but keep original too


Q20. [TRAP] Can you catch Error? Should you?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ YES technically you can, but you generally SHOULD NOT.
       Errors like OutOfMemoryError or StackOverflowError indicate JVM-level problems.
       Catching them rarely helps and can mask serious issues.


--- 1.4 Autoboxing, Primitives & Wrapper Traps ---

Q21. [TRAP] Integer a = 127; Integer b = 127; a == b â†’ ?
     Integer c = 128; Integer d = 128; c == d â†’ ?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ a == b â†’ TRUE (Integer cache: -128 to 127)
       c == d â†’ FALSE (outside cache range, new objects created)
       Always use .equals() for wrapper comparisons!


Q22. [TRAP] What happens here? Integer x = null; int y = x;
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ NullPointerException during auto-unboxing.
       This is a common production bug when mixing primitives and wrappers.


Q23. [SCENARIO] You have a method that takes an int parameter and you pass an Integer that is null. 
	What happens at runtime?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ NullPointerException during unboxing. Always null-check before unboxing.


Q24. [TRAP] int[] vs Integer[] - Can you use Arrays.sort() on int[]? Can you use Collections.sort() on int[]?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Arrays.sort(int[]) works (uses dual-pivot quicksort).
       Collections.sort() requires List<T>, so int[] won't work.
       You need Integer[] or List<Integer> for Collections.sort().


--- 1.5 Control Flow & Misc Traps ---

Q25. [TRAP] What is the difference between == and equals() for comparing enum values?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Both work. Enums are singletons, so == is safe and actually preferred (faster, no NPE risk).


Q26. [SCENARIO] You use a switch statement on a String in Java. What Java version introduced this?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Java 7. Before that, only primitives and enums were allowed in switch.


Q27. [TRAP] What happens with: for (int i = 0; i < 10; i = i + 0) {}
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Infinite loop. i never changes.


Q28. [SCENARIO] Explain the difference between pass-by-value and pass-by-reference in Java.
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Java is ALWAYS pass-by-value. But for objects, the VALUE being passed is the REFERENCE.
       So modifying object contents inside a method affects the original,
       but reassigning the reference inside the method does NOT affect the original.

ğŸ”— Code Explanation:
class Person {
    String name;
    Person(String name) { this.name = name; }
}

public class Main {

    static void test(Person p) {
        p.name = "Changed";          // âœ… affects original object
        p = new Person("New Person"); // âŒ doesn't affect original reference
        p.name = "New Changed";      // affects only the new object
    }

    public static void main(String[] args) {
        Person person = new Person("Ankur");

        test(person);

        System.out.println(person.name); // âœ… Output: Changed
    }
}


Q29. [TRAP] Can you have two methods in the same class with the same name and same parameter types
     but different return types?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ NO. This is NOT valid overloading. Return type alone cannot distinguish methods.


Q30. [SCENARIO] Explain var keyword in Java. When was it introduced? Can it be used for method parameters?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Introduced in Java 10 for local variable type inference.
       CANNOT be used for method parameters, return types, or class fields.
       It is a reserved type name, not a keyword (you can still name variables "var").


--- 1.6 Multithreading & Concurrency (Production Scenarios) ---

Q31. [SCENARIO] Explain the difference between Thread and Runnable. When would you use which?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Thread: Extend only if you need to customize thread behavior.
       Runnable: Preferred. Allows code reuse, works with thread pools, doesn't consume
       the single inheritance slot.


Q32. [TRAP] What is the difference between synchronized method and synchronized block?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ synchronized method locks on 'this' (the entire object).
       synchronized block lets you lock on a specific object, giving finer granularity.
       Production: synchronized blocks are preferred to avoid unnecessary blocking.


Q33. [SCENARIO] Two threads are updating a shared counter. You use volatile on the counter.
     Is this thread-safe for counter++?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ NO. volatile ensures visibility but NOT atomicity.
       counter++ is a compound operation (read-modify-write).
       Use AtomicInteger or synchronize the block.


Q34. [TRAP] Difference between wait() and sleep()?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ wait(): Releases the lock, thread goes to waiting state. Must be called inside synchronized block.
       sleep(): Does NOT release the lock. Thread goes to sleeping state.
       wait() is for inter-thread communication; sleep() is for time delay.


Q35. [SCENARIO] Explain the concept of a thread pool. Why is it better than creating new threads?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Thread creation is expensive (stack allocation, OS resources).
       Thread pools reuse threads, reducing overhead. Managed via ExecutorService.
       Production: Use Executors.newFixedThreadPool() or configure thread pool sizes based on workload.


Q36. [TRAP] What is a deadlock? Give a scenario with two resources.
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Thread A holds Resource1, waits for Resource2.
       Thread B holds Resource2, waits for Resource1.
       Neither can proceed â†’ deadlock.
       Prevention: Always acquire locks in the same order across all threads.


Q37. [SCENARIO] Explain the difference between Callable and Runnable.
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Runnable: void run(), cannot throw checked exceptions, no return value.
       Callable: V call(), can throw exceptions, returns a value via Future<V>.
       Use Callable when you need a result from the task.

--- 1.7 Inner Classes & Lambda Traps ---

Q38. [TRAP] Types of inner classes in Java and when to use each.
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Static Nested Class: Does not need outer class instance. Like a helper class.
       Inner Class: Needs outer class instance. Can access outer class members.
       Local Class: Defined inside a method.
       Anonymous Class: No name, used for one-time implementation (e.g., Comparator).


Q39. [SCENARIO] You have a lambda capturing a local variable. You try to modify that variable
     inside the lambda. Does it compile?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ NO. Variables captured by lambdas must be effectively final.
       You cannot modify them. Use AtomicReference or array wrapper as a workaround.

â“ What is â€œeffectively finalâ€?
A variable is effectively final if:
â¤ you assign it only once
â¤ you donâ€™t change it later

âœ… Example:
int x = 10;  // effectively final
Runnable r = () -> System.out.println(x); // âœ… OK

âŒ Code that DOES NOT compile
public class Main {
    public static void main(String[] args) {

        int count = 0;
        Runnable r = () -> {
            count++;  // âŒ ERROR: Local variable count must be final or effectively final
        };
        r.run();
    }
}

âŒ Compiler error
Local variable count defined in an enclosing scope must be final or effectively final

âœ… Workaround 1ï¸âƒ£: Use AtomicInteger / AtomicReference
âœ… Using AtomicInteger
import java.util.concurrent.atomic.AtomicInteger;

public class Main {
    public static void main(String[] args) {

        AtomicInteger count = new AtomicInteger(0);

        Runnable r = () -> {
            count.incrementAndGet(); // âœ… allowed
            System.out.println(count.get());
        };
        r.run();
        r.run();
    }
}
âœ… Output:
1
2

âœ… Workaround 2ï¸âƒ£: Use Array Wrapper (Simple trick)
public class Main {
    public static void main(String[] args) {

        int[] count = {0}; // wrapper

        Runnable r = () -> {
            count[0]++; // âœ… allowed
            System.out.println(count[0]);
        };
        r.run();
        r.run();
    }
}
âœ… Output:
1
2

â“ Why Java enforces this rule?
â¤ Because captured local variables live on the stack, but lambdas may execute later, even after the method finishes.
â¤ So Java requires captured values to be stable â†’ effectively final.


Q40. [TRAP] Difference between lambda and anonymous inner class regarding 'this' keyword.
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ In anonymous inner class: 'this' refers to the anonymous class instance.
       In lambda: 'this' refers to the ENCLOSING class instance.
       This is a common trap in event handling and callbacks.

this in Lambda vs Anonymous Inner Class
ğŸ”¥ Anonymous Inner Class
ğŸ‘‰ this refers to the anonymous inner class object

ğŸ”¥ Lambda Expression
ğŸ‘‰ this refers to the enclosing (outer) class object

âœ… Code Example
public class ThisTrapDemo {

    private String name = "Outer-Class";

    public void test() {

        // âœ… Anonymous Inner Class
        Runnable anonymous = new Runnable() {
            private String name = "Anonymous-Class";

            @Override
            public void run() {
                System.out.println("Anonymous this.name = " + this.name);
                System.out.println("Outer name using OuterClass.this.name = " + ThisTrapDemo.this.name);
            }
        };

        // âœ… Lambda Expression
        Runnable lambda = () -> {
            // In lambda, "this" refers to the enclosing class instance
            System.out.println("Lambda this.name = " + this.name);
        };

        anonymous.run();
        lambda.run();
    }

    public static void main(String[] args) {
        new ThisTrapDemo().test();
    }
}

âœ… Output
Anonymous this.name = Anonymous-Class
Outer name using OuterClass.this.name = Outer-Class
Lambda this.name = Outer-Class

ğŸ§  Whatâ€™s happening internally?
âœ… Anonymous inner class creates a NEW class instance
â¤ this = anonymous object
â¤ It can have its own fields like name


âœ… Lambda does NOT create a new class instance
Lambda is more like:
  âœ”ï¸ a function passed around
  âœ”ï¸ it uses the same outer object
So: this = outer class object


--- 1.8 Java Collections API Edge Cases ---

Q41. [TRAP] Can you modify a list while iterating over it using a for-each loop?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ NO. Throws ConcurrentModificationException.
       Use Iterator.remove() or a CopyOnWriteArrayList for safe removal during iteration.


Q42. [SCENARIO] Explain fail-fast vs fail-safe iterators with examples.
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Fail-fast: Throws ConcurrentModificationException if collection is modified during iteration.
       Examples: ArrayList, HashMap iterators.
       Fail-safe: Works on a snapshot/copy. No exception thrown.
       Examples: CopyOnWriteArrayList, ConcurrentHashMap iterators.


Q43. [TRAP] Arrays.asList() returns a fixed-size list. Can you add elements to it?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ NO. Throws UnsupportedOperationException. It is backed by the original array.
       Use new ArrayList<>(Arrays.asList(...)) for a modifiable list.
       In Java 9+: List.of() also returns an immutable list.


Q44. [SCENARIO] What is the difference between Collections.unmodifiableList() and List.of()?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ unmodifiableList(): Wraps an existing list. Changes to the original list are reflected.
       List.of(): Creates a truly immutable list. No backing mutable list.


Q45. [TRAP] HashMap vs LinkedHashMap vs TreeMap - when to use which?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ HashMap: No order guarantee. O(1) get/put.
       LinkedHashMap: Maintains INSERTION ORDER. Useful for LRU cache (access order constructor).
       TreeMap: Maintains SORTED ORDER (natural or Comparator). O(log n) operations.


--- 1.9 Generics Traps ---

Q46. [TRAP] What is type erasure in Java Generics?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ At runtime, generic type information is ERASED. List<String> and List<Integer> are
       both just List at runtime. This prevents runtime type checking on generics.
       This is why you get "unchecked" warnings.


Q47. [TRAP] Can you create a generic array? new T[10] â€” does this compile?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ NO. Due to type erasure, you cannot create generic arrays directly.
       Workaround: Use Object[] and cast, or use ArrayList<T> instead.


Q48. [SCENARIO] Explain wildcard types: ?, ? extends T, ? super T with real examples.
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ ?: Unknown type. Read-only (except null).
       ? extends T: Upper bounded. Can read as T. Used for consuming (reading).
       ? super T: Lower bounded. Can write T. Used for producing (writing).
       Producer Extends, Consumer Super (PECS) rule.


Q49. [TRAP] Why can't you do: List<Integer> list = new ArrayList<Number>();
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Generics are INVARIANT, not covariant.
       List<Integer> is NOT a subtype of List<Number>.
       Use List<? extends Number> if you need to accept both.


--- 1.10 Miscellaneous Core Java ---

Q50. [TRAP] What is the difference between final, finally, and finalize?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ final: keyword for constants, methods that can't be overridden, classes that can't be extended.
       finally: block that always executes after try-catch.
       finalize(): method called by GC before object destruction (deprecated, unreliable).


Q51. [SCENARIO] Explain the Java memory model briefly. What is the difference between stack and heap?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Stack: Thread-local. Stores primitives, references, method calls. LIFO. Fast.
       Heap: Shared. Stores objects. Managed by GC. Slower but larger.


Q52. [TRAP] What is the difference between transient and volatile?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ transient: Field is NOT serialized during object serialization.
       volatile: Field is always read/written directly to main memory (visibility guarantee).
       They serve completely different purposes.


Q53. [SCENARIO] Explain the difference between deep copy and shallow copy with an example.
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Shallow copy: Copies reference. Both original and copy point to same inner objects.
       Deep copy: Copies everything recursively. Independent objects.
       Production: Use clone() carefully or implement your own copy logic.


Q54. [TRAP] Can an interface have static methods? Can it have private methods?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Static methods: YES (since Java 8).
       Private methods: YES (since Java 9). Used as helper methods for default methods.


Q55. [SCENARIO] What is the difference between Comparable and Comparator?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Comparable: Implemented BY the class itself. Single natural ordering. int compareTo(T).
       Comparator: External sorting strategy. Multiple orderings possible. compare(T, T).


Q56. [TRAP] Explain the difference between ClassNotFoundException and NoClassDefFoundError.
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ ClassNotFoundException: Checked exception. Class not found at COMPILE TIME or during Class.forName().
       NoClassDefFoundError: Error. Class was found at compile time but NOT at RUNTIME (classpath issue).
       Common production issue in deployment/classpath misconfigurations.


Q57. [SCENARIO] You have a singleton class. In a multi-threaded environment, two threads call getInstance()
     simultaneously for the first time. What can go wrong with a naive implementation?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Both threads see instance as null, both create new instances â†’ broken singleton.
       Fix: Double-checked locking with volatile, or use Enum singleton (preferred), or Bill Pugh singleton.


Q58. [TRAP] What is the difference between Class.forName() and ClassLoader.loadClass()?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Class.forName(): Loads AND initializes the class (runs static blocks).
       ClassLoader.loadClass(): Only loads the class, does NOT initialize it.

Q59. [SCENARIO] Explain the difference between serialization and cloning.
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Serialization: Converting object to byte stream (for storage/transmission). Uses ObjectOutputStream.
       Cloning: Creating a shallow/deep copy of an object. Uses clone() method.
       Both have pitfalls: serialization ignores transient fields; cloning is shallow by default.

Q60. [TRAP] What is the significance of serialVersionUID?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Used during deserialization to verify that the serialized class version matches the runtime class.
       If not declared, JVM auto-generates one. Changing class structure without updating serialVersionUID
       causes InvalidClassException. Always declare it explicitly.


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 SECTION 2: COLLECTIONS DEEP DIVE (Questions 61-110)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

--- 2.1 ArrayList & LinkedList ---

Q61. [SCENARIO] When would you choose LinkedList over ArrayList in a production application?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ LinkedList is better for frequent insertions/deletions at the beginning or middle.
       ArrayList is better for random access and iteration (cache-friendly).
       In practice, ArrayList is preferred in most cases due to better cache performance.


Q62. [TRAP] What is the initial capacity and load factor of ArrayList?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Initial capacity: 10. Growth factor: 1.5x (capacity * 1.5).
       If you know the size upfront, pass it in the constructor to avoid resizing.


Q63. [SCENARIO] ArrayList.remove(int index) vs ArrayList.remove(Object o) â€” what's the trap?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ remove(int) removes by INDEX. remove(Object) removes by VALUE.
       If you have ArrayList<Integer> and call remove(1), it removes index 1, NOT the value 1.
       To remove value 1: list.remove(Integer.valueOf(1)).


Q64. [TRAP] What is the time complexity of ArrayList.contains()?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ O(n). It does a linear scan. For frequent lookups, use a HashSet instead.

--- 2.2 HashMap Deep Dive ---

Q65. [SCENARIO] Explain the internal working of HashMap. How does it handle collisions?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Uses an array of buckets (linked lists / trees since Java 8).
       hashCode() determines the bucket. equals() resolves collisions.
       When a bucket exceeds 8 entries (TREEIFY_THRESHOLD), it converts to a Red-Black Tree â†’ O(log n).


Q66. [TRAP] What happens if you use a mutable object as a HashMap key and then modify it?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ The hashCode changes after modification. The entry becomes unreachable.
       You can never get it back via get(). Classic production bug.
       Always use immutable keys (String, Integer, or custom immutable classes).


Q67. [SCENARIO] What is the default initial capacity and load factor of HashMap?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Initial capacity: 16. Load factor: 0.75.
       When size > capacity * loadFactor (12), HashMap resizes (doubles capacity).
       Resizing is expensive (O(n) rehashing). Pre-size if you know the expected size.


Q68. [TRAP] HashMap allows one null key and multiple null values. Does TreeMap allow null keys?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ TreeMap does NOT allow null keys (throws NullPointerException) because it needs to compare keys.
       LinkedHashMap allows null keys (like HashMap).


Q69. [SCENARIO] Explain the difference between HashMap, Hashtable, and ConcurrentHashMap.
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ HashMap: Not thread-safe. Allows null key/values. Fastest.
       Hashtable: Thread-safe (synchronized). Does NOT allow null key/values. Slow (legacy).
       ConcurrentHashMap: Thread-safe with fine-grained locking (segment-level in Java 7, node-level in Java 8).
       Production: Use ConcurrentHashMap for concurrent access, NOT Hashtable.


Q70. [TRAP] What is the difference between putIfAbsent() and computeIfAbsent() in HashMap?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ putIfAbsent(key, value): Always evaluates the value, even if key exists.
       computeIfAbsent(key, mappingFunction): Only computes the value if key is absent.
       Production: Use computeIfAbsent() when value creation is expensive (e.g., new ArrayList<>()).

1ï¸âƒ£ putIfAbsent(key, value)
â¤ Inserts the value only if key is absent
â¤ BUT the value expression is evaluated BEFORE calling the method
â¤ So even if key exists â†’ your expensive object is already created âŒ

âœ… Example
import java.util.*;

public class Demo1 {
    public static void main(String[] args) {

        Map<String, List<Integer>> map = new HashMap<>();
        map.put("A", new ArrayList<>(List.of(1, 2)));

        // âŒ Value is created anyway (even though key "A" already exists)
        map.putIfAbsent("A", new ArrayList<>());

        System.out.println(map.get("A")); // [1, 2]
    }
}
ğŸ‘‰ Here "A" already exists, so map is unchanged, but new ArrayList<>() was still created.

2ï¸âƒ£ computeIfAbsent(key, mappingFunction)
â¤ If key is absent â†’ compute value using the function and put it
â¤ If key exists â†’ does NOT call the function at all âœ…

âœ… Example (Best practical use)
import java.util.*;

public class Demo2 {
    public static void main(String[] args) {

        Map<String, List<Integer>> map = new HashMap<>();

        // âœ… Only creates list when key is missing
        map.computeIfAbsent("A", k -> new ArrayList<>()).add(10);
        map.computeIfAbsent("A", k -> new ArrayList<>()).add(20);

        System.out.println(map.get("A")); // [10, 20]
    }
}

âš¡ Production Use Case
Grouping / adjacency list / multi-map pattern
âœ… Wrong way (creates list always)
map.putIfAbsent(key, new ArrayList<>());
map.get(key).add(value);


âœ… Best way: map.computeIfAbsent(key, k -> new ArrayList<>()).add(value);

âš¡ Extra Edge case
If mappingFunction returns null
ğŸ‘‰ then nothing is inserted
map.computeIfAbsent("X", k -> null); // no entry added


--- 2.3 HashSet & TreeSet ---

Q71. [TRAP] How is HashSet implemented internally?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ HashSet is backed by a HashMap internally. Elements are stored as keys with a dummy value (PRESENT).
       So all HashMap rules about hashCode() and equals() apply to HashSet.

Q72. [SCENARIO] You need a Set that maintains sorted order. What do you use?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ TreeSet. It uses a Red-Black Tree internally. O(log n) for add/remove/contains.
       You can provide a custom Comparator for custom ordering.

Q73. [TRAP] What is the difference between TreeSet and LinkedHashSet?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ TreeSet: Sorted order (natural or Comparator). O(log n).
       LinkedHashSet: Insertion order. O(1) for add/contains (backed by LinkedHashMap).

--- 2.4 Queue, Deque & PriorityQueue ---

Q74. [SCENARIO] Explain PriorityQueue. What is the default ordering?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Min-heap by default (smallest element at head).
       Use a reverse Comparator for max-heap: new PriorityQueue<>(Collections.reverseOrder()).
       Does NOT maintain full sorted order â€” only the head is guaranteed to be min/max.


Q75. [TRAP] Difference between poll() and remove() in Queue.
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ poll(): Returns null if queue is empty.
       remove(): Throws NoSuchElementException if queue is empty.
       Production: Use poll() to avoid exceptions; use remove() only when empty state is a bug.


Q76. [SCENARIO] When would you use ArrayDeque vs LinkedList as a Queue/Stack?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ ArrayDeque is PREFERRED over LinkedList for both Queue and Stack operations.
       It is more memory-efficient and cache-friendly (no node overhead).
       LinkedList as Stack/Queue is generally discouraged.


Q77. [TRAP] Can PriorityQueue contain null elements?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ NO. Throws NullPointerException. It needs to compare elements.

--- 2.5 Iterator & Streams ---

Q78. [SCENARIO] Explain the difference between Iterator and ListIterator.
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Iterator: Forward-only traversal. Supports remove().
       ListIterator: Bidirectional. Supports add(), set(), hasPrevious(), previous().
       ListIterator is specific to List implementations.


Q79. [TRAP] What is the difference between Iterable and Iterator?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Iterable: Has iterator() method. Represents something that CAN be iterated.
       Iterator: Has next(), hasNext(), remove(). Does the actual iteration.
       Every Iterable provides an Iterator, not vice versa.


Q80. [SCENARIO] You have a List<String> and want to filter, transform, and collect results.
     Compare the imperative loop vs Stream API approach. What are the performance tradeoffs?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Stream API: Cleaner, supports lazy evaluation, can be parallelized.
       For loop: Less overhead for small collections. Streams have overhead for setup.
       Production: Use streams for medium-to-large collections. Simple loops for small ones.


Q81. [TRAP] What is the difference between stream() and parallelStream()? When should you use parallelStream()?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ stream(): Sequential processing.
       parallelStream(): Splits work across multiple threads using ForkJoinPool.
       Use parallelStream() only for CPU-intensive operations on LARGE datasets.
       For I/O-bound or small datasets, it adds overhead and can cause issues.


Q82. [SCENARIO] Explain the difference between map(), flatMap(), and filter() in Streams.
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ map(): Transforms each element 1-to-1.
       flatMap(): Transforms each element to a stream, then flattens into one stream (1-to-many).
       filter(): Keeps elements matching a predicate.
       Example: flatMap is used when each element contains a collection that needs to be flattened.


Q83. [TRAP] Can you use a Stream more than once?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ NO. Streams are consumed after a terminal operation. Using it again throws IllegalStateException.
       You need to create a new stream each time.


Q84. [SCENARIO] Explain Collectors.groupingBy() with a real-world example.
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Groups elements by a classifier function.
       Example: Group employees by department.
       Map<String, List<Employee>> byDept = employees.stream()
           .collect(Collectors.groupingBy(Employee::getDepartment));


--- 2.6 Collections Utility & Edge Cases ---

Q85. [TRAP] What does Collections.singletonList() return? Can you add to it?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns an immutable list with exactly one element.
       Adding throws UnsupportedOperationException.


Q86. [SCENARIO] Explain the difference between Collections.synchronizedList() and CopyOnWriteArrayList.
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ synchronizedList(): Wraps a list with synchronized access. Must manually synchronize during iteration.
       CopyOnWriteArrayList: Creates a copy on every write. Safe for iteration without synchronization.
       Production: Use CopyOnWriteArrayList when reads >> writes (e.g., event listener lists).


Q87. [TRAP] What is the contract between hashCode() and equals()?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ If two objects are equal (equals() returns true), they MUST have the same hashCode().
       The reverse is NOT required (different objects can have the same hashCode â€” collision).
       Violating this contract breaks HashMap, HashSet, and all hash-based collections.


Q88. [SCENARIO] You need to sort a list of objects by multiple fields (e.g., by age, then by name).
     How do you implement this?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Use Comparator.comparing().thenComparing():
       list.sort(Comparator.comparing(Person::getAge).thenComparing(Person::getName));


Q89. [TRAP] What happens if you compare two objects that are not Comparable and don't provide a Comparator?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ ClassCastException at runtime. Always ensure your objects implement Comparable or provide a Comparator.


Q90. [SCENARIO] Explain the difference between Map.getOrDefault() and Map.computeIfAbsent().
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ getOrDefault(key, defaultValue): Returns default if key is absent. Does NOT insert it.
       computeIfAbsent(key, function): Computes and INSERTS the value if key is absent.
       Production: Use computeIfAbsent() when you want to populate the map lazily.


Q91. [TRAP] Can you store null in a TreeSet?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ NO (in most cases). If using natural ordering, NullPointerException is thrown.
       With a custom Comparator that handles null, it might work, but it's generally avoided.


Q92. [SCENARIO] What is the difference between EnumSet and EnumMap?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ EnumSet: A Set optimized for enum types (uses bit vectors internally). Very fast.
       EnumMap: A Map with enum keys, optimized with an array internally.
       Both are more efficient than HashSet/HashMap for enum types.


Q93. [TRAP] Explain the behavior of Iterator.remove() vs Collection.remove() during iteration.
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Iterator.remove(): Safe to use during iteration. Removes the last element returned by next().
       Collection.remove(): Causes ConcurrentModificationException if called during for-each iteration.


Q94. [SCENARIO] You need a thread-safe map where you frequently read and occasionally write.
     What data structure do you choose and why?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ ConcurrentHashMap. It uses fine-grained locking (per-node in Java 8).
       Reads don't block other reads. Only conflicting writes block each other.
       Alternative: Collections.synchronizedMap() but it's coarser-grained.


Q95. [TRAP] What is the difference between Deque.offerFirst() and Deque.addFirst()?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ offerFirst(): Returns false if the deque is full (capacity-restricted).
       addFirst(): Throws IllegalStateException if the deque is full.
       For unbounded deques (like ArrayDeque), behavior is the same.


Q96. [SCENARIO] Explain how you would implement an LRU Cache using Java collections.
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Use LinkedHashMap with accessOrder=true (third constructor parameter).
       Override removeEldestEntry() to return true when size exceeds capacity.
       This automatically removes the least recently used entry.


Q97. [TRAP] List.of() vs Arrays.asList() vs Collections.singletonList() â€” key differences?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ List.of(): Truly immutable. No nulls allowed. Java 9+.
       Arrays.asList(): Fixed-size but allows set(). Backed by array. Allows nulls.
       Collections.singletonList(): Immutable single-element list. Allows null element.


Q98. [SCENARIO] What is the time complexity of HashMap operations in the best and worst case?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Best case: O(1) for get/put (no collisions).
       Worst case: O(n) if all keys hash to same bucket (all in one linked list).
       Java 8+: Worst case becomes O(log n) when bucket converts to TreeMap (after 8 entries).


Q99. [TRAP] How does HashMap handle the case where two different keys have the same hashCode()?
     âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ This is a COLLISION. The entry is added to the same bucket.
       equals() is used to distinguish between keys within the bucket.
       This is why both hashCode() and equals() must be correctly overridden.


Q100. [SCENARIO] You need to find the frequency of each word in a large text. What collection strategy do you use?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ HashMap<String, Integer> or use Collectors.groupingBy() with Collectors.counting().
        For concurrent processing: ConcurrentHashMap with merge() or compute().

--- 2.7 Advanced Collections Scenarios ---

Q101. [TRAP] What is a WeakHashMap and when would you use it?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Keys are held with weak references. If a key is garbage collected, the entry is automatically removed.
        Used for caching scenarios where you don't want to prevent garbage collection.
        Production: Be careful â€” entries can disappear unexpectedly.

Q102. [SCENARIO] Explain IdentityHashMap and when it would be useful.
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Uses reference equality (==) instead of equals() for key comparison.
        Useful when you intentionally want two equal objects to be treated as different keys.
        Rare in practice but useful in serialization frameworks.

Q103. [TRAP] What happens when you use Collections.sort() on an unmodifiable list?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Throws UnsupportedOperationException. You cannot sort an unmodifiable list in-place.
        Create a new mutable list first, sort it, then wrap it.

Q104. [SCENARIO] How do you efficiently merge two HashMaps in Java?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ map1.putAll(map2) â€” simple but overwrites duplicates.
        For custom merge logic: map2.forEach((k, v) -> map1.merge(k, v, mergeFunction));

Q105. [TRAP] Difference between Map.put() and Map.merge() when key already exists.
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ put(): Replaces the value entirely.
        merge(): Applies a remapping function to combine old and new values.
        Example: Counting occurrences â€” map.merge(word, 1, Integer::sum);

Q106. [SCENARIO] You have a huge list and want to process it in parallel streams safely.
      What are the pitfalls?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Shared mutable state causes data races.
        Non-thread-safe collectors cause issues.
        Use thread-safe collectors (toList(), groupingBy() are safe).
        Avoid side effects in stream operations.


Q107. [TRAP] What is the difference between Optional.orElse() and Optional.orElseGet()?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ orElse(value): Always evaluates the default value, even if Optional is present.
        orElseGet(supplier): Only evaluates the supplier if Optional is empty (lazy).
        Production: Use orElseGet() when the default is expensive to compute.

1ï¸âƒ£ orElse(defaultValue)
ğŸ‘‰ Default value is ALWAYS evaluated (even if Optional has a value)

âœ… Code Demo
import java.util.Optional;

public class OptionalTrapDemo {

    public static String expensiveDefault() {
        System.out.println("ğŸ”¥ expensiveDefault() called");
        return "DEFAULT";
    }

    public static void main(String[] args) {

        Optional<String> opt = Optional.of("VALUE");

        // âŒ expensiveDefault() will still run
        String result = opt.orElse(expensiveDefault());

        System.out.println("Result = " + result);
    }
}
âœ… Output
ğŸ”¥ expensiveDefault() called
Result = VALUE
ğŸ‘‰ Even though Optional already had "VALUE", still expensiveDefault() executed â†’ wasteful


2ï¸âƒ£ orElseGet(supplier)
ğŸ‘‰ Default value is computed ONLY if Optional is empty (Lazy evaluation)

âœ… Code Demo
import java.util.Optional;

public class OptionalTrapDemo2 {

    public static String expensiveDefault() {
        System.out.println("ğŸ”¥ expensiveDefault() called");
        return "DEFAULT";
    }

    public static void main(String[] args) {

        Optional<String> opt = Optional.of("VALUE");

        // âœ… expensiveDefault() will NOT run
        String result = opt.orElseGet(() -> expensiveDefault());

        System.out.println("Result = " + result);
    }
}
âœ… Output
Result = VALUE
ğŸ‘‰ No call to expensiveDefault() â†’ correct & efficient

ğŸ‘‰ When Optional is Empty (Both will execute default)
âœ… Example
Optional<String> opt = Optional.empty();
System.out.println(opt.orElse(expensiveDefault()));
System.out.println(opt.orElseGet(() -> expensiveDefault()));

âœ… Output
ğŸ”¥ expensiveDefault() called
DEFAULT
ğŸ”¥ expensiveDefault() called
DEFAULT


Q108. [SCENARIO] How would you implement a frequency map (word count) using Java 8 streams?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Map<String, Long> freq = words.stream()
            .collect(Collectors.groupingBy(w -> w, Collectors.counting()));


Q109. [TRAP] What is the difference between Collectors.toMap() and Collectors.groupingBy()?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ toMap(): Creates a Map with one value per key. Throws on duplicate keys (unless merge function provided).
        groupingBy(): Groups into Map<Key, List<Value>>. Handles duplicates by grouping.


Q110. [SCENARIO] Explain the difference between a stack implemented with ArrayDeque vs Stack class.
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Stack class: Legacy, synchronized (slow), extends Vector.
        ArrayDeque: Modern, not synchronized (fast), recommended for stack operations.
        Production: Always use ArrayDeque as a stack. Never use java.util.Stack.


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 SECTION 3: SPRING BOOT (Questions 111-180)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

--- 3.1 Core Spring Concepts ---

Q111. [SCENARIO] Explain the difference between @Component, @Service, @Repository, and @Controller.
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ All are stereotypes of @Component (component scanning picks them all up).
        @Controller: Handles HTTP requests. Used with @RequestMapping.
        @Service: Business logic layer. No special Spring behavior beyond @Component.
        @Repository: Data access layer. Enables exception translation (e.g., translates JPA exceptions to Spring DataAccessException).
        @Component: Generic. Use when no specific stereotype fits.


Q112. [TRAP] What is the difference between constructor injection, setter injection, and field injection?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Constructor injection: PREFERRED. Makes dependencies explicit, supports final fields, easier to test.
        Setter injection: Allows optional dependencies but violates immutability.
        Field injection: Uses @Autowired on fields. Convenient but HARD TO TEST (cannot mock easily).
        Production: Always prefer constructor injection.


Q113. [SCENARIO] Explain bean scoping in Spring. What are the available scopes?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ singleton (default): One instance per ApplicationContext. Shared across all threads.
        prototype: New instance every time it is requested.
        request: One instance per HTTP request (web apps only).
        session: One instance per HTTP session.
        application: One instance per ServletContext.
        websocket: One instance per WebSocket session.


Q114. [TRAP] What happens if a singleton-scoped bean depends on a prototype-scoped bean?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ The singleton holds a SINGLE reference to the prototype bean created at initialization time.
        Subsequent requests get the SAME prototype instance â†’ effectively singleton behavior.
        Fix: Use @Scope(value = "prototype", proxyMode = ScopedProxyMode.TARGET_CLASS) or
             inject ObjectProvider<PrototypeBean> and call getObject() each time.


Q115. [SCENARIO] Explain the Spring ApplicationContext lifecycle. What are the phases?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ 1. Bean definitions are loaded (XML/annotations/Java config).
        2. BeanFactoryPostProcessors run (e.g., PropertyPlaceholderConfigurer).
        3. Beans are instantiated.
        4. Dependencies are injected.
        5. BeanPostProcessors run (e.g., proxying for AOP).
        6. @PostConstruct / InitializingBean.afterPropertiesSet() are called.
        7. Application is ready.


Q116. [TRAP] Difference between BeanFactory and ApplicationContext.
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ BeanFactory: Lazy initialization. Basic DI container. Lighter.
        ApplicationContext: Eager initialization. Extends BeanFactory.
        Adds: Event publishing, i18n, AOP proxy support, resource loading.
        Production: Always use ApplicationContext (via SpringApplication).


Q117. [SCENARIO] What is @Autowired and how does Spring resolve ambiguity when multiple beans of the same type exist?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Spring throws NoUniqueBeanDefinitionException.
        Fix: Use @Qualifier("beanName") to specify which bean.
        Or use @Primary on the preferred bean.


Q118. [TRAP] Can Spring autowire a bean into a static field or method?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ NO. @Autowired does NOT work on static fields/methods.
        Workaround: Use @PostConstruct to set a static field, or use ApplicationContext directly.

--- 3.2 Spring Boot Specific ---

Q119. [SCENARIO] Explain what @SpringBootApplication does. What annotations does it combine?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ It is a convenience annotation combining:
        @Configuration: Marks class as a source of bean definitions.
        @EnableAutoConfiguration: Enables Spring Boot's auto-configuration.
        @ComponentScan: Scans for components in the package and sub-packages.


Q120. [TRAP] What is auto-configuration in Spring Boot? How does it work internally?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Spring Boot reads META-INF/spring.factories (or spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports in newer versions).
        It contains a list of @Configuration classes. Spring Boot conditionally loads them based on classpath, beans, and properties.
        Example: If jackson is on classpath, Jackson auto-configuration is loaded.


Q121. [SCENARIO] How do you disable a specific auto-configuration in Spring Boot?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ @SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})
        Or in application.properties: spring.autoconfigure.exclude=fully.qualified.ClassName


Q122. [TRAP] What is the difference between @Configuration and @Component?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ @Configuration: Specifically for defining beans via @Bean methods.
        It uses CGLIB proxying to ensure @Bean methods return singleton instances.
        @Component: Generic component. @Bean methods inside @Component are NOT proxied by default.


Q123. [SCENARIO] Explain profiles in Spring Boot. How do you activate them?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Profiles allow you to have different configurations for different environments (dev, prod, test).
        Activate via: spring.profiles.active=prod in properties, or -Dspring.profiles.active=prod, or @ActiveProfiles in tests.
        Use @Profile("prod") on beans or configuration classes.
        Profile-specific property files: application-prod.properties / application-prod.yml.


Q124. [TRAP] What is the order of property source resolution in Spring Boot?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ (Simplified, from highest to lowest priority):
        1. Command-line arguments
        2. OS environment variables
        3. Profile-specific properties (application-{profile}.properties)
        4. application.properties / application.yml
        5. Default values in @Value annotations
        Profile-specific properties OVERRIDE default properties.


Q125. [SCENARIO] Explain @Value vs @ConfigurationProperties. When to use which?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ @Value: Injects a single property. Simple but inflexible.
        @ConfigurationProperties: Binds a group of properties to a POJO. Supports validation (@Valid).
        Production: Use @ConfigurationProperties for complex configurations. @Value for simple ones.

--- 3.3 REST & Web Layer ---

Q126. [SCENARIO] Difference between @RequestMapping, @GetMapping, @PostMapping, etc.
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ @RequestMapping: Generic. Can specify method attribute.
        @GetMapping, @PostMapping, etc.: Shorthand for specific HTTP methods.
        Production: Use specific annotations for clarity.


Q127. [TRAP] What is the difference between @RequestParam and @PathVariable?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ @PathVariable: Extracts from URL path. /users/{id} â†’ @PathVariable int id
        @RequestParam: Extracts from query string. /users?id=1 â†’ @RequestParam int id


Q128. [SCENARIO] How does Spring handle request body deserialization? What annotation is used?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ @RequestBody deserializes the JSON/XML body using HttpMessageConverters (typically Jackson for JSON).
        If deserialization fails, it throws HttpMessageNotReadableException (400 Bad Request).


Q129. [TRAP] What is the difference between @ResponseBody and @RestController?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ @ResponseBody: Marks a method to serialize return value directly to HTTP response body.
        @RestController: Combines @Controller + @ResponseBody at the CLASS level.
        All methods in @RestController automatically have @ResponseBody.


Q130. [SCENARIO] Explain how you implement global exception handling in Spring Boot.
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Use @ControllerAdvice (or @RestControllerAdvice) with @ExceptionHandler methods.
        This catches exceptions from all controllers centrally.
        You can also implement ResponseEntityExceptionHandler for standard Spring exceptions.


Q131. [TRAP] What HTTP status code does Spring return when @RequestBody validation fails with @Valid?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ 400 Bad Request. If validation annotations (@NotNull, @Size, etc.) fail,
        MethodArgumentNotValidException is thrown â†’ 400.


Q132. [SCENARIO] How do you implement pagination in a Spring Boot REST API?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Use Spring Data's Pageable parameter in controller methods.
        Spring automatically binds page, size, and sort query parameters.
        Return Page<Entity> from the service/repository.


Q133. [TRAP] What is the difference between @Transactional on a service method and calling another method
      within the same class that is also @Transactional?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ SELF-INVOCATION. When a method calls another @Transactional method in the SAME class,
        the proxy is bypassed â†’ the inner method's @Transactional is IGNORED.
        Spring AOP uses proxies. Internal method calls bypass the proxy.
        Fix: Separate into different classes or use AspectJ weaving.

ğŸ¯ What Spring actually does
â¤ Spring doesnâ€™t put transaction logic inside your method directly.
â¤ Instead, Spring creates a proxy (wrapper) around your class.
â¤ Think like this:
  ğŸ§  Your service = Real object
  ğŸ›¡ï¸ Spring proxy = Security guard / gatekeeper
Whenever someone calls your service from outside, the call goes like:

âœ… Controller â†’ Proxy â†’ Your method
Proxy starts transaction â†’ runs method â†’ commits/rollbacks

ğŸš¨ The Problem: Self-invocation (calling method inside same class)

When you do:
public void methodA() {
    methodB(); // calling inside same class
}
This is like:
âŒ methodA() directly calls methodB() inside the real object
It does NOT go through the proxy.
So Spring never gets a chance to apply @Transactional on methodB().


âœ… Real-life analogy
Imagine a company rule:
ğŸ“Œ â€œWhenever you enter the office, security guard checks your IDâ€
If you come from outside â†’ security guard checks you âœ…
But if you are already inside and move to another room â†’ no security guard âŒ

Similarly:
External call â†’ proxy applies transaction âœ…
Internal call (same class) â†’ proxy bypassed âŒ

âœ… What happens in Spring?
Case 1: External call works âœ…
service.saveOrder(); // called from Controller
Spring proxy starts transaction âœ”ï¸

Case 2: Internal call fails âŒ
saveOrder() {
   savePayment(); // @Transactional here is ignored
}
Even if savePayment() has @Transactional, it wonâ€™t work because:
â¡ï¸ It was called inside the same class, not through proxy.


--- 3.4 Spring AOP ---

Q134. [SCENARIO] Explain AOP concepts: Aspect, Advice, Pointcut, Join Point, Weaving.
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Aspect: The modular unit of cross-cutting concern (e.g., logging, security).
        Advice: The action taken at a join point (Before, After, Around, AfterReturning, AfterThrowing).
        Pointcut: Expression that matches join points.
        Join Point: A point in program execution (method call, exception, etc.).
        Weaving: Linking aspects with target objects to create advised objects.


Q135. [TRAP] What is the difference between Spring AOP and AspectJ?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Spring AOP: Proxy-based. Works at method level only. Runtime weaving.
        AspectJ: Full AOP framework. Works at field, constructor, etc. Compile-time/load-time weaving.
        Spring AOP is sufficient for most use cases. AspectJ is needed for non-method join points.


Q136. [SCENARIO] You add @Around advice to log method execution time. How do you implement it?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ @Around("execution(* com.example.service.*.*(..))")
        public Object logTime(ProceedingJoinPoint pjp) throws Throwable {
            long start = System.currentTimeMillis();
            Object result = pjp.proceed();
            long end = System.currentTimeMillis();
            // log (end - start)
            return result;
        }

--- 3.5 Spring Data & Caching ---

Q137. [SCENARIO] Explain the difference between CrudRepository, JpaRepository, and PagingAndSortingRepository.
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ CrudRepository: Basic CRUD operations.
        PagingAndSortingRepository: Extends CrudRepository + pagination and sorting.
        JpaRepository: Extends PagingAndSortingRepository + JPA-specific methods (flush, batch save, etc.).
        Production: Usually use JpaRepository as it's the most feature-rich.

Q138. [TRAP] What is the difference between findById() and getOne() (or getById()) in JpaRepository?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ findById(): Executes a SELECT query immediately. Returns Optional<Entity>.
        getOne()/getById(): Returns a PROXY (lazy reference). Throws EntityNotFoundException when accessed if not found.
        Production: Use findById() for most cases. getById() is for cases where you only need a reference (e.g., setting a foreign key).

Q139. [SCENARIO] Explain Spring Cache annotations: @Cacheable, @CacheEvict, @CachePut.
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ @Cacheable: Check cache first; if miss, execute method and store result.
        @CacheEvict: Remove entry from cache (on method execution).
        @CachePut: Always execute method and update cache with the result.
        Production: Use @Cacheable for reads, @CacheEvict on updates/deletes.


Q140. [TRAP] What is the default cache key in Spring @Cacheable?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ By default, Spring uses ALL method parameters as the cache key.
        If you have @Cacheable on a method with parameters (id, name), both are used as key.
        Customize with: key = "#id" or keyGenerator.

--- 3.6 Spring Boot Testing ---

Q141. [SCENARIO] Explain the difference between @SpringBootTest and @WebMvcTest.
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ @SpringBootTest: Loads the FULL application context. Used for integration tests.
        @WebMvcTest: Loads only the web layer (controllers, filters, etc.). Faster.
        Use @MockBean to mock services in @WebMvcTest.


Q142. [TRAP] What is the difference between @Mock and @MockBean in Spring Boot tests?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ @Mock: Mockito annotation. Creates a mock but does NOT add it to Spring context.
        @MockBean: Spring Boot annotation. Creates a mock AND registers it in the ApplicationContext,
        replacing any existing bean of that type.


Q143. [SCENARIO] How do you test a Spring Boot application with a different profile?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Use @ActiveProfiles("test") on the test class.
        Or create application-test.properties with test-specific configurations.


Q144. [TRAP] What annotation do you use to test only the repository layer with an in-memory database?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ @DataJpaTest. It configures an in-memory database, scans for @Entity classes,
        and configures Spring Data JPA repositories. It does NOT load the full context.

--- 3.7 Spring Boot Production Scenarios ---

Q145. [SCENARIO] How do you handle database connection pooling in Spring Boot?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Spring Boot auto-configures HikariCP (default since 2.0) as the connection pool.
        Configure via spring.datasource.hikari.* properties (max-pool-size, idle-timeout, etc.).
        Production: Monitor pool usage. Set appropriate pool sizes based on concurrent load.


Q146. [TRAP] What happens if you have circular dependency between two Spring beans?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Spring throws BeanCurrentlyInCreationException (with constructor injection).
        With field/setter injection, Spring can resolve it using proxies (but it's a code smell).
        Production: Refactor to break the circular dependency. Use @Lazy as a temporary fix.


Q147. [SCENARIO] How do you implement retry logic in Spring Boot?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Use Spring Retry (@EnableRetry + @Retryable annotation).
        Or use resilience4j retry decorator.
        Configure max attempts, delay, and which exceptions to retry on.


Q148. [TRAP] What is the difference between @Lazy and prototype scope?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ @Lazy: Bean is instantiated only when first requested (lazy initialization of singleton).
        Prototype: New instance every time it's requested.
        @Lazy on a singleton â†’ still one instance, just created lazily.


Q149. [SCENARIO] Explain how Spring Boot's embedded server works. What is the default server?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Spring Boot embeds Tomcat by default (spring-boot-starter-web).
        Alternatives: Jetty (replace with spring-boot-starter-jetty), Netty (WebFlux).
        No need to deploy a WAR file â€” run as a standalone JAR.


Q150. [SCENARIO] How do you externalize configuration in Spring Boot for different environments?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Use application-{profile}.properties/yml files.
        Use environment variables (override properties).
        Use Spring Cloud Config for centralized configuration management.
        Production: Never hardcode environment-specific values.

--- 3.8 Spring Security Basics ---

Q151. [SCENARIO] Explain the basic flow of Spring Security filter chain.
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Every HTTP request passes through a chain of security filters.
        Key filters: SecurityContextPersistenceFilter, UsernamePasswordAuthenticationFilter,
        FilterSecurityInterceptor.
        Authentication â†’ Authorization â†’ Access to resource.


Q152. [TRAP] What is the difference between authentication and authorization?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Authentication: WHO are you? (Verify identity â€” login process).
        Authorization: WHAT can you do? (Check permissions â€” role-based access).
        Spring Security handles both.

Q153. [SCENARIO] How do you secure specific endpoints in Spring Boot?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Use HttpSecurity configuration:
        http.authorizeRequests()
            .antMatchers("/api/public/**").permitAll()
            .antMatchers("/api/admin/**").hasRole("ADMIN")
            .anyRequest().authenticated();


Q154. [TRAP] What is CSRF and when should you disable it in Spring Security?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ CSRF (Cross-Site Request Forgery): Spring Security enables it by default for stateful apps.
        Disable for STATELESS REST APIs (using token-based auth like JWT):
        http.csrf().disable();
        Keeping it enabled for stateless APIs causes 403 errors on POST/PUT/DELETE.

--- 3.9 Spring Miscellaneous ---

Q155. [SCENARIO] Explain the difference between @Bean and @Component.
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ @Component: Class-level annotation for component scanning.
        @Bean: Method-level annotation inside @Configuration. More control over instantiation.
        Use @Bean when you need to configure third-party classes or customize creation logic.


Q156. [TRAP] What is @Import used for in Spring?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Imports additional @Configuration classes or registers beans programmatically.
        Used when beans are outside the component scan path.
        Example: @Import(SecurityConfig.class)


Q157. [SCENARIO] How does Spring Boot handle multiple datasources?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Define multiple DataSource beans with @Bean.
        Use @Primary for the default datasource.
        Use @Qualifier to inject specific datasources.
        Configure separate EntityManagerFactory for each datasource.


Q158. [TRAP] What is the difference between @Transactional(readOnly = true) and a regular @Transactional?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ readOnly = true: Hints to the persistence provider for optimization.
        Can improve performance (no dirty checking in Hibernate).
        Should be used on read-only service methods.


Q159. [SCENARIO] Explain actuator in Spring Boot. What are commonly used endpoints?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Spring Boot Actuator provides production-ready endpoints for monitoring.
        Common: /health, /info, /env, /metrics, /loggers, /mappings.
        Production: Secure actuator endpoints! They can expose sensitive information.


Q160. [SCENARIO] How do you implement asynchronous processing in Spring Boot?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Use @Async on service methods + @EnableAsync on configuration.
        The method returns CompletableFuture<T> or void.
        Spring creates a thread pool to handle async execution.
        Production: Configure thread pool sizes appropriately.

--- 3.10 More Spring Traps ---

Q161. [TRAP] What happens if you annotate a private method with @Transactional?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ It is IGNORED. Spring AOP proxies cannot intercept private methods.
        The transaction will NOT be applied. Make the method public.


Q162. [SCENARIO] Explain how @EventListener works in Spring.
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Allows methods to listen for Spring events (ApplicationEvent subclasses).
        @EventListener on a method automatically registers it as an event handler.
        Production: Use for decoupling components (e.g., send email on user registration).


Q163. [TRAP] What is the difference between @Controller and @RestController in terms of return type handling?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ @Controller: Return value is treated as a VIEW NAME (for template rendering) by default.
        @RestController: Return value is serialized to response body (JSON/XML).
        If you use @Controller and want to return data, you must add @ResponseBody.


Q164. [SCENARIO] How does Spring Boot handle property type conversion for @Value?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Spring automatically converts String properties to the target type (int, boolean, etc.).
        For complex types, use SpEL expressions or @ConfigurationProperties with nested POJOs.


Q165. [TRAP] What is @DirtiesContext and when should you use it?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Forces the test framework to close and recreate the ApplicationContext after the test.
        Use when a test modifies the context (e.g., modifies beans, changes properties).
        WARNING: It is SLOW. Use sparingly.

Q166. [SCENARIO] Explain how Spring Boot's auto-configuration conditional annotations work.
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ @ConditionalOnClass: Load config only if a class is on the classpath.
        @ConditionalOnBean: Load config only if a specific bean exists.
        @ConditionalOnProperty: Load config only if a property is set.
        @ConditionalOnMissingBean: Load config only if NO bean of that type exists.

Q167. [TRAP] Can you have two @SpringBootApplication classes in the same project?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Technically yes, but it causes issues. Component scanning from both classes may conflict.
        Production: Have ONE @SpringBootApplication class as the entry point.

Q168. [SCENARIO] How do you configure CORS in Spring Boot?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ @CrossOrigin on specific controllers/methods.
        Or globally via WebMvcConfigurer.addCorsMappings().
        Production: Be specific about allowed origins. Do not use allowCredentials with *.

Q169. [TRAP] What is the difference between @PathVariable and @RequestParam when the parameter is missing?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ @PathVariable: If missing, the URL won't match â†’ 404 Not Found.
        @RequestParam: If missing and required=true (default), â†’ 400 Bad Request.
        Use required=false or defaultValue to make it optional.

Q170. [SCENARIO] How would you implement rate limiting in a Spring Boot application?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Use a filter or interceptor to count requests per IP/user.
        Or use Bucket4j library with Spring Cache.
        Or use an API gateway (Kong, AWS API Gateway).

--- 3.11 Spring Boot Interview Traps (Additional) ---

Q171. [TRAP] What is the difference between spring.jpa.hibernate.ddl-auto and spring.jpa.defer-datasource-initialization?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ ddl-auto: Controls schema generation (create, update, validate, none).
        defer-datasource-initialization: When true, data.sql runs AFTER Hibernate schema generation.
        Common trap: data.sql runs BEFORE ddl-auto by default â†’ table not found errors.

Q172. [SCENARIO] What happens when you use @Transactional on a controller method?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ It works technically, but it is BAD PRACTICE.
        Transactions should be at the SERVICE layer, not controller.
        Reason: Controllers should be thin. If an exception occurs after the service call
        but before the response is sent, the transaction may not roll back as expected.

Q173. [TRAP] What is lazy initialization in Spring Boot 2.3+ and how to enable it?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ spring.main.lazy-initialization=true
        All beans are created lazily (only when first needed) instead of eagerly at startup.
        Reduces startup time but may cause delays on first request.
        Production: Can help with startup time but may mask missing bean issues.

Q174. [SCENARIO] Explain how Spring Boot handles multiple implementations of the same interface.
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Use @Qualifier to specify which implementation to inject.
        Or use @Primary on the default implementation.
        Or inject a List<InterfaceName> to get ALL implementations.

Q175. [TRAP] What is the difference between @PostConstruct and InitializingBean?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ @PostConstruct: Standard Java annotation. Runs after dependency injection.
        InitializingBean: Spring interface. afterPropertiesSet() runs after properties are set.
        Both serve the same purpose. @PostConstruct is preferred (less coupling to Spring).

Q176. [SCENARIO] How do you handle file upload in Spring Boot?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Use @RequestParam("file") MultipartFile file in the controller.
        Configure max file size: spring.servlet.multipart.max-file-size=10MB
        Production: Stream large files instead of loading into memory.

Q177. [TRAP] Can Spring Boot's @Transactional roll back on checked exceptions?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ By default, @Transactional rolls back ONLY on unchecked exceptions (RuntimeException).
        For checked exceptions, use: @Transactional(rollbackFor = Exception.class)
        This is a VERY common production bug.

Q178. [SCENARIO] How do you implement a health check for an external service in Spring Boot Actuator?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Implement HealthIndicator interface.
        Override health() method to check the external service status.
        Register it as a bean. It appears automatically in /actuator/health.

Q179. [TRAP] What is @ConditionalOnProperty and how does it work?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Conditionally loads a bean based on a property value.
        @ConditionalOnProperty(name = "feature.enabled", havingValue = "true")
        If the property is not set or has a different value, the bean is NOT created.

Q180. [SCENARIO] Explain the difference between @Scope("prototype") and @Scope(value = "prototype", proxyMode = ScopedProxyMode.TARGET_CLASS).
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Without proxyMode: Each injection point gets a new instance.
        With proxyMode: A proxy is injected. Each METHOD CALL on the proxy delegates to a NEW instance.
        The proxy version is needed when injecting prototype into a singleton.


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 SECTION 4: HIBERNATE & JPA (Questions 181-220)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

--- 4.1 Core Hibernate/JPA Concepts ---

Q181. [SCENARIO] Explain the difference between Hibernate Session and JPA EntityManager.
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Session: Hibernate-specific. Has more methods and flexibility.
        EntityManager: JPA standard interface. Hibernate implements it.
        Production: Use EntityManager (JPA standard) for portability. Spring Data abstracts both.

Q182. [TRAP] What are the states of an entity in Hibernate? Explain transitions.
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Transient: New object, not associated with a session, no database representation.
        Managed/Persistent: Associated with a session, changes are tracked (dirty checking).
        Detached: Was managed but session is closed. Changes are NOT tracked.
        Removed: Marked for deletion.
        Transition: new â†’ persist() â†’ Managed â†’ close() â†’ Detached â†’ merge() â†’ Managed

Q183. [SCENARIO] Explain the difference between persist() and merge().
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ persist(): Makes a transient entity managed. The entity must be NEW (no ID or ID not in DB).
          Throws exception if entity already exists.
        merge(): Copies the state of a detached entity into a managed entity.
          Works for both new and existing entities. Returns the MANAGED copy.
        Production: Use merge() when you're unsure if the entity is new or detached.

Q184. [TRAP] What is the N+1 query problem? Give a real example.
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ When loading a parent entity triggers 1 query, then loading each child triggers N additional queries.
        Example: Load all Orders (1 query), then for each Order, load its Items (N queries).
        Fix: Use @JoinFetch, batch fetching, or Spring Data's @EntityGraph.

Q185. [SCENARIO] Explain the difference between @OneToMany and @ManyToOne. Which side owns the relationship?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ @ManyToOne side OWNS the relationship (has the foreign key column in its table).
        @OneToMany side is the inverse side. Changes on the inverse side are NOT persisted.
        Production: Always update the owning side to persist changes.

Q186. [TRAP] What is the difference between FetchType.LAZY and FetchType.EAGER?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ LAZY: Collections/associations are loaded only when accessed. Default for @OneToMany, @ManyToMany.
        EAGER: Loaded immediately with the parent. Default for @ManyToOne, @OneToOne.
        Production trap: Accessing a LAZY collection outside the session/transaction â†’
        LazyInitializationException. Use Open Session in View or fetch explicitly.

Q187. [SCENARIO] Explain the difference between @JoinColumn and @JoinTable.
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ @JoinColumn: Used for @ManyToOne and @OneToOne. Specifies the foreign key column in the current table.
        @JoinTable: Used for @ManyToMany. Specifies the join/pivot table.

Q188. [TRAP] What is CascadeType and what are the available types?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Cascade propagates operations from parent to child.
        Types: ALL, PERSIST, MERGE, REMOVE, REFRESH, DETACH.
        Common trap: Using CascadeType.ALL with REMOVE on @ManyToOne can accidentally delete the parent.

--- 4.2 Hibernate Advanced ---

Q189. [SCENARIO] Explain the difference between the first-level cache and second-level cache in Hibernate.
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ First-level cache (Session cache): Enabled by default. Scoped to a single session/transaction.
        Ensures that within a session, the same entity (by ID) is loaded only once.
        Second-level cache (SessionFactory cache): Shared across sessions. Must be explicitly configured.
        Examples: EhCache, Redis, Caffeine.

Q190. [TRAP] What is the Query Cache in Hibernate? Is it always beneficial?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Caches query results (not entities). Must be enabled explicitly.
        Requires second-level cache to be enabled.
        Trap: Query cache is invalidated whenever ANY entity in the queried table is modified.
        In high-write environments, query cache can cause more harm than benefit.

Q191. [SCENARIO] Explain the difference between JPQL and native queries. When to use which?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ JPQL: Object-oriented query language. Works on entities, not tables. Portable across databases.
        Native Query: SQL query on actual tables. Database-specific.
        Production: Use JPQL for portability. Use native queries for complex/optimized queries.

Q192. [TRAP] What is the difference between @Query and @NativeQuery in Spring Data JPA?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ @Query(jpql): Uses JPQL by default.
        @Query(nativeQuery = true): Uses native SQL.
        Both are on Spring Data repository methods.

Q193. [SCENARIO] How do you handle optimistic locking in Hibernate?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Add @Version field (Long or Integer) to your entity.
          Hibernate automatically increments it on each update.
        If two transactions try to update the same row, the second one gets OptimisticLockException.
        Production: Catch the exception and retry or notify the user.

Q194. [TRAP] Explain the difference between @Id @GeneratedValue strategies.
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ AUTO: Hibernate chooses the strategy based on the database.
        IDENTITY: Database auto-increment (INSERT must happen immediately â€” no batching).
        SEQUENCE: Database sequence (allows batching, more efficient).
        TABLE: Uses a table to simulate a sequence (portable but slow).
        Production: SEQUENCE is preferred for performance and batching.

Q195. [SCENARIO] What is the difference between @Transient (JPA) and transient (Java keyword)?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ @Transient (javax.persistence): Field is NOT mapped to any database column.
        transient (Java keyword): Field is not serialized during Java serialization.
        They serve DIFFERENT purposes. In Hibernate context, use @Transient for unmapped fields.

Q196. [TRAP] What happens when you modify a managed entity outside a transaction?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Changes are NOT persisted. Dirty checking happens only within an active transaction.
        Production: Ensure all entity modifications happen within a @Transactional method.

Q197. [SCENARIO] Explain the difference between @OneToOne with optional=true and optional=false.
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ optional=true (default): The association can be null. Hibernate may issue a separate SELECT to check.
        optional=false: Hibernate knows the association is always present. Can use a JOIN instead of separate SELECT.
        Production: Set optional=false when the relationship is mandatory (performance improvement).

Q198. [TRAP] What is the difference between save() and saveAndFlush() in Spring Data JPA?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ save(): Persists the entity. The SQL may be deferred until flush time (end of transaction).
        saveAndFlush(): Persists AND immediately flushes to database (executes SQL now).
        Production: Use save() normally. Use saveAndFlush() only when you need the generated ID immediately
        or when subsequent queries depend on the persisted data within the same transaction.

--- 4.3 Hibernate Production Scenarios ---

Q199. [SCENARIO] You are getting LazyInitializationException in your production app. What are the causes and fixes?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Cause: Accessing a lazy-loaded collection after the Hibernate session is closed.
        Fixes:
        1. Use @Fetch(FetchMode.JOIN) or @JoinFetch to eagerly fetch in the query.
        2. Use @EntityGraph in Spring Data repository method.
        3. Enable Open Session in View (spring.jpa.open-in-view=true â€” enabled by default in Spring Boot).
        4. Use DTO projection to avoid lazy loading entirely.
        Production: Open Session in View is controversial. Better to fetch explicitly.

Q200. [SCENARIO] How do you implement soft delete in Hibernate?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Add an @Column boolean isDeleted or a deletedAt timestamp.
        Use @Where("is_deleted = false") on the entity to filter automatically.
        Override delete method in repository to set isDeleted = true instead of actual deletion.

Q201. [TRAP] What is the difference between flush() and commit() in Hibernate?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ flush(): Synchronizes the session state with the database (executes pending SQL).
          Does NOT commit the transaction. Changes can still be rolled back.
        commit(): Commits the transaction. Implicitly flushes before committing.
        Production: Explicit flush is rarely needed. Let the transaction manage it.

Q202. [SCENARIO] How do you handle inheritance in Hibernate? What are the strategies?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Single Table Inheritance (STI): All subclasses in one table. Simple but wastes space.
        Table Per Class (TPC): Each class (including parent) has its own table. Duplicated columns.
        Joined Table Inheritance (JTI): Parent and child have separate tables, joined by key.
        Production: JTI is most common. STI for simple hierarchies.

Q203. [TRAP] What is the difference between @Enumerated(EnumType.ORDINAL) and @Enumerated(EnumType.STRING)?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ ORDINAL: Stores the enum's numeric position. FAST but FRAGILE.
          If you reorder enum values, existing data becomes incorrect.
        STRING: Stores the enum name as a string. Safer but uses more space.
        Production: ALWAYS use EnumType.STRING unless you have a very specific reason not to.

Q204. [SCENARIO] Explain the concept of dirty checking in Hibernate.
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Hibernate keeps a copy of each managed entity's state at load time.
          At flush time, it compares current state with the original â†’ detects changes (dirty).
        Only changed fields are included in the UPDATE statement.
        Production: Avoid unnecessary state changes on managed entities (e.g., setting the same value).

Q205. [TRAP] Can you use @Transactional(readOnly = true) with Hibernate to improve performance?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ YES. It tells Hibernate to skip dirty checking (no need to track changes).
        This can significantly improve performance for read-heavy operations.
        Production: Always annotate read-only service methods with readOnly = true.

--- 4.4 JPA Relationship Traps ---

Q206. [TRAP] You add a child entity to the parent's collection but don't set the parent reference on the child.
      Will the child be persisted?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Depends on cascade settings. If CascadeType.PERSIST is set, the child is persisted.
        BUT the foreign key (parent_id) on the child may be NULL if you don't set the parent reference.
        Production: Always maintain BOTH sides of the relationship.

Q207. [SCENARIO] How do you avoid the N+1 problem with @ManyToMany relationships?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Use @JoinFetch in JPQL: SELECT DISTINCT o FROM Order o JOIN FETCH o.items
        Or use @EntityGraph: @EntityGraph(attributePaths = {"items"})
        Production: Avoid using @ManyToMany with large collections. Consider a join entity instead.

Q208. [TRAP] What is the difference between @ManyToOne(fetch = LAZY) and @ManyToOne(fetch = EAGER)?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ @ManyToOne defaults to EAGER. If you set it to LAZY, Hibernate creates a PROXY.
        The proxy throws LazyInitializationException if accessed outside the session.
        Production: Be careful when changing default fetch types. Test thoroughly.

--- 4.5 Spring Data JPA Specific ---

Q209. [SCENARIO] Explain the difference between derived query methods and @Query in Spring Data JPA.
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Derived: Method name encodes the query. findByNameAndAge(String name, int age).
        @Query: Explicit JPQL/native query. More readable for complex queries.
        Production: Use derived for simple queries. @Query for complex ones.

Q210. [TRAP] What is the difference between List<Entity> and Page<Entity> return types in Spring Data?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ List<Entity>: Returns all matching results. No pagination info.
        Page<Entity>: Returns a page of results with metadata (totalPages, totalElements, etc.).
        Use Page for paginated APIs.

Q211. [SCENARIO] How do you implement custom repository methods in Spring Data JPA?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Create an interface with your custom methods.
        Implement the interface in a class ending with "Impl" (e.g., MyRepoCustomImpl).
        Spring Data automatically picks up the implementation.

Q212. [TRAP] What is @Modifying annotation used for in Spring Data JPA?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Required for UPDATE and DELETE @Query methods.
        Without it, Spring Data treats all @Query as SELECT queries.
        Must also set clearAutomatically = true to clear the persistence context after the update.

Q213. [SCENARIO] Explain the difference between Spring Data's save() returning the entity vs void.
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ save() returns the managed entity (important for IDENTITY strategy where ID is generated by DB).
        Always use the RETURNED entity, not the original, especially after save.
        Production bug: Using the original entity after save() may have stale ID/version.

Q214. [TRAP] Can you use @Transactional(readOnly = true) on a Spring Data repository interface?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ YES. You can annotate at the interface or method level.
        SimpleJpaRepository already annotates class-level with @Transactional(readOnly = true)
        and write methods with @Transactional.


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 SECTION 5: SQL (Questions 215-255)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

--- 5.1 Core SQL Concepts ---

Q215. [SCENARIO] Explain the difference between WHERE and HAVING clauses.
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ WHERE: Filters rows BEFORE grouping. Works on individual rows.
        HAVING: Filters groups AFTER GROUP BY. Works on aggregated results.
        Example: WHERE salary > 50000 vs HAVING COUNT(*) > 5

Q216. [TRAP] What is the order of execution of SQL clauses?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ FROM â†’ JOIN â†’ WHERE â†’ GROUP BY â†’ HAVING â†’ SELECT â†’ DISTINCT â†’ ORDER BY â†’ LIMIT/OFFSET
        This is why you cannot use column aliases in WHERE or HAVING (they are not yet defined).

Q217. [SCENARIO] Explain the difference between INNER JOIN, LEFT JOIN, RIGHT JOIN, and CROSS JOIN.
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ INNER JOIN: Returns rows where there is a match in BOTH tables.
        LEFT JOIN: Returns ALL rows from left table + matching rows from right (NULL if no match).
        RIGHT JOIN: Returns ALL rows from right table + matching rows from left.
        CROSS JOIN: Cartesian product. Every row from left joined with every row from right.

Q218. [TRAP] What is the difference between UNION and UNION ALL?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ UNION: Removes duplicates (applies DISTINCT). Slower.
        UNION ALL: Keeps all rows including duplicates. Faster.
        Production: Use UNION ALL when you know there are no duplicates or duplicates are acceptable.

Q219. [SCENARIO] Explain the difference between a correlated subquery and a non-correlated subquery.
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Non-correlated: Independent of the outer query. Executed once.
          SELECT * FROM employees WHERE salary > (SELECT AVG(salary) FROM employees)
        Correlated: Depends on the outer query. Executed for each row of the outer query.
          SELECT * FROM employees e1 WHERE salary > (SELECT AVG(salary) FROM employees e2 WHERE e2.dept = e1.dept)
        Production: Correlated subqueries can be slow. Consider replacing with JOINs or CTEs.

--- 5.2 Indexing & Performance ---

Q220. [SCENARIO] When should you create an index? When should you NOT?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ CREATE index on: Columns frequently used in WHERE, JOIN, ORDER BY.
        Do NOT create index on: Columns with low cardinality (e.g., boolean), columns in small tables,
        columns that are frequently updated (index maintenance overhead).

Q221. [TRAP] What is the difference between a unique index and a primary key index?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Primary key: Unique + NOT NULL. Only one per table. Clustered index (usually).
        Unique index: Allows NULL (one NULL in most databases). Can have multiple per table.

Q222. [SCENARIO] Explain the difference between a clustered index and a non-clustered index.
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Clustered: Determines the physical order of rows in the table. Only ONE per table.
        Non-clustered: Separate structure that points to the actual rows. Multiple allowed.
        Production: Clustered index on the column you most frequently query/sort by (often PK).

Q223. [TRAP] What is a covering index?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ An index that contains ALL columns needed to satisfy a query without accessing the actual table.
        The query can be answered entirely from the index â†’ much faster.
        Example: Index on (department, salary) covers: SELECT salary FROM emp WHERE department = 'IT'

Q224. [SCENARIO] How do you find slow queries in a production database?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Use EXPLAIN / EXPLAIN ANALYZE to see the query execution plan.
        Look for: Full table scans, nested loop joins on large tables, missing indexes.
        Use slow query log (MySQL) or pg_stat_statements (PostgreSQL).

--- 5.3 Window Functions & Advanced SQL ---

Q225. [SCENARIO] Explain window functions with a real example. What is the difference between ROW_NUMBER(), RANK(), and DENSE_RANK()?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ ROW_NUMBER(): Unique sequential number. No ties.
        RANK(): Same rank for ties. Skips next ranks (1, 2, 2, 4).
        DENSE_RANK(): Same rank for ties. Does NOT skip (1, 2, 2, 3).
        Example: SELECT name, salary, RANK() OVER (ORDER BY salary DESC) as salary_rank FROM employees;

Q226. [TRAP] What is the difference between PARTITION BY and GROUP BY?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ GROUP BY: Collapses rows into groups. Returns one row per group.
        PARTITION BY: Divides rows into partitions but KEEPS all rows.
        Used in window functions to compute values across partitions without collapsing.

Q227. [SCENARIO] How do you find the second-highest salary in a table?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Method 1: SELECT MAX(salary) FROM employees WHERE salary < (SELECT MAX(salary) FROM employees)
        Method 2: SELECT salary FROM employees ORDER BY salary DESC LIMIT 1 OFFSET 1
        Method 3: SELECT salary, RANK() OVER (ORDER BY salary DESC) r FROM employees â†’ WHERE r = 2
        Method 3 is most robust (handles ties correctly).

Q228. [TRAP] Explain the difference between EXISTS and IN for subqueries. Which is more efficient?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ IN: Fetches all values from subquery, then checks if current value is in the list.
        EXISTS: Checks for the EXISTENCE of at least one row. Stops as soon as one match is found.
        Production: EXISTS is generally more efficient, especially with correlated subqueries and large datasets.

--- 5.4 Transaction & Isolation ---

Q229. [SCENARIO] Explain the four isolation levels in SQL and the problems they solve.
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ READ UNCOMMITTED: Allows dirty reads. Lowest isolation.
        READ COMMITTED: Prevents dirty reads. Default in most databases (PostgreSQL, Oracle).
        REPEATABLE READ: Prevents dirty and non-repeatable reads. Default in MySQL (InnoDB).
        SERIALIZABLE: Prevents all anomalies. Highest isolation but most restrictive.

Q230. [TRAP] What is a dirty read, non-repeatable read, and phantom read? Give examples.
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Dirty read: Transaction reads uncommitted data from another transaction.
        Non-repeatable read: Transaction reads same row twice, gets different values (another transaction modified it).
        Phantom read: Transaction reads a set of rows twice, gets different number of rows (another transaction inserted/deleted).

Q231. [SCENARIO] Explain the difference between optimistic and pessimistic locking in the database context.
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Optimistic: Assumes conflicts are rare. Checks at commit time (version check).
        Pessimistic: Assumes conflicts are likely. Locks rows immediately (SELECT FOR UPDATE).
        Production: Use optimistic locking for read-heavy workloads. Pessimistic for write-heavy critical sections.

--- 5.5 SQL Production Scenarios ---

Q232. [SCENARIO] How do you handle pagination efficiently in SQL for large tables?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ LIMIT/OFFSET: Simple but slow for large offsets (scans and discards rows).
        Keyset pagination (cursor-based): WHERE id > last_seen_id ORDER BY id LIMIT n.
        Production: Use keyset pagination for large datasets. LIMIT/OFFSET is fine for small ones.

Q233. [TRAP] What is the difference between DELETE and TRUNCATE?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ DELETE: Removes rows one by one. Triggers row-level triggers. Can use WHERE clause. Transaction-safe.
        TRUNCATE: Removes ALL rows at once. Much faster. Cannot use WHERE. Resets auto-increment.
        TRUNCATE cannot be rolled back in some databases (MySQL). DELETE can always be rolled back.

Q234. [SCENARIO] Explain CTEs (Common Table Expressions) and when they are useful.
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ CTEs (WITH clause) allow you to define a named subquery that can be referenced multiple times.
        Useful for: Recursive queries, improving readability, avoiding repeated subqueries.
        Example: WITH dept_avg AS (SELECT dept, AVG(salary) as avg_sal FROM emp GROUP BY dept)
                 SELECT * FROM emp JOIN dept_avg ON emp.dept = dept_avg.dept WHERE emp.salary > dept_avg.avg_sal

Q235. [TRAP] What is the difference between a VIEW and a CTE?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ VIEW: Persistent (stored in the database). Can be referenced across multiple queries.
        CTE: Temporary. Only available within the single query it is defined in.
        Production: Use views for reusable queries. CTEs for one-time complex queries.

Q236. [SCENARIO] How do you find duplicate rows in a table?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ SELECT col1, col2, COUNT(*) as cnt
        FROM table
        GROUP BY col1, col2
        HAVING COUNT(*) > 1;
        For deleting duplicates: Use ROW_NUMBER() with PARTITION BY to identify and delete extras.

Q237. [TRAP] What is the difference between a UNIQUE constraint and a CHECK constraint?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ UNIQUE: Ensures all values in a column (or combination) are distinct.
        CHECK: Ensures values in a column satisfy a condition (e.g., age > 0).

Q238. [SCENARIO] How do you optimize a query that joins 3+ tables and is running slowly?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ 1. Check EXPLAIN plan for full table scans.
        2. Ensure JOIN columns are indexed.
        3. Apply WHERE filters early (filter before join where possible).
        4. Consider denormalization for frequently joined tables.
        5. Use covering indexes.
        6. Rewrite as a CTE or subquery if the optimizer is choosing a bad plan.

--- 5.6 SQL Traps & Edge Cases ---

Q239. [TRAP] What happens with NULL in SQL comparisons?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ NULL = NULL â†’ NULL (not TRUE!). You must use IS NULL / IS NOT NULL.
        NULL in GROUP BY: All NULLs are grouped together.
        NULL in ORDER BY: Placement depends on the database (first or last).
        NULL in DISTINCT: Only one NULL is kept.
        Production: Always handle NULLs explicitly. Use COALESCE() or IFNULL().

Q240. [SCENARIO] Explain the difference between COALESCE() and IFNULL().
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ COALESCE(a, b, c): Returns the first non-NULL value from the argument list. Standard SQL.
        IFNULL(a, b): Returns a if not NULL, else b. MySQL-specific (equivalent to COALESCE with 2 args).
        Production: Use COALESCE() for portability.

Q241. [TRAP] Can you use GROUP BY without an aggregate function?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ In strict SQL mode (MySQL 5.7+, PostgreSQL): NO. All non-aggregated columns must be in GROUP BY.
        In non-strict mode (MySQL default before 5.7): Yes, but you get an ARBITRARY value for non-grouped columns.
        Production: Always include all non-aggregated columns in GROUP BY or use aggregate functions.

Q242. [SCENARIO] How do you implement a self-join? Give a real-world example.
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Example: Find employees and their managers.
        SELECT e.name as employee, m.name as manager
        FROM employees e
        JOIN employees m ON e.manager_id = m.id;
        Self-joins are common for hierarchical data (org charts, category trees).

Q243. [TRAP] What is the difference between NATURAL JOIN and USING clause?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ NATURAL JOIN: Automatically joins on ALL columns with the same name. Can be dangerous (unintended matches).
        USING (column): Explicitly specifies which common column to join on.
        Production: NEVER use NATURAL JOIN. Always be explicit with JOIN conditions.

Q244. [SCENARIO] How do you find the top N rows per group in SQL?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Use ROW_NUMBER() with PARTITION BY:
        SELECT * FROM (
          SELECT *, ROW_NUMBER() OVER (PARTITION BY dept ORDER BY salary DESC) as rn
          FROM employees
        ) sub WHERE rn <= 3;
        This returns the top 3 earners per department.

Q245. [TRAP] What is the difference between LIKE and ILIKE (case-insensitive LIKE)?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ LIKE: Case-sensitive in most databases (PostgreSQL, Oracle).
        ILIKE: Case-insensitive. PostgreSQL-specific.
        MySQL LIKE is case-insensitive by default (depends on collation).
        Production: Be aware of case sensitivity differences across databases.

--- 5.7 Database Design & Normalization ---

Q246. [SCENARIO] Explain the first three normal forms (1NF, 2NF, 3NF) with examples.
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ 1NF: Each column contains atomic values. No repeating groups.
        2NF: 1NF + No partial dependency (all non-key columns depend on the ENTIRE primary key).
        3NF: 2NF + No transitive dependency (non-key columns depend ONLY on the primary key).

Q247. [TRAP] When is denormalization justified in production?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ When read performance is critical and joins are expensive.
        Examples: Reporting tables, dashboards, search indexes.
        Trade-off: Faster reads but data redundancy and update anomalies.

Q248. [SCENARIO] Explain the difference between a foreign key constraint and an application-level check.
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Foreign key: Database enforces referential integrity. Prevents orphaned records.
        Application-level: Check done in code. Can be bypassed (direct DB access, bugs).
        Production: Always use foreign keys for data integrity. Application checks are additional validation.

--- 5.8 Additional SQL Scenarios ---

Q249. [SCENARIO] How do you handle case expressions in SQL? Give an example.
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ CASE WHEN salary > 80000 THEN 'High'
             WHEN salary > 50000 THEN 'Medium'
             ELSE 'Low'
         END as salary_bracket
        FROM employees;
        Useful for conditional logic within queries without application code.

Q250. [TRAP] What is the difference between COUNT(*), COUNT(column), and COUNT(DISTINCT column)?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ COUNT(*): Counts all rows (including NULLs).
        COUNT(column): Counts non-NULL values in that column.
        COUNT(DISTINCT column): Counts unique non-NULL values.
        Production: Be precise about which one you need. COUNT(*) vs COUNT(column) can give very different results.

Q251. [SCENARIO] How do you implement an upsert (insert or update) in SQL?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ MySQL: INSERT ... ON DUPLICATE KEY UPDATE column = VALUES(column)
        PostgreSQL: INSERT ... ON CONFLICT (column) DO UPDATE SET column = EXCLUDED.column
        Production: Upserts are atomic and avoid race conditions between separate SELECT and INSERT/UPDATE.

Q252. [TRAP] What is the difference between GROUP BY with ROLLUP and CUBE?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ ROLLUP: Generates subtotals and a grand total hierarchically.
          GROUP BY dept, team ROLLUP â†’ totals per dept+team, then per dept, then grand total.
        CUBE: Generates all possible combinations of subtotals (cross-tabulation).
        Production: Useful for reporting and analytics dashboards.

Q253. [SCENARIO] You have a query that runs in 30 seconds on a table with 10 million rows.
      Walk through your optimization approach.
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ 1. Run EXPLAIN to see the execution plan.
        2. Identify full table scans or expensive sorts.
        3. Add appropriate indexes (check if existing indexes are used).
        4. Rewrite query to reduce result set early (push WHERE filters).
        5. Consider partitioning the table if data is time-based.
        6. Check for lock contention or blocking queries.
        7. Consider caching at the application level for frequently run queries.

Q254. [TRAP] What is the difference between a temporary table and a CTE in terms of performance?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Temporary table: Physically created (in memory or disk). Can be indexed. Persists for the session.
        CTE: Logical. May be inlined by the optimizer (not always materialized).
        Production: If a CTE is referenced multiple times and the optimizer doesn't materialize it,
        use a temporary table for guaranteed performance.

Q255. [SCENARIO] How do you handle bulk inserts efficiently in a production database?
      âœ… Answer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Use bulk INSERT statements (INSERT INTO ... VALUES (...), (...), (...))
        Or use COPY command (PostgreSQL) / LOAD DATA INFILE (MySQL) for very large datasets.
        With Hibernate: Use batch processing (hibernate.jdbc.batch_size).
        Production: Avoid inserting rows one by one in a loop. It is extremely slow.


============================================================
  QUICK REVISION CHEAT SHEET - TOP 20 TRAPS TO REMEMBER
============================================================

  1.  Integer caching: == works for -128 to 127 only. Use .equals().
  2.  String == vs .equals(): == compares references, .equals() compares content.
  3.  HashMap key mutation: Mutable keys break HashMap. Use immutable keys.
  4.  @Transactional rollback: Only rolls back on RuntimeException by default.
  5.  Self-invocation AOP: Internal method calls bypass Spring proxy.
  6.  Singleton + Prototype scope: Singleton holds one prototype instance forever.
  7.  N+1 query problem: Use @JoinFetch or @EntityGraph to fix.
  8.  LazyInitializationException: Access lazy collections within transaction boundary.
  9.  CascadeType.ALL: Be careful with REMOVE cascade on @ManyToOne.
  10. Static method polymorphism: Static methods use static binding (compile time).
  11. Arrays.asList() is fixed-size: Cannot add/remove. Wrap in new ArrayList<>().
  12. volatile â‰  thread-safe: volatile ensures visibility, not atomicity.
  13. NULL = NULL is NULL in SQL: Always use IS NULL / IS NOT NULL.
  14. @Enumerated: Always use EnumType.STRING, not ORDINAL.
  15. finally return overrides try return: Always a trap in interviews.
  16. Checked exception catch order: Most specific first, most general last.
  17. @Transactional on private methods: Ignored by Spring AOP.
  18. HashMap collision handling: Java 8 converts to TreeMap after 8 entries per bucket.
  19. LIMIT/OFFSET pagination: Slow for large offsets. Use keyset pagination.
  20. @GeneratedValue(IDENTITY): Prevents batch inserts. Use SEQUENCE instead.

============================================================
  END OF DOCUMENT
  Good luck with your interview! ğŸ¯
============================================================


============================================================
  ADVANCED JAVA INTERVIEW QUESTIONS - 3 YEAR EXPERIENCE
  PRODUCTION SCENARIOS | DEBUGGING | ARCHITECTURE | PERFORMANCE
  Total Questions: 200+
============================================================


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 SECTION 1: ADVANCED CORE JAVA & JVM (Questions 1-40)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

--- 1.1 Memory Management & GC Deep Dive ---

Q1. [PRODUCTION CRISIS] Your production application starts throwing OutOfMemoryError: Java heap space
    after running fine for 2 days. How do you diagnose and fix it?
    â†’ Immediate: Take heap dump: jmap -dump:live,format=b,file=heap.bin <pid>
      Analyze with Eclipse MAT or VisualVM to find memory leaks.
      Common causes:
      - Unclosed connections/streams
      - Static collections growing unbounded
      - ThreadLocal leaks
      - Caching without eviction policy
      Long-term fix: Implement monitoring (heap usage metrics), fix leaks, tune heap size.

Q2. [SCENARIO] Explain the different types of OutOfMemoryError and what each indicates.
    â†’ Java heap space: Heap is full. Objects cannot be allocated.
      GC overhead limit exceeded: GC is spending >98% time and recovering <2% heap.
      PermGen/Metaspace: Too many classes loaded (common in app servers with redeploys).
      Unable to create new native thread: Thread limit reached (OS or JVM).
      Direct buffer memory: NIO direct buffers exhausted.
      Each has a different root cause and fix.

Q3. [TRAP] What is the difference between -Xms, -Xmx, -XX:MaxMetaspaceSize, and -Xss?
    â†’ -Xms: Initial heap size
      -Xmx: Maximum heap size
      -XX:MaxMetaspaceSize: Maximum metaspace (class metadata) size
      -Xss: Stack size per thread
      Production trap: Setting -Xms != -Xmx causes heap resizing overhead during runtime.
      Best practice: Set -Xms = -Xmx for predictable performance.

Q4. [PRODUCTION] You notice frequent Full GC events (10+ seconds pause) in production logs.
    How do you identify the issue?
    â†’ Enable GC logging: -Xlog:gc*:file=gc.log (Java 9+) or -XX:+PrintGCDetails (Java 8)
      Analyze GC logs with GCViewer or GCEasy.
      Look for:
      - Large heap size causing long marking phase
      - Old generation filling up quickly (premature promotion)
      - Humongous allocations (G1GC)
      Solutions: Tune GC (switch to G1 or ZGC), reduce object creation, increase heap.

Q5. [TRAP] Explain the difference between Minor GC, Major GC, and Full GC.
    â†’ Minor GC: Cleans Young Generation only. Fast (milliseconds).
      Major GC: Cleans Old Generation. Slower.
      Full GC: Cleans entire heap (Young + Old + Metaspace). Longest pause.
      Production: Too many Full GCs indicate memory pressure or GC tuning issues.

Q6. [SCENARIO] Compare the GC algorithms: Serial, Parallel, CMS, G1, ZGC, Shenandoah.
    When would you use each?
    â†’ Serial: Single-threaded. Small heaps (<100MB), client apps.
      Parallel: Multi-threaded. Throughput-oriented. Batch processing.
      CMS: Concurrent Mark-Sweep. Low pause times but fragmentation issues. Deprecated.
      G1: Default in Java 9+. Balanced. Good for most server apps (heap 4GB-64GB).
      ZGC: Ultra-low pause (<10ms). Very large heaps (100GB+). Java 15+.
      Shenandoah: Low pause, alternative to ZGC. Java 12+.
      Production: G1 for most cases, ZGC for latency-critical apps.

Q7. [PRODUCTION CRISIS] Your microservice has a memory leak. Every deployment, memory grows.
    After 3 days, it OOMs. How do you find the leak?
    â†’ Take heap dumps at different intervals (day 1, day 2, before crash).
      Use MAT's "Leak Suspects Report" or "Histogram" view.
      Compare dumps to see which objects are growing.
      Common leaks:
      - ThreadLocal not removed (tomcat thread pool reuses threads)
      - Event listeners not de-registered
      - Static caches without size limits
      Fix: Implement try-finally with cleanup, use WeakHashMap where appropriate.

Q8. [TRAP] What is the difference between soft references, weak references, and phantom references?
    â†’ Strong: Normal references. Object won't be GC'd.
      Soft: GC'd only when memory is low. Used for caches.
      Weak: GC'd as soon as no strong refs exist. Used in WeakHashMap.
      Phantom: Used for cleanup actions. Object already GC'd, reference is enqueued.
      Production: Use SoftReference for caching, WeakReference for canonicalization.

--- 1.2 Multithreading Deep Dive ---

Q9. [PRODUCTION] Two threads are deadlocked in production. How do you detect and resolve it?
    â†’ Detection:
      - jstack <pid> > thread_dump.txt (look for "BLOCKED" and circular wait)
      - jconsole or VisualVM (Threads tab shows deadlock detection)
      - Enable -XX:+PrintConcurrentLocks
      Prevention:
      - Always acquire locks in the same order
      - Use tryLock() with timeout instead of lock()
      - Use java.util.concurrent utilities (no manual locking)

Q10. [SCENARIO] Explain the happens-before relationship in the Java Memory Model.
     â†’ Guarantees visibility of memory writes across threads.
       Rules:
       - Program order: Each action happens-before subsequent actions in the same thread.
       - Monitor lock: Unlock happens-before subsequent lock on the same monitor.
       - volatile: Write to volatile happens-before subsequent read.
       - Thread start: Thread.start() happens-before any action in the started thread.
       - Thread join: All actions in a thread happen-before Thread.join() returns.
       Production: Violations cause visibility issues (stale reads).

Q11. [TRAP] What is the difference between synchronized(this) and synchronized(SomeClass.class)?
     â†’ synchronized(this): Locks on the instance (object-level lock).
       synchronized(SomeClass.class): Locks on the class object (class-level lock).
       Different instances can execute synchronized(this) blocks concurrently.
       All instances block on synchronized(SomeClass.class).

Q12. [PRODUCTION CRISIS] Your application has 500 threads, most in WAITING state.
     Thread pool is exhausted. What's wrong?
     â†’ Likely thread pool starvation.
       Causes:
       - Tasks waiting for other tasks in the same pool (nested tasks â†’ deadlock)
       - Database connection pool smaller than thread pool (threads wait for connections)
       - Blocking I/O without timeouts
       Fix:
       - Separate thread pools for different task types
       - Use async/reactive patterns (CompletableFuture, Project Reactor)
       - Add timeouts to all blocking operations

Q13. [SCENARIO] Explain CountDownLatch, CyclicBarrier, Phaser, and Semaphore. When to use each?
     â†’ CountDownLatch: One-time barrier. Threads wait until count reaches zero.
         Use: Wait for N tasks to complete before proceeding.
       CyclicBarrier: Reusable barrier. Threads wait for each other at a sync point.
         Use: Parallel algorithms where threads sync at multiple points.
       Phaser: Advanced, dynamic barrier. Parties can register/deregister.
         Use: Complex multi-phase algorithms.
       Semaphore: Limits concurrent access to a resource.
         Use: Rate limiting, connection pools.

Q14. [TRAP] What is the difference between ReentrantLock and synchronized?
     â†’ synchronized: Implicit, JVM-level. Simpler. Cannot interrupt waiting threads.
       ReentrantLock: Explicit. Can try locking with timeout (tryLock).
         Can interrupt waiting threads. Supports fairness policy.
       Production: Use synchronized unless you need advanced features.

Q15. [PRODUCTION] You use CompletableFuture.allOf() to wait for 10 API calls.
     One API times out after 30 seconds. Your users wait 30 seconds for an error.
     How do you fix this?
     â†’ Wrap each CompletableFuture with orTimeout(Duration):
       CompletableFuture.supplyAsync(() -> apiCall())
           .orTimeout(5, TimeUnit.SECONDS)
           .exceptionally(ex -> defaultValue);
       Then CompletableFuture.allOf() completes when all complete/timeout.
       Users get partial results or errors quickly.

Q16. [TRAP] What is a spurious wakeup? How do you handle it?
     â†’ A thread waiting on wait() wakes up WITHOUT notify()/notifyAll() being called.
       This can happen due to OS-level interrupts.
       Fix: ALWAYS use wait() inside a while loop, not if:
       while (!condition) { obj.wait(); }

Q17. [SCENARIO] Explain Fork/Join framework. When is it beneficial?
     â†’ Recursive divide-and-conquer algorithms (merge sort, parallel aggregation).
       Uses work-stealing: Idle threads steal tasks from busy threads.
       Not beneficial for: I/O-bound tasks, small datasets, simple parallelism.
       Production: Use Stream.parallel() for simple cases. Fork/Join for custom parallel algorithms.

--- 1.3 ClassLoading & Reflection ---

Q18. [PRODUCTION] Your application deployed in Tomcat suffers from PermGen/Metaspace leaks
     after multiple redeploys. What causes this?
     â†’ Tomcat creates a new classloader per deployment but old classes aren't GC'd.
       Causes:
       - Static references to app classes from shared libraries
       - ThreadLocal leaks (Tomcat's thread pool is shared)
       - JDBC drivers not deregistered
       - Logging frameworks holding references
       Fix: Implement ServletContextListener to clean up on undeploy.

Q19. [TRAP] Explain the delegation model of ClassLoaders in Java.
     â†’ Parent-first delegation (default):
       1. Bootstrap ClassLoader (java.lang.*)
       2. Extension ClassLoader (lib/ext)
       3. Application ClassLoader (classpath)
       Child asks parent before loading. Prevents class version conflicts.
       Exception: Servlet containers use child-first for web app classes.

Q20. [SCENARIO] You use reflection to invoke methods 1 million times. Performance is terrible.
     How do you optimize?
     â†’ Reflection is slow due to security checks and boxing/unboxing.
       Optimizations:
       - Cache Method objects: method = clazz.getMethod(...) ONCE.
       - Use method.setAccessible(true) to bypass security checks.
       - Use MethodHandles (Java 7+) for better performance.
       - Consider code generation (Byte Buddy, Javassist) for hot paths.

Q21. [PRODUCTION TRAP] You have a class with both @PostConstruct and InitializingBean.afterPropertiesSet().
     Which executes first? Does constructor run before both?
     â†’ Order: Constructor â†’ @PostConstruct â†’ afterPropertiesSet().
       Spring processes @PostConstruct via BeanPostProcessor before InitializingBean callback.

--- 1.4 Advanced Language Features ---

Q22. [TRAP] Explain type erasure deeply. Why can't you do: new T[10] in generics?
     â†’ At runtime, T becomes Object due to type erasure.
       new T[10] would effectively be new Object[10], breaking type safety.
       Arrays are reified (type info exists at runtime), generics are not.
       This is why List<String>[] is illegal but ArrayList<String>[] is a warning.

Q23. [SCENARIO] You create a custom annotation @Loggable. How do you process it at runtime?
     â†’ Use reflection:
       if (method.isAnnotationPresent(Loggable.class)) {
           Loggable annotation = method.getAnnotation(Loggable.class);
           // Use annotation values
       }
       Spring uses AnnotationUtils for advanced processing.
       Production: AOP is better than manual reflection for cross-cutting concerns.

Q24. [PRODUCTION] You serialize an object to Redis cache. Later, you add a new field to the class.
     Deserializing cached objects throws InvalidClassException. How do you handle versioning?
     â†’ Declare serialVersionUID explicitly:
       private static final long serialVersionUID = 1L;
       Do NOT let JVM auto-generate (changes with class modifications).
       When adding fields, keep serialVersionUID the same and make new fields transient
       or provide default values.

Q25. [TRAP] What is the diamond problem in Java? How does Java 8 handle it with default methods?
     â†’ Diamond problem: Multiple inheritance where two parents have the same method.
       Java 8 allows default methods in interfaces â†’ potential conflict.
       Solution: Implementing class MUST override the method and explicitly choose:
       InterfaceA.super.method() or InterfaceB.super.method()

Q26. [SCENARIO] You have a recursive method that causes StackOverflowError for large inputs.
     How do you fix it?
     â†’ Convert to iterative with explicit stack (Stack<> or ArrayDeque<>).
       Or increase stack size: -Xss2m (not recommended, just delays the problem).
       Or use tail recursion (not optimized in Java, but can be simulated).
       Production: Avoid deep recursion. Use iteration or trampolining.

Q27. [PRODUCTION] You call Integer.valueOf(10000) twice. Does it return the same object?
     â†’ NO. Integer caches only -128 to 127.
       For 10000, two different objects are created.
       Production trap: Using == for Integer comparison outside cache range fails.

Q28. [TRAP] Why is String immutable? What are the benefits?
     â†’ Benefits:
       - String pool sharing (memory efficiency)
       - Thread-safe (no synchronization needed)
       - Hashcode caching (String's hashCode is cached)
       - Security (strings in security-sensitive operations can't be modified)
       Drawback: Lots of string concatenation creates garbage.

Q29. [SCENARIO] Explain method references and their types with examples.
     â†’ Static: ClassName::staticMethod
       Instance (bound): instance::method
       Instance (unbound): ClassName::instanceMethod
       Constructor: ClassName::new
       Array constructor: String[]::new
       Production: Method references are syntactic sugar for lambdas. Performance is identical.

Q30. [PRODUCTION] You use try-with-resources on a custom AutoCloseable. close() throws an exception.
     What happens?
     â†’ The exception is suppressed if the try block also throws.
       The try block's exception is the primary one.
       Suppressed exceptions are available via ex.getSuppressed().
       Production: close() should NOT throw exceptions. Log and swallow if necessary.

--- 1.5 JVM Tuning & Monitoring ---

Q31. [SCENARIO] Your app's response time degrades after 6 hours. Thread dumps show many threads
     in TIMED_WAITING state. What's the issue?
     â†’ Possible thread pool exhaustion or thread leaks.
       Threads are waiting on I/O, DB, or downstream services.
       Check:
       - Connection pool sizes (DB, HTTP client)
       - Downstream service latencies (circuit breakers?)
       - Thread pool sizes and queue lengths
       Fix: Increase connection pools, implement timeouts, add circuit breakers.

Q32. [PRODUCTION] You enable JMX monitoring. What critical metrics do you watch?
     â†’ Heap usage: Heap Memory Usage (committed, used, max)
       GC metrics: GC count, GC time
       Thread metrics: Live thread count, peak thread count
       Connection pools: Active/idle connections
       CPU usage, response times, error rates
       Tools: JConsole, VisualVM, Prometheus + Grafana, New Relic.

Q33. [TRAP] What is the difference between jmap, jstack, jstat, and jcmd?
     â†’ jmap: Heap dumps, heap histograms
       jstack: Thread dumps
       jstat: GC statistics, class loading stats
       jcmd: Unified diagnostic command (combines many features)
       Production: Use jcmd for most tasks (it's more modern).

Q34. [SCENARIO] Explain JIT compilation. What is the difference between C1 and C2 compilers?
     â†’ JIT: Compiles hot bytecode to native code at runtime.
       C1 (Client): Fast compilation, less optimization. Low latency.
       C2 (Server): Slower compilation, aggressive optimization. High throughput.
       Tiered compilation (default Java 8+): Uses both. C1 first, then C2 for hot methods.

Q35. [PRODUCTION TRAP] You enable -XX:+UseStringDeduplication in G1GC. What does it do?
     â†’ G1GC deduplicates identical String objects (same char[]) to save memory.
       Only works with G1GC.
       Useful for apps with many duplicate strings (JSON parsing, logging).
       Cost: Some CPU overhead for deduplication checks.

Q36. [SCENARIO] Your application has 1000 requests/sec. Each request creates 100 short-lived objects.
     GC is overwhelmed. How do you reduce GC pressure?
     â†’ Object pooling: Reuse objects instead of creating new ones (e.g., ByteBuffer pools).
       Reduce allocations: Use primitives instead of wrappers, reuse StringBuilder instances.
       Off-heap memory: Store large data structures off-heap (Unsafe, Netty's ByteBuf).
       Increase Young Generation size: More space for short-lived objects.

Q37. [TRAP] What happens if you call System.gc()? Should you use it?
     â†’ Suggests that the JVM run GC. It's a HINT, not a guarantee.
       Modern JVMs usually ignore it or treat it as a Full GC (expensive).
       Production: NEVER use System.gc(). Let the JVM manage GC.
       Exception: Testing memory leaks in controlled environments.

Q38. [PRODUCTION] You notice CPU spikes during GC pauses. How do you correlate GC with CPU?
     â†’ Enable GC logging with timestamps.
       Use OS monitoring (top, vmstat) to correlate CPU spikes with GC events.
       GC is CPU-intensive (marking, compacting).
       Solutions: Tune GC, reduce heap size, switch to ZGC/Shenandoah for concurrent GC.

Q39. [SCENARIO] Explain Escape Analysis. How does it help performance?
     â†’ JIT compiler analyzes if an object escapes the method scope.
       If it doesn't escape, JIT can allocate it on the stack (instead of heap).
       Stack allocation is faster and doesn't require GC.
       JIT can also eliminate synchronization if the object doesn't escape.
       Production: Modern JVMs do this automatically. No code changes needed.

Q40. [TRAP] What is the difference between -server and -client JVM modes?
     â†’ -client: Fast startup, less aggressive JIT optimization. For short-lived apps.
       -server: Slower startup, aggressive JIT optimization. For long-running apps.
       Java 8+: These flags are mostly ignored. Tiered compilation combines both.


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 SECTION 2: ADVANCED COLLECTIONS & CONCURRENCY (Questions 41-70)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

--- 2.1 ConcurrentHashMap Deep Dive ---

Q41. [SCENARIO] Explain how ConcurrentHashMap works internally in Java 8.
     â†’ Uses CAS (Compare-And-Swap) + synchronized on individual nodes (not segments).
       Each bucket is a linked list or TreeNode (if collision threshold exceeded).
       Reads are non-blocking. Writes lock only the specific bucket.
       Much finer-grained than Java 7's segment locking.

Q42. [PRODUCTION] You use ConcurrentHashMap.computeIfAbsent() to lazily initialize values.
     The mapping function calls another computeIfAbsent() on the same map. What happens?
     â†’ IllegalStateException: Recursive update.
       ConcurrentHashMap detects this and throws to prevent deadlock.
       Fix: Pre-compute values or use a different approach (manual locking).

Q43. [TRAP] What is the difference between ConcurrentHashMap.size() and mappingCount()?
     â†’ size(): Returns int. Can overflow if size > Integer.MAX_VALUE.
       mappingCount(): Returns long. Accurate for large maps.
       Production: Use mappingCount() for correctness.

Q44. [SCENARIO] Compare ConcurrentHashMap, Collections.synchronizedMap(), and Hashtable.
     â†’ Hashtable: Synchronizes entire map (one lock). Very slow. Legacy.
       synchronizedMap(): Wraps a Map, synchronizes all methods. Single lock.
       ConcurrentHashMap: Fine-grained locking. Best performance.
       Production: Always use ConcurrentHashMap for concurrent access.

Q45. [PRODUCTION TRAP] You iterate over ConcurrentHashMap while other threads modify it.
     Do you get ConcurrentModificationException?
     â†’ NO. ConcurrentHashMap's iterators are weakly consistent.
       They reflect some modifications but don't throw exceptions.
       They MAY or MAY NOT see concurrent updates.

--- 2.2 BlockingQueue & Producer-Consumer ---

Q46. [SCENARIO] Explain the different BlockingQueue implementations and when to use each.
     â†’ ArrayBlockingQueue: Bounded, backed by array. FIFO. Use when capacity is known.
       LinkedBlockingQueue: Optionally bounded, backed by linked nodes. FIFO.
       PriorityBlockingQueue: Unbounded, priority heap. Use when tasks have priorities.
       DelayQueue: Elements available only after delay expires. Use for scheduling.
       SynchronousQueue: No capacity. Direct handoff. Use for work-stealing pools.

Q47. [PRODUCTION] Your producer produces 1000 msgs/sec. Consumer processes 500 msgs/sec.
     Queue grows unbounded â†’ OutOfMemoryError. How do you fix?
     â†’ Use a bounded queue: new ArrayBlockingQueue<>(1000)
       Producer blocks when queue is full (backpressure).
       Or add more consumers (scale horizontally).
       Or implement rate limiting on producer.
       Or use a reactive approach (Project Reactor with backpressure).

Q48. [TRAP] What is the difference between poll() and take() on BlockingQueue?
     â†’ poll(): Returns null immediately if queue is empty (non-blocking).
       poll(timeout): Waits up to timeout, then returns null.
       take(): Blocks indefinitely until an element is available.
       Production: Use take() in consumer loops. Use poll(timeout) with shutdown hooks.

Q49. [SCENARIO] Implement a thread-safe bounded cache with LRU eviction using LinkedHashMap.
     â†’ Use LinkedHashMap with accessOrder=true.
       Override removeEldestEntry() to return true when size > capacity.
       Wrap all access in synchronized blocks (or use Collections.synchronizedMap()).
       Production: For high concurrency, use Caffeine or Guava Cache instead.

Q50. [PRODUCTION] Your application uses a thread pool with LinkedBlockingQueue.
     Queue has 10,000 pending tasks. New tasks are rejected. Why?
     â†’ LinkedBlockingQueue is unbounded by default (capacity = Integer.MAX_VALUE).
       It should NOT reject tasks.
       Check: Are you using a bounded queue? Is the thread pool shutdown?
       Or is the rejection policy set to AbortPolicy?
       Fix: Verify queue capacity and rejection policy.

--- 2.3 Atomic Variables ---

Q51. [SCENARIO] Explain how AtomicInteger works. What is CAS?
     â†’ Uses CPU-level Compare-And-Swap (CAS) instructions.
       CAS(expected, new): Atomically compares current value with expected.
       If they match, updates to new value. Returns true if successful.
       If CAS fails, retry in a loop (lock-free algorithm).
       No thread blocking â†’ better performance than synchronized.

Q52. [TRAP] When would you use LongAdder instead of AtomicLong?
     â†’ AtomicLong: Single variable updated atomically. Good for low contention.
       LongAdder: Maintains multiple counters, sums them on read. Better for HIGH contention.
       Use LongAdder for metrics/counters with frequent updates from many threads.
       Trade-off: LongAdder uses more memory, reads are slower (summation).

Q53. [PRODUCTION] You implement a lock-free stack using AtomicReference. How?
     â†’ Use CAS to update the top pointer:
       Node oldTop = top.get();
       Node newTop = new Node(value, oldTop);
       while (!top.compareAndSet(oldTop, newTop)) {
           oldTop = top.get();
           newTop = new Node(value, oldTop);
       }
       Production: Existing libraries (ConcurrentLinkedDeque) are better tested.

--- 2.4 Stream API Edge Cases ---

Q54. [PRODUCTION TRAP] You use Stream.parallel() and collect to ArrayList.
     Multiple threads cause ConcurrentModificationException. Why?
     â†’ ArrayList is NOT thread-safe.
       Parallel streams require thread-safe collectors.
       Use Collectors.toList() (uses ConcurrentHashMap internally for combining).
       Or collect to ConcurrentLinkedQueue first, then convert to list.

Q55. [SCENARIO] Explain the difference between findFirst() and findAny() in parallel streams.
     â†’ findFirst(): Returns the first element in encounter order.
         In parallel streams, requires coordination â†’ slower.
       findAny(): Returns any element. Faster in parallel streams (no coordination).
       Production: Use findAny() when order doesn't matter.

Q56. [TRAP] You use Stream.peek() to modify objects. Is this guaranteed to execute?
     â†’ NO. peek() is an intermediate operation. It only executes when a terminal operation is invoked.
       Also, peek() is for debugging, NOT for side effects.
       Production: Use forEach() or map() for side effects.

Q57. [PRODUCTION] Your stream processing runs much slower with parallelStream(). Why?
     â†’ Overhead of thread management and splitting exceeds benefits for:
       - Small datasets (<1000 elements)
       - I/O-bound operations (database calls, HTTP requests)
       - Operations not CPU-intensive
       Fix: Use sequential stream() or use reactive/async approaches for I/O.

Q58. [SCENARIO] How do you implement custom collectors with Collector.of()?
     â†’ Collector.of(
           supplier: () -> new ArrayList<>(),
           accumulator: (list, item) -> list.add(item),
           combiner: (list1, list2) -> { list1.addAll(list2); return list1; },
           finisher: Function.identity(),
           characteristics: Collector.Characteristics.IDENTITY_FINISH
       );
       Production: Use built-in collectors when possible. Custom collectors for specialized aggregations.

Q59. [TRAP] What happens if a NullPointerException occurs inside a stream pipeline?
     â†’ The exception propagates immediately. Stream processing stops.
       Use filter(Objects::nonNull) to skip nulls.
       Or use Optional.ofNullable() to handle nulls gracefully.

Q60. [PRODUCTION] You flatMap a stream of lists, each with 1 million elements.
     OutOfMemoryError occurs. Why?
     â†’ flatMap can materialize large intermediate collections.
       If all nested streams are large, memory explodes.
       Fix: Process in batches, use lazy evaluation, or stream files line-by-line.

--- 2.5 Advanced Collection Patterns ---

Q61. [SCENARIO] Implement a thread-safe counter map (word frequency counter) efficiently.
     â†’ Option 1: ConcurrentHashMap + computeIfAbsent
       map.merge(word, 1, Integer::sum);
       Option 2: ConcurrentHashMap<String, LongAdder>
       map.computeIfAbsent(word, k -> new LongAdder()).increment();
       Option 2 is faster under high contention.

Q62. [PRODUCTION] Your API returns List<Employee> sorted by salary.
     Multiple concurrent requests cause ConcurrentModificationException. Why?
     â†’ The list is shared and being sorted in-place by Collections.sort().
       Multiple threads call sort() concurrently â†’ concurrent modification.
       Fix: Return a NEW sorted list (use stream().sorted().collect(toList())).
       Or use an immutable list (List.copyOf()).

Q63. [TRAP] You use TreeSet to store custom objects but ordering is inconsistent.
     Why might this happen?
     â†’ The Comparator or Comparable is inconsistent (violates contract).
       Or the object's fields used in comparison are mutable and change after insertion.
       Production: Ensure comparator is transitive, consistent with equals, and uses immutable fields.

Q64. [SCENARIO] How do you implement a fixed-size circular buffer thread-safely?
     â†’ Use ArrayBlockingQueue with fixed capacity.
       Or implement with an array + AtomicInteger for head/tail pointers + CAS.
       Production: Use existing libraries (Disruptor for high performance).

Q65. [PRODUCTION] You use HashSet to deduplicate 10 million objects.
     Memory usage is 4GB. How do you reduce it?
     â†’ Use Bloom filter (probabilistic, false positives allowed).
       Or store hashes instead of full objects.
       Or use external storage (Redis Set, database).
       Or use primitive collections (e.g., fastutil IntOpenHashSet for integers).

Q66. [TRAP] What is the time complexity of remove() on ArrayList vs LinkedList?
     â†’ ArrayList: O(n) â€” must shift elements after removal.
       LinkedList: O(n) â€” must traverse to find the element, then O(1) to remove.
       Both are O(n) in practice. ArrayList is still faster due to cache locality.

Q67. [SCENARIO] Implement a cache that expires entries after 5 minutes of inactivity.
     â†’ Use ConcurrentHashMap + ScheduledExecutorService to check and evict.
       Or use Guava Cache: CacheBuilder.newBuilder().expireAfterAccess(5, TimeUnit.MINUTES).build()
       Or use Caffeine (better performance than Guava).

Q68. [PRODUCTION TRAP] You iterate ConcurrentHashMap.values() and call remove() on each.
     Does it work?
     â†’ NO. Iterator.remove() is NOT supported on ConcurrentHashMap's views.
       Throws UnsupportedOperationException.
       Fix: Collect keys first, then remove:
       map.keySet().removeIf(predicate);

Q69. [SCENARIO] Explain the difference between CopyOnWriteArrayList and synchronizedList().
     When to use each?
     â†’ CopyOnWriteArrayList: Copies the entire array on every write. Safe for iteration.
         Use when reads >> writes (e.g., event listener lists).
       synchronizedList(): Locks on every access. Must manually synchronize iteration.
         Use when reads ~= writes.

Q70. [TRAP] You add 1 million entries to a HashMap without specifying initial capacity.
     What performance issue occurs?
     â†’ HashMap resizes multiple times (16 â†’ 32 â†’ 64 â†’ ... â†’ 1048576).
       Each resize is O(n) rehashing.
       Fix: new HashMap<>(initialCapacity, loadFactor)
       Formula: initialCapacity = expectedSize / loadFactor (e.g., 1_000_000 / 0.75 â‰ˆ 1_333_333).


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 SECTION 3: SPRING BOOT PRODUCTION SCENARIOS (Questions 71-120)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

--- 3.1 Startup & Configuration Issues ---

Q71. [PRODUCTION CRISIS] Your Spring Boot app takes 3 minutes to start. How do you profile and fix it?
     â†’ Enable startup logging: -Ddebug or logging.level.org.springframework=DEBUG
       Look for slow auto-configurations, component scans, or bean instantiations.
       Common issues:
       - ComponentScan on wrong package (scans too many classes)
       - Expensive @PostConstruct methods
       - Slow database migrations (Flyway/Liquibase at startup)
       - Too many auto-configurations loading
       Fixes: Narrow component scan, use lazy initialization, move migrations to separate process.

Q72. [TRAP] You enable spring.main.lazy-initialization=true.
     First HTTP request is very slow. Why?
     â†’ Beans are created on-demand. First request triggers bean creation for controllers, services, etc.
       Subsequent requests are fast.
       Production: Use lazy init for faster startup in cloud environments (scale-out quickly).
       Trade-off: First request latency.

Q73. [SCENARIO] Your app loads 50MB of static data at startup into a singleton bean.
     How do you optimize this?
     â†’ Load asynchronously: Use @Async on @PostConstruct or ApplicationRunner.
       Or lazy-load: Only load data when first requested.
       Or externalize: Load from Redis/cache instead of in-memory.
       Production: Large in-memory datasets increase heap size and GC pressure.

Q74. [PRODUCTION] Two beans have circular dependency. Spring fails to start with
     "The dependencies of some beans in the application context form a cycle". How to fix?
     â†’ Use @Lazy on one of the dependencies:
       public MyService(@Lazy OtherService other) { ... }
       Or refactor to remove circular dependency (better long-term).
       Production: Circular dependencies indicate design smell. Refactor if possible.

Q75. [TRAP] You have @Value("${db.url}") but property is missing. App starts fine but field is null. Why?
     â†’ @Value doesn't fail if the property is missing (uses literal value).
       Use @Value("${db.url:}") to get empty string, or use required=true in @ConfigurationProperties.
       Production: Use @Validated on @ConfigurationProperties to enforce required properties.

--- 3.2 REST API Production Issues ---

Q76. [PRODUCTION] Your REST API returns 500 Internal Server Error instead of 400 Bad Request
     for invalid input. How do you fix this?
     â†’ Add @Valid on @RequestBody to trigger validation.
       Implement @ExceptionHandler for MethodArgumentNotValidException to return 400.
       Example:
       @ExceptionHandler(MethodArgumentNotValidException.class)
       public ResponseEntity<ErrorResponse> handleValidation(MethodArgumentNotValidException ex) {
           return ResponseEntity.badRequest().body(...);
       }

Q77. [SCENARIO] Your API endpoint /users/{id} returns 404 when id is not found.
     Should it return 404 or 204 No Content? What about 200 with null body?
     â†’ 404: Resource does not exist (correct for /users/{id}).
       204: Request succeeded but no content to return (correct for DELETE).
       200 with null: Misleading (implies success but no data).
       Production: Follow REST semantics strictly. Clients rely on status codes.

Q78. [PRODUCTION TRAP] You return Page<Entity> directly from your REST controller.
     Clients complain about huge JSON payloads. What's wrong?
     â†’ Hibernate lazy collections are being serialized (Jackson triggers lazy loading).
       Fix:
       - Use DTOs (never expose entities directly).
       - Add @JsonIgnoreProperties({"hibernateLazyInitializer", "handler"})
       - Configure Jackson to fail on lazy loading: jackson.serialization.FAIL_ON_EMPTY_BEANS=true

Q79. [SCENARIO] Explain the difference between @ResponseStatus and ResponseEntity.
     When to use which?
     â†’ @ResponseStatus: Fixed status code for the method/exception.
       ResponseEntity: Dynamic status code + headers + body.
       Use @ResponseStatus for simple cases (@ResponseStatus(HttpStatus.CREATED) on POST).
       Use ResponseEntity when you need control over headers, cookies, or conditional status.

Q80. [PRODUCTION] Your API has a file upload endpoint. Users upload 2GB files â†’ OutOfMemoryError. Fix?
     â†’ Do NOT load the entire file into memory.
       Stream the file directly to disk or S3:
       MultipartFile.transferTo(new File(...))
       Or use InputStreamResource with StreamingResponseBody.
       Configure max file size: spring.servlet.multipart.max-file-size=100MB

Q81. [TRAP] Client sends Content-Type: text/plain but your controller expects JSON.
     What HTTP status is returned?
     â†’ 415 Unsupported Media Type.
       Spring checks Content-Type header and rejects if it doesn't match @RequestBody expectations.

Q82. [SCENARIO] How do you implement API versioning in Spring Boot? Compare strategies.
     â†’ URI versioning: /v1/users, /v2/users (simple, visible).
       Header versioning: Accept: application/vnd.myapi.v1+json (cleaner URLs).
       Parameter versioning: /users?version=1 (less common).
       Production: URI versioning is most common. Header versioning is more RESTful.

--- 3.3 Transaction Management Deep Dive ---

Q83. [PRODUCTION CRISIS] Your @Transactional method saves an entity but it's not in the database
     after the method completes. Why?
     â†’ Transaction rolled back silently due to RuntimeException.
       Or transaction never started (self-invocation, AOP proxy bypassed).
       Or transaction is read-only (@Transactional(readOnly=true)).
       Debug: Enable transaction logging: logging.level.org.springframework.transaction=DEBUG

Q84. [SCENARIO] Explain propagation types: REQUIRED, REQUIRES_NEW, NESTED, MANDATORY, SUPPORTS.
     â†’ REQUIRED (default): Join existing transaction or create new one.
       REQUIRES_NEW: Always create new transaction, suspend current one.
       NESTED: Create savepoint in existing transaction (rollback to savepoint).
       MANDATORY: Must run in existing transaction, fail otherwise.
       SUPPORTS: Run in transaction if exists, else run without.
       NEVER: Fail if transaction exists.
       NOT_SUPPORTED: Suspend current transaction and run without transaction.

Q85. [PRODUCTION TRAP] You call methodA() which is @Transactional.
     Inside methodA(), you call methodB() which is also @Transactional(propagation=REQUIRES_NEW).
     Both methods are in the SAME class. Does methodB() create a new transaction?
     â†’ NO. This is self-invocation. Spring AOP proxy is bypassed.
       methodB() runs in the SAME transaction as methodA().
       Fix: Move methodB() to a different bean or use AspectJ weaving.

Q86. [SCENARIO] Your transaction times out after 30 seconds. How do you configure timeout?
     â†’ @Transactional(timeout=60) â€” timeout in seconds.
       Or spring.transaction.default-timeout=60
       Production: Set timeouts on long-running transactions to prevent connection pool exhaustion.

Q87. [PRODUCTION] You update 10,000 records in a single transaction. Database runs out of
     transaction log space. How do you fix?
     â†’ Batch updates in smaller transactions (e.g., 1,000 records per transaction).
       Pseudocode:
       for (int i = 0; i < total; i += BATCH_SIZE) {
           transactionalService.updateBatch(i, i + BATCH_SIZE);
       }
       Production: Large transactions lock resources and increase rollback cost.

Q88. [TRAP] What is the difference between @Transactional on a class vs on a method?
     â†’ Class-level: Applies to ALL public methods in the class.
       Method-level: Overrides class-level settings for that specific method.
       Private methods are ALWAYS ignored (AOP can't intercept private methods).

--- 3.4 Caching Production Scenarios ---

Q89. [PRODUCTION] You enable @Cacheable on a method. Cache grows to 50GB. How do you fix?
     â†’ Configure cache eviction policy:
       Caffeine: CacheBuilder.maximumSize(10000).expireAfterWrite(10, TimeUnit.MINUTES)
       Redis: Set TTL on keys.
       Spring Cache: Configure CacheManager with size/TTL limits.
       Production: NEVER use unbounded caches.

Q90. [SCENARIO] Your @Cacheable method is called with the same parameters but returns different results.
     Cache returns stale data. Why?
     â†’ Cache key doesn't include all relevant parameters.
       Default key: All method parameters.
       If results depend on user session, include session ID in key:
       @Cacheable(value="users", key="#userId + '-' + #userContext.sessionId")

Q91. [TRAP] You use @CacheEvict(allEntries=true) to clear cache. Performance degrades immediately. Why?
     â†’ All cached data is evicted. Next requests trigger cache misses â†’ thundering herd.
       All requests hit the database simultaneously.
       Fix: Evict selectively (by key) or use cache warming (pre-load cache after eviction).

Q92. [PRODUCTION] Two instances of your microservice share a Redis cache.
     Instance A updates the database and evicts cache. Instance B still serves stale data from local cache.
     How do you fix?
     â†’ Use distributed cache (Redis) without local cache.
       Or implement cache invalidation pub/sub (Redis pub/sub to notify all instances).
       Or use short TTLs on local cache.

Q93. [SCENARIO] Explain cache-aside, read-through, write-through, and write-behind patterns.
     â†’ Cache-aside: App checks cache, if miss, loads from DB and populates cache.
       Read-through: Cache automatically loads from DB on miss (transparent to app).
       Write-through: Writes go to cache AND DB synchronously.
       Write-behind: Writes go to cache immediately, DB asynchronously (eventual consistency).
       Production: Cache-aside is most common. Write-behind for high-write scenarios.

--- 3.5 Security Deep Dive ---

Q94. [PRODUCTION] Your API is vulnerable to SQL injection despite using Spring Data JPA.
     How is this possible?
     â†’ Native queries with string concatenation:
       @Query(nativeQuery=true, value="SELECT * FROM users WHERE name = '" + name + "'")
       Fix: Use parameterized queries:
       @Query(nativeQuery=true, value="SELECT * FROM users WHERE name = :name")

Q95. [SCENARIO] Implement JWT-based authentication in Spring Boot. What are the key steps?
     â†’ 1. Generate JWT on login (sign with secret key).
       2. Return JWT to client.
       3. Client sends JWT in Authorization: Bearer <token> header.
       4. Validate JWT in filter (JwtAuthenticationFilter).
       5. Extract user details and set SecurityContext.
       Production: Use libraries like jjwt. Store secret in environment variables.

Q96. [TRAP] You store JWT secret in application.properties. It's committed to Git. What's the risk?
     â†’ Secret is exposed. Anyone can forge JWTs.
       Fix: Store in environment variables or external secret manager (AWS Secrets Manager, Vault).
       Use spring-cloud-config or Kubernetes secrets.

Q97. [PRODUCTION] Your API allows users to access /admin endpoints by guessing admin user IDs.
     What security flaw is this?
     â†’ Broken Access Control (OWASP Top 10).
       Authorization checks are missing or insufficient.
       Fix: Implement role-based access control (RBAC) with method security:
       @PreAuthorize("hasRole('ADMIN')")

Q98. [SCENARIO] How do you prevent CSRF attacks in a Spring Boot REST API?
     â†’ Stateless REST APIs (JWT-based) are NOT vulnerable to CSRF (no session cookies).
       Disable CSRF: http.csrf().disable()
       Stateful APIs (session-based): Keep CSRF enabled. Include CSRF token in requests.

Q99. [PRODUCTION TRAP] You hash passwords with MD5. Security audit flags this. Why?
     â†’ MD5 is NOT cryptographically secure (rainbow tables, collisions).
       Fix: Use BCrypt, Argon2, or PBKDF2.
       Spring Security: PasswordEncoderFactories.createDelegatingPasswordEncoder()
       Upgrade existing MD5 hashes: Wrap with BCrypt on next login.

Q100. [SCENARIO] How do you implement rate limiting to prevent API abuse?
      â†’ Use Bucket4j (token bucket algorithm).
        Or Spring Cloud Gateway with rate limiter.
        Or API gateway (Kong, AWS API Gateway).
        Production: Implement per-user and global rate limits.

--- 3.6 Microservices Patterns ---

Q101. [PRODUCTION] Your microservice calls 5 downstream services. One service is down.
      All requests fail. How do you implement resilience?
      â†’ Circuit Breaker pattern (Resilience4j or Hystrix).
        When failure rate exceeds threshold, circuit opens â†’ fast fail.
        After timeout, circuit half-opens â†’ test if service recovered.
        Fallback: Return cached data or default response.

Q102. [SCENARIO] Explain the difference between Hystrix and Resilience4j.
      â†’ Hystrix: Netflix library. Now in maintenance mode (no new features).
        Resilience4j: Lightweight, functional, modern. Recommended.
        Both provide: Circuit breaker, rate limiter, retry, bulkhead.

Q103. [TRAP] Your circuit breaker is configured with a 10-second timeout.
      The downstream service responds in 15 seconds. What happens?
      â†’ The call times out. Circuit breaker records a failure.
        Too many timeouts â†’ circuit opens.
        Fix: Increase timeout or optimize downstream service.

Q104. [PRODUCTION] How do you implement distributed tracing across microservices?
      â†’ Use Spring Cloud Sleuth (generates trace IDs and span IDs).
        Send traces to Zipkin or Jaeger.
        Each service propagates trace ID in HTTP headers.
        Production: Essential for debugging latency issues in microservices.

Q105. [SCENARIO] Explain saga pattern for distributed transactions.
      â†’ Saga: A sequence of local transactions. Each service commits its transaction.
        If one fails, compensating transactions undo previous steps.
        Two types:
        - Choreography: Services publish events, others react (decentralized).
        - Orchestration: Central coordinator manages the saga (centralized).
        Production: Use for cross-service transactions (e.g., order + payment + shipping).

Q106. [TRAP] You implement retry logic with exponential backoff.
      All retries happen within 1 second â†’ downstream service still overwhelmed. Why?
      â†’ Base delay is too small. Exponential backoff should start with 100ms-1s.
        Also add jitter (randomization) to prevent synchronized retries from multiple clients.

--- 3.7 Performance Optimization ---

Q107. [PRODUCTION] Your API response time is 5 seconds. How do you profile and optimize?
      â†’ Use Spring Boot Actuator metrics (/actuator/metrics).
        Enable method-level timing: @Timed (Micrometer).
        Use APM tools (New Relic, Datadog, Dynatrace).
        Identify bottlenecks: Database queries (N+1), external API calls, CPU-intensive operations.
        Optimize: Add indexes, cache results, parallelize, use async.

Q108. [SCENARIO] Your database query takes 10 seconds. EXPLAIN shows a full table scan.
      How do you fix?
      â†’ Add index on columns in WHERE, JOIN, ORDER BY clauses.
        Rewrite query to use indexed columns.
        Check: Is index being used? (EXPLAIN output).
        Production: Monitor slow query log regularly.

Q109. [TRAP] You add @Async on a method but it still runs synchronously. Why?
      â†’ @EnableAsync not present on configuration class.
        Or method is private (proxy can't intercept).
        Or self-invocation (called from same class).
        Fix: Add @EnableAsync, make method public, call from another bean.

Q110. [PRODUCTION] Your async method returns CompletableFuture but exceptions are swallowed. How to handle?
      â†’ Add exception handling:
        CompletableFuture.supplyAsync(...)
            .exceptionally(ex -> { log.error("Error", ex); return defaultValue; })
        Or configure AsyncUncaughtExceptionHandler.

--- 3.8 Testing Strategies ---

Q111. [SCENARIO] Explain the difference between @SpringBootTest, @WebMvcTest, and @DataJpaTest.
      â†’ @SpringBootTest: Loads FULL context. Integration test. Slow.
        @WebMvcTest: Loads ONLY web layer. Fast. Mock services with @MockBean.
        @DataJpaTest: Loads ONLY JPA/repository layer. Uses in-memory DB. Fast.
        Production: Use slice tests (@WebMvcTest, @DataJpaTest) for faster feedback.

Q112. [TRAP] Your @DataJpaTest test fails with "No qualifying bean of type EntityManager". Why?
      â†’ @DataJpaTest only loads JPA beans. If you inject a service, it won't be available.
        Use @MockBean to mock services or use @SpringBootTest.

Q113. [PRODUCTION] Your integration tests work locally but fail in CI/CD. Why?
      â†’ Database state differences (CI uses clean DB, local has test data).
        Or time zone differences (CI uses UTC, local uses local time).
        Or missing environment variables.
        Fix: Use @DirtiesContext to reset context, use Testcontainers for consistent DB.

Q114. [SCENARIO] How do you test a method that uses @Transactional?
      â†’ Test inherits transaction behavior by default (rolls back after test).
        Use @Commit to commit the transaction (for testing actual persistence).
        Or @Transactional(propagation=NOT_SUPPORTED) to disable transaction in test.

Q115. [TRAP] You mock a repository method with when(repo.findById(1)).thenReturn(...).
      The actual call is repo.findById(2). Mock returns null. How to fix?
      â†’ Use argument matchers: when(repo.findById(anyLong())).thenReturn(...)
        Or verify the argument is correct and fix the test.

--- 3.9 Deployment & Containerization ---

Q116. [PRODUCTION] Your Docker image is 500MB. How do you reduce it?
      â†’ Use multi-stage builds:
        FROM maven:3.8-jdk-11 AS build â†’ build the app
        FROM openjdk:11-jre-slim â†’ run the app (no build tools)
        Use .dockerignore to exclude unnecessary files.
        Use Spring Boot's layered JARs for better caching.

Q117. [SCENARIO] Your Spring Boot app runs fine locally but crashes in Kubernetes with OOMKilled. Why?
      â†’ Container memory limit is lower than JVM heap size.
        JVM doesn't respect container limits by default (Java 8).
        Fix (Java 10+): JVM respects container limits automatically.
        Fix (Java 8): Set -XX:+UnlockExperimentalVMOptions -XX:+UseCGroupMemoryLimitForHeap

Q118. [TRAP] You set -Xmx2g but container has 2GB memory. App is OOMKilled. Why?
      â†’ JVM needs more than heap: Metaspace, thread stacks, direct buffers, code cache.
        Rule of thumb: Set container memory to 1.5-2x heap size.
        Example: -Xmx1500m for 2GB container.

Q119. [PRODUCTION] Your app's health check endpoint (/actuator/health) returns DOWN but app is running. Why?
      â†’ A custom health indicator failed (database unreachable, external service down).
        Check: /actuator/health shows details (up, down, components).
        Fix: Implement custom health indicators carefully. Avoid false negatives.

Q120. [SCENARIO] How do you implement graceful shutdown in Spring Boot for zero-downtime deployments?
      â†’ Spring Boot supports graceful shutdown (since 2.3):
        server.shutdown=graceful
        spring.lifecycle.timeout-per-shutdown-phase=30s
        Allows in-flight requests to complete before shutdown.
        Production: Essential for rolling updates in Kubernetes.


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 SECTION 4: HIBERNATE & JPA ADVANCED (Questions 121-160)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

--- 4.1 Performance Tuning ---

Q121. [PRODUCTION CRISIS] You execute a query that returns 100,000 entities.
      Application freezes and eventually OOMs. Why?
      â†’ Hibernate loads ALL entities into memory (first-level cache).
        Fix: Use pagination (setFirstResult, setMaxResults).
        Or use ScrollableResults for large datasets (cursor-based).
        Or use DTOs with native queries (no entity state tracking).

Q122. [SCENARIO] Explain the difference between fetch join and entity graph.
      â†’ Fetch join: JPQL/HQL with JOIN FETCH. Inline in query.
        Entity graph: Declarative. Uses @NamedEntityGraph or @EntityGraph annotation.
        Both solve N+1 problem by eagerly fetching associations.
        Production: Entity graphs are reusable. Fetch joins are more flexible.

Q123. [TRAP] You use @BatchSize(size=10) on a @OneToMany collection. How does it work?
      â†’ Hibernate fetches the collection for up to 10 parent entities in a single query (IN clause).
        Reduces N+1 to N/10 + 1 queries.
        Not as good as fetch join but better than lazy loading individually.

Q124. [PRODUCTION] Your application has 5 second delays when saving entities. Logs show
      hundreds of individual INSERT statements. How to fix?
      â†’ Enable batch inserts:
        spring.jpa.properties.hibernate.jdbc.batch_size=50
        spring.jpa.properties.hibernate.order_inserts=true
        Use @GeneratedValue(strategy=SEQUENCE) (NOT IDENTITY â€” identity disables batching).

Q125. [SCENARIO] Explain Hibernate's write-behind strategy. What is the flush mode?
      â†’ Hibernate queues SQL statements and executes them at flush time (not immediately).
        Flush modes:
        - AUTO (default): Flush before query execution and before transaction commit.
        - COMMIT: Flush only on commit.
        - MANUAL: Flush only when explicitly called.
        Production: AUTO is safe. COMMIT can cause stale data in queries.

Q126. [TRAP] You call entityManager.persist(entity) but SELECT queries afterward don't see the entity. Why?
      â†’ The entity is persisted in Hibernate's session but not yet flushed to the database.
        Fix: Call entityManager.flush() to force SQL execution.
        Or rely on AUTO flush mode (flushes before queries).

Q127. [PRODUCTION] You update 10,000 entities in a loop. Each update is a separate query.
      How do you optimize?
      â†’ Use bulk update query:
        entityManager.createQuery("UPDATE Entity e SET e.status = :status WHERE e.id IN :ids")
            .setParameter("status", status)
            .setParameter("ids", ids)
            .executeUpdate();
        Bypasses Hibernate's dirty checking. Much faster.

--- 4.2 Locking Strategies ---

Q128. [SCENARIO] Explain pessimistic locking in JPA. How do you implement it?
      â†’ Locks the row in the database (SELECT FOR UPDATE).
        entityManager.find(Entity.class, id, LockModeType.PESSIMISTIC_WRITE);
        Other transactions block until the lock is released.
        Use for: High contention, critical updates (e.g., inventory reservation).

Q129. [TRAP] You use PESSIMISTIC_WRITE but the database doesn't support row-level locking.
      What happens?
      â†’ Database may lock the entire table â†’ severe performance degradation.
        Or lock is ignored (no error, no lock).
        Check database documentation for locking support.

Q130. [PRODUCTION] Two users update the same entity simultaneously. Second user's changes
      overwrite the first user's changes. How to prevent?
      â†’ Use optimistic locking: Add @Version field.
        Hibernate checks version on update. If version changed â†’ OptimisticLockException.
        User is notified to retry with fresh data.

Q131. [SCENARIO] Explain the difference between PESSIMISTIC_READ and PESSIMISTIC_WRITE.
      â†’ PESSIMISTIC_READ: Shared lock (other transactions can read but not write).
        PESSIMISTIC_WRITE: Exclusive lock (other transactions can't read or write).
        Database support varies. PostgreSQL: both are exclusive. MySQL: READ allows reads.

Q132. [TRAP] You catch OptimisticLockException and retry the update.
      It fails again. Why might this happen indefinitely?
      â†’ Another process is continuously updating the entity.
        Fix: Add maximum retry limit (e.g., 3 retries).
        Or use pessimistic locking instead.
        Or re-design to avoid contention (event sourcing, CQRS).

--- 4.3 Inheritance & Polymorphism ---

Q133. [PRODUCTION] You use SINGLE_TABLE inheritance. Tables have 50 nullable columns for subclass fields.
      Queries return lots of null values. How to optimize?
      â†’ Switch to JOINED inheritance: Each subclass has its own table.
        Reduces null columns but requires joins.
        Trade-off: SINGLE_TABLE is faster (no joins), JOINED is more normalized.

Q134. [SCENARIO] You query the parent class but only need instances of one subclass. How to filter?
      â†’ Use Hibernate's @Where annotation or discriminator in JPQL:
        SELECT c FROM Customer c WHERE TYPE(c) = PremiumCustomer
        Production: Add index on discriminator column for performance.

Q135. [TRAP] You use TABLE_PER_CLASS inheritance. Polymorphic queries are extremely slow. Why?
      â†’ Hibernate uses UNION to query all subclass tables.
        Each subclass table is queried separately, then results are combined.
        Production: Avoid TABLE_PER_CLASS unless you never query polymorphically.

--- 4.4 Advanced Querying ---

Q136. [PRODUCTION] Your JPQL query joins 4 tables. Query plan shows multiple left outer joins.
      Performance is terrible. How to optimize?
      â†’ Use explicit JOIN instead of implicit joins:
        Explicit: SELECT e FROM Employee e JOIN e.department d JOIN d.company c
        Implicit: SELECT e FROM Employee e WHERE e.department.company.name = :name
        Explicit joins give the optimizer more control.

Q137. [SCENARIO] How do you implement pagination with sorting in Spring Data JPA?
      â†’ repository.findAll(PageRequest.of(page, size, Sort.by("name").descending()));
        Spring Data generates LIMIT/OFFSET query.
        Production: For large offsets, use keyset pagination for better performance.

Q138. [TRAP] You use @Query with nativeQuery=true. Sorting via Pageable doesn't work. Why?
      â†’ Spring Data can't inject Sort into native queries safely (SQL injection risk).
        Fix: Use JPQL instead or hardcode sorting in native query.

Q139. [PRODUCTION] Your query returns List<Object[]> (native query projection).
      You have to manually map to DTOs. How to simplify?
      â†’ Use Spring Data projection interfaces:
        interface EmployeeDto { String getName(); Integer getSalary(); }
        List<EmployeeDto> findByDepartment(String dept);
        Or use class-based DTOs with constructor in JPQL.

Q140. [SCENARIO] Explain the difference between DTO projection and entity projection.
      â†’ Entity projection: Returns managed entities. Hibernate tracks changes.
          Use when you need to modify data.
        DTO projection: Returns unmanaged POJOs. No change tracking. Faster.
          Use for read-only queries (reports, dashboards).

--- 4.5 Caching Deep Dive ---

Q141. [PRODUCTION] You enable second-level cache. Concurrent updates cause stale reads. How to fix?
      â†’ Configure cache concurrency strategy:
        @Cache(usage = CacheConcurrencyStrategy.READ_WRITE) â€” allows updates, uses locking.
        READ_ONLY: For immutable entities only.
        NONSTRICT_READ_WRITE: No locking, eventual consistency.
        TRANSACTIONAL: Requires JTA, strict consistency.

Q142. [TRAP] You cache a @OneToMany collection. Child entities are added in another session.
      Cached collection is stale. Why?
      â†’ Collection cache is NOT automatically invalidated when children are added externally.
        Fix: Evict collection cache explicitly or use shorter TTLs.

Q143. [SCENARIO] How do you configure Hibernate second-level cache with Redis?
      â†’ Use hibernate-redis library or Redisson.
        Configure in application.properties:
        spring.jpa.properties.hibernate.cache.use_second_level_cache=true
        spring.jpa.properties.hibernate.cache.region.factory_class=org.redisson.hibernate.RedissonRegionFactory
        Production: Redis cache is shared across instances (distributed caching).

Q144. [PRODUCTION TRAP] You clear second-level cache in production to fix stale data.
      Database is overwhelmed with queries. What happened?
      â†’ Cache stampede: All cache misses hit database simultaneously.
        Fix: Implement cache warming or gradual eviction.
        Or use circuit breaker to protect database.

--- 4.6 Advanced Mappings ---

Q145. [SCENARIO] You have a composite primary key (OrderId = customerId + orderDate).
      How do you map it in JPA?
      â†’ Use @Embeddable and @EmbeddedId:
        @Embeddable class OrderId { Long customerId; LocalDate orderDate; }
        @Entity class Order { @EmbeddedId OrderId id; }
        OrderId must implement equals() and hashCode().

Q146. [TRAP] You use @IdClass instead of @EmbeddedId for composite key.
      Queries require both key fields. Is there a difference?
      â†’ @EmbeddedId: Single composite object. Cleaner API.
        @IdClass: Separate fields in entity. More verbose.
        Both work. @EmbeddedId is generally preferred.

Q147. [PRODUCTION] You map a JSON column (PostgreSQL jsonb) to a Java object. How?
      â†’ Use Hibernate Types library: @Type(type = "jsonb")
        Or implement custom UserType.
        Or use @Convert with AttributeConverter.

Q148. [SCENARIO] Explain @ElementCollection. When to use it instead of @OneToMany?
      â†’ @ElementCollection: For value objects (no separate table with PK).
        Example: List<String> emails, Set<Address> addresses.
        @OneToMany: For entities with their own identity.
        Production: @ElementCollection is simpler but less flexible.

Q149. [TRAP] You use @ElementCollection and add 10,000 elements. Performance degrades. Why?
      â†’ Hibernate loads the ENTIRE collection eagerly by default.
        Fix: Use @OneToMany with a separate entity instead.
        Or use pagination to load collections in chunks.

Q150. [PRODUCTION] Your entity has a large @Lob field (PDF content). Loading entities is slow.
      How to optimize?
      â†’ Use lazy loading on the field: @Basic(fetch=FetchType.LAZY)
        Field is loaded only when accessed.
        Production: Store large BLOBs outside the database (S3, file system).

--- 4.7 Transaction Pitfalls ---

Q151. [SCENARIO] Your transaction spans 30 seconds. Other transactions are blocked. Why?
      â†’ Long-running transactions hold locks on rows/tables.
        Other transactions wait for locks â†’ contention.
        Fix: Shorten transaction scope (only wrap critical updates).
        Or use READ_COMMITTED isolation to reduce locking.

Q152. [TRAP] You read an entity, close the session, then modify and merge it.
      Changes are not persisted. Why?
      â†’ merge() returns a MANAGED entity. You must use the returned entity.
        Entity mergedEntity = entityManager.merge(detachedEntity);
        // Use mergedEntity, not detachedEntity

Q153. [PRODUCTION] You call saveAndFlush() but the database shows no data. Why?
      â†’ Transaction is rolled back due to an exception after saveAndFlush().
        saveAndFlush() executes SQL but doesn't commit the transaction.
        Fix: Ensure transaction completes successfully (no exceptions).

Q154. [SCENARIO] Explain the difference between flush() and commit().
      â†’ flush(): Synchronizes session with database (executes SQL). Transaction is still active.
        commit(): Ends the transaction and makes changes permanent.
        Production: flush() is useful to detect constraint violations early.

Q155. [TRAP] You delete 100,000 entities with repository.deleteAll(). It's extremely slow. Why?
      â†’ Hibernate loads each entity, then deletes one by one (to handle cascades, lifecycle callbacks).
        Fix: Use bulk delete query:
        entityManager.createQuery("DELETE FROM Entity e WHERE ...").executeUpdate();

--- 4.8 Advanced Scenarios ---

Q156. [PRODUCTION] You use Hibernate Envers for auditing. Audit tables grow to 500GB.
      Queries are slow. How to manage?
      â†’ Implement audit table partitioning (by date).
        Archive old audit data to separate storage.
        Or use selective auditing (@Audited only on critical entities).

Q157. [SCENARIO] How do you implement multi-tenancy in Hibernate?
      â†’ Database per tenant: Separate database for each tenant (complete isolation).
        Schema per tenant: Separate schema for each tenant (same database).
        Discriminator column: Shared tables with tenant_id column (least isolation).
        Hibernate supports all three via TenantResolver.

Q158. [TRAP] You use Hibernate filter: @FilterDef + @Filter. Filter is not applied. Why?
      â†’ Filters are disabled by default. Must enable per session:
        session.enableFilter("activeUsers").setParameter("active", true);
        Production: Filters are useful for soft deletes or multi-tenancy.

Q159. [PRODUCTION] Your Hibernate application generates 1000 SQL queries for a single page load.
      How do you diagnose?
      â†’ Enable SQL logging: spring.jpa.show-sql=true
        Or use hibernate.generate_statistics=true + log at DEBUG level.
        Look for N+1 patterns.
        Fix: Use fetch joins, entity graphs, or batch fetching.

Q160. [SCENARIO] You need to call a stored procedure from JPA. How?
      â†’ Use @NamedStoredProcedureQuery or entityManager.createStoredProcedureQuery().
        Example:
        StoredProcedureQuery query = em.createStoredProcedureQuery("calculate_bonus");
        query.registerStoredProcedureParameter("empId", Long.class, ParameterMode.IN);
        query.setParameter("empId", 123L);
        query.execute();


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 SECTION 5: SQL ADVANCED SCENARIOS (Questions 161-205)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

--- 5.1 Query Optimization ---

Q161. [PRODUCTION CRISIS] A query that normally takes 100ms suddenly takes 30 seconds.
      No code changes. What could be wrong?
      â†’ Statistics are outdated (optimizer chooses bad plan).
        Fix: ANALYZE table (PostgreSQL) or UPDATE STATISTICS (SQL Server).
        Index fragmentation: REINDEX or REBUILD INDEX.
        Parameter sniffing (SQL Server): Cached plan is suboptimal for current parameters.
        Lock contention: Check for blocking queries.

Q162. [SCENARIO] EXPLAIN shows "Using filesort" (MySQL) or "Sort" (PostgreSQL). What does it mean?
      â†’ Database cannot use an index for sorting. It sorts results in memory or on disk.
        Slow for large result sets.
        Fix: Add index on ORDER BY columns.
        Or reduce result set before sorting (WHERE filters).

Q163. [TRAP] You add an index on (col1, col2). Query uses WHERE col2 = ? but doesn't use the index. Why?
      â†’ Composite index is left-to-right. Query must use col1 to benefit from the index.
        WHERE col2 = ? cannot use (col1, col2) index.
        Fix: Add separate index on col2 or reorder columns in index.

Q164. [PRODUCTION] Your query joins a 10M row table with a 100-row lookup table.
      Join takes 60 seconds. What's wrong?
      â†’ Likely missing index on join column.
        Or optimizer chooses nested loop join instead of hash join.
        Fix: Add index on join column. Force hash join (if database supports hints).

Q165. [SCENARIO] Explain the difference between nested loop, hash join, and merge join.
      â†’ Nested loop: For each row in outer table, scan inner table. Good for small inner table.
        Hash join: Build hash table from smaller table, probe with larger table. Good for large tables without indexes.
        Merge join: Both tables sorted by join key, merge them. Good when both have indexes.

Q166. [TRAP] You have an index on (created_at). Query uses WHERE created_at > DATE_SUB(NOW(), INTERVAL 7 DAY).
      Index is not used. Why?
      â†’ Function on column (DATE_SUB, NOW()) prevents index usage in some databases.
        Fix: Rewrite as: WHERE created_at > '2024-01-26'
        Or use function-based index (if supported).

Q167. [PRODUCTION] Your COUNT(*) query on a 100M row table takes 5 minutes. How to optimize?
      â†’ COUNT(*) must scan all rows (or index).
        Optimizations:
        - Use approximate count (EXPLAIN output estimates).
        - Maintain count in separate table (updated via triggers).
        - Use covering index (COUNT scans index instead of table).
        - Partition table and count partitions separately.

--- 5.2 Index Strategies ---

Q168. [SCENARIO] You have WHERE col1 = ? AND col2 = ? and ORDER BY col3.
      What index do you create?
      â†’ Create composite index: (col1, col2, col3).
        Supports both WHERE and ORDER BY (avoids filesort).
        Order matters: Equality filters first, then ORDER BY column.

Q169. [TRAP] You create a unique index on (email). Someone inserts NULL twice. Does it violate uniqueness?
      â†’ Depends on database:
        MySQL/SQL Server: Multiple NULLs allowed (NULL != NULL).
        PostgreSQL: By default, multiple NULLs allowed. Use UNIQUE NULLS NOT DISTINCT for strict uniqueness.

Q170. [PRODUCTION] Your table has 20 indexes. Writes are extremely slow. Why?
      â†’ Each INSERT/UPDATE/DELETE must update ALL indexes.
        Too many indexes slow down writes.
        Fix: Drop unused indexes (check index usage stats).
        Production: Monitor index usage. Keep only essential indexes.

Q171. [SCENARIO] Explain the difference between clustered and non-clustered indexes in SQL Server.
      â†’ Clustered: Data rows are physically ordered by the index key. Only ONE per table.
        Non-clustered: Separate structure pointing to data rows. Multiple allowed.
        Production: Choose clustered index carefully (usually primary key).

Q172. [TRAP] You create an index on VARCHAR column with 1000 characters. Index size is huge. Fix?
      â†’ Index only a prefix: CREATE INDEX idx_name ON table(long_text(50));
        Or use full-text index for text search.
        Production: Don't index entire long text columns.

--- 5.3 Transaction & Isolation Deep Dive ---

Q173. [PRODUCTION] Two transactions update the same row simultaneously.
      First commits. Second waits, then commits. Second's changes overwrite first's. Is this correct?
      â†’ Depends on isolation level:
        READ_COMMITTED: Yes, this is correct (second write wins).
        REPEATABLE_READ/SERIALIZABLE: Second transaction may get serialization error.
        Production: Use optimistic locking (version field) to detect conflicts.

Q174. [SCENARIO] Explain phantom reads with an example.
      â†’ Transaction 1: SELECT COUNT(*) FROM orders WHERE status = 'pending' â†’ returns 10
        Transaction 2: INSERT INTO orders (status) VALUES ('pending'); COMMIT;
        Transaction 1: SELECT COUNT(*) FROM orders WHERE status = 'pending' â†’ returns 11
        Same query, different result within the same transaction â†’ phantom read.
        Prevented by SERIALIZABLE isolation.

Q175. [TRAP] You set isolation to SERIALIZABLE. All transactions are much slower. Why?
      â†’ SERIALIZABLE uses range locks or validation to prevent anomalies.
        High contention â†’ more blocking/retries.
        Production: Use SERIALIZABLE only when necessary (financial transactions).

Q176. [PRODUCTION] You have a deadlock between two transactions updating orders and invoices.
      How do you prevent it?
      â†’ Acquire locks in consistent order (e.g., always lock orders before invoices).
        Or use shorter transactions.
        Or set deadlock timeout and retry logic.

Q177. [SCENARIO] Explain two-phase locking (2PL) and multi-version concurrency control (MVCC).
      â†’ 2PL: Transactions acquire locks in growing phase, release in shrinking phase.
        Used by SQL Server, MySQL (InnoDB with some MVCC).
        MVCC: Each transaction sees a snapshot of data. No read locks needed.
        Used by PostgreSQL, Oracle.
        Production: MVCC has better read performance.

--- 5.4 Advanced SQL Features ---

Q178. [PRODUCTION] You need to update a table based on a complex calculation from another table.
      How do you write an efficient UPDATE with JOIN?
      â†’ PostgreSQL:
        UPDATE orders o SET total = (SELECT SUM(price) FROM order_items i WHERE i.order_id = o.id);
        MySQL:
        UPDATE orders o JOIN (SELECT order_id, SUM(price) as total FROM order_items GROUP BY order_id) i
        ON o.id = i.order_id SET o.total = i.total;

Q179. [SCENARIO] Explain the difference between DELETE, TRUNCATE, and DROP.
      â†’ DELETE: Removes rows. Can use WHERE. Can rollback. Slow for large tables.
        TRUNCATE: Removes all rows. Fast. Cannot rollback (in most databases). Resets auto-increment.
        DROP: Removes the entire table structure.

Q180. [TRAP] You TRUNCATE a table in a transaction and try to rollback. Does it work?
      â†’ Depends on database:
        PostgreSQL: TRUNCATE can be rolled back.
        MySQL: TRUNCATE is DDL, commits implicitly, cannot rollback.

Q181. [PRODUCTION] You need to insert 1M rows from a CSV. Individual INSERTs take 10 hours.
      How to optimize?
      â†’ Use bulk insert:
        PostgreSQL: COPY FROM 'file.csv' CSV
        MySQL: LOAD DATA INFILE 'file.csv'
        Or batch INSERTs: INSERT INTO ... VALUES (...), (...), ... (1000 rows per statement).

Q182. [SCENARIO] How do you implement upsert (insert or update on conflict)?
      â†’ PostgreSQL: INSERT ... ON CONFLICT (id) DO UPDATE SET ...
        MySQL: INSERT ... ON DUPLICATE KEY UPDATE ...
        SQL Server: MERGE INTO ...
        Production: Upserts are atomic and avoid race conditions.

Q183. [TRAP] You use INSERT INTO SELECT with WHERE clause. No rows match WHERE. Does INSERT fail?
      â†’ NO. Zero rows are inserted (no error).
        Production: Check @@ROWCOUNT (SQL Server) or ROW_COUNT() (MySQL) to verify.

--- 5.5 Database Design Patterns ---

Q184. [PRODUCTION] Your users table has 50M rows. Queries are slow. How do you partition it?
      â†’ Horizontal partitioning (sharding): Split by range or hash (e.g., by user_id or region).
        Vertical partitioning: Split columns (frequently accessed vs rarely accessed).
        Production: Partitioning improves query performance but complicates cross-partition queries.

Q185. [SCENARIO] Explain the difference between normalization and denormalization.
      â†’ Normalization: Reduce redundancy, enforce constraints. Multiple joins for reads.
        Denormalization: Duplicate data to avoid joins. Faster reads, slower writes.
        Production: Normalize for transactional systems, denormalize for reporting/analytics.

Q186. [TRAP] You denormalize and store calculated fields (e.g., order_total).
      order_total is out of sync with order_items. How to prevent?
      â†’ Use triggers to update order_total when order_items change.
        Or recalculate on-the-fly (don't store).
        Or use database views (virtual denormalization).

Q187. [PRODUCTION] You implement soft delete with is_deleted flag. Queries forget to filter deleted rows. Fix?
      â†’ Use database view with WHERE is_deleted = false.
        Or use Hibernate @Where filter.
        Or use row-level security (PostgreSQL policies).

--- 5.6 Stored Procedures & Functions ---

Q188. [SCENARIO] When should you use stored procedures vs application logic?
      â†’ Stored procedures: Complex calculations, data-heavy operations (reduce network round trips).
        Application logic: Business logic, flexibility, testability.
        Production: Stored procedures are harder to version and test. Use sparingly.

Q189. [TRAP] Your stored procedure has a cursor looping through 100K rows. Performance is terrible. Fix?
      â†’ Cursors are row-by-row processing. Very slow.
        Fix: Rewrite as set-based query (UPDATE/INSERT with WHERE).
        Production: Avoid cursors. Use SQL's set-based operations.

--- 5.7 Database Debugging ---

Q190. [PRODUCTION] A query returns duplicate rows. How do you investigate?
      â†’ Check for Cartesian joins (missing join condition).
        Add DISTINCT to verify duplicates go away.
        Examine EXPLAIN plan for unexpected join types.

Q191. [SCENARIO] Your INSERT fails with "Duplicate entry for key 'PRIMARY'". How to debug?
      â†’ Check if row already exists: SELECT * FROM table WHERE id = ?
        Check auto-increment counter: SHOW CREATE TABLE (MySQL).
        Production: This often happens after manual INSERTs with explicit IDs.

Q192. [TRAP] Your query returns 0 rows but you know data exists. What could be wrong?
      â†’ Case-sensitive comparison (if collation is case-sensitive).
        Leading/trailing whitespace: TRIM() values.
        Implicit type conversion: '123' vs 123.
        Join condition is wrong (e.g., ON a.id = b.id should be ON a.id = b.user_id).

--- 5.8 Advanced Querying Scenarios ---

Q193. [PRODUCTION] You need to find gaps in a sequence (missing invoice numbers). How?
      â†’ SELECT a.id + 1 AS missing_start, b.id - 1 AS missing_end
        FROM invoices a
        JOIN invoices b ON b.id = (SELECT MIN(id) FROM invoices WHERE id > a.id)
        WHERE b.id - a.id > 1;

Q194. [SCENARIO] Implement running total (cumulative sum) in SQL.
      â†’ Window function:
        SELECT date, amount, SUM(amount) OVER (ORDER BY date) AS running_total FROM transactions;

Q195. [TRAP] You use RANK() to get top 5 per group but get more than 5 rows. Why?
      â†’ RANK() assigns the same rank to ties. Multiple rows can have rank 5.
        Use ROW_NUMBER() for strict top N (no ties).

Q196. [PRODUCTION] You need to pivot rows to columns (sales by month). How?
      â†’ Use CASE WHEN in SELECT:
        SELECT product,
               SUM(CASE WHEN month = 'Jan' THEN amount ELSE 0 END) AS jan,
               SUM(CASE WHEN month = 'Feb' THEN amount ELSE 0 END) AS feb
        FROM sales GROUP BY product;
        Or use PIVOT (SQL Server).

Q197. [SCENARIO] How do you find the median in SQL?
      â†’ PostgreSQL: SELECT PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY value) FROM table;
        MySQL (before 8.0): Use subqueries or variables (complex).
        MySQL 8.0+: Use window functions with NTILE or ROW_NUMBER.

Q198. [TRAP] You use GROUP BY col1, col2 and SELECT col3 (not in GROUP BY). Some databases allow this. Why?
      â†’ MySQL (in non-strict mode): Allows selecting non-aggregated columns. Returns arbitrary values.
        PostgreSQL: Throws error (correct SQL behavior).
        Production: Always include ALL non-aggregated columns in GROUP BY.

--- 5.9 Database-Specific Features ---

Q199. [PRODUCTION] You use PostgreSQL's JSONB column. Queries on nested keys are slow. How to optimize?
      â†’ Add GIN index: CREATE INDEX idx_data ON table USING GIN (jsonb_column);
        Or use expression index: CREATE INDEX ON table ((jsonb_column->>'key'));

Q200. [SCENARIO] Explain the difference between MySQL's MyISAM and InnoDB storage engines.
      â†’ MyISAM: Table-level locking. No transactions. Faster for read-heavy.
        InnoDB: Row-level locking. ACID transactions. Foreign keys. Default since MySQL 5.5.
        Production: Always use InnoDB. MyISAM is deprecated.

Q201. [TRAP] You create a foreign key in MySQL but it's not enforced. Why?
      â†’ Table is using MyISAM (foreign keys not supported).
        Or foreign key constraint creation failed silently (old MySQL versions).
        Fix: ALTER TABLE ... ENGINE=InnoDB;

Q202. [PRODUCTION] Your PostgreSQL query planner chooses a bad plan.
      You use EXPLAIN ANALYZE. How do you force a better plan?
      â†’ Use query hints (limited in PostgreSQL).
        Or rewrite query (subquery to CTE, join order).
        Or update statistics: ANALYZE table;
        Or disable specific plan types: SET enable_seqscan = off; (testing only).

Q203. [SCENARIO] How do you implement full-text search in PostgreSQL vs MySQL?
      â†’ PostgreSQL: CREATE INDEX idx_fts ON table USING GIN (to_tsvector('english', content));
        Query: WHERE to_tsvector('english', content) @@ to_tsquery('search');
        MySQL: CREATE FULLTEXT INDEX idx_fts ON table(content);
        Query: WHERE MATCH(content) AGAINST('search');

Q204. [TRAP] You use MySQL's LIMIT 1000000, 10. Query is extremely slow. Why?
      â†’ MySQL scans and discards the first 1M rows.
        Fix: Use keyset pagination:
        WHERE id > last_seen_id ORDER BY id LIMIT 10;

Q205. [PRODUCTION] Your database has 500 concurrent connections. Performance degrades.
      How do you handle this?
      â†’ Implement connection pooling (HikariCP with Spring Boot).
        Reduce pool size per instance (e.g., 20 connections per app instance).
        Scale horizontally (more app instances with smaller pools).
        Monitor active vs idle connections.
        Consider read replicas for read-heavy workloads.


============================================================
  BONUS SECTION: DEBUGGING PRODUCTION ISSUES (Questions 206-210)
============================================================

Q206. [PRODUCTION CRISIS] Your application throws "Too many open files" error. What's wrong?
      â†’ File descriptor limit exceeded.
        Causes: Unclosed streams, database connections, sockets.
        Debug: lsof -p <pid> | wc -l (count open files)
        Fix: Close resources (try-with-resources).
        Increase limit: ulimit -n 10000 (temporary) or /etc/security/limits.conf (permanent).

Q207. [PRODUCTION CRISIS] Your app's CPU usage is 100%. Thread dumps show all threads in RUNNABLE.
      How do you identify the hot method?
      â†’ Use profiler (VisualVM, YourKit, async-profiler).
        Or sample thread dumps multiple times, look for common stack traces.
        Or use top -H -p <pid> to find the hot thread, then map thread ID to thread dump.

Q208. [PRODUCTION CRISIS] Your database connection pool is exhausted but queries are fast.
      Where are the connections going?
      â†’ Leaked connections: Connections not returned to pool.
        Check: Unclosed EntityManager, transactions not committed.
        Debug: Enable connection pool metrics (HikariCP: hikaricp.metrics).
        Fix: Use try-with-resources or Spring's transaction management.

Q209. [PRODUCTION CRISIS] Your API returns 503 Service Unavailable. Logs show
      "Rejected execution of task". What happened?
      â†’ Thread pool queue is full. New tasks are rejected.
        Causes: Downstream service slow, thread pool too small, queue too small.
        Fix: Increase thread pool size, implement backpressure, add circuit breaker.

Q210. [PRODUCTION CRISIS] Your app works fine for 24 hours, then starts throwing random errors.
      Restarting fixes it temporarily. What could be wrong?
      â†’ Memory leak (heap or metaspace).
        Or thread leak (threads not terminating).
        Or resource leak (connections, file handles).
        Debug: Take heap dumps before/after. Monitor thread count. Check resource usage.


============================================================
  RAPID-FIRE CONCEPTUAL TRAPS (Questions 211-220)
============================================================

Q211. [TRAP] ConcurrentHashMap is thread-safe. Can you use it without synchronization for compound operations?
      â†’ NO. Compound operations (check-then-act, read-modify-write) need synchronization.
        Example: if (!map.containsKey(key)) { map.put(key, value); } â†’ race condition.
        Fix: Use computeIfAbsent(key, k -> value).

Q212. [TRAP] Spring Boot's @Scheduled methods run in a single thread by default. True or false?
      â†’ TRUE. Default thread pool size is 1.
        If one task takes 10 seconds, the next task waits.
        Fix: Configure: spring.task.scheduling.pool.size=10

Q213. [TRAP] Hibernate's @DynamicUpdate generates UPDATE statements with only changed columns. Always beneficial?
      â†’ NO. It prevents batch updates (each entity has a different UPDATE statement).
        Only use when updates are rare and selective.

Q214. [TRAP] You use Optional.of(value). Value is null. What happens?
      â†’ NullPointerException.
        Use Optional.ofNullable(value) when value might be null.

Q215. [TRAP] Stream operations are lazy. Does this guarantee better performance?
      â†’ NO. Overhead of stream creation can exceed benefits for small collections.
        For collections <1000 elements, loops are often faster.

Q216. [TRAP] @Transactional on a method that throws checked exception. Transaction rolls back?
      â†’ NO. By default, only RuntimeException triggers rollback.
        Use @Transactional(rollbackFor = Exception.class).

Q217. [TRAP] You call Thread.sleep() inside a synchronized block. Other threads are blocked. True?
      â†’ TRUE. sleep() does NOT release the lock. Other threads wait.
        Use wait() to release lock while waiting.

Q218. [TRAP] LIMIT 10 OFFSET 1000000 vs WHERE id > 1000000 LIMIT 10. Which is faster?
      â†’ WHERE id > 1000000 is MUCH faster (keyset pagination).
        OFFSET scans and discards 1M rows.

Q219. [TRAP] G1GC is always better than Parallel GC. True or false?
      â†’ FALSE. Parallel GC has higher throughput. Use it for batch jobs.
        G1GC has lower pause times. Use it for latency-sensitive apps.

Q220. [TRAP] ArrayList is faster than LinkedList for all operations. True or false?
      â†’ FALSE. LinkedList is faster for insertions/deletions at the beginning.
        But ArrayList is faster for most real-world use cases due to cache locality.


============================================================
  END OF ADVANCED QUESTIONS
  Good luck with your interview preparation! ğŸš€
============================================================
