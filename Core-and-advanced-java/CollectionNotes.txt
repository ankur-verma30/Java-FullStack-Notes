=============
ğŸ”· Generics
=============
â¤ Generics allow you to define classes, interfaces, and methods with type parameters instead of fixed data types.
â¤ They bring compile-time type safety and code reusability to Java collections and other custom classes.


ğŸ”„ Why use Generics
| Purpose                 | Explanation                                                            |
| ------------------------| ---------------------------------------------------------------------- |
| Type Safety             | Detects invalid data types at compile time                             |
| Code Reusability        | Allows writing one class or method that works with multiple data types |
| Eliminates Type Casting | Removes the need for explicit `(Type)` casting while retrieving data   |
| Compile-Time Checking   | Prevents runtime errors such as `ClassCastException`                   |


âœ… Example:
List<String> names = new ArrayList<>();
names.add("Ankur");
names.add(100); // âŒ Compile-time error (Type safety)
ğŸ‘‰ Without Generics, this would only fail at runtime.


ğŸ”„ Syntax
We use angle brackets <> to define a generic type.
class ClassName<T> { // T is a type parameter
}
Here:
â¤ T â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Type parameter (can be replaced by any object type when using the class).
â¤ You can have multiple parameters: <T, U, V>.
â¤ Conventionally used letters:
    âœ”ï¸ T â†’ Type
    âœ”ï¸ E â†’ Element (used in collections)
    âœ”ï¸ K â†’ Key
    âœ”ï¸ V â†’ Value
    âœ”ï¸ N â†’ Number


âœ… Example â€“ Generic Class
public class GenericsIntro<T, U> {
    private T name;
    private U id;

    public GenericsIntro(T name, U id) {
        this.name = name;
        this.id = id;
    }

    public T getName() { return name; }
    public U getId() { return id; }
}

public class GenericsImpl {
    public static void main(String[] args) {
        GenericsIntro<String, Integer> a1 = new GenericsIntro<>("Ankur", 120);
        System.out.println(a1.getName()); â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Ankur
        System.out.println(a1.getId());   â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ 120
    }
}

âœ… Advantages shown:
    âœ”ï¸ Same class works for different data types.
    âœ”ï¸ Compile-time safety.
    âœ”ï¸ No casting needed.


ğŸ”„ Generic Methods
A method can have its own type parameter even if the class is not generic.
public class Util {
    public static <T> void printArray(T[] array) {
        for (T element : array)
            System.out.println(element);
    }

    public static void main(String[] args) {
        Integer[] numbers = {1, 2, 3};
        String[] names = {"Ankur", "Verma"};
        printArray(numbers);
        printArray(names);
    }
}
â¤ <T> before return type indicates that is a generic method.


=============================
ğŸ”· Wildcards in Generics (?)
=============================
â¤ The wildcard ? is an unknown type.
â¤ Used when the exact type parameter is not important.
â¤ Wildcards allow flexibility when you don't know the exact type.

1ï¸âƒ£ Unbounded Wildcard â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ <?>
â¤ Means â€œany typeâ€.
public void printList(List<?> list) {
    for (Object obj : list) {
        System.out.println(obj);
    }
}
âœ… Can read data
âŒ Cannot write(expect null).


2ï¸âƒ£ Upper Bounded Wildcard â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ <? extends Type>
â¤ Means â€œType or any subclass of Typeâ€.
â¤ Use when: You want to read data but not modify it.
public void processNumbers(List<? extends Number> list) {
    for (Number num : list) {
        System.out.println(num.doubleValue());
    }
}
âœ… Can read as Number
âŒ Cannot add new elements(because it might be List<Double> or List<Integer> â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ not safe).


3ï¸âƒ£ Lower Bounded Wildcard â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ <? super Type>
â¤ Means â€œType or any superclass of Typeâ€.
â¤ Use when: You want to write data.
public void addIntegers(List<? super Integer> list) {
    list.add(10);
    list.add(20);
}

ğŸ”„ Producer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ extends
â¤ If the list gives you data, use extends
ğŸ‘‰ Think: I am only taking things out of the list

âœ… Example: List<? extends Animal> animals;
ğŸ‘‰ This means:
    âœ”ï¸ The list contains Animal or its children(Dog, Labrador etc.)
    âœ”ï¸ You don't know the exact type.
    âœ”ï¸ But whatever you get is at least an Animal.

ğŸ”„ What you can do
Animal a=animals.get(0); //âœ… allowed
animals.add(new Animal()); //âŒ not allowed

ğŸ”„ Why?
Because Java doesn't know:
    âœ”ï¸ Is it a List<Dog>?
    âœ”ï¸ Is it a List<Cat>?
    âœ”ï¸ Is it a List<Animal>?

ğŸ”„ Consumer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ super
"If the list takes your data, use super"
ğŸ‘‰ Think: I am putting things into the list

âœ… Example:
List<? super Dog>dogs;
This means:
    âœ”ï¸ List<Dog>
    âœ”ï¸ List<Labrador>
    âœ”ï¸ List<Animal>
    âœ”ï¸ List<Object>

ğŸ”„ What you can do
dogs.add(new Dog());       // âœ… allowed
dogs.add(new Labrador()); // âœ… allowed

ğŸ”„ What you CANNOT safely do
Dog d=dogs.get(0); //âŒ not allowed
dogs.add(new Animal()); //âŒ not allowed


â“ Why?
Because Java doesn't know: This list can hold Dogs, but I don't know what it actually stores."
    âœ”ï¸ Is it a List<Dog>?
    âœ”ï¸ Is it a List<Cat>?
    âœ”ï¸ Is it a List<Animal>?


ğŸ”„ Why not use both read and write?
| Type                     | Can Read                 | Can Write      |
| ------------------------ | ----------------------   | -------------  |
| `extends`                | âœ… Yes (as parent type) | âŒ No          |
| `super`                  | âŒ No (only `Object`)   | âœ… Yes         |
| Exact type (`List<Dog>`) | âœ… Yes                  | âœ… Yes         |
ğŸ‘‰ Only exact type gives full freedom


ğŸ”„ PECS(Producer Extends, Consumer Super) rule
| Situation                      | Wildcard to Use     | Reason                               |
| -------------------------------| ------------------- | ------------------------------------ |
| You only read / produce items  | `<? extends T>`     | Guarantees type safety while reading |
| You only write / consume items | `<? super T>`       | Guarantees type safety while adding  |


ğŸ”„ Trap Questions
| Trap                                                      | Explanation                                                         |
| -------------------------------------------------------   | ------------------------------------------------------------------- |
| âŒ You canâ€™t use primitive types with generics           | `List<int>` is invalid; use wrapper types like `List<Integer>`      |
| âŒ Generic type info is erased at runtime (Type Erasure) | JVM removes generic type information after compilation              |
| âŒ Cannot create instances of type parameter             | `T obj = new T();` âŒ not allowed due to type erasure               |
| âŒ Cannot use static variables of generic type           | Static members are shared across all instantiations, but `T` varies |
| âŒ Arrays and Generics donâ€™t mix well                    | `new List<String>[10]` âŒ causes type-safety issues                 |


=================
ğŸ”· Type Erasure
=================
Java removes generic type information at runtime and replaces it with Object(or a bound).
ğŸ‘‰ Generics are only for compile-time saftey, not runtime.

ğŸ”„ Why does Java use Type Erasure?
Main reason:
âœ”ï¸ Backward compatibility
â¤ Java generics were introduced in Java 5.
â¤ Old Java code (pre-generics) should still work.
â¤ So the JVM:
    âœ”ï¸ Does not know List<String> or List<Integer>
    âœ”ï¸ It only sees List


âœ… Example:
Code you write:
List<String> names=new ArrayList<>();
names.add("Ankur");

What JVM actually sees:
List names=new ArrayList();
names.add("Ankur");
ğŸ‘‰ The <String> part is erased


ğŸ”„ Another Example
List<String> list1 = new ArrayList<>();
List<Integer> list2 = new ArrayList<>();

System.out.println(list1.getClass() == list2.getClass());
âœ… Output: true

ğŸ”„ Why?
Because after type erasure, both become: List


ğŸ”„ How Type Erasure Works Internally
1ï¸âƒ£ Unbounded generics
class Box<T>{
    T value;
}

After type erasure:
class Box{
    Object value;
}


2ï¸âƒ£ Bounded generics
class Box<T extends Number>{
    T value;
}

After type erasure:
class Box{
    Number value;
}
ğŸ‘‰ Bound replaces Object


ğŸ” Why Some Things Are NOT Allowed in Generics
Because type info is gone at runtime

âŒ Cannot create generic arrays
T[] arr=new T[10]; //âŒ not allowed
â¤ JVM doesn't know what T is at runtime

âŒ Cannot use instanceof with generics
if (obj instanceof List<String>) // âŒ not allowed

But this is allowed:
if (obj instanceof List<?>) // âœ… allowed

âŒ Cannot overload methods only by generic type
void print(List<String> list)
void print(List<Integer> list) // âŒ compile-time error

Add erasure, both look like: void print(List list)


=====================================
ğŸ”·How Java Still Ensures Type Safety
=====================================
ğŸ”„ Using compile-time checks + casting
List<String> names = new ArrayList<>();
names.add("Ankur");

String name = names.get(0); // implicit cast

ğŸ‘‰ After erasure: String name=(String )names.get(0);


================
ğŸ”· Collections
================
â¤ Collections in Java refer to a framework (set of classes and interfaces) that provide ready-made data structures for storing, retrieving, and manipulating groups of objects efficiently.
â¤ It is defined in the package: java.util
â¤ Think of Collections Framework as a toolbox of reusable data structures (like Lists, Sets, Queues, Maps) that save you from writing custom logic for storage and searching.


ğŸ”„ Why Collections Framework?
Before Java 1.2, developers used arrays, Vectors, or Hashtables â€” which were:
    âœ”ï¸ Fixed in size
    âœ”ï¸ Lacked type safety
    âœ”ï¸ Hard to manipulate
ğŸ‘‰ The Java Collections Framework (JCF) unified these into a consistent architecture.


âŒ Drawbacks or limitations
1ï¸âƒ£ Inconsistency â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Each class had a different way of managing collections, leading to confusion and a steep learning curve.
2ï¸âƒ£ Lack of inter-operability â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ These classes were not designed to work together seamlessly.
3ï¸âƒ£ No common Interface â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ There was no common interface for all these classes which meant you couldn't write generic algorithms that could operate on different types of collections.
ğŸ‘‰ To solve those problems, the Collection Framework was introduced in JDK 1.2.


ğŸ”„ Key Features of Collections Framework
1ï¸âƒ£ Consistent Interfaces â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Common methods across all collections (add(), remove(), size())
2ï¸âƒ£ Dynamic Size â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Can grow or shrink at runtime
3ï¸âƒ£ Type Safety â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Supports Generics
4ï¸âƒ£ Polymorphic Algorithms â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Works with all types of collections (Collections.sort(), Collections.reverse())
5ï¸âƒ£ Ready Implementations â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Efficient, tested data structures
6ï¸âƒ£ Thread-Safe Options â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Concurrent collections (ConcurrentHashMap, CopyOnWriteArrayList)


===========================================
ğŸ”· Key Interfaces in Collection Framework
===========================================
The hierarchy starts from the top-level interface Iterable and branches into key interfaces:

1ï¸âƒ£ Iterable
â¤ Root interface of the collection hierarchy.
â¤ All collection classes implement this indirectly.
â¤ Provides iterator() to traverse elements using Iterator.
ğŸ”— Iterator<T> iterator();


2ï¸âƒ£ Collection
â¤ Extends Iterable.
â¤ The base interface for all collections except Map.
â¤ Defines basic operations like add(), remove(), clear(), size().

âœ… Example:
ğŸ”— boolean add(E e);
ğŸ”— boolean remove(Object o);
ğŸ”— int size();

ğŸ”„ Subinterfaces of Collection:
1ï¸âƒ£ List
2ï¸âƒ£ Set
3ï¸âƒ£ Queue
4ï¸âƒ£ (Since Java 21) SequencedCollection


3ï¸âƒ£ List Interface
â¤ Ordered collection (elements have index).
â¤ Allows duplicates.
â¤ Can access elements by index.

Implementations:
âœ”ï¸ ArrayList
âœ”ï¸ LinkedList
âœ”ï¸ Vector
âœ”ï¸ Stack
âœ”ï¸ CopyOnWriteArrayList


4ï¸âƒ£ Set Interface
â¤ Unordered and unique elements (no duplicates).
â¤ Follows mathematical set behavior.

Implementations:
    âœ”ï¸ HashSet
    âœ”ï¸ LinkedHashSet
    âœ”ï¸ TreeSet
    âœ”ï¸ EnumSet
    âœ”ï¸ CopyOnWriteArraySet


5ï¸âƒ£ Queue Interface
â¤ Follows FIFO (First In, First Out) order.
â¤ Used to hold elements before processing.

Implementations:
    âœ”ï¸ LinkedList
    âœ”ï¸ PriorityQueue
    âœ”ï¸ ArrayDeque
    âœ”ï¸ ConcurrentLinkedQueue
    âœ”ï¸ BlockingQueue (and its subclasses)


6ï¸âƒ£ Deque Interface (extends Queue)
â¤ Double-ended queue â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ allows insertion/removal from both ends.
â¤ Supports both FIFO and LIFO behaviors.

Implementations:
    âœ”ï¸ ArrayDeque
    âœ”ï¸ LinkedList
    âœ”ï¸ ConcurrentLinkedDeque


7ï¸âƒ£ Map Interface (Separate Hierarchy)
â¤ Stores keyâ€“value pairs.
â¤ Unique keys, values can be duplicated.
â¤ Not a subtype of Collection.

Implementations:
    âœ”ï¸HashMap
    âœ”ï¸LinkedHashMap
    âœ”ï¸TreeMap
    âœ”ï¸WeakHashMap
    âœ”ï¸ConcurrentHashMap
    âœ”ï¸Hashtable
    âœ”ï¸EnumMap


======================================
ğŸ”· Hierarchy of Collection Framework
======================================
Iterable
â””â”€â”€ Collection
    â”œâ”€â”€ SequencedCollection
            â”œâ”€â”€ List
            |    â”œâ”€â”€ ArrayList
            |    â”œâ”€â”€ LinkedList
            |    â”œâ”€â”€ Vector
            |    â”œâ”€â”€ Stack
            |    â””â”€â”€ CopyOnWriteArrayList
            â”‚
            â”œâ”€â”€ Set
            â”‚   â”œâ”€â”€ HashSet
            â”‚   â”œâ”€â”€ LinkedHashSet
            â”‚   â”œâ”€â”€ TreeSet
            â”‚   â”œâ”€â”€ EnumSet
            â”‚   â”œâ”€â”€ ConcurrentSkipListSet
            â”‚   â”œâ”€â”€ SortedSet
            â”‚   â””â”€â”€ CopyOnWriteArraySet
            â”‚
            â””â”€â”€ Queue
                â”œâ”€â”€ LinkedList
                â”œâ”€â”€ PriorityQueue
                â”œâ”€â”€ Deque
                â”‚   â”œâ”€â”€ ArrayDeque
                â”‚   |â”€â”€ LinkedList (also Deque)
                |   |â”€â”€ ConcurrentLinkedDeque
                â”œâ”€â”€ BlockingQueue
                â”‚   â”œâ”€â”€ ArrayBlockingQueue
                â”‚   â”œâ”€â”€ LinkedBlockingQueue
                â”‚   â”œâ”€â”€ PriorityBlockingQueue
                â”‚   â”œâ”€â”€ SynchronousQueue
                â”‚   â””â”€â”€ DelayQueue
                â””â”€â”€ ConcurrentLinkedQueue

 The hierarchy flows from Iterable â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Collection â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ SequencedCollection â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ List â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ ArrayList.

Letâ€™s break this down step by step:
===========================
ğŸ”· Iterable<E> (Interface)
===========================
â¤ Iterable is the top-most interface in the Java Collections Framework hierarchy.
â¤ Every collection class in Java (like List, Set, Queue, etc.) implements Iterable directly or indirectly.

âš¡Package: java.lang
â¤ Introduced in: Java 5 (as part of Generics & enhanced for-loop support)

ğŸ”„ Syntax:
public interface Iterable<T> {
    Iterator<T> iterator();
}
ğŸ‘‰ Here:
    âœ”ï¸ T â†’ Generic type parameter (the type of elements to iterate).
    âœ”ï¸ Any class implementing Iterable must provide an implementation for the iterator() method.


ğŸ”„ Purpose of Iterable
â¤ The main purpose of the Iterable interface is to provide a standard way to traverse elements of a collection, one by one.
â¤ It allows:
    âœ”ï¸ Iteration using Iterator
    âœ”ï¸ Enhanced for-loop (for-each loop)
    âœ”ï¸ Stream creation (Java 8+)


ğŸ”„ Key Methods of Iterable
| Method                                             | Description                                                              | Since     |
| -------------------------------------------------- | ------------------------------------------------------------------------ | --------- |
| `Iterator<T> iterator()`                           | Returns an Iterator over elements of type `T`.                           | Java 5    |
| `default void forEach(Consumer<? super T> action)` | Performs the given action for each element (commonly used with lambdas). | Java 8    |


ğŸ”„ Method 1ï¸âƒ£:iterator()
This is the core abstract method every implementing class must define.
Iterator<T> iterator();

It returns an Iterator, which has the following methods:
ğŸ”— boolean hasNext();
ğŸ”— T next();
ğŸ”— void remove(); // optional

âœ…Example:
List<String> names = new ArrayList<>();
names.add("Ankur");
names.add("Verma");

Iterator<String> it = names.iterator();
while (it.hasNext()) {
    System.out.println(it.next());
}


â¤ Removal of elements is allowed while iterating.
Iterator<Integer> itr=numbers.iterator();
while(itr.hasNext()){
    Integer i=itr.next();
    if(i%2==0){
        itr.remove();
    }
}


=================
ğŸ”· ListIterator
=================
â¤ In the Java Collections Framework, the ListIterator is an interface that extends the standard Iterator. While a regular Iterator only allows you to move forward through a list, a ListIterator allows for bidirectional traversal and modification of the list during iteration.
â¤ It is specifically designed for use with List implementations like ArrayList, LinkedList, and Vector.

ğŸ”„ Key Features of ListIterator
The ListIterator offers several advantages over the basic Iterator:
    âœ”ï¸ Bidirectional â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ You can move both forward and backward.
    âœ”ï¸ Index-Aware â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ You can retrieve the current index of the cursor.
    âœ”ï¸ Modification â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ You can add, remove, or replace elements during iteration.


ğŸ”„ Internal Cursor Mechanism
The ListIterator maintains a cursor position between elements. When you call next(), the cursor moves over the element and returns it. When you call previous(), it moves back over the element and returns it.


ğŸ”„ Core Methods Breakdown
1ï¸âƒ£ Forward Navigation
ğŸ”— boolean hasNext() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns true if there are more elements in the forward direction.
ğŸ”— E next() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns the next element and moves the cursor forward.


2ï¸âƒ£ Backward Navigation
ğŸ”— boolean hasPrevious() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns true if there are more elements in the reverse direction.
ğŸ”— E previous() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns the previous element and moves the cursor backward.


3ï¸âƒ£ Index Tracking
ğŸ”— int nextIndex() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns the index of the element that would be returned by a subsequent call to next().
ğŸ”— int previousIndex() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns the index of the element that would be returned by a subsequent call to previous().


4ï¸âƒ£ Element Modification
ğŸ”— void add(E e) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Inserts the specified element into the list immediately before the element that would be returned by next().
ğŸ”— void set(E e) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Replaces the last element returned by next() or previous() with the specified element.
ğŸ”— void remove() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Removes the last element returned by next() or previous().


ğŸ”„ Comparison between ListIterator and Iterator
| **Feature**       | **Iterator**                        | **ListIterator**                         |
| ----------------- | ----------------------------------- | ---------------------------------------- |
| **Direction**     | Forward only                        | Forward and backward                     |
| **Applicability** | Any `Collection` (Set, List, Queue) | `List` only                              |
| **Add elements**  | âŒ No                                | âœ… Yes                                    |
| **Get index**     | âŒ No                                | âœ… Yes (`nextIndex()`, `previousIndex()`) |
| **Set / replace** | âŒ No                                | âœ… Yes (`set()`)                          |


âœ…Example:
import java.util.*;

public class ListIteratorExample {
    public static void main(String[] args) {
        List<String> names = new ArrayList<>(Arrays.asList("Alice", "Bob", "Charlie"));
        ListIterator<String> litr = names.listIterator();

        // Moving Forward
        while (litr.hasNext()) {
            String name = litr.next();
            if (name.equals("Bob")) {
                litr.set("Bobby"); // Replacing an element
            }
        }

        // Moving Backward
        while (litr.hasPrevious()) {
            System.out.println(litr.previous()); // Outputs Charlie, Bobby, Alice
        }
    }
}


ğŸ”„ Important Constraints
1ï¸âƒ£ IllegalStateException: Methods like remove() and set() can only be called after a call to next() or previous().
2ï¸âƒ£ Concurrent Modification: If the list is structurally modified (e.g., using list.add()) while using the iterator, it will throw a ConcurrentModificationException. Always use litr.add() instead.


ğŸ”„ Method2: forEach()
Introduced in Java 8 provides a functional way to iterate
default void  forEach(Consumer<? super T> action)

âœ…Example: names.forEach(n -> System.out.println(n.toUpperCase()));
âœ”ï¸ Simplifies iteration
âœ”ï¸ Works well with Lambda expressions and Streams

â¤ Enables use of the enhanced for-each loop:
âœ”ï¸ for (String s : someCollection) {}
âœ… So, any class implementing Iterable automatically supports enhanced for-loops.


âœ… Custom Iterable Example
Can create our own class implementing Iterable:
import java.util.Iterator;
import java.util.NoSuchElementException;

public class MyIterable implements Iterable<Integer> {
    private int[] data = {10, 20, 30, 40};

    @Override
    public Iterator<Integer> iterator() {
        return new Iterator<Integer>() {
            int index = 0;
            public boolean hasNext() {
                return index < data.length;
            }
            public Integer next() {
                if (!hasNext()) throw new NoSuchElementException();
                return data[index++];
            }
        };
    }

    public static void main(String[] args) {
        MyIterable obj = new MyIterable();
        for (int val : obj) {
            System.out.println(val);
        }
    }
}
âœ… Output:
10
20
30
40


ğŸ”„ Relationship with Iterator
| Feature | Iterable                                   | Iterator                             |
| --------| ------------------------------------------ | ------------------------------------ |
| Type    | Interface that provides `iterator()`       | Interface used to traverse elements  |
| Purpose | Supplies an `Iterator` object              | Performs the actual iteration        |
| Methods | `iterator()`, `forEach()`, `spliterator()` | `hasNext()`, `next()`, `remove()`    |
| Usage   | Implemented by collection classes          | Used by `for-each` and `while` loops |


=============================
ğŸ”· Collection<E> (Interface)
=============================
The Collection interface in Java is the root interface of the Java Collections Framework. It resides in the java.util package and represents a group of objects known as its elements. It defines the basic operations that all collection classes must implement or support.
â¤ Root interface for all collection types (except maps).
â¤ Extends: Iterable<E>
â¤ Common Subinterfaces: List, Set, Queue, etc.


ğŸ”„ Details of Collection Interface
â¤ Hierarchy Root:Â It is at the top of the collection interface hierarchy. Subinterfaces like List, Set, and Queue extend it.
â¤ Purpose:Â Allows manipulation of groups of objects independently of their representation or implementation.
â¤ Common Methods
    âœ”ï¸ add(E e) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Add an element.
    âœ”ï¸ remove(Object o) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Remove an element.
    âœ”ï¸ contains(Object o) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Check if an element exists.
    âœ”ï¸ size() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns number of elements.
    âœ”ï¸ isEmpty() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Checks if empty.
    âœ”ï¸ clear() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Removes all elements.
    âœ”ï¸ iterator() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns an iterator over the elements.
    âœ”ï¸ Bulk operations likeÂ addAll(),Â removeAll(),Â retainAll().

â¤  No Direct Instantiation â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶Â As an interface, it cannot be instantiated directly. Instead, you use concrete classes (e.g. ArrayList, HashSet) that implement Collection and assign them to a Collection reference.
â¤  Common Subinterfaces
    âœ”ï¸ List â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶Â Ordered collections allowing duplicates, accessible by index (e.g., ArrayList).
    âœ”ï¸ Set â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶Â Collections with unique elements, no duplicates allowed (e.g., HashSet).
    âœ”ï¸ Queue â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶Â Collection models a FIFO (First-In-First-Out) structure (e.g., PriorityQueue).


ğŸ”„ Advantages of Collection Interface
â¤ Provides a uniform API to handle different types of collections.
â¤ Enables interchangeable use of collection types adhering to the same interface.
â¤ Defines the contract for collections to support iteration, adding, removing, and searching.


âœ… Example:
Collection<String> fruits = new ArrayList<>();
fruits.add("Apple");
fruits.add("Banana");
fruits.add("Mango");
Here, an ArrayList implementing Collection interface is used, enabling manipulation of the elements via Collection methods.


â“ Collection is root or Iterable?
â¤ The Collection interface is often called the root interface of the Java Collections Framework because it defines the fundamental operations common to all collections. However, it itself extends the Iterable interface, which means:
    âœ”ï¸ Iterable interfaceÂ is a more general contract that provides the ability to obtain an iterator over elements, enabling iteration. It declares theÂ iterator() method.
    âœ”ï¸ TheÂ Collection interface extends Iterable, meaning it inherits the ability to be iterated, but adds more specific methods for adding, removing, querying, and bulk operations on groups of elements.

â¤ So, calling Collection the "root" interface refers to it being theÂ root of most collection types in the frameworkÂ (like List, Set, Queue), defining the core behaviors of collections beyond basic iteration.
â¤ The Iterable interface is a more basic iteration capability interface, while Collection builds on it to provide a richer API for manipulating collections of objects.


========================================
ğŸ”· SequencedCollection<E> (Interface)
========================================
The SequencedCollection interface is a new interface introduced in Java 21 that extends the Collection interface to represent collections with a well-defined encounter (iteration) order. It models collections whose elements have a linear sequence from a first element to a last element, supporting operations at both ends and reversible iteration.
â¤ Purpose â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Provides a standardized way to handle ordered collections (like first and last elements).


ğŸ”„ Key Characteristics of SequencedCollection
â¤ Defines a strict encounter order of elements conceptually arranged in sequence.
â¤ Supports operations at both the front and back ends of the collection, such as:
    âœ”ï¸ addFirst(E e) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶Â  add element at the beginning.
    âœ”ï¸ addLast(E e) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶Â  add element at the end.
    âœ”ï¸ getFirst() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶Â  get the first element.
    âœ”ï¸ getLast() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶Â  get the last element.
    âœ”ï¸ removeFirst() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶Â  remove and return the first element.
    âœ”ï¸ removeLast() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶Â  remove and return the last element.
â¤ Provides a methodÂ reversed()Â which returns a view of the collection in reverse order.
â¤ Extends the Collection interface, thus inherits all standard collection operations.
â¤ Enables efficient manipulation and traversal of ordered elements from both ends.
â¤ Conceptually similar to a Deque but generalized for collections beyond just double-ended queues.


ğŸ”„ Use and Significance
â¤ It formalizes collections with order and two-ended operations.
â¤ Supports processing the elements both forward and in reverse.
â¤ Enables uniform APIs for ordered collections in the Java Collections Framework.
â¤ Forms the base for new related interfaces like SequencedSet and SequencedMap.


âœ… Example
SequencedCollection<String> seqCollection = ...;
seqCollection.addFirst("start");
seqCollection.addLast("end");
String first = seqCollection.getFirst();
String last = seqCollection.getLast();
SequencedCollection<String> reversedView = seqCollection.reversed();


âœ… Example demonstrating how to implement and use the SequencedCollection interface in Java 21
import java.util.SequencedCollection;
import java.util.LinkedList;

public class SequencedCollectionExample {
    public static void main(String[] args) {
        *// LinkedList implements SequencedCollection as of Java 21*
        SequencedCollection<String> seqCollection = new LinkedList<>();

        *// Add elements at the front and end*
        seqCollection.addFirst("First");
        seqCollection.addLast("Second");
        seqCollection.addLast("Third");

        *// Access first and last elements*
        String first = seqCollection.getFirst();
        String last = seqCollection.getLast();
        System.out.println("First Element: " + first);
        System.out.println("Last Element: " + last);

        *// Remove first and last elements*
        String removedFirst = seqCollection.removeFirst();
        String removedLast = seqCollection.removeLast();
        System.out.println("Removed First Element: " + removedFirst);
        System.out.println("Removed Last Element: " + removedLast);

        *// Add one more element at the end*
        seqCollection.addLast("Fourth");

        *// Iterate in normal order*
        System.out.println("Normal iteration:");
        for (String s : seqCollection) {
            System.out.println(s);
        }

        *// Get and iterate using reversed view*
        SequencedCollection<String> reversed = seqCollection.reversed();
        System.out.println("Reversed iteration:");
        for (String s : reversed) {
            System.out.println(s);
        }
    }
}
ğŸ‘‰ This example shows:
â¤ Adding elements at both ends of the collection usingÂ addFirstÂ andÂ addLast.
 Accessing and removing elements from the front and back.
 Iterating elements in both forward and reverse order withÂ reversed().

âš¡ Note: To run this code, you need Java 21 or later, as the SequencedCollection interface and related methods are introduced in Java 21. The LinkedList class is enhanced to implement this interface supporting dual-ended operations and reversed views.


===================
ğŸ”· List Interface
===================
The List interface is part of the Java Collections Framework and represents an ordered collection (also known as a sequence). It extends the Collection interface and provides additional methods to manipulate elements based on their integer index.

ğŸ”„ Key Features of List Interface:
â¤ Maintains the order of insertion; elements can be accessed by their position (index).
â¤ Allows duplicate elements.
â¤ Supports positional access and insertion of elements.
â¤ Provides methods to search for elements and manipulate elements by their position.
â¤ Allows null elements.


ğŸ”„ Common Methods Defined in List
â¤ add(E e) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Adds element at the end.
â¤ add(int index, E element) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Inserts element at specific index.
â¤ get(int index) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Retrieves element at given index.
â¤ set(int index, E element) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Replaces element at index.
â¤ remove(int index) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Removes element at specific index.
â¤ indexOf(Object o) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns first occurrence index of element else -1.
â¤ lastIndexOf(Object o) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns last occurrence index else -1.
â¤ listIterator() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns a List Iterator for bidirectional traversal.


ğŸ”„ Common Implementations
ArrayList â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Resizable array implementation, fast random access but slower insertions/removals in the middle.
LinkedList â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Doubly-linked list implementation, good for frequent insertions/removals.
Vector â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Synchronized resizable array (legacy).
Stack â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Last-In-First-Out stack built on Vector.


âœ… Example Code:
import java.util.List;
import java.util.ArrayList;

public class ListExample {
    public static void main(String[] args) {
        List<String> fruits = new ArrayList<>();
        fruits.add("Apple");
        fruits.add("Banana");
        fruits.add("Cherry");
        fruits.add(1, "Mango"); // Insert at index 1

        System.out.println("Fruits List: " + fruits); // [Apple, Mango, Banana, Cherry]

        String fruit = fruits.get(2);
        System.out.println("Element at index 2: " + fruit); // Banana

        fruits.set(2, "Grapes");
        System.out.println("After setting index 2: " + fruits); // [Apple, Mango, Grapes, Cherry]

        fruits.remove(3);
        System.out.println("After removing index 3: " + fruits); // [Apple, Mango, Grapes]

        int index = fruits.indexOf("Mango");
        System.out.println("Index of Mango: " + index); // 1
    }
}


==============
ğŸ”· ArrayList
==============
â¤ ArrayList is a resizablearray implementation of the List interface in Java.
â¤ It allows dynamic arrays that can grow as needed, unlike plain arrays with fixed size.
â¤ This flexibility makes it a popular choice when the number of elements in a list isn't known in advance.
â¤ Part of the Java Collections Framework and located inÂ java.utilÂ package.


ğŸ”„ Key Features
â¤ Resizable â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶Â Internally uses a dynamic array that increases its size by 50% when capacity is exceeded.
â¤ Indexed Access â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶Â Supports fast random access by index with O(1) time complexity forÂ get()Â andÂ set().
â¤ Allows Duplicates & Nulls â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶Â Can store duplicate elements and null values.
â¤ Insertion Order â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶Â Maintains the order in which elements are inserted.
â¤ Non-synchronized â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶Â Not thread-safe by default; useÂ Collections.synchronizedList()Â for thread safety.


ğŸ”„ Internal Working
â¤ Internally maintains an array calledÂ elementData.
â¤ When adding elements exceeds capacity, the array grows by approximately 50%.
â¤ Copying of the old array to new array happens during resizing, which is costly (O(n)).
â¤ Adding elements at the end is generally O(1) amortized; inserting or removing at middle involves shifting elements O(n).


ğŸ”„ Important Methods
â¤ add(E e) Â â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Adds element at the end.
â¤ add(int index, E element) Â â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Inserts at specified position, shifting elements.
â¤ get(int index) Â â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Retrieves element at index quickly.
â¤ set(int index, E element) Â â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Replaces element at index.
â¤ remove(int index) Â â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Removes element at index, shifts subsequent elements.
â¤ size() Â â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns number of elements.
â¤ contains(Object o) Â â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Checks if an element is present.
â¤ clear() Â â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Removes all elements.


ğŸ”„ Time Complexity
| Operation                 | Time Complexity        |
| --------------------------| -----------------------|
| Access by index           | O(1)                   |
| Add at end                | O(1) amortized         |
| Insert / remove at middle | O(n) (due to shifting) |
| Search (contains)         | O(n)                   |
| Resize (occasional)       | O(n)                   |


ğŸ”„ When to Use ArrayList
â¤ When frequent random access is needed.
â¤ When insertions and deletions mainly occur at the end.
â¤ When you want a dynamically resizable array.


âŒ When Not to Use ArrayList
â¤ When thread safety is needed (use Vector or Collections.synchronizedList).
â¤ When frequent insertions/deletions at start or middle of the list are expected (LinkedList preferred).


ğŸ”„ Differences from Array
â¤ Arrays have fixed size, ArrayList grows dynamically.
â¤ ArrayList provides methods for easy manipulation (add, remove, search).
â¤ Arrays can store primitives directly; ArrayList stores objects (use wrapper classes for primitives).


ğŸ” Understand internal resizing mechanics and performance costs.
ğŸ”„ Internal Resizing Mechanics of ArrayList
1ï¸âƒ£ Initial Capacity â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ When an ArrayList is created without specifying capacity, it typically starts with a default capacity (commonly 10). Internally, it maintains an array calledÂ elementDataÂ to store elements.
2ï¸âƒ£ Adding Elements â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ When elements are added, they are placed sequentially in the internal array.
3ï¸âƒ£ Resizing Trigger â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ When the number of elements exceeds the current capacity, ArrayList must resize its internal array to accommodate new elements.
4ï¸âƒ£ Resize Operation:
    Resizing involves:
    âœ”ï¸ Creating a new, larger array (usually 1.5 times the original capacity).
    âœ”ï¸ Copying existing elements from the old array to the new array.
    âœ”ï¸ Assigning the new array as the backing storage.

5ï¸âƒ£ Capacity Growth Strategy: The capacity generally increases by about 50% over the old capacity (not doubling exactly, unlike some other systems). For example, if the capacity is 10, after resizing it might become 15.
    
6ï¸âƒ£ Amortized Cost: Although resizing is an expensive operation (O(n) due to array copy), it does not occur with every insertion. MostÂ `add()`Â operations run in O(1) time. The occasional cost of resizing is spread out over many insertions, leading to an amortized time complexity of O(1) for additions at the end.
    

ğŸ”„ Performance Costs Explained
| Operation                    | Time Complexity Details                                                                                  |
| -----------------------------| ---------------------------------------------------------------------------------------------------------|
| Adding element at end        | O(1) amortized â€” most insertions are constant time; occasional resizing costs O(n) but is infrequent     |
| Adding element in middle     | O(n) â€” elements to the right of the index must be shifted                                                |
| Removing element from middle | O(n) â€” elements to the left must shift to fill the gap                                                   |
| Access by index              | O(1) â€” direct access using the internal array                                                            |
| Contains / Search            | O(n) â€” requires linear traversal of elements                                                             |


ğŸ”„ Important Points
â¤ Resizing can cause temporary performance hiccups due to:
    âœ”ï¸ Memory allocation for larger array.
    âœ”ï¸ Copying all elements from old array to new array.
â¤ Over-allocating capacity initially when the expected size is known can reduce resizing costs.
â¤ Frequent insertions/removals in the middle make ArrayList inefficient compared to linked structures.


âœ… Example of Resizing (Conceptual)
â¤ Initially: capacity = 10
â¤ Add elements 1 to 10 â†’ No resize needed
â¤ Add 11th element â†’ Resize: Make new array with capacity ~15, copy 10 elements to new array, add 11th element


ğŸ”„ Ways to create ArrayList
Here are the main ways to create an ArrayList in Java, important for placements:

1ï¸âƒ£ Default Constructor (Empty ArrayList)
ArrayList<String> list = new ArrayList<>();
ğŸ‘‰ Creates an empty ArrayList with an initial capacity of 10 by default.


2ï¸âƒ£ Constructor with Initial Capacity
ArrayList<String> list = new ArrayList<>(50);
ğŸ‘‰ Creates an empty ArrayList but with specified initial capacity to optimize resizing if size is known.


3ï¸âƒ£ Constructor with Collection
List<String> collection = Arrays.asList("A", "B", "C");
ArrayList<String> list = new ArrayList<>(collection);
ğŸ‘‰ Creates an ArrayList initialized with elements from the specified collection.


4ï¸âƒ£ UsingÂ `Arrays.asList()`Â and Constructor
ArrayList<String> list = new ArrayList<>(Arrays.asList("One", "Two", "Three"));
ğŸ‘‰ Initialize ArrayList from existing array elements conveniently.


5ï¸âƒ£ Using Java 9+Â `List.of()`Â Factory Method
ArrayList<String> list = new ArrayList<>(List.of("Alpha", "Beta", "Gamma"));
ğŸ‘‰ Creates an unmodifiable list, wrapped by ArrayList for modifiable access; requires Java 9+.


6ï¸âƒ£ Collecting from Stream
List<String> list = Stream.of("x", "y", "z").collect(Collectors.toCollection(ArrayList::new));
ğŸ‘‰ Creates and collects elements from a Stream into a new ArrayList.


ğŸ”„ Common Operations on ArrayList
Here is a comprehensive overview of common operations on ArrayList in Java, covering typical usage you'll need for placements:

1ï¸âƒ£Â Add Elements
â¤ list.add(10); â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ add element at the end
â¤ list.add(1, 20); â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ insert element at index 1
â¤ list.addAll(otherList); â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ add all elements from another collection

2ï¸âƒ£Â Access Elements
â¤ int x = list.get(0); â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ get element at index 0

3ï¸âƒ£Â Update Elements
â¤ list.set(1, 50); â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ update element at index 1

4ï¸âƒ£Â Remove Elements
â¤ list.remove(2); â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ remove element at index 2
â¤ list.remove(Integer.valueOf(10)); â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ remove first occurrence of value 10
â¤ list.clear(); â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ remove all elements

5ï¸âƒ£Â Search Operations
â¤ boolean present = list.contains(30); â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ check if element exists
â¤ int idx = list.indexOf(50); â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ get first occurrence index of element 50
â¤ int lastIdx = list.lastIndexOf(50); â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ get last occurrence index

6ï¸âƒ£Â Iteration
    1ï¸âƒ£ For-each loop 
    for(Integer val : list) { System.out.println(val); }

    2ï¸âƒ£ Using Iterator  
    Iterator<Integer> it = list.iterator();
    while(it.hasNext()) System.out.println(it.next());

    
    3ï¸âƒ£ Using ListIterator (forward & backward)
    ListIterator<Integer> itr = list.listIterator();
    while(itr.hasNext()) System.out.println(itr.next());
    while(itr.hasPrevious()) System.out.println(itr.previous());

    
    4ï¸âƒ£ Using forEach + Lambda
    list.forEach(System.out::println);

    
7ï¸âƒ£Â Size & Capacity
â¤ int size = list.size(); â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ get current size
â¤ boolean empty = list.isEmpty(); â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ check if empty


8ï¸âƒ£Â Conversion
    1ï¸âƒ£ ArrayList to Array:
    Integer[] arr = list.toArray(new Integer[0]);

    2ï¸âƒ£ Array to ArrayList:
    ArrayList<Integer> list = new ArrayList<>(Arrays.asList(arr));


===============
ğŸ”· Comparator
===============
A comparator in Java is a functional interface used to define custom ordering logic for objects. It belongs to theÂ java.utilÂ package and provides a way to compare two objects to determine their relative ordering, which is essential for sorting collections of objects by criteria different from their natural ordering.

â¤ Interface â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶Â Comparator<T>Â is a generic interface that compares two objects of typeÂ T.
â¤ Purpose â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶Â Used to create custom sort orders for collections (likeÂ List,Â TreeSet, or arrays) separate from the object's natural order defined byÂ Comparable.
â¤ Functional Method â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶Â Must implement the method:
        int compare(T o1, T o2);
    âœ”ï¸ Returns aÂ negativeÂ integer ifÂ o1Â should come beforeÂ o2.
    âœ”ï¸ ReturnsÂ zeroÂ if they are considered equal in ordering.
    âœ”ï¸ Returns aÂ positiveÂ integer ifÂ o1Â should come afterÂ o2.


ğŸ”„ Why Use Comparator?
â¤ When you want to sort objects by multiple or dynamic fields.
â¤ When the class of the objects does not implementÂ Comparable, or you want to provide an alternative ordering.
â¤ Helpful for sorting on fields other than the natural ordering, for example, by age, name, or salary.


ğŸ”„ How to Implement Comparator?
1ï¸âƒ£ Separate class implementation
    class StudentAgeComparator implements Comparator<Student> {
        public int compare(Student s1, Student s2) {
            return s1.getAge() - s2.getAge(); *// Ascending order by age*
        }
    }
   
 
2ï¸âƒ£ Anonymous class instance
    Comparator<Student> comp = new Comparator<>() {
        public int compare(Student s1, Student s2) {
            return s1.getName().compareTo(s2.getName());
        }
    };
   
    
3ï¸âƒ£ Lambda expression (Java 8+)
    Comparator<Student> comp = (s1, s2) > s1.getId() - s2.getId();
   
    
4ï¸âƒ£ Using method references and Comparator utility methods
    list.sort(Comparator.comparing(Student::getName).thenComparing(Student::getAge));
   
    
ğŸ”„ Methods in Comparator Interface
âœ”ï¸ compare(T o1, T o2) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶Â Core comparison method.
âœ”ï¸ thenComparing â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶Â Compose comparators for multilevel sorting.
âœ”ï¸ reversed() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶Â Returns a comparator that imposes the reverse ordering.
âœ”ï¸ equals(Object obj) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶Â Checks equality of comparators.


ğŸ”„ Usage Examples
List<Student> students = new ArrayList<>();
students.add(new Student("Ajay", 27));
students.add(new Student("Sneha", 23));
students.add(new Student("Simran", 37));

 Sort by age ascending
students.sort(Comparator.comparing(Student::getAge));

 Sort by name ascending, then age
students.sort(Comparator.comparing(Student::getName).thenComparing(Student::getAge));


âš¡ Important Points
â¤ Comparator enables flexible, powerful sorting beyond an object's natural order.
â¤ Commonly combined with Collections.sort(), Arrays.sort(), or stream operations.
â¤ Understanding Comparator is crucial for solving complex ordering problems and writing clean, maintainable code.


###############
ğŸ”· LinkedList
###############
â¤ LinkedList is an implementation of the List and Deque interfaces using a doubly linked list data structure.
â¤ It stores elements in nodes where each node contains the data and references to the previous and next nodes.
â¤ Located in theÂ java.utilÂ package.


ğŸ”„ Key Characteristics
â¤ Doubly Linked List â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶Â Each element points to both the next and previous nodes.
â¤ Non-contiguous memory allocation â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶Â Nodes can be anywhere in memory, linked by pointers.
â¤ Maintains insertion order.
â¤ Allows duplicate and null elements.
â¤ ImplementsÂ List,Â Deque, andÂ QueueÂ interfaces, so it supports stack, queue, and deque operations


ğŸ”„ LinkedList Constructors in Java
The LinkedList class provides multiple constructors to create instances of linked lists:

1ï¸âƒ£ Default Constructor
    LinkedList<E> list = new LinkedList<>();
â¤ Creates an empty linked list.
â¤ Internally initializes the list with no elements.


2ï¸âƒ£ Constructor with Collection
    Collection<? extends E> c;
    LinkedList<E> list = new LinkedList<>(c);
â¤ Creates a linked list containing the elements of the specified collection, in the order they are returned by the collection's iterator.
â¤ Useful for copying or converting collections into a LinkedList.


ğŸ”„ Core Advantages
â¤ Efficient insertions and deletions anywhere in the list, especially at the beginning or middle (O(1) if node is known).
â¤ No need to resize like ArrayList.
â¤ Useful when frequent add/remove operations at ends or middle are needed.


ğŸ”„ Disadvantages
â¤ Slower random access (O(n)) since it requires traversal from the start or end.
â¤ More memory overhead than ArrayList due to storing node pointers.


ğŸ”„ Important Methods
â¤ add(E e) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Append element at end.
â¤ add(int index, E element) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Insert at specific position.
â¤ addFirst(E e) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Add at the beginning.
â¤ addLast(E e) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Add at the end.
â¤ get(int index) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Get element by index (O(n)).
â¤ getFirst(),Â getLast() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Get first and last elements.
â¤ remove(),Â removeFirst(),Â removeLast() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Remove elements.
â¤ contains(Object o) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Check existence.
â¤ size() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Get total elements.
â¤ clear() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Clear all elements.
â¤ iterator(),Â listIterator() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ For traversal.
â¤ offer(),Â poll(),Â peek() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Queue operations.


ğŸ”„ Performance Complexity
| Operation              | LinkedList Complexity                 | ArrayList Complexity    |
| -----------------------| --------------------------------------| ------------------------|
| Access by index        | O(n)                                  | O(1)                    |
| Add at end             | O(1)                                  | O(1) amortized          |
| Add at beginning       | O(1)                                  | O(n)                    |
| Add / remove in middle | O(n) to traverse + O(1) to modify     | O(n) (element shifting) |
| Remove by value        | O(n)                                  | O(n)                    |
| Search (contains)      | O(n)                                  | O(n)                    |


ğŸ”„ Use Cases
â¤ When you require frequent insertions/deletions not just at the end of the list.
â¤ Implementing stacks, queues, or deques where add/remove at both ends are common.
â¤ When random access is not a priority.


âœ… Example Code
LinkedList<String> list = new LinkedList<>();

// Adding elements
list.add("Apple");
list.addFirst("Mango");  // Add at start
list.addLast("Banana");  // Add at end// Accessing elements
String first = list.getFirst(); // Mango
String last = list.getLast();   // Banana
String second = list.get(1);    // Apple// Removing elements
list.removeFirst();
list.removeLast();
list.remove("Apple");

// Iterating
for(String fruit : list) {
    System.out.println(fruit);
}


ğŸ”„ Difference Between ArrayList and LinkedList
| Feature                  | ArrayList                          | LinkedList                          |
| -------------------------| ---------------------------------- | ----------------------------------- |
| Data structure           | Resizable dynamic array            | Doubly linked list                  |
| Access time              | O(1) random access                 | O(n) sequential access              |
| Memory overhead          | Less (contiguous memory)           | More (stores node pointers)         |
| Insert / delete (middle) | O(n) due to shifting               | O(1) if node reference is known     |
| Insert / delete (ends)   | O(1) amortized at end              | O(1) at both ends                   |
| Cache locality           | Good (contiguous memory)           | Poor                                |
| Use case                 | Frequent reads, rare modifications | Frequent insertions/deletions       |



#############
ğŸ”· Vectors
#############
â¤ Vector is a class in the Java Collections Framework that implements aÂ dynamic arrayÂ similar to ArrayList but isÂ synchronizedÂ (thread-safe).
â¤ It is present in theÂ `java.util`Â package.
â¤ Grows automatically as elements are added.

ğŸ”„ Key Features
â¤ Resizable array â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶Â Like ArrayList, Vector can grow dynamically.
â¤ Thread-safe â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶Â All methods of Vector are synchronized, making it safe for concurrent access by multiple threads.
â¤ Maintains insertion order.
â¤ Allows duplicate and null elements.
â¤ ImplementsÂ List,Â RandomAccess,Â Cloneable, andÂ SerializableÂ interfaces.


ğŸ”„ Internal Working
â¤ Uses an internal array (elementData) to store elements.
â¤ Initial capacity is typically 10 elements by default.
â¤ When capacity is exceeded, VectorÂ doublesÂ its size (unlike ArrayList which grows by 50%).
â¤ Due to synchronization, Vector has overhead compared to ArrayList.


ğŸ”„ Vector Constructors in Java
Vector class includes constructors to initialize vectors:
1ï¸âƒ£ Default Constructor
    Vector<E> vector = new Vector<>();
â¤ Creates an empty vector with an initial capacity of 10.

2ï¸âƒ£ Constructor with Initial Capacity
    Vector<E> vector = new Vector<>(int initialCapacity);
â¤ Creates an empty vector with specified initial capacity.

3ï¸âƒ£ Constructor with Initial Capacity and Capacity Increment
    Vector<E> vector = new Vector<>(int initialCapacity, int capacityIncrement);
â¤ Capacity increment specifies by how much capacity is increased when the vector overflows.
â¤ If capacityIncrement is 0, it doubles the size (default behavior).

4ï¸âƒ£ Constructor with Collection
    Collection<? extends E> c;
    Vector<E> vector = new Vector<>(c);
â¤ Constructs a vector containing the elements of the specified collection, in the order they are returned by the collection's iterator.


ğŸ”„ Important Methods
â¤ add(E e) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Add element at the end.
â¤ add(int index, E element) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Add element at a given position.
â¤ get(int index) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Access element by index.
â¤ set(int index, E element) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Update element at index.
â¤ remove(int index) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Remove element at index.
â¤ size() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns number of elements.
â¤ capacity() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns current capacity of the vector.
â¤ clear() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Removes all elements.
â¤ elementAt(int index) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Similar toÂ get().
â¤ firstElement(),Â lastElement() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Access first and last elements.


ğŸ”„ Performance and Usage
| Operation                 | Vector Time Complexity | Notes                                         |
| --------------------------| -----------------------| --------------------------------------------- |
| Access by index           | O(1)                   | Fast random access via internal array         |
| Insert at end             | O(1) amortized         | Occasional resize creates a new array         |
| Insert / remove in middle | O(n)                   | Elements must be shifted                      |
| Thread safety             | Synchronized           | All public methods are thread-safe but slower |


ğŸ”„ Synchronization and Performance
ğŸ‘‰ Since vector methods are synchronized, it ensures that only one thread can access the vector at a time. This makes it thread-safe but can introduce performance overhead in single-threaded environments because synchronization adds locking and unlocking costs.

ğŸ‘‰ In moder Java applications, ArrayList is generally preferred over Vector when synchronization isn't required. For thread-safe collections, the CopyOnWriteArrayList or ConcurrentHashMap from the java.util.concurrent package are often recommended.


ğŸ”„ Difference between Vector and ArrayList
| Feature         | Vector                                   | ArrayList                                         |
| ----------------| ---------------------------------------- | ------------------------------------------------- |
| Synchronization | Synchronized (thread-safe by default)    | Not synchronized                                  |
| Growth factor   | Capacity typically doubles on resize     | Capacity grows by ~50%                            |
| Performance     | Slower due to synchronization overhead   | Faster in single-threaded or read-heavy scenarios |


ğŸ”„ When to Use Vector
â¤ When thread safety is required without external synchronization.
â¤ Legacy applications that already use Vector.
â¤ Replace with modern alternatives likeÂ CollectionssynchronizedListÂ orÂ CopyOnWriteArrayListÂ if concurrency is required with better performance.


âœ…Code Implementation of Vector Methods
import java.util.Vector;

public class VectorDemo {
    public static void main(String[] args) {
        // Create a Vector of Strings
        Vector<String> vector = new Vector<>();

        // 1. add(E e) - add element at the end
        vector.add("Apple");
        vector.add("Banana");
        vector.add("Cherry");
        System.out.println("After add: " + vector);

        // 2. add(int index, E element) - insert at specific index
        vector.add(1, "Mango");
        System.out.println("After add at index 1: " + vector);

        // 3. get(int index) - retrieve element at index
        System.out.println("Element at index 2: " + vector.get(2));

        // 4. set(int index, E element) - replace element
        vector.set(2, "Orange");
        System.out.println("After set at index 2: " + vector);

        // 5. remove(int index) - remove element by index
        vector.remove(3); // removes element at index 3
        System.out.println("After remove at index 3: " + vector);

        // 6. remove(Object o) - remove by value
        vector.remove("Apple"); 
        System.out.println("After removing 'Apple': " + vector);

        // 7. size() - get number of elements
        System.out.println("Size of vector: " + vector.size());

        // 8. isEmpty() - check if empty
        System.out.println("Is vector empty? " + vector.isEmpty());

        // 9. contains(Object o) - check if element exists
        System.out.println("Contains 'Banana'? " + vector.contains("Banana"));
        System.out.println("Contains 'Apple'? " + vector.contains("Apple"));

        // 10. clear() - remove all elements
        vector.clear();
        System.out.println("After clear: " + vector);
        System.out.println("Is vector empty after clear? " + vector.isEmpty());
    }
}

âœ…Output of above code:
After add: [Apple, Banana, Cherry]
After add at index 1: [Apple, Mango, Banana, Cherry]
Element at index 2: Banana
After set at index 2: [Apple, Mango, Orange, Cherry]
After remove at index 3: [Apple, Mango, Orange]
After removing 'Apple': [Mango, Orange]
Size of vector: 2
Is vector empty? false
Contains 'Banana'? false
Contains 'Apple'? false
After clear: []
Is vector empty after clear? true


==========
ğŸ”· Stack
==========
The Stack class in Java represents a last-in-first-out (LIFO) stack of objects. It extends the Vector class and provides five primary operations:


ğŸ”„ Key Concepts of Java Stack
â¤ LIFO principle â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶Â Last element added is the first to be removed.
â¤ Synchronized â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶Â Thread-safe due to Vector inheritance.
â¤ Generic â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶Â Can hold any type of objects with generics.


ğŸ”„ Constructors of Stack
â¤ Stack() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Creates an empty stack.


ğŸ”„ Main Stack Methods
â¤ push(E item) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Adds an item to the top of the stack.
â¤ pop() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Removes and returns the top item; throws EmptyStackException if empty.
â¤ peek() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns the top item without removing it; throws EmptyStackException if empty.
â¤ empty() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Checks if the stack is empty.
â¤ search(Object o) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns 1-based position from the top; returns -1 if not found.


âœ…Code Implementation 1ï¸âƒ£
package collections;

import java.util.Stack;

public class StackDemo {

	public static void main(String[] args) {
		Stack<Integer> st = new Stack<>();

		// to add the elements in the stack
		st.push(1);
		st.push(2);
		st.push(3);
		st.push(4);
		st.push(5);

		// to remove the top element
		int removedElement = st.pop();
		System.out.println(removedElement);
		System.out.println(st);

		// to see what the top element
		System.out.println(st.peek());

		// to check whether the stack is empty or not
		System.out.println(st.isEmpty());

		// to check the size of the stack
		System.out.println(st.size());

		//to search the element
		//Gives the index from the top
		System.out.println(st);
//		3 is at the 2nd index from the top
		System.out.println(st.search(3));	
	}
}


âœ…Code Implementation 2ï¸âƒ£: LinkedList as Stack
package collections;

import java.util.LinkedList;
import java.util.Stack;

public class StackDemo {

	public static void main(String[] args) {
		LinkedList<Integer> linkedlist = new LinkedList<>();

		// adding element in the LIFO manner
		linkedlist.addLast(1);
		linkedlist.addLast(2);
		linkedlist.addLast(3);
		linkedlist.addLast(4);
		linkedlist.addLast(5);

		// removing elements
		linkedlist.removeLast();

		// peek at the top element
		linkedlist.getLast();

		// return boolean whether the linkedlist is empty or not
		linkedlist.isEmpty();
	}
}


ğŸ”„ Performance
â¤ Inherits Vector's synchronized methods, being thread-safe but slower than ArrayDeque or LinkedList when used as stack.
â¤ Recommended to useÂ DequeÂ implementations (like ArrayDeque) for better performance and flexibility in modern applications.


=========================
ğŸ”· CopyOnWriteArrayList
=========================
CopyOnWriteArrayList in Java is a thread-safe variant of ArrayList where all mutative operations (like add, set, remove) are implemented by making a fresh copy of the underlying array. It resides in theÂ java.util.concurrentÂ package and is designed for concurrent environments where reads heavily outnumber writes.


ğŸ”„ Key Features
â¤ Thread safety â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶Â Safe to use concurrently without external synchronization.
â¤ Copy-on-write mechanism â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶Â Every update clones the internal array, so read operations are not blocked and can be performed without locking.
â¤ Iterator Snapshot â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶Â The iterator obtained from CopyOnWriteArrayList reflects the state of the list at the time it was created and will not see changes made after the iterator is created.
â¤ No ConcurrentModificationException â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶Â Modifications during iteration are safe and don't throw exceptions.
â¤ Costs â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶Â Copy-on-write comes with overhead on updates due to array copying. Therefore, it's best when reads dominate writes.


ğŸ”„ Constructors:
â¤ CopyOnWriteArrayList()Â â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Creates an empty list.
â¤ CopyOnWriteArrayList(Collection<? extends E> c)Â â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Creates a list containing the elements of the specified collection, in order.
â¤ CopyOnWriteArrayList(E[] array)Â â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Creates a list holding a copy of the given array.


ğŸ”„ Internal Working of CopyOnWriteArrayList
It creates a new copy of the underlying array every time the list is modified.

1ï¸âƒ£ The Core Data Structure
â¤ Internally, it uses a simple volatile array to store elements.
â¤ Volatile Keyword â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ The internal array is declared as private transient volatile Object[] array. This ensures that any change to the array reference is immediately visible to all other threads (guaranteeing "happens-before" consistency).


2ï¸âƒ£ How Write Operations Work (add, set, remove)
â¤ When you perform a mutation, like add(), the following steps happen internally:
    âœ”ï¸ Locking â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ The thread acquires an exclusive ReentrantLock to ensure that only one thread can modify the list at a time.
    âœ”ï¸ Copying â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ It fetches the current array and creates a fresh copy (cloned) with a new size (e.g., length + 1 for an add operation).
    âœ”ï¸ Modification â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ The new element is added to this newly created copy.
    âœ”ï¸ Pointer Update â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ The internal reference is updated to point to the new array.
    âœ”ï¸ Release â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ The lock is released.


3ï¸âƒ£ How Read Operations Work (get, iterator)
â¤ Read operations are completely lock-free.
â¤ Direct Access â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ When you call get(index), it simply returns the element from the "current" version of the array.
â¤ Snapshots â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Because the array is never modified in place, a reader thread can continue reading from its version of the array even if a writer thread is currently creating a new copy.


4ï¸âƒ£ Fail-Safe Iterators
â¤ The iterator of CopyOnWriteArrayList is considered fail-safe.
â¤ When you call .iterator(), it captures a reference to the snapshot of the array at that exact moment.
â¤ If another thread adds an item while you are iterating, it doesn't matter; your iterator is still looking at the old array.
â¤ No ConcurrentModificationException â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Since the iterator works on an immutable snapshot, it will never throw this exception.
â¤ Limitation â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ The iterator does not support mutative operations like remove(), set(), or add(). Calling these on the iterator will throw an UnsupportedOperationException, means that if we mutate the snapshot it will give error. Meanwhile, we can mutate the original list.

| Operation (during iteration) | Behavior                                 | Reason                                                                                    |
| ---------------------------- | ---------------------------------------- | ------------------------------------------------------------------------------------------|
| list.add("X")                | Works fine                               | It creates a new internal array; the iterator continues to use the old snapshot           |
| iterator.next()              | Works fine                               | Iterator reads from the immutable snapshot taken at creation time                         |
| iterator.remove()            | âŒ Throws UnsupportedOperationException  | Snapshot iterator is read-only and does not support structural modifications             |


âŒ Problem with List and ArrayList
package collections;

import java.util.ArrayList;
import java.util.List;

public class CopyOnWriteArrayListDemo {

	public static void main(String[] args) {
List<String>copyArrayList=new ArrayList<>();
		copyArrayList.add("Milk");
		copyArrayList.add("Eggs");
		copyArrayList.add("Bread");
		copyArrayList.add("Meat");
		
		for(String item:copyArrayList) {
			System.out.println(item);
			if(item.equals("Eggs")) {
				copyArrayList.add("Butter");
				System.out.println("Added Butter while Reading");
			}
		}
		System.out.println("The new udpated Array List");
		System.out.println(copyArrayList);
	}
}

âŒOutput:
Milk
Eggs
Added Butter while Reading
Exception in thread "main" java.util.ConcurrentModificationException
	at java.base/java.util.ArrayList$Itr.checkForComodification(ArrayList.java:1096)
	at java.base/java.util.ArrayList$Itr.next(ArrayList.java:1050)
	at CollectionFramework/collections.CopyOnWriteArrayListDemo.main(CopyOnWriteArrayListDemo.java:15)

While Iterating we cannot modify the list, it will throw an exception.

âœ… Using CopyOnWriteArrayList:
List<String>copyArrayList=new CopyOnWriteArrayList<>(); //using this we will get the

âš¡Output:
Milk
Eggs
Added Butter while Reading
Bread
Meat
The new udpated Array List
[Milk, Eggs, Bread, Meat, Butter]


ğŸ”„ Advantages
â¤ Ideal for cases with frequent reads and infrequent writes.
â¤ Avoids synchronization overhead during reads.
â¤ Simplifies concurrent programming by managing its own synchronization internally.

ğŸ”„ Limitations
â¤ Not suitable for scenarios with frequent writes as copying arrays on each update is costly.
â¤ Iterator does not reflect latest changes made after iterator creation.


=========
ğŸ”· Maps
=========
The Map interface (java.util.Map) is a core part of the Java Collections Framework, but unlike List or Set, it does not extend the Collection interface.

It is designed to store data in Key-Value pairs.
    âœ”ï¸ Key â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ A unique identifier used to retrieve data.
    âœ”ï¸ Value â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ The actual data associated with the key.


ğŸ”„ Key Characteristics
1ï¸âƒ£ Unique Keys â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ A Map cannot contain duplicate keys. If you try to insert a key that already exists, the old value is overwritten.
2ï¸âƒ£ One-to-One Mapping â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Each key maps to exactly one value.
3ï¸âƒ£ Value Duplication â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Duplicate values are allowed (different keys can point to the same value).


ğŸ”„ The Map.Entry Interface
The Map interface contains a nested inner interface called Map.Entry<K, V>.
    âœ”ï¸ It represents a single Key-Value pair stored inside the map.
    âœ”ï¸ When you iterate over a map, you are essentially iterating over these Entry objects.


ğŸ”„ Core Methods of Map.Entry
ğŸ”— K getKey() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns the key corresponding to this entry.
ğŸ”— V getValue() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns the value corresponding to this entry.
ğŸ”— V setValue(V value) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Replaces the value corresponding to this entry with the specified value.


ğŸ”„ Core Map Methods
These are the fundamental methods available in the interface before Java 8.

ğŸ” Basic Operations
ğŸ”— V put(K key, V value) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Associates the specified value with the specified key. If the map previously contained a mapping for the key, the old value is returned.
ğŸ”— V get(Object key) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key.
ğŸ”— V remove(Object key) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Removes the mapping for a key from this map if it is present. Returns the value that was associated with the key.
ğŸ”— boolean containsKey(Object key) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns true if this map contains a mapping for the specified key.
ğŸ”— boolean containsValue(Object value) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns true if this map maps one or more keys to the specified value.
ğŸ”— int size() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns the number of key-value mappings.
ğŸ”— void clear() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Removes all mappings from the map.


ğŸ” Collection Views
The Map interface provides three methods to view the data as a Collection. These views are backed by the map, meaning if you remove an element from the view, it is removed from the map.

1ï¸âƒ£ Set<K> keySet() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns a Set view of the keys contained in this map.
2ï¸âƒ£ Collection<V> values() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns a Collection view of the values contained in this map.
3ï¸âƒ£ Set<Map.Entry<K, V>> entrySet() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns a Set view of the mappings (entries) contained in this map. This is the most efficient way to iterate through a map.


ğŸ” Modern Map Methods (Java 8+)
Java 8 introduced "Default Methods" to the Map interface, significantly simplifying common coding tasks.

ğŸ”— V getOrDefault(Object key, V defaultValue) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns the value to which the specified key is mapped, or defaultValue if this map contains no mapping for the key.

ğŸ”— V putIfAbsent(K key, V value) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ If the specified key is not already associated with a value (or is mapped to null), associates it with the given value.

ğŸ”— void forEach(BiConsumer action) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Performs the given action for each entry in this map.

ğŸ”— boolean replace(K key, V oldValue, V newValue) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Replaces the entry for the specified key only if currently mapped to the specified value.

ğŸ”— V computeIfAbsent(K key, Function mappingFunction) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ If the specified key is not already associated with a value, attempts to compute its value using the given mapping function and enters it into this map.

ğŸ”— V merge(K key, V value, BiFunction remappingFunction) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ If the specified key is not already associated with a value or is associated with null, associates it with the given non-null value. Otherwise, replaces the associated value with the results of the given remapping function.


âœ… Conceptual Code Example
This example demonstrates the usage of the Interface methods specifically. Note that we use HashMap only to instantiate the object, but the reference type is Map.


import java.util.*;

public class MapInterfaceDemo {
    public static void main(String[] args) {
        // Polymorphism: Using Map interface reference
        Map<String, Integer> scores = new HashMap<>();

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Basic Insertion
        scores.put("Alice", 90);
        scores.put("Bob", 85);
        
        // returns 90 (the old value) and updates Alice to 95
        System.out.println("Old Alice Score: " + scores.put("Alice", 95)); 

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Java 8 features
        scores.putIfAbsent("Charlie", 88); // Adds Charlie
        scores.putIfAbsent("Alice", 100);  // Does nothing, Alice exists

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Iterating using entrySet (Best Practice)
        System.out.println("\n--- Student Scores ---");
        for (Map.Entry<String, Integer> entry : scores.entrySet()) {
            System.out.println("Key: " + entry.getKey() + " | Value: " + entry.getValue());
        }

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Using Views
        Set<String> keys = scores.keySet();
        // Removing from KeySet removes from Map!
        keys.remove("Bob"); 
        System.out.println("\nDoes map contain Bob? " + scores.containsKey("Bob")); // False
        
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Using forEach (Java 8)
        scores.forEach((k, v) -> System.out.println("Student: " + k + " has " + v));
    }
}


==============
ğŸ”· HashMap
==============
HashMap is the most commonly used implementation of the Map interface. It stores data in (Key, Value) pairs and is based on the hashing principle.


ğŸ”„ Key Characteristics
â¤ Unordered â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Does not maintain any order of its elements.
â¤ Allows null keys and Values â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Can have one null key and multiple null values.
â¤ Not Synchhronized â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Not thread-safe, requires external synchronization if used in a multi-threaded context.
â¤ Performance â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Offers constant time performance(O(1)) for basic operations like get and put, assuming the hash function disperses elements properly.


ğŸ”„ Internal Structure of HashMap
Basic components:
âœ”ï¸ Key: The identifer used to retrieve a value.
âœ”ï¸ Value:The data associated with the key.
âœ”ï¸ Bucket: A place where key-value paris are stored. Think of buckets as cells in a list(array).
âœ”ï¸ Hash function: Converts a key into an index(bucket location) for storage.
â¤ A hash function is an algorithm that takes an input(or key) and returns a fixed-size string of bytes, typically a numerical value. The output is known as the hash code, hash value or simply hash. The primary purpose of a hash function is to map data of arbitrary size to a fixed-size value.


ğŸ”„ Characteristics of Hash Function:
âœ”ï¸ Deterministic: Given the same input, the hash function always produces the same output.
âœ”ï¸ Fixed Output size: The output of the hash function is a fixed-size string of bytes.
âœ”ï¸ Efficient Computation: The hash function is fast to compute.


ğŸ” How Data is Stored in HashMap
1ï¸âƒ£ Hashing the Key
â¤ The key is passed through a hash function to generate a unique hash code(an integer number). This hash code helps determine where the key-value pair will be stored in the array(called a "bucket array").


2ï¸âƒ£ Calculating the Index
â¤ The hash code is then used to calculate an index in the array(bucket location) using
int index= hashCode % array.length;
â¤ The index decides which bucket will hold the key-value pair.
âœ… For example: If the array size is 16, the key's hash code will be divided by 16, and the remainder will be the index.


3ï¸âƒ£ Storing in the Bucket
â¤ The key-value pair is stored in the bucket at the calculated index.
â¤ Each bucket can hold multiple key-value pairs.
(this is called a collision handling mechanism).


ğŸ” Data Reterival in Hashmap
When we call get(Key), the HashMap follows the following steps
1ï¸âƒ£ Hashing the key â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Similar to insertion, the key is hashed using the same hash function to calculate its hash code.
2ï¸âƒ£ Finding the index â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ The hash code is used to find the index of the bucket where the key-value pair is stored.
3ï¸âƒ£ Searching in the Bucket â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Once the correct bucket is found, it checks for the key in that bucket. If found, it returns the value associated with the key.	


ğŸ”„ Handling Collisions
â¤ Since different keys can generate the same index(called a collision)
HashMap uses a technique to handle this situation. Java's HashMap uses Linked List(or balanced Red-Black Tree(self balancing binary search tree) after Java 8) to resolve collisions.

â¤ If multiple key-value paris map to the same bucket, they are stored i a linked list inside the bucket.
â¤ This is called Separate Chaining.

â¤ When a key-value pair is retrieved, the HashMap traverse the linked list to find the value associated with the key.


ğŸ”„ HashMap Resizing(Rehashing)
â¤ HashMap has an internal array size, which is by default is 16.
When the number of elements(key-value pairs) grows and exceeds a certain load factor(default is 0.75), HashMap automatically resizes the array to hold more data. This process is called rehashing.

â¤ The default size of the array is 16, so when more than 12 elements(16*0.75) are inserted, the HashMap will resize.

â—During rehashing
â¤ The array size is doubled
â¤ All existing entries are rehashed(i.e., their positions are recalculated)
and placed in the new array.
â¤ This ensures the HashMap continues to work efficiently even after more data is added.


ğŸ”„ Time Compplexity
â¤ Average: O(1) for insertion, deletion, search.
â¤ Worst case (all collisions in same bucket): O(logn) (but rare in practice).
But after Java 8, if there are too many elements in the bucket, HashMap switches to a balanced tree instead of a linked list to ensure better performance.
TREEFY_THRESHOLD = 8 for converting linked list to balanced tree.


âœ… Example: Custom Class as Key in HashMap
â—Problem:
â¤ When you create a custom class Person with fields like id and name, and put it into a HashMap, then:
â¤ By default, Object's implementation of hashCode() and equals() is used.
â¤ That implementation uses memory address â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ so two objects with the same values (id=1, name="Ankur") are considered different keys.


import java.util.*;

class Person {
    private int id;
    private String name;

    public Person(int id, String name) {
        this.id = id;
        this.name = name;
    }
}

public class Main {
    public static void main(String[] args) {
        Map<Person, String> map = new HashMap<>();

        Person p1 = new Person(1, "Ankur");
        Person p2 = new Person(1, "Ankur");

        map.put(p1, "Developer");
        map.put(p2, "Manager");

        System.out.println("Map size: " + map.size());
        System.out.println(map);
    }
}
ğŸ‘‰ Output:
Map size: 2
â¤ Even though both objects have the same id and name, they are treated as different keys.


âœ… Fix:
To fix this, override hashCode() and equals() in the Person class.
ğŸ”„ Correct Implementation:
import java.util.*;

class Person {
    private int id;
    private String name;

    public Person(int id, String name) {
        this.id = id;
        this.name = name;
    }

    // Override equals
    @Override
    public boolean equals(Object o) {
        if (this == o) return true; // same reference
        if (o == null || getClass() != o.getClass()) return false;

        Person person = (Person) o;
        return id == person.id && Objects.equals(name, person.name);
    }

    // Override hashCode
    @Override
    public int hashCode() {
        return Objects.hash(id, name);
    }

    @Override
    public String toString() {
        return "Person{id=" + id + ", name='" + name + "'}";
    }
}

public class Main {
    public static void main(String[] args) {
        Map<Person, String> map = new HashMap<>();

        Person p1 = new Person(1, "Ankur");
        Person p2 = new Person(1, "Ankur");

        map.put(p1, "Developer");
        map.put(p2, "Manager");

        System.out.println("Map size: " + map.size());
        System.out.println(map);
    }
}
ğŸ‘‰ Output:
Map size: 1
{Person{id=1, name='Ankur'}=Manager}

â¤ Now both objects are considered the same key because hashCode() is same and equals() says they are equal.
â¤ The second put() overwrites the value (Manager replaces Developer).


ğŸ”„ Key Notes 
â¤ Always override both equals() and hashCode() together (not just one).
â¤ If you only override equals() but not hashCode(), HashMap may still treat them as different keys.
â¤ Use Objects.hash() and Objects.equals() (Java 7+) to simplify.
â¤ Consistency rule: if a.equals(b) == true, then a.hashCode() == b.hashCode() must also hold.


ğŸ” Working of getOrDefault() Method
package collections;

import java.util.HashMap;

public class HashMapDemo {

	public static void main(String[] args) {
		HashMap<String, Integer> hashMap = new HashMap<>();
		hashMap.put("Ankur", 100);
		hashMap.put("Alice", 99);
		hashMap.put("Bob", 101);

		Integer res1 = hashMap.getOrDefault("Ankur", -1);
		if (res1 != -1) {
			System.out.println("Ankur is present in the map");
		} else {
			System.out.println("Ankur Not present");
		}

		Integer res2 = hashMap.getOrDefault("Sam", -1);
		if (res2 != -1) {
			System.out.println("Sam is present in the map");
		} else {
			System.out.println("Sam Not present");
		}

	}
}
âœ…Output:
Ankur is present in the map
Sam Not present


ğŸ” putIfAbsent() Method
package collections;

import java.util.HashMap;

public class HashMapDemo {

	public static void main(String[] args) {
		HashMap<String, Integer> hashMap = new HashMap<>();
		hashMap.put("Ankur", 100);
		hashMap.put("Alice", 99);
		hashMap.put("Bob", 101);

		hashMap.putIfAbsent("Ankur", 200);
		hashMap.putIfAbsent("Sam", 201);
		System.out.println(hashMap);
	}
}
âœ…Output: {Ankur=200, Alice=99, Bob=101, Sam=201}


=================
ğŸ”· LinkedHashMap
=================
A LinkedHashMap is a specialized implementation of the Map interface that combines the speed of a HashMap with the ordering capabilities of a LinkedList.


ğŸ”„ Core Concept
Think of a LinkedHashMap as a HashMap with a hidden thread running through it.
âœ”ï¸ HashMap Component â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ It uses a hash table to store data, ensuring $O(1)$ performance for basic operations.
âœ”ï¸ LinkedList Component â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ It maintains a doubly-linked list running through all its entries. This list defines the iteration order.


ğŸ”„ Internal Structure: The Entry Node
In a standard HashMap, a node contains: hash, key, value, and next. In a LinkedHashMap, the internal class (static inner class) extends HashMap.Node to add two more pointers:

1ï¸âƒ£ before: Points to the entry that was inserted before this one.
2ï¸âƒ£ after: Points to the entry that was inserted after this one.

ğŸ”— Code:
static class Entry<K,V> extends HashMap.Node<K,V> {
    Entry<K,V> before, after; // Pointers for the doubly linked list
    Entry(int hash, K key, V value, Node<K,V> next) {
        super(hash, key, value, next);
    }
}


ğŸ”„ Two Types of Ordering
Unlike HashMap (random order) or TreeMap (sorted order), LinkedHashMap offers two specific ordering modes based on a boolean flag in its constructor:

1ï¸âƒ£ Insertion-Order (Default)
â¤ The map remembers the order in which keys were inserted. 
â¤ If you re-insert a key (put a new value for an existing key), the order is not affected.

2ï¸âƒ£ Access-Order
â¤ The map keeps track of which entries were recently accessed. When you call get() or put(), that entry moves to the end of the list. 
â¤ This makes LinkedHashMap perfect for building LRU (Least Recently Used) Caches.
ğŸ”— Constructor:
LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)

â¤ initialCapacity â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ number of buckets initially.
â¤ loadFactor â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ controls resizing.
â¤ accessOrder â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶
	âœ”ï¸ false â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ maintains insertion order.
	âœ”ï¸ true â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ maintains access order (order changes when an entry is accessed with get() or put()).


âœ… Example: Insertion-Order vs Access-Order

import java.util.*;

public class LinkedHashMapDemo {
    public static void main(String[] args) {
        // 1. DEFAULT: Insertion Order
        Map<String, Integer> lhm = new LinkedHashMap<>();
        lhm.put("Zebra", 10);
        lhm.put("Apple", 50);
        lhm.put("Mango", 20);
        
        System.out.println("Insertion Order: " + lhm.keySet());
        // Output: [Zebra, Apple, Mango]

        // 2. Access Order (For LRU Cache behavior)
        // (Initial Capacity, Load Factor, accessOrder=true)
        LinkedHashMap<String, Integer> cache = new LinkedHashMap<>(16, 0.75f, true);
        cache.put("A", 1);
        cache.put("B", 2);
        cache.put("C", 3);

        cache.get("A"); // Accessing "A" moves it to the end
        
        System.out.println("Access Order: " + cache.keySet());
        // Output: [B, C, A]
    }
}


ğŸ”„ Key Differences: HashMap vs. LinkedHashMap
| Feature                 | HashMap                                                               | LinkedHashMap                                  |
| ----------------------- | --------------------------------------------------------------------- | ---------------------------------------------- |
| Iteration Order         | Undefined / Unpredictable                                             | Predictable (Insertion order or Access order)  |
| Internal Data Structure | Hash table + Red-Black Tree (after Java 8 for high-collision buckets) | Hash table + Doubly-linked list                |
| Memory Usage            | Lower                                                                 | Higher (extra `before` / `after` pointers)     |
| Performance             | Slightly faster for put/get                                           | Slightly slower due to maintaining linked list |
| Use Case                | Fast access, no order needed                                          | When iteration order matters (e.g., LRU cache) |


ğŸ”„ Special Feature: removeEldestEntry()
â¤ This is a protected method in LinkedHashMap that you can override to create a fixed-size cache.
â¤ When put() or putAll() is called, the map checks this method to see if it should delete the oldest entry.

âœ… Example of a simple LRU Cache:
LinkedHashMap<Integer, String> lru = new LinkedHashMap<Integer, String>(5, 0.75f, true) {
    @Override
    protected boolean removeEldestEntry(Map.Entry<Integer, String> eldest) {
        return size() > 5; // Automatically remove oldest if size exceeds 5
    }
};


==============
ğŸ”·WeakHashMap
==============
â¤ WeakHashMap<K,V> is a special implementation of Map where keys are stored as weak references.
â¤ If a key is not strongly referenced elsewhere in the program, the GC (Garbage Collector) can reclaim it.
â¤ Once GC collects the key, the corresponding entry is automatically removed from the map.

ğŸ”„ Use of WeakHashMap
â¤ Commonly used for caches where you donâ€™t want unused objects to prevent GC.
â¤ If the key object is no longer in use anywhere else â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ its entry is automatically removed.

âœ… Example
import java.util.WeakHashMap;

public class WeakHashMapDemo {

	public static void main(String[] args) {
		WeakHashMap<String, Image> imageCache = new WeakHashMap<>();
		imageCache.put(new String("img1"), new Image("Image 1"));
		imageCache.put(new String("img2"), new Image("Image 2"));
		imageCache.put(new String("img3"), new Image("Image 3"));
		System.out.println(imageCache);
		System.gc();
		simulation();
		System.out.println("Cache after running(some entries may be cleared): " + imageCache);
	}

	private static void simulation() {
		try {
			System.out.println("Simulating application running...");
			Thread.sleep(10000);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

class Image {
	private String name;

	public Image(String name) {
		this.name = name;
	}

	@Override
	public String toString() {
		return name;
	}
}
âœ…Output:
{img1=Image 1, img2=Image 2, img3=Image 3}
Simulating application running...
Cache after running(some entries may be cleared): {}

ğŸ§ Explaination
ğŸ‘‰WeakHashMap<String, Image> imageCache = new WeakHashMap<>();
Creates a WeakHashMap where:
	âœ”ï¸ Key = String (weakly referenced)
	âœ”ï¸ Value = Image object (normal strong reference)

ğŸ‘‰imageCache.put(new String("img1"), new Image("Image 1"));
â¤ Uses new String("img1") â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ ensures the key is not from String pool (important!).
â¤ If we had used "img1" directly, it would come from the string pool (strongly referenced by JVM), and GC wouldnâ€™t clear it.

ğŸ‘‰System.gc();
Suggests JVM to run garbage collection (not guaranteed, but usually works in demos).

ğŸ‘‰simulation();
Sleeps for 10 seconds â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ gives JVM time to clear weakly referenced keys.

ğŸ‘‰ Class Image
â¤ Just a wrapper with a name field.
â¤ toString() overridden â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ so when map is printed, values show as "Image 1", "Image 2", etc.

ğŸ‘‰ Output Explaination:
â¤ The second print may show {} or partially cleared entries depending on GC.
â¤ Because keys (new String("imgX")) are weakly referenced â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ once GC runs, they vanish.

âš¡ Important Points
âœ”ï¸ WeakHashMap removes entries automatically when keys are weakly referenced and GC runs.
ğŸ†š Difference from HashMap:
â¤ HashMap â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ keys are strongly referenced (never removed unless explicitly).
â¤ WeakHashMap â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ keys are weak references (removed after GC if no strong reference exists).
âœ”ï¸ Values (Image) are still strongly referenced, but without a strong key reference, they become unreachable.
âœ”ï¸ Useful for memory-sensitive caching.

ğŸ§  Trap Question
package collections;

import java.util.HashMap;
import java.util.Map;

public class IdentityHashMapDemo {

	public static void main(String[] args) {
		String key1 = new String("Key");
		String key2 = new String("Key");
		Map<String, Integer> map = new HashMap<>();
		map.put(key1, 1);
		map.put(key2, 2);
		System.out.println(map);
	}

}
âœ… Output: {key=2};
ğŸ§ Explaination: Even though string is made through new keyword, that hashcode will not be generated based on the memory address, as string already has a function to calculate hashcode based on the value stored inside the string so both the values are same. 
Therefore, inside the map it will use the key1.equals(key2) and it will return true so it will return the value of key2 which is 2.

If we want output like {key=1, key=2} then we can use IdentityHashMap.


====================
ğŸ”·IdentityHashMap
====================
â¤ IdentityHashMap is a special implementation of Map in Java where keys are compared using reference equality (==) instead of equals().
â¤ It is part of java.util package.

ğŸŒŸ Key Features
â¤ Uses reference equality (==) for both key comparison and hashing.
â¤ Allows null keys and null values.
â¤ Performance is similar to HashMap.
â¤ Not synchronized (like HashMap).
â¤ It breaks the general contract of Map because two logically equal keys (according to .equals()) may not be treated as equal here.

ğŸ†š Difference from HashMap
| Feature        | `HashMap`                     | `IdentityHashMap`                |
| -------------- | ----------------------------- | -------------------------------- |
| Key comparison | Uses `equals()`               | Uses `==` (reference equality)   |
| Hashing        | Uses `hashCode()` of key      | Uses `System.identityHashCode()` |
| Usage          | When logical equality matters | When reference identity matters  |

âœ… Example 1:
import java.util.*;

public class IdentityHashMapDemo {
    public static void main(String[] args) {
        Map<String, String> map = new IdentityHashMap<>();

        String a = new String("hello");
        String b = new String("hello");

        map.put(a, "Value A");
        map.put(b, "Value B");

        System.out.println("Size: " + map.size());
        System.out.println(map);
    }
}

âœ… Output:
Size: 2
{hello=Value A, hello=Value B}
ğŸ‘‰ Even though a.equals(b) is true, IdentityHashMap treats them as different keys because a != b (different objects in memory).

ğŸŒŸ Use Cases
âœ”ï¸ When you need object identity instead of equality.
âœ”ï¸ Caching frameworks (where reference equality is important).
âœ”ï¸ Serialization/deserialization where temporary objects need unique tracking.
âœ”ï¸ Graph processing (tracking visited nodes by identity).
âœ”ï¸ Object pools.

âœ… Example: What will happen if you put two equal String objects as keys?
package collections;

import java.util.IdentityHashMap;
import java.util.Map;

public class IdentityHashMapDemo {

	public static void main(String[] args) {
		String key1 = new String("Key");
		String key2 = new String("Key");
		Map<String, Integer> map = new IdentityHashMap<>();
		map.put(key1, 1);
		map.put(key2, 2);
		System.out.println(map);
	}
}
âœ…Output : {Key=2}


===============
ğŸ”· Comparable
===============
â¤ Belongs to java.lang package.
â¤ Used to define the natural/default ordering of objects.
â¤ A class implements Comparable to provide its own comparison logic.
â¤ It has one method:
ğŸ”— public int compareTo(T o):
Returns:
	âœ”ï¸ 0 â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ equal
	âœ”ï¸ <0 â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ current object < given object
	âœ”ï¸ >0 â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ current object > given object

ğŸ”¸ Example: Student sorting by age (natural order)
class Student implements Comparable<Student> {
    String name;
    int age;

    Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public int compareTo(Student s) {
        return this.age - s.age; // ascending order
    }
}

âœ… Comparator (Interface)
â¤ Belongs to java.util package.
â¤ Used when we want to define multiple sorting strategies or sorting logic outside the class.
â¤ It has two main methods Java 8 added comparing() and thenComparing() for chaining.:
	âœ”ï¸ public int compare(T o1, T o2);
	âœ”ï¸ public boolean equals(Object obj); // rarely overridden
â¤ Can be used with lambda/method references for concise sorting.

ğŸ”¸ Example: Sorting Student by name
import java.util.*;

class Student {
    String name;
    int age;
    Student(String name, int age) {
        this.name = name;
        this.age = age;
    }
}

class NameComparator implements Comparator<Student> {
    public int compare(Student s1, Student s2) {
        return s1.name.compareTo(s2.name);
    }
}
ğŸ”„ Usage: Collections.sort(list, new NameComparator());

ğŸ†š Comparable vs Comparator â€” Differences
| Feature             | Comparable                              | Comparator                                          |
| ------------------- | --------------------------------------- | --------------------------------------------------- |
| Package             | `java.lang`                             | `java.util`                                         |
| Method              | `compareTo(Object o)`                   | `compare(Object o1, Object o2)`                     |
| Sorting logic       | Defined inside the class            | Defined outside the class                       |
| Natural Order       | Provides default (natural) ordering | Provides custom/multiple orderings              |
| Modifies class code | Yes (must implement inside class)       | No (separate comparator class or lambda)            |
| One vs Many         | One natural order only                  | Many possible comparators                           |
| Java 8 support      | No enhancements                         | Added `comparing()`, `thenComparing()` for chaining |

âœ… Example with Both
import java.util.*;

class Student implements Comparable<Student> {
    String name;
    int age;
    Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // Natural order: by age
    @Override
    public int compareTo(Student s) {
        return this.age - s.age;
    }

    @Override
    public String toString() {
        return name + " (" + age + ")";
    }
}

public class Main {
    public static void main(String[] args) {
        List<Student> list = new ArrayList<>();
        list.add(new Student("John", 25));
        list.add(new Student("Alice", 22));
        list.add(new Student("Bob", 30));

        // Using Comparable (natural order: by age)
        Collections.sort(list);
        System.out.println("Sorted by age: " + list);

        // Using Comparator (custom order: by name)
        Collections.sort(list, (s1, s2) -> s1.name.compareTo(s2.name));
        System.out.println("Sorted by name: " + list);
    }
}

ğŸŒŸ Insights
â¤ Comparable â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ "I have a natural order, built inside the class."
â¤ Comparator â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ "I allow multiple sorting logics, outside the class."
â¤ Common trick: â€œCan a class implement both?â€ â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ âœ… Yes, a class can have a natural order (Comparable) and also be sorted by different comparators when needed.


=============
ğŸ”· SortedMap
=============
An interface in Java that extends Map and guarantees ordering of keys in ascending order (natural ordering or custom Comparator).

ğŸŒŸ Key Features:
â¤ Maintains elements in sorted order of keys.
â¤ Duplicate keys âŒ not allowed.
â¤ Backed by implementations like TreeMap.
â¤ Provides range-view methods (headMap, tailMap, subMap).

Important Methods:
â¤ K firstKey() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ returns lowest key.
â¤ K lastKey() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ returns highest key.
â¤ SortedMap<K,V> headMap(K toKey) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ view of keys < toKey.
â¤ SortedMap<K,V> tailMap(K fromKey) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ view of keys >= fromKey.
â¤ SortedMap<K,V> subMap(K fromKey, K toKey) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ view between fromKey and toKey.
â¤ Comparator<? super K> comparator() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ returns comparator used, or null if natural ordering.

Use Cases:
âœ”ï¸ Maintaining sorted dictionaries.
âœ”ï¸ Range-based operations (e.g., retrieving values within a range of keys).
âœ”ï¸ Implementing priority-like behavior using keys.

âœ…Code Implementation:
import java.util.*;

public class SortedMapDemo {
    public static void main(String[] args) {
        // Creating a SortedMap
        SortedMap<Integer, String> sortedMap = new TreeMap<>();

        // Adding elements
        sortedMap.put(3, "Banana");
        sortedMap.put(1, "Apple");
        sortedMap.put(5, "Mango");
        sortedMap.put(2, "Orange");
        sortedMap.put(4, "Grapes");

        // Displaying map (sorted automatically by keys)
        System.out.println("SortedMap: " + sortedMap);

        // Methods of SortedMap
        System.out.println("First Key: " + sortedMap.firstKey());
        System.out.println("Last Key: " + sortedMap.lastKey());
        System.out.println("HeadMap (<3): " + sortedMap.headMap(3));
        System.out.println("TailMap (>=3): " + sortedMap.tailMap(3));
        System.out.println("SubMap (2 to 5): " + sortedMap.subMap(2, 5));
        System.out.println("Comparator Used: " + sortedMap.comparator()); // null â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ natural ordering
    }
}

âœ…Output
{1=Apple, 2=Orange, 3=Banana, 4=Grapes, 5=Mango}
First Key: 1
Last Key: 5
HeadMap(<3): {1=Apple, 2=Orange}
TailMap(>=3): {3=Banana, 4=Grapes, 5=Mango}
SubMap(2 to 5): {2=Orange, 3=Banana, 4=Grapes}
Comparator Used: null


================
ğŸ”· NavigableMap
================
An interface that extends SortedMap, providing navigation methods for key search and traversal.

ğŸŒŸ Key Features:
â¤ Allows finding closest matches (floorKey, ceilingKey, etc.).
â¤ Can return reverse order views of the map.
â¤ Common implementation: TreeMap.

ğŸŒŸ Important Methods:
â¤ K lowerKey(K key) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ greatest key < key.
â¤ K floorKey(K key) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ greatest key <= key.
â¤ K ceilingKey(K key) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ least key >= key.
â¤ K higherKey(K key) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ least key > key.
â¤ Map.Entry<K,V> firstEntry() / lastEntry() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ first and last entry.
â¤ Map.Entry<K,V> pollFirstEntry() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ removes and returns first entry.
â¤ NavigableMap<K,V> descendingMap() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ reverse order view.

ğŸ”„ Use Cases:
â¤ Efficient searching for nearest values.
â¤ Implementing caches, scheduling systems, range queries.
â¤ Situations where ordering + navigation are critical.

âœ…Code Implementation:
import java.util.*;

public class NavigableMapDemo {
    public static void main(String[] args) {
        // Creating a NavigableMap
        NavigableMap<Integer, String> navMap = new TreeMap<>();

        // Adding elements
        navMap.put(1, "Apple");
        navMap.put(2, "Orange");
        navMap.put(3, "Banana");
        navMap.put(4, "Grapes");
        navMap.put(5, "Mango");

        // Displaying map
        System.out.println("NavigableMap: " + navMap);

        // Methods of NavigableMap
        System.out.println("Lower Key(3): " + navMap.lowerKey(3));    // < 3
        System.out.println("Floor Key(3): " + navMap.floorKey(3));    // <= 3
        System.out.println("Ceiling Key(3): " + navMap.ceilingKey(3));// >= 3
        System.out.println("Higher Key(3): " + navMap.higherKey(3));  // > 3

        System.out.println("First Entry: " + navMap.firstEntry());
        System.out.println("Last Entry: " + navMap.lastEntry());
        System.out.println("Descending Map: " + navMap.descendingMap());

        // Polling entries (removes from map)
        System.out.println("Poll First Entry: " + navMap.pollFirstEntry());
        System.out.println("Poll Last Entry: " + navMap.pollLastEntry());
        System.out.println("Remaining Map: " + navMap);
    }
}
âœ…Output:
{1=Apple, 2=Orange, 3=Banana, 4=Grapes, 5=Mango}
Lower Key(3): 2
Floor Key(3): 3
Ceiling Key(3): 3
Higher Key(3): 4
Descending Map: {5=Mango, 4=Grapes, 3=Banana, 2=Orange, 1=Apple}
Poll First Entry: 1=Apple
Poll Last Entry: 5=Mango
Remaining Map: {2=Orange, 3=Banana, 4=Grapes}


==============
ğŸ”· Hashtable
==============
A legacy class (from JDK 1.0) that implements Map, storing key-value pairs in hash table form.

ğŸ”„ Key Features:
â¤ âœ… Thread-safe (all methods synchronized).
â¤ âŒ Null keys/values not allowed (unlike HashMap).
â¤ Slower than HashMap due to synchronization.
â¤ Introduced before Java Collections Framework â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ considered legacy.
â¤ Replaced by ConcurrentHashMap in modern concurrent apps.

ğŸ”„ Internal Working:
â¤ Uses array of buckets where each bucket stores a linked list of entries.
â¤ On collision â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ new entry appended to linked list of that bucket.
â¤ Since Java 8, HashMap/ConcurrentHashMap optimize collision handling with balanced trees, but Hashtable still uses only linked list.

ğŸ”„ Important Methods:
â¤ V put(K key, V value) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ insert key-value.
â¤ V get(Object key) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ retrieve value.
â¤ boolean containsKey(Object key) / containsValue(Object value) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ check existence.
â¤ Enumeration<K> keys() / elements() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ legacy iteration methods.

ğŸ”„ Use Cases:
â¤ Very limited today â€” mostly in legacy systems.
â¤ For thread-safe maps â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ use ConcurrentHashMap.

ğŸ”„ Comparison with HashMap:
â¤ Hashtable â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ synchronized, no null keys/values, slower.
â¤ HashMap â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ not synchronized, allows one null key & multiple null values, faster.

âœ…Code Implementation:
import java.util.*;

public class HashtableDemo {
    public static void main(String[] args) {
        // Creating a Hashtable
        Hashtable<Integer, String> hashtable = new Hashtable<>();

        // Adding elements
        hashtable.put(101, "Java");
        hashtable.put(102, "Python");
        hashtable.put(103, "C++");
        hashtable.put(104, "JavaScript");

        // Displaying Hashtable
        System.out.println("Hashtable: " + hashtable);

        // Access methods
        System.out.println("Value at key 102: " + hashtable.get(102));
        System.out.println("Contains key 103? " + hashtable.containsKey(103));
        System.out.println("Contains value 'C#'? " + hashtable.containsValue("C#"));

        // Iterating with Enumeration (legacy style)
        System.out.println("Iterating using Enumeration:");
        Enumeration<Integer> keys = hashtable.keys();
        while (keys.hasMoreElements()) {
            Integer key = keys.nextElement();
            System.out.println(key + " -> " + hashtable.get(key));
        }
    }
}

âœ…Output:
{104=JavaScript, 103=C++, 102=Python, 101=Java}
Value at key 102: Python
Contains key 103? true
Contains value 'C#'? false
Iterating with Enumeration:
104 -> JavaScript
103 -> C++
102 -> Python
101 -> Java


======================
ğŸ”· ConcurrentHashMap
======================
ConcurrentHashMap is a highly efficient, thread-safe implementation of the Map interface. It was introduced in Java 5 as a replacement for Hashtable and Collections.synchronizedMap(), which have poor performance in multi-threaded environments.


ğŸ”„ The Problem with Synchronized Maps
â¤ Before ConcurrentHashMap, if you wanted thread safety, you had to lock the entire map for every operation.
â¤ Hashtable / SynchronizedMap: They use a single "Global Lock." If Thread A is reading, Thread B must wait to write (and vice versa). This creates a massive bottleneck.


ğŸ”„ Java 7
â¤ Used segment-based locking (default: 16 segments â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ 16 smaller hash tables).
â¤ Only the segment being modified/read is locked.
â¤ Read: doesnâ€™t require locking unless concurrent write is happening.
â¤ Write: locks only that segment (better concurrency than Hashtable).


ğŸ”„ Java 8 and Beyond
In Java 8, the internal structure was redesigned to be even faster, moving away from "Segmented Locking" to a more granular Node-level locking strategy.

1ï¸âƒ£ Data Structure
Like HashMap, it uses an array of buckets (Nodes). When a collision occurs, it uses a Linked List or a Red-Black Tree.

2ï¸âƒ£ CAS (Compare-And-Swap) Operations
For inserting a node into an empty bucket, ConcurrentHashMap does not use locks. Instead, it uses CAS (an atomic CPU instruction). This is extremely fast because it avoids the overhead of blocking threads.

3ï¸âƒ£ Synchronized Buckets (Fine-Grained Locking)
If a bucket is not empty (a collision occurs), the map synchronizes only on the first node of that specific bucket.
    âœ”ï¸ Impact: Thread A can update Bucket 1 while Thread B updates Bucket 2 simultaneously. They do not block each other.


ğŸ”„ Key Characteristics
| Key Characteristic | Behavior                                                                            |
| ------------------ | ----------------------------------------------------------------------------------- |
| Locking            | Fine-grained locking (bucket-level / CAS-based after Java 8)                        |
| Null Keys / Values | âŒ Not allowed; throws `NullPointerException`                                        |
| Read Operations    | Lock-free; return the most recently available value                                 |
| Iterators          | Fail-safe and weakly consistent; do **not** throw `ConcurrentModificationException` |


ğŸ”„ Important Methods
Because multiple threads access the map, standard get and put aren't always enough to avoid "race conditions." ConcurrentHashMap provides atomic "Check-then-Act" methods:

ğŸ”— putIfAbsent(K key, V value) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Only inserts if the key is missing.

ğŸ”— remove(Object key, Object value) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Only removes if the key is mapped to that specific value.

ğŸ”— replace(K key, V oldValue, V newValue) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Only replaces if the current value matches oldValue.


âœ… Code Example: Concurrent Access
This example demonstrates how multiple threads can safely modify the map without explicit synchronized blocks.

import java.util.concurrent.ConcurrentHashMap;
import java.util.Map;

public class ConcurrentMapDemo {
    public static void main(String[] args) {
        // 1. Initialize Map
        Map<String, Integer> inventory = new ConcurrentHashMap<>();
        inventory.put("Apples", 10);

        // 2. Atomic update (Safe from race conditions)
        // computeIfPresent ensures the logic is atomic
        inventory.computeIfPresent("Apples", (key, val) -> val + 50);

        // 3. Thread-safe iteration
        inventory.put("Oranges", 20);
        inventory.put("Bananas", 30);

        System.out.println("Inventory before iteration: " + inventory);

        // Fail-safe iterator: We can modify the map WHILE iterating!
        for (String key : inventory.keySet()) {
            if (key.equals("Oranges")) {
                inventory.put("Grapes", 40); // This won't throw Exception
            }
        }

        System.out.println("Final Inventory: " + inventory);
    }
}


ğŸ”„ HashMap vs. SynchronizedMap vs. ConcurrentHashMap
| Feature           | HashMap                            | SynchronizedMap                    | ConcurrentHashMap                               |
| ----------------- | ---------------------------------- | ---------------------------------- | ----------------------------------------------- |
| Thread Safety     | âŒ No                               | âœ… Yes (single global lock)         | âœ… Yes (fine-grained / bucket-level locking)     |
| Performance       | Fastest in single-threaded use     | Slow under high contention         | High performance in multi-threaded environments |
| Iterator Behavior | Fail-fast                          | Fail-fast                          | Fail-safe (weakly consistent)                   |
| Null Support      | One null key, multiple null values | One null key, multiple null values | âŒ No null keys or values                        |


ğŸ”„ Why are Nulls not allowed?
The creator of ConcurrentHashMap (Doug Lea) famously excluded nulls to avoid ambiguity in multi-threaded environments.
    âœ”ï¸ In a normal HashMap, get(key) == null could mean the key isn't there, OR the value is actually null. You'd check containsKey(key) to be sure.
    âœ”ï¸ In a concurrent environment, the map could change between your call to get() and containsKey(). By forbidding nulls, if get() returns null, you are 100% certain the key does not exist.


=========================
ğŸ”· ConcurrentSkipListMap
=========================
â¤ Thread-safe, Sorted Map implementation.
â¤ Backed by a SkipList, which is a probabilistic data structure with multiple layers (like â€œexpress lanesâ€ in a linked list).
â¤ Allows logarithmic time search, insert, delete.

âœ… Key Features
â¤ Maintains sorted order of keys (like TreeMap).
â¤ Concurrent access supported.
â¤ Non-blocking reads, fine-grained locking on writes.

âœ…Code Implementation
import java.util.concurrent.*;

public class ConcurrentSkipListMapDemo {
    public static void main(String[] args) {
        ConcurrentSkipListMap<Integer, String> cslm = new ConcurrentSkipListMap<>();

        // Adding elements
        cslm.put(5, "Mango");
        cslm.put(2, "Apple");
        cslm.put(4, "Banana");
        cslm.put(1, "Orange");

        // Sorted automatically
        System.out.println("ConcurrentSkipListMap: " + cslm);

        // Methods
        System.out.println("First Key: " + cslm.firstKey());
        System.out.println("Last Key: " + cslm.lastKey());
        System.out.println("HeadMap (<4): " + cslm.headMap(4));
        System.out.println("TailMap (>=2): " + cslm.tailMap(2));
    }
}

âœ…Output:
ConcurrentSkipListMap: {1=Orange, 2=Apple, 4=Banana, 5=Mango}
First Key: 1
Last Key: 5
HeadMap (<4): {1=Orange, 2=Apple}
TailMap (>=2): {2=Apple, 4=Banana, 5=Mango}


===========
ğŸ”· EnumMap
===========
â¤ A specialized Map implementation where keys must be enum constants.
â¤ Internally uses an array of values, indexed by enumâ€™s ordinal().
â¤ Very fast (no hashing) and memory-efficient.
â¤ Null keys âŒ not allowed.

âœ…Code Implementation:
import java.util.*;

enum Day { MON, TUE, WED, THU, FRI, SAT, SUN }

public class EnumMapDemo {
    public static void main(String[] args) {
        EnumMap<Day, String> em = new EnumMap<>(Day.class);

        // Adding elements
        em.put(Day.MON, "Start of week");
        em.put(Day.FRI, "Weekend is near");
        em.put(Day.SUN, "Holiday");

        // Displaying map
        System.out.println("EnumMap: " + em);

        // Access
        System.out.println("Message for FRI: " + em.get(Day.FRI));
    }
}

âœ…Output:
EnumMap: {MON=Start of week, FRI=Weekend is near, SUN=Holiday}
Message for FRI: Weekend is near


=================
ğŸ”· ImmutableMap
=================
â¤ Map that cannot be modified once created.
â¤ Any attempt to add/remove/update will throw UnsupportedOperationException.

âœ… Ways to Create ImmutableMap
1. Guavaâ€™s ImmutableMap (Google library):
// Guava ImmutableMap
// ImmutableMap<String, Integer> map1 = ImmutableMap.of("A", 1, "B", 2, "C", 3);

2.Using Collections.unmodifiableMap():
âœ…Code Implementation:
import java.util.*;

public class ImmutableMapDemo1 {
    public static void main(String[] args) {
        Map<String, Integer> normalMap = new HashMap<>();
        normalMap.put("A", 1);
        normalMap.put("B", 2);

        Map<String, Integer> immutableMap = Collections.unmodifiableMap(normalMap);
        System.out.println("ImmutableMap: " + immutableMap);

        // immutableMap.put("C", 3); // âŒ Throws UnsupportedOperationException
    }
}

âœ…Output:
ImmutableMap: {A=1, B=2}

3. Using Java 9+ Map.of() (limited to 10 pairs):
âœ…Code Implementation:
import java.util.*;

public class ImmutableMapDemo2 {
    public static void main(String[] args) {
        Map<String, Integer> map2 = Map.of("A", 1, "B", 2, "C", 3);
        System.out.println("Map.of: " + map2);

        // map2.put("D", 4); // âŒ Throws UnsupportedOperationException
    }
}

âœ…Output:
Map.of: {A=1, B=2, C=3}

4. Using Map.ofEntries() for larger maps:
âœ…Code Implementation:
import java.util.*;

public class ImmutableMapDemo3 {
    public static void main(String[] args) {
        Map<String, Integer> map3 = Map.ofEntries(
            Map.entry("A", 1),
            Map.entry("B", 2),
            Map.entry("C", 3),
            Map.entry("D", 4)
        );

        System.out.println("Map.ofEntries: " + map3);

        // map3.remove("A"); // âŒ UnsupportedOperationException
    }
}

âœ…Output:
Map.ofEntries: {A=1, B=2, C=3, D=4}

 
========
 ğŸ”· Set
========
In the Java Collections Framework, the Set interface (java.util.Set) represents a collection that cannot contain duplicate elements. It models the mathematical set abstraction.


ğŸ”„ Key Characteristics
1ï¸âƒ£ No Duplicates â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ The primary feature. If you try to add an element that is already present, the add() method returns false and the set remains unchanged.

2ï¸âƒ£ Mathematical Operations â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ It provides methods for standard set operations like Union, Intersection, and Difference.

3ï¸âƒ£ Order â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ The Set interface itself does not guarantee any specific order of elements (though some implementations like LinkedHashSet or TreeSet do).

4ï¸âƒ£ Implementation â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Like Map, Set is an interface, so you cannot instantiate it directly. You must use a concrete class.


ğŸ”„ How Set Prevents Duplicates
Internally, almost all Set implementations in Java are backed by a corresponding Map.
1ï¸âƒ£ When you add an element to a HashSet, it actually adds that element as a Key in an internal HashMap.

2ï¸âƒ£Since Map keys must be unique, the Set inherits this behavior. A "dummy" object is used as the constant Value for every key.


ğŸ”„ Core Methods
Since Set extends the Collection interface, it contains all the standard collection methods, but their behavior is strictly governed by the "no-duplicate" rule.

ğŸ”„ Basic Operations
ğŸ”— boolean add(E e) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Adds the element if it is not already present.

ğŸ”— boolean remove(Object o) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Removes the specified element.

ğŸ”— boolean contains(Object o) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns true if the set contains the element.

ğŸ”— int size() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns the number of elements.


ğŸ”„ Bulk Operations (Set Theory)
1ï¸âƒ£ Union â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ s1.addAll(s2) â€” Transforms s1 into the union of s1 and s2.

2ï¸âƒ£ Intersection â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ s1.retainAll(s2) â€” Transforms s1 into the intersection (only elements present in both).

3ï¸âƒ£ Difference â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ s1.removeAll(s2) â€” Removes from s1 all elements found in s2.


ğŸ” The SortedSet and NavigableSet Interfaces
While Set is the base, there are two important sub-interfaces
1ï¸âƒ£ SortedSet â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Guarantees that elements are maintained in ascending order (either natural or via a Comparator).

2ï¸âƒ£ NavigableSet â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Extends SortedSet with navigation methods like lower(), higher(), floor(), and ceiling() to find matches based on proximity.


âœ… Code Example: Basic Set Operations
import java.util.*;

public class SetInterfaceDemo {
    public static void main(String[] args) {
        // Using HashSet as the concrete implementation
        Set<String> set = new HashSet<>();

        // 1. Adding elements
        set.add("Java");
        set.add("Python");
        set.add("C++");
        
        // 2. Attempting a duplicate
        boolean isAdded = set.add("Java"); 
        System.out.println("Was 'Java' added again? " + isAdded); // false

        // 3. Mathematical Operations example
        Set<Integer> a = new HashSet<>(Arrays.asList(1, 2, 3, 4));
        Set<Integer> b = new HashSet<>(Arrays.asList(3, 4, 5, 6));

        // Intersection
        Set<Integer> intersection = new HashSet<>(a);
        intersection.retainAll(b);
        System.out.println("Intersection: " + intersection); // [3, 4]
    }
}


ğŸ”„ Constraints and Considerations
1ï¸âƒ£ hashCode and equals â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ To work correctly in a Set, the objects you store must properly override hashCode() and equals(). If two objects are "equal" but have different hash codes, the Set will mistakenly allow both.

2ï¸âƒ£ Mutability â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ You must be very careful if you modify an object that is already inside a Set. If the modification changes the result of equals() or hashCode(), the Set may become "corrupted" (you won't be able to find or remove the element).


====================
ğŸ”· LinkedHashSet
====================
LinkedHashSet is a specific implementation of the Set interface that provides a predictable iteration order while maintaining the unique property of a Set. It is the "ordered" version of HashSet.


ğŸ”„ The Core Concept
LinkedHashSet is physically a combination of a Hash Table and a Doubly-Linked List.
1ï¸âƒ£ Hash Table â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Used for high-performance storage and $O(1)$ lookups.
2ï¸âƒ£ Doubly-Linked List â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Used to maintain the insertion order of the elements.


ğŸ”„ Internal Working
The internal working of LinkedHashSet is very similar to HashSet, but with one key difference in how it uses the underlying Map
1ï¸âƒ£ Backed by LinkedHashMap â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ While HashSet uses a HashMap internally, LinkedHashSet uses a LinkedHashMap.
2ï¸âƒ£ Order Preservation â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ When you add an element, the LinkedHashMap creates an entry and links it to the previous element added. This creates a chain through all elements in the order they were inserted.
3ï¸âƒ£ Efficiency â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Because it uses a hash table, it still provides O(1) time complexity for add, remove, and contains operations.


ğŸ”„ Key Characteristics
| Feature       | Description                                                      |
| ------------- | ---------------------------------------------------------------- |
| Duplicates    | âŒ Not allowed (inherits `Set` behavior)                          |
| Null Elements | âœ… Allows one `null` element                                      |
| Ordering      | Maintains **insertion order** during iteration                   |
| Performance   | Slightly slower than `HashSet`, faster than `TreeSet`            |
| Memory Usage  | Higher than `HashSet` due to linked list `before/after` pointers |


âœ… Code Implementation: HashSet vs. LinkedHashSet
This example highlights the difference in iteration behavior.

import java.util.*;

public class LinkedHashSetDemo {
    public static void main(String[] args) {
        // HashSet - Random Order
        Set<String> hs = new HashSet<>();
        hs.add("India");
        hs.add("USA");
        hs.add("Japan");
        hs.add("Brazil");
        System.out.println("HashSet (Random): " + hs);

        // LinkedHashSet - Insertion Order
        Set<String> lhs = new LinkedHashSet<>();
        lhs.add("India");
        lhs.add("USA");
        lhs.add("Japan");
        lhs.add("Brazil");
        System.out.println("LinkedHashSet (Ordered): " + lhs);
    }
}
âœ… Output
HashSet (Random): [USA, Japan, Brazil, India] 
LinkedHashSet (Ordered): [India, USA, Japan, Brazil]


ğŸ”„ When to Use LinkedHashSet
You should choose LinkedHashSet when
1ï¸âƒ£ You need a collection of unique elements.
2ï¸âƒ£ The order in which you add elements must be preserved (e.g., a "Recently Viewed Products" list where you don't want duplicates).
3ï¸âƒ£ You are willing to trade a small amount of memory/performance for that ordering.


ğŸ”„ Compared to Other Set Implementations
| Feature                 | HashSet                      | LinkedHashSet                  | TreeSet                 |
| ----------------------- | ---------------------------- | ------------------------------ | ----------------------- |
| Ordering                | No ordering                  | Insertion order                | Natural / Sorted order  |
| Internal Data Structure | Hash table                   | Hash table + linked list       | Red-Black Tree          |
| Search Time             | **O(1)** (average)           | **O(1)** (average)             | **O(log n)**            |
| Null Elements           | Allows one `null`            | Allows one `null`              | âŒ Does not allow `null` |
| Performance             | Fastest                      | Slightly slower than `HashSet` | Slowest among three     |
| Use Case                | Fast lookup, no order needed | Order matters                  | Sorted data required    |


============
ğŸ”· TreeSet
============
TreeSet is a concrete implementation of the NavigableSet interface, which in turn extends SortedSet. Unlike HashSet, it guarantees that the elements will be in a specific, sorted order.

ğŸ”„ The Core Concept
TreeSet stores its elements in a Red-Black Tree (a type of self-balancing binary search tree).
    âœ”ï¸ Sorted Order â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Elements are stored in their "natural" ascending order (like 1, 2, 3 or A, B, C) or according to a custom Comparator provided at creation time.
    âœ”ï¸ Internal Map â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Similar to HashSet being backed by HashMap, TreeSet is internally backed by a TreeMap.


ğŸ”„ Key Characteristics
| Feature            | Description                                                               |
| ------------------ | ------------------------------------------------------------------------- |
| Duplicates         | âŒ Not allowed                                                             |
| Null Elements      | âŒ Does not allow `null` (throws `NullPointerException` due to comparison) |
| Performance        | **O(log n)** for `add`, `remove`, and `contains`                          |
| Ordering           | Always sorted (natural order or custom `Comparator`)                      |
| Thread Safety      | âŒ Not synchronized / not thread-safe                                      |
| Internal Structure | Red-Black Tree                                                            |


ğŸ”„ Navigation Methods
Because TreeSet implements NavigableSet, it provides powerful methods to find elements relative to a target:
ğŸ”— first() / last() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns the smallest and largest elements.

ğŸ”— lower(e) / higher(e) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns the greatest element strictly less than e, or the least element strictly greater than e.

ğŸ”— floor(e) / ceiling(e) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Same as lower/higher, but includes equality (returns e if it exists in the set).

ğŸ”— pollFirst() / pollLast() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Retrieves and removes the first or last element.


ğŸ”„ How TreeSet Determines Equality
Crucial Distinction â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ HashSet uses .equals() and .hashCode() to identify duplicates. TreeSet does not.
    âœ”ï¸ TreeSet uses the compareTo() (or compare()) method.
    âœ”ï¸ If a.compareTo(b) == 0, TreeSet considers them duplicates and will not add the second one, even if a.equals(b) is false.

âŒ Warning â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ To ensure your TreeSet behaves correctly, your compareTo logic should be consistent with your equals logic.


âœ… Code Example: Natural vs. Custom Sorting
import java.util.*;

public class TreeSetDemo {
    public static void main(String[] args) {
        // 1. Natural Sorting (Integers)
        TreeSet<Integer> numbers = new TreeSet<>();
        numbers.add(50);
        numbers.add(10);
        numbers.add(30);
        numbers.add(30); // Duplicate, ignored
        
        System.out.println("Sorted Numbers: " + numbers); // [10, 30, 50]

        // 2. Navigation
        System.out.println("Closest below 35: " + numbers.floor(35)); // 30
        System.out.println("Higher than 10: " + numbers.higher(10)); // 30

        // 3. Custom Sorting (Descending Order)
        TreeSet<String> names = new TreeSet<>(Comparator.reverseOrder());
        names.add("Alice");
        names.add("Charlie");
        names.add("Bob");
        
        System.out.println("Reverse Names: " + names); // [Charlie, Bob, Alice]
    }
}


===========================
ğŸ”· ConcurrentSkipListSet
===========================
â¤ A concurrent, sorted, thread-safe set.
â¤ Backed by ConcurrentSkipListMap internally.
â¤ Maintains ascending sorted order.
â¤ Good for range-based operations (subSet, headSet, tailSet).
â¤ Weakly consistent iterators â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ do not throw ConcurrentModificationException, but may miss new updates.

âœ…Code Implementation:
import java.util.concurrent.*;

public class ConcurrentSkipListSetDemo {
    public static void main(String[] args) {
        ConcurrentSkipListSet<Integer> csls = new ConcurrentSkipListSet<>();

        csls.add(50);
        csls.add(20);
        csls.add(10);
        csls.add(40);

        System.out.println("ConcurrentSkipListSet: " + csls);
        System.out.println("HeadSet(<40): " + csls.headSet(40));
        System.out.println("TailSet(>=20): " + csls.tailSet(20));
        System.out.println("SubSet(10 to 40): " + csls.subSet(10, 40));
    }
}

âœ… Output:
ConcurrentSkipListSet: [10, 20, 40, 50]
HeadSet(<40): [10, 20]
TailSet(>=20): [20, 40, 50]
SubSet(10 to 40): [10, 20]


========================
ğŸ”· CopyOnWriteArraySet
========================
â¤ Backed by CopyOnWriteArrayList.
â¤ Thread-safe set.
â¤ On every write operation (add/remove) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ creates a new copy of the underlying array.
â¤ Reads are fast (no lock needed), but writes are expensive.
â¤ Best suited for:
	âœ”ï¸ Read-heavy, write-light scenarios.
	âœ”ï¸ Avoiding ConcurrentModificationException.

ğŸ”„ Iterator Behavior
â¤ Iterators are fail-safe (donâ€™t throw ConcurrentModificationException).
â¤ Iterators work on a snapshot of the array at the time of iteration â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ modifications made after iterator creation are not reflected.

âœ…Code Implementation
import java.util.concurrent.*;
import java.util.*;

public class CopyOnWriteArraySetDemo {
    public static void main(String[] args) {
        CopyOnWriteArraySet<String> cowSet = new CopyOnWriteArraySet<>();

        cowSet.add("Java");
        cowSet.add("Python");
        cowSet.add("C++");
        cowSet.add("Java"); // duplicate ignored

        System.out.println("CopyOnWriteArraySet: " + cowSet);

        // Iterating while modifying (safe)
        Iterator<String> it = cowSet.iterator();
        cowSet.add("Go"); // modification after iterator creation

        System.out.println("Iterator Snapshot:");
        while (it.hasNext()) {
            System.out.println(it.next()); // "Go" wonâ€™t appear here
        }

        System.out.println("After modification: " + cowSet); // "Go" appears in actual set
    }
}
âœ… Output:
CopyOnWriteArraySet: [Java, Python, C++]
Iterator Snapshot:
Java
Python
C++
After modification: [Java, Python, C++, Go]


=======================
ğŸ”· Queue Interface
=======================
The Queue interface (java.util.Queue) is a collection designed for holding elements prior to processing. It typically (but not necessarily) orders elements in a FIFO (First-In-First-Out) manner.

ğŸ”„ Key Characteristics
1ï¸âƒ£ Ordering â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Most queues are FIFO, where the element added first is the one removed first. Exceptions include PriorityQueue (ordered by priority) and LIFO stacks (if used via a Deque implementation).

2ï¸âƒ£ Insert/Remove/Inspect â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ The interface provides two methods for each of these three operationsâ€”one that throws an exception if the operation fails, and one that returns a special value (null or false).

3ï¸âƒ£ Null Elements â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Most implementations (like LinkedList or PriorityQueue) discourage or forbid null elements because null is used as a special return value by the poll() and peek() methods.


ğŸ”„ Core Methods
The Queue interface is unique because it offers two forms for every operation to allow for different error-handling styles.
| Operation Type     | Throws Exception                                       | Returns Special Value                |
| ------------------ | ------------------------------------------------------ | ------------------------------------ |
| Insert (at tail)   | `add(e)` â†’ throws `IllegalStateException` if full      | `offer(e)` â†’ returns `false` if full |
| Remove (from head) | `remove()` â†’ throws `NoSuchElementException` if empty  | `poll()` â†’ returns `null` if empty   |
| Examine (head)     | `element()` â†’ throws `NoSuchElementException` if empty | `peek()` â†’ returns `null` if empty   |


ğŸ”„ Queue Hierarchy
The Queue interface is the root for several specialized sub-interfaces and implementations:
1ï¸âƒ£ Deque (Double Ended Queue): Extends Queue to allow insertion and removal from both ends.

2ï¸âƒ£ BlockingQueue: Used in concurrent programming; methods wait for the queue to become non-empty when retrieving or wait for space to become available when storing.

3ï¸âƒ£ PriorityQueue: An implementation where elements are ordered according to their natural ordering or a custom Comparator.


âœ… Code Example: Basic Queue Operations
import java.util.*;

public class QueueDemo {
    public static void main(String[] args) {
        // Using LinkedList as a Queue
        Queue<String> queue = new LinkedList<>();

        // 1. Enqueue (Add elements)
        queue.add("Patient 1");
        queue.offer("Patient 2");
        queue.offer("Patient 3");

        System.out.println("Queue: " + queue);

        // 2. Peek (Look at the head without removing)
        System.out.println("Head of queue: " + queue.peek()); 

        // 3. Dequeue (Remove elements from the head)
        System.out.println("Removed: " + queue.poll()); // Removes Patient 1
        
        System.out.println("Queue after poll: " + queue);

        // 4. Iterating
        System.out.println("Remaining Patients:");
        for (String patient : queue) {
            System.out.println("- " + patient);
        }
    }
}


ğŸ”„ When to use a Queue?
    âœ”ï¸ Messaging Systems â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ To handle tasks in the order they were received.
    âœ”ï¸ Breadth-First Search (BFS) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ In graph algorithms to track nodes to visit.
    âœ”ï¸ Buffer Management â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ For IO operations or printer spooling where data is produced faster than it is consumed.


ğŸ”„ Common Implementations
| Class           | Internal Structure          | Ordering       |
| --------------- | --------------------------- | -------------- |
| `LinkedList`    | Doubly linked list          | FIFO           |
| `PriorityQueue` | Priority heap (binary heap) | Priority-based |
| `ArrayDeque`    | Resizable array             | FIFO / LIFO    |


===================
ğŸ”· PriorityQueue
===================
PriorityQueue is a specialized implementation of the Queue interface. Unlike a standard queue that follows FIFO (First-In-First-Out), a PriorityQueue processes elements based on their priority.


ğŸ”„ The Core Concept
In a PriorityQueue, every element has an associated priority.
â¤ Elements with higher priority are served before elements with lower priority.
â¤ By default (Natural Ordering), the smallest element is considered the highest priority (e.g., the number 1 comes out before 10).
â¤ You can provide a custom Comparator to define your own priority logic (e.g., the largest number first).


ğŸ”„ Internal Working: The Binary Heap
Internally, PriorityQueue is not a sorted list. It is implemented using a Priority Heap (specifically a Min-Heap by default).
â¤ Structure â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ It is a balanced binary tree stored in an array.
â¤ The Heap Property â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ In a Min-Heap, for any given node, the value of that node is less than or equal to the values of its children. This ensures that the root (index 0) is always the smallest element.
â¤ Efficiency â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ * Insert (offer) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ O(log n) (requires "bubbling up" the element).
    âœ”ï¸ Remove Head (poll) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ O(log n) (requires "sifting down" to restore heap property).
    âœ”ï¸ Peek â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ O(1) (the smallest element is always at the root).


ğŸ”„ Key Characteristics
| Feature            | Description                                                                                                                |
| ------------------ | -------------------------------------------------------------------------------------------------------------------------- |
| Duplicates         | âœ… Allowed                                                                                                                  |
| Null Elements      | âŒ Not allowed (`NullPointerException` due to comparison requirement)                                                       |
| Ordering           | Not globally sorted; only the **head** is guaranteed to be the minimum (or highest priority). Iteration order is undefined |
| Thread Safety      | âŒ Not thread-safe (`PriorityBlockingQueue` for concurrent use)                                                             |
| Internal Structure | Binary heap                                                                                                                |


âœ…Code Implementation 1:Natural Ordering (Min-Heap)
import java.util.*;

public class PriorityQueueMinHeap {
    public static void main(String[] args) {
        PriorityQueue<Integer> pq = new PriorityQueue<>(); // min-heap

        pq.add(40);
        pq.add(10);
        pq.add(30);
        pq.add(20);

        System.out.println("PriorityQueue (Min-Heap): " + pq);
        System.out.println("Peek (smallest): " + pq.peek()); // 10

        while (!pq.isEmpty()) {
            System.out.println("Poll: " + pq.poll());
        }
    }
}

âœ… Output:
PriorityQueue (Min-Heap): [10, 20, 30, 40]
Peek (smallest): 10
Poll: 10
Poll: 20
Poll: 30
Poll: 40

âœ…Code Implementation 2:Reverse Order (Max-Heap)
import java.util.*;

public class PriorityQueueMaxHeap {
    public static void main(String[] args) {
        // Max-Heap using Comparator
        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());

        pq.offer(40);
        pq.offer(10);
        pq.offer(30);
        pq.offer(20);

        System.out.println("PriorityQueue (Max-Heap): " + pq);
        System.out.println("Peek (largest): " + pq.peek()); // 40

        while (!pq.isEmpty()) {
            System.out.println("Poll: " + pq.poll());
        }
    }
}

âœ… Code Example 3: PriorityQueue with Custom Objects
import java.util.*;

class Task {
    String name;
    int priority; // smaller value = higher priority

    Task(String name, int priority) {
        this.name = name;
        this.priority = priority;
    }

    @Override
    public String toString() {
        return name + " (priority " + priority + ")";
    }
}

public class PriorityQueueCustom {
    public static void main(String[] args) {
        PriorityQueue<Task> taskQueue = new PriorityQueue<>(
            Comparator.comparingInt(t -> t.priority) // custom comparator
        );

        taskQueue.add(new Task("Write report", 3));
        taskQueue.add(new Task("Fix bug", 1));
        taskQueue.add(new Task("Email client", 2));

        System.out.println("Task Queue: " + taskQueue);

        while (!taskQueue.isEmpty()) {
            System.out.println("Processing: " + taskQueue.poll());
        }
    }
}


ğŸ”„ Why is the Iterator Not Sorted?
â¤ A common point of confusion is that if you print a PriorityQueue directly, the output looks unsorted: [10, 50, 30].
â¤ This is because the heap only guarantees the top element is the smallest.
â¤ The internal array arrangement satisfies the heap property but is not a fully sorted sequence.
â¤ To get elements in order, you must use poll() until the queue is empty.


ğŸ”„ Queue vs PriorityQueue
| Feature                       | LinkedList (as Queue)   | PriorityQueue             |
| ----------------------------- | ----------------------- | ------------------------- |
| Order                         | FIFO (insertion order)  | Priority-based            |
| Internal Data Structure       | Doubly linked list      | Binary heap (array-based) |
| Time Complexity (Head access) | **O(1)**                | **O(1)**                  |
| Time Complexity (Insert)      | **O(1)**                | **O(log n)**              |
| Null Elements                 | Allows `null`           | âŒ Does not allow `null`   |
| Use Case                      | Simple queue processing | Priority-based scheduling |


==============================
ğŸ”· Deque (Double Ended Queue)
==============================
â¤ A linear data structure that allows insertion & deletion at both ends (front & rear).
â¤ More versatile than Queue and Stack:
    âœ”ï¸ Queue â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Insert at rear, delete at front
    âœ”ï¸ Stack â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Insert & delete at same end (LIFO)
    âœ”ï¸ Deque â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Supports both behaviors.

ğŸ”„ Implementations in Java
Interface: Deque<E> (extends Queue<E> from java.util).

ğŸŒŸ Common Implementations:
âœ”ï¸ ArrayDeque<E> â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Resizable circular array
    â¤ Fast iteration, no null allowed, better cache locality
    â¤ Preferred in most cases over LinkedList

âœ”ï¸ LinkedList<E> â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Doubly linked list
    â¤ Allows null values, higher memory usage
    â¤ Slower iteration than ArrayDeque

ğŸ”„ Methods in Deque
âš¡ Insertion
ğŸ”— addFirst(E e) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Insert at front (throws exception if fails)
ğŸ”— addLast(E e) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Insert at end (throws exception if fails)
ğŸ”— offerFirst(E e) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Insert at front (returns false if fails)
ğŸ”— offerLast(E e) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Insert at end (returns false if fails)

âš¡ Removal
ğŸ”— removeFirst() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Remove & return front (throws exception if empty)
ğŸ”— removLast() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Remove & return end (throws exception if empty)
ğŸ”— pollFirst() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Remove & return front (returns null if empty)
ğŸ”— pollLast() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Remove & return end (returns null if empty)

âš¡ Examination (Access without removal, exception if empty)
ğŸ”— getFirst() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Retrieve front element
ğŸ”— getLast() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Retrieve last element

âš¡ Peeking (Access without removal, safe)
ğŸ”— peekFirst() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Peek front element
ğŸ”— peekLast() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Peek last element

âš¡ Other Important Methods
ğŸ”— size() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Number of elements
ğŸ”— isEmpty() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Check if empty
ğŸ”— contains(Object o) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Check existence
ğŸ”— iterator() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Iterates from front â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ end
ğŸ”— descendingIterator() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Iterates from end â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ front

âœ… Example (Using ArrayDeque)
import java.util.*;

public class DequeExample {
    public static void main(String[] args) {
        Deque<Integer> deque1 = new ArrayDeque<>(); 

        // Insertions
        deque1.addFirst(10);    // [10]
        deque1.addLast(20);     // [10, 20]
        deque1.offerFirst(30);  // [30, 10, 20]
        deque1.offerLast(40);   // [30, 10, 20, 40]

        System.out.println(deque1);  // [30, 10, 20, 40]

        // Access elements
        System.out.println(deque1.getFirst()); // 30
        System.out.println(deque1.getLast());  // 40

        // Removals
        deque1.removeFirst();   // removes 30 â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ [10, 20, 40]
        deque1.pollLast();      // removes 40 â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ [10, 20]

        System.out.println(deque1);  // [10, 20]
    }
}

ğŸ”„ Special Usages
ğŸ‘‰ As Queue â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Only use addLast(), removeFirst()
ğŸ‘‰ As Stack â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Use push(), pop(), peek()
    â¤ Internally mapped as addFirst(), removeFirst(), peekFirst()

âœ… Example:
Deque<Integer> stack = new ArrayDeque<>();
stack.push(1);   // addFirst(1)
stack.push(2);   // addFirst(2)
System.out.println(stack.pop()); // removeFirst() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ 2

ğŸ”„ Key Differences Between Implementations
âœ”ï¸ ArrayDeque
    â¤ Backed by resizable circular array
    â¤ Doesnâ€™t allow null
    â¤ Faster than LinkedList (less memory, no node overhead)

âœ”ï¸ LinkedList
    â¤ Doubly linked list
    â¤ Allows null
    â¤ More memory overhead

ğŸ§  Traps / Notes
â¤ add/remove methods â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Throw exceptions on failure
â¤ offer/poll methods â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Return special values (false / null) instead of exception
â¤ Prefer ArrayDeque unless null values are required
â¤ Iteration order:
    âœ”ï¸ iterator() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ head â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ tail
    âœ”ï¸ descendingIterator() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ tail â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ head


=================
ğŸ”· BlockingQueue
=================
â¤ Interface in java.util.concurrent package.
â¤ A thread-safe queue designed for concurrent programming.
â¤ Unlike normal queues:
    âœ”ï¸ Blocks when trying to add to a full queue.
    âœ”ï¸ Blocks when trying to remove from an empty queue.
â¤ Simplifies classic concurrency problems like Producerâ€“Consumer.

ğŸ”„ Implementations
ğŸ‘‰ ArrayBlockingQueue â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ bounded, circular array-backed
ğŸ‘‰ LinkedBlockingQueue â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ optional capacity (unbounded by default), linked nodes
ğŸ‘‰ PriorityBlockingQueue â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ priority-based (like PriorityQueue, but thread-safe)
ğŸ‘‰ DelayQueue, SynchronousQueue, etc. (specialized cases)

ğŸ”„ Core Methods
âš¡ Insertion
ğŸ”— put(E e) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Blocks if queue is full until space is available.
ğŸ”— offer(E e) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Immediately returns false if queue is full.
ğŸ”— offer(E e, long timeout, TimeUnit unit) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Waits up to timeout for space.

âš¡ Removal
ğŸ”— take() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Blocks if queue is empty until element is available.
ğŸ”— poll() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns null if queue is empty.
ğŸ”— poll(long timeout, TimeUnit unit) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Waits up to timeout for an element.

âš¡ Others
ğŸ”— peek() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Retrieves head without removing (null if empty).
ğŸ”— size() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns number of elements.
ğŸ”— remainingCapacity() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Available space before full.

ğŸ”„ Key Difference with Normal Queue
â¤ Normal Queue: No waiting â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ add/remove fail immediately if full/empty.
â¤ BlockingQueue: Waits (blocks) until space or element becomes available.

ğŸŒŸ Using ArrayBlockingQueue
â¤ A bounded, blocking queue backed by a circular array.
â¤ Low memory overhead.
â¤ Uses a single lock for both Enqueue and Dequeue operations.
â¤ More threads can casuse contention on the lock.

âœ… Example: 
import java.util.concurrent.*;

public class BlockingQueueExample {
    public static void main(String[] args) throws InterruptedException {
        BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(5);

        // Producer thread
        Thread producer = new Thread(() -> {
            try {
                for (int i = 1; i <= 7; i++) {
                    System.out.println("Producing: " + i);
                    queue.put(i); // Blocks if full
                    Thread.sleep(500); // simulate work
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        // Consumer thread
        Thread consumer = new Thread(() -> {
            try {
                for (int i = 1; i <= 7; i++) {
                    int item = queue.take(); // Blocks if empty
                    System.out.println("Consuming: " + item);
                    Thread.sleep(1000); // simulate work
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        producer.start();
        consumer.start();

        producer.join();
        consumer.join();
    }
}
âœ… Sample Output (Producerâ€“Consumer)
Producing: 1
Consuming: 1
Producing: 2
Producing: 3
Consuming: 2
Producing: 4
Producing: 5
Producing: 6  // Producer blocks if queue is full
Consuming: 3  // Consumer frees space â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Producer resumes

ğŸ§  Traps & Notes
â¤ put() and take() are blocking, unlike normal queue ops.
â¤ Thread-safe: no need for manual synchronization.
â¤ Bounded queues (like ArrayBlockingQueue) prevent memory overflow.
â¤ Useful in multi-threading scenarios:
    âœ”ï¸ Producerâ€“Consumer problem
    âœ”ï¸ Task scheduling systems
    âœ”ï¸ Thread pools
    âœ”ï¸ LinkedBlockingQueue


========================
ğŸ”· LinkedBlockingQueue
========================
â¤ A thread-safe blocking queue based on a linked list.
â¤ Optionally bounded:
    âœ”ï¸ Default = unbounded (capacity = Integer.MAX_VALUE)
    âœ”ï¸ Can be bounded at creation â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ safer (prevents memory issues).
â¤ Located in java.util.concurrent package.

ğŸ”„ Characteristics
â¤ Unbounded by default â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ may cause OutOfMemoryError if producers are much faster than consumers.
â¤ Bounded form recommended â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ use constructor new LinkedBlockingQueue<>(capacity).
â¤ Backed by linked list â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ memory allocated per node.
â¤ Two separate locks:
    âœ”ï¸ One for enqueue (put/offer)
    âœ”ï¸ One for dequeue (take/poll)
    âœ”ï¸ â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Allows higher concurrency between producers and consumers.
â¤ Supports more threads compared to ArrayBlockingQueue due to reduced contention.

ğŸ”„ Core Methods (Same as BlockingQueue)

âœ…Code Example: Bounded LinkedBlockingQueue
import java.util.concurrent.*;

public class LinkedBlockingQueueExample {
    public static void main(String[] args) throws InterruptedException {
        BlockingQueue<Integer> queue = new LinkedBlockingQueue<>(3); // bounded

        Thread producer = new Thread(() -> {
            try {
                for (int i = 1; i <= 6; i++) {
                    System.out.println("Producing: " + i);
                    queue.put(i); // blocks if full
                    Thread.sleep(300);
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        Thread consumer = new Thread(() -> {
            try {
                for (int i = 1; i <= 6; i++) {
                    int item = queue.take(); // blocks if empty
                    System.out.println("Consuming: " + item);
                    Thread.sleep(800);
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        producer.start();
        consumer.start();

        producer.join();
        consumer.join();
    }
}

LinkedBlockingQueue ğŸ†š ArrayBlockingQueue
Feature                  LinkedBlockingQueue                      ArrayBlockingQueue
------------------------------------------------------------------------------------------
Capacity                 Unbounded by default / Can be bounded    Always bounded (fixed size)
Backing                  Linked list (dynamic nodes)              Circular array
Locks                    Two locks (enqueue & dequeue)            Single lock (both ops)
Concurrency              Higher (better producer-consumer)        Lower (more contention)
Throughput               Better in high-thread scenarios          Better in low contention
Memory Usage             Higher (node overhead per element)       Lower (contiguous array)
Null Allowed?            No                                       No

ğŸ§  Traps & Notes
â¤ Default is unbounded â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ may cause OutOfMemoryError. Always set capacity in real-world use.
â¤ Higher concurrency because producers and consumers donâ€™t block each other as much (separate locks).
â¤ Preferred for high producer-consumer traffic.
â¤ ArrayBlockingQueue is preferred for predictable, bounded workloads with better memory efficiency.


=========================
ğŸ”· PriorityBlockingQueue
=========================
â¤,A thread-safe, unbounded blocking queue that orders elements based on:
    âœ”ï¸ Natural ordering (Comparable) at head OR
    âœ”ï¸ Custom Comparator provided at construction.
â¤ Default initial capacity = 11, grows dynamically (like PriorityQueue).
â¤ Implemented using a binary heap (array-backed).

ğŸ”„ Characteristics
â¤ Unbounded â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ capacity can grow dynamically (but bounded by memory).
â¤ put() wonâ€™t block (unlike ArrayBlockingQueue or LinkedBlockingQueue) because the queue never becomes â€œfull.â€
â¤ take() will block if the queue is empty until an element is available.
â¤ Head = least element according to ordering.
â¤ Null elements not allowed.

ğŸ”„ Core Methods (same as BlockingQueue)

âœ…Code Example:
import java.util.concurrent.*;

public class PriorityBlockingQueueExample {
    public static void main(String[] args) throws InterruptedException {
        BlockingQueue<Integer> pq = new PriorityBlockingQueue<>();

        // Producer
        Thread producer = new Thread(() -> {
            try {
                int[] nums = {50, 10, 30, 20, 40};
                for (int n : nums) {
                    System.out.println("Producing: " + n);
                    pq.put(n);  // never blocks
                    Thread.sleep(300);
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        // Consumer
        Thread consumer = new Thread(() -> {
            try {
                for (int i = 0; i < 5; i++) {
                    int item = pq.take(); // retrieves in natural order
                    System.out.println("Consuming: " + item);
                    Thread.sleep(700);
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        producer.start();
        consumer.start();

        producer.join();
        consumer.join();
    }
}

âœ…Output:
Producing: 50
Producing: 10
Consuming: 10   // smallest first
Producing: 30
Producing: 20
Consuming: 20
Producing: 40
Consuming: 30
Consuming: 40
Consuming: 50

ğŸ§  Traps / Notes
â¤ Difference from other BlockingQueues:
    âœ”ï¸ put() never blocks because itâ€™s unbounded.
    âœ”ï¸ Only take() blocks when queue is empty.
â¤ Ordering:
    âœ”ï¸ Natural (via Comparable) OR custom (via Comparator).
    âœ”ï¸ No FIFO guarantee for same-priority elements.
â¤ Use cases:
    âœ”ï¸ Task scheduling (e.g., priority-based job execution).
    âœ”ï¸ Message prioritization systems.


====================
ğŸ”· SynchronousQueue
====================
â¤ A special type of BlockingQueue in java.util.concurrent.
â¤ Capacity = 0 (or conceptually 1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ it cannot hold elements.
â¤ Each put() must wait for a take() by another thread (and vice versa).
â¤ Think of it as a handoff queue between threads.

ğŸ”„ Characteristics
â¤ No element storage â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ acts as a direct handoff.
â¤ Producer and consumer must rendezvous (meet) for an element transfer.
â¤ Good for scenarios like thread pools, work handoff, or when tasks should not be queued.
â¤ Has two modes internally:
    âœ”ï¸ Fair mode (FIFO order, true constructor flag)
    âœ”ï¸ Non-fair mode (default, higher throughput, not strictly ordered)


ğŸ”„Methods Behavior
â¤ put(E e) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Blocks until another thread calls take().
â¤ take() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Blocks until another thread calls put().
â¤ offer(E e, timeout, unit) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Waits for a consumer within timeout, else fails.
â¤ poll(timeout, unit) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Waits for a producer within timeout, else returns null.
    
âœ…Code Example:
import java.util.concurrent.*;

public class SynchronousQueueExample {
    public static void main(String[] args) {
        BlockingQueue<String> queue = new SynchronousQueue<>();

        // Producer
        new Thread(() -> {
            try {
                System.out.println("Producer: trying to put A");
                queue.put("A");
                System.out.println("Producer: put A successfully");

                System.out.println("Producer: trying to put B");
                queue.put("B");
                System.out.println("Producer: put B successfully");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();

        // Consumer
        new Thread(() -> {
            try {
                Thread.sleep(1000); // Delay to show blocking
                System.out.println("Consumer: took " + queue.take());

                Thread.sleep(1000);
                System.out.println("Consumer: took " + queue.take());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
    }
}

âœ…Output:
Producer: trying to put A
(Producer blocks until Consumer takes)
Consumer: took A
Producer: put A successfully
Producer: trying to put B
(Producer blocks again)
Consumer: took B
Producer: put B successfully


ğŸ”„ Interview Traps / Notes
â¤ Unlike ArrayBlockingQueue or LinkedBlockingQueue, it does not store data.
â¤ Ensures direct synchronization between producer and consumer.
â¤ Use case:
    âœ”ï¸ Task handoff in thread pools (Executors.newCachedThreadPool() uses it internally).
    âœ”ï¸ Workflows where queueing is undesirable.
â¤ Constructor: new SynchronousQueue<>(true) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ fair mode (FIFO order).


===============
ğŸ”· DelayQueue
===============
â¤ A thread-safe, unbounded blocking queue in java.util.concurrent.
â¤ Stores elements that implement the Delayed interface.
â¤ Elements can be retrieved only when their delay has expired.
â¤ Internally backed by a priority queue (ordered by remaining delay).

ğŸ”„ Characteristics
â¤ Unbounded â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ grows dynamically (bounded by memory).
â¤ Ordering â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ element with the least remaining delay is at the head.
â¤ Blocking behavior:
    âœ”ï¸ take() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ waits until head elementâ€™s delay has expired.
    âœ”ï¸ poll() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ returns element if delay expired, else null.
â¤ Cannot contain null elements.
â¤ Useful for task scheduling, caching with timeouts, rate limiting.

ğŸ”„ Core Methods
â¤ put(E e) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Inserts element (no blocking since unbounded).
â¤ take() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Blocks until an element with expired delay is available.
â¤ poll() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns head if delay expired, else null.
â¤ peek() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns head (even if delay not expired), does not remove.

ğŸ”„ Implementing Delayed Elements
To use DelayQueue, elements must implement:
    âœ”ï¸ getDelay(TimeUnit unit) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Remaining delay.
    âœ”ï¸ compareTo(Delayed other) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Ordering (usually based on delay expiry time).

âœ…Code Example: DelayQueue with Delayed Tasks    
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;

class DelayedTask implements Delayed {
    private final long startTime;
    private final String taskName;

    public DelayedTask(String taskName, long delayMillis) {
        this.taskName = taskName;
        this.startTime = System.currentTimeMillis() + delayMillis;
    }

    @Override
    public long getDelay(TimeUnit unit) {
        long diff = startTime - System.currentTimeMillis();
        return unit.convert(diff, TimeUnit.MILLISECONDS);
    }

    @Override
    public int compareTo(Delayed other) {
        return Long.compare(this.startTime, ((DelayedTask) other).startTime);
    }

    @Override
    public String toString() {
        return taskName;
    }
}

public class DelayQueueExample {
    public static void main(String[] args) throws InterruptedException {
        DelayQueue<DelayedTask> queue = new DelayQueue<>();

        queue.put(new DelayedTask("Task-1", 2000)); // 2 sec delay
        queue.put(new DelayedTask("Task-2", 1000)); // 1 sec delay
        queue.put(new DelayedTask("Task-3", 3000)); // 3 sec delay

        for (int i = 0; i < 3; i++) {
            DelayedTask task = queue.take(); // blocks until delay expires
            System.out.println("Executed: " + task + " at " + System.currentTimeMillis());
        }
    }
}

âœ…Output:
Executed: Task-2 at 1001
Executed: Task-1 at 2002
Executed: Task-3 at 3003
(Execution order depends on delay expiry, not insertion order).


ğŸ”„ Interview Traps / Notes
â¤ Unlike PriorityBlockingQueue, an element is not available immediately â€” it must expire first.
â¤ Always unbounded â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ possible memory issues if too many delayed tasks are queued.
â¤ Common use cases:
    âœ”ï¸ Scheduling tasks after a delay.
    âœ”ï¸ Implementing retry mechanisms.
    âœ”ï¸ Session timeouts / cache eviction.


===========================
ğŸ”· ConcurrentLinkedQueue
===========================
â¤ A lock-free, thread-safe implementation of Queue interface.
â¤ Located in java.util.concurrent.
â¤ Based on non-blocking algorithms (uses CAS â€“ Compare-And-Swap) instead of locks.
â¤ Suitable for high-concurrency scenarios where blocking is undesirable.

ğŸ”„ Characteristics
â¤ Unbounded â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ grows dynamically (bounded by memory).
â¤ Non-blocking:
    âœ”ï¸ If empty â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ poll() returns null (does not wait).
    âœ”ï¸ If full (theoretically never, since unbounded) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ inserts always succeed.
â¤ FIFO order maintained.
â¤ Better scalability than synchronized collections (Vector, Collections.synchronizedList).
â¤ Null elements not allowed.

ğŸ”„ Core Methods
ğŸ”— add(E e) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Inserts element at tail (same as offer()).
ğŸ”— offer(E e) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Inserts element at tail.
ğŸ”— poll() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Retrieves & removes head, returns null if empty.
ğŸ”— peek() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Retrieves head without removing, returns null if empty.
ğŸ”— size() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns current size (but not constant-time, may be expensive).
ğŸ”— isEmpty() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Check if queue is empty.

âœ…Code Example:Task Submission System
import java.util.concurrent.*;

class Task implements Runnable {
    private final String taskName;

    public Task(String name) {
        this.taskName = name;
    }

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + " executing " + taskName);
    }
}

public class ConcurrentLinkedQueueExample {
    public static void main(String[] args) throws InterruptedException {
        ConcurrentLinkedQueue<Task> taskQueue = new ConcurrentLinkedQueue<>();

        // Producer threads (submitting tasks)
        Thread producer1 = new Thread(() -> {
            for (int i = 1; i <= 5; i++) {
                Task t = new Task("Task-P1-" + i);
                taskQueue.offer(t);
                System.out.println("Producer1 submitted " + t);
            }
        });

        Thread producer2 = new Thread(() -> {
            for (int i = 1; i <= 5; i++) {
                Task t = new Task("Task-P2-" + i);
                taskQueue.offer(t);
                System.out.println("Producer2 submitted " + t);
            }
        });

        // Consumer thread (executing tasks)
        Thread consumer = new Thread(() -> {
            while (true) {
                Task t = taskQueue.poll();
                if (t != null) {
                    t.run();
                } else {
                    break; // exit when no tasks left
                }
            }
        });

        producer1.start();
        producer2.start();
        producer1.join();
        producer2.join();

        consumer.start();
        consumer.join();
    }
}

âœ…Output:
Producer1 submitted Task-P1-1
Producer2 submitted Task-P2-1
Producer1 submitted Task-P1-2
Producer2 submitted Task-P2-2
Thread-2 executing Task-P1-1
Thread-2 executing Task-P2-1
Thread-2 executing Task-P1-2
Thread-2 executing Task-P2-2
...

ğŸ§  Traps & Notes
â¤ Non-blocking: no put() / take() like BlockingQueue.
â¤ CAS (Compare-And-Swap) ensures atomic updates without locks â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ high throughput.
â¤ Best for message passing systems, task submission, event queues where blocking is not needed.
â¤ size() is not constant time â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ avoid in performance-critical code.


===========================
ğŸ”· ConcurrentLinkedDeque
===========================
â¤ A non-blocking, thread-safe, double-ended queue (Deque).
â¤ Located in java.util.concurrent.
â¤ Backed by lock-free, linked nodes with CAS (Compare-And-Swap) operations.
â¤ Allows concurrent insertions and removals at both ends.

ğŸ”„ Characteristics
â¤ Unbounded â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ grows dynamically (limited by memory).
â¤ Non-blocking:
    âœ”ï¸ No waiting (unlike BlockingDeque).
    âœ”ï¸ If empty â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ retrieval methods return null.
â¤ Thread-safe â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ multiple producers/consumers can work simultaneously.
â¤ Maintains FIFO order when used as a queue, or LIFO order when used as a stack.
â¤ Null elements not allowed.

ğŸ”„ Core Methods (Same as Deque, but thread-safe & lock-free)
â¤ Insertion
ğŸ”—  addFirst(E e) / offerFirst(E e) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Insert at head.
ğŸ”—  addLast(E e) / offerLast(E e) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Insert at tail.

â¤ Removal
ğŸ”—  pollFirst() / removeFirst() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Retrieve & remove head.
ğŸ”—  pollLast() / removeLast() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Retrieve & remove tail.

â¤ Access (no removal)
ğŸ”—  peekFirst() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Head element, or null if empty.
ğŸ”—  peekLast() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Tail element, or null if empty.

âœ…Code Example: Concurrent Task Queue
import java.util.concurrent.*;

public class ConcurrentLinkedDequeExample {
    public static void main(String[] args) throws InterruptedException {
        ConcurrentLinkedDeque<String> deque = new ConcurrentLinkedDeque<>();

        // Producer thread adds tasks at both ends
        Thread producer = new Thread(() -> {
            for (int i = 1; i <= 5; i++) {
                deque.addLast("Task-" + i);
                System.out.println("Produced Task-" + i);
            }
        });

        // Consumer thread processes tasks from the front
        Thread consumer = new Thread(() -> {
            while (true) {
                String task = deque.pollFirst();
                if (task != null) {
                    System.out.println("Consumed " + task);
                } else {
                    break;
                }
            }
        });

        producer.start();
        producer.join();

        consumer.start();
        consumer.join();
    }
}

âœ…Output:
Produced Task-1
Produced Task-2
Produced Task-3
Produced Task-4
Produced Task-5
Consumed Task-1
Consumed Task-2
Consumed Task-3
Consumed Task-4
Consumed Task-5


ğŸ§  Traps & Notes
â¤ Difference from BlockingDeque:
    âœ”ï¸ ConcurrentLinkedDeque â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ non-blocking (returns null if empty).
    âœ”ï¸ BlockingDeque â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ blocking (take() waits if empty).
â¤ Best for highly concurrent producer-consumer systems where waiting is not required.
â¤ Often used in work-stealing algorithms (threads can take tasks from both ends).
â¤ Provides lock-free scalability for multiple threads.


==========
ğŸ”· Enums 
==========
Enum (short for enumeration) is a special data type in Java used to represent a fixed set of named constants.

Introduced in Java 5.

Syntax:
enum EnumName {
    CONSTANT1, CONSTANT2, CONSTANT3
}

ğŸŒŸCharacteristics
â¤ Each constant in an enum is public, static, and final by default.
â¤ Enum extends java.lang.Enum internally.
â¤ Cannot extend another class because enums already extend Enum.
â¤ Can implement interfaces.
â¤ Can have fields, constructors, and methods.
â¤ Enum constants are singleton objects.

3. When to Use
1. When you have a predefined set of related constants, such as:
   â¤ Days of the week (MONDAY, TUESDAY, â€¦)
   â¤ States in a process (STARTED, IN_PROGRESS, COMPLETED)
   â¤ Severity levels (MINOR, MAJOR, CRITICAL)
2. Avoids "magic numbers" and string literals in code.

ğŸŒŸ Issues Without Enums (Your Current Code Problems)
â¤ Constants like MINOR=0, MAJOR=1 require manual mapping.
â¤ Risk of passing invalid values (e.g., 5 for severity).
â¤ Poor readability: You have to remember what 1 or 2 means.
â¤ No type safety â€” any int can be passed to methods.
â¤ Switching over raw numbers is error-prone.
â¤ Difficult to maintain â€” adding/removing constants requires editing multiple locations.

ğŸŒŸ Benefits of Using Enums
âœ… Type Safety â€” Compiler ensures only valid enum constants are used.
âœ… Readability â€” Constants have meaningful names.
âœ… No invalid values â€” Cannot pass unrelated numbers/strings.
âœ… Easy to maintain â€” Adding new constants is straightforward.
âœ… Can store data & behavior â€” Enums can have fields, constructors, and methods.

âŒ Code without Enums

public class Severity{
    final static int MINOR=0;
    final static int MAJOR=1;
    final static int CRITICAL=2;
}

public class Defect{
    public static int getDefectFixingTime( int severity){
        return switch(severity){
            case 0 -> 1;
            case 1->  3;
            case 2 -> 5;
            default -> thorw new IllegalArgumentException("Unexpected Value);
        }
    }
}

public class ReportDefect {
public static void main(String[] args) {
	int days=Defect.getDefectFixingTime(2);
	System.out.println(days);
}
}

âœ… Rewritten Using Enums
enum Severity {
    MINOR(1), MAJOR(3), CRITICAL(5);

    private final int fixingDays;

    //by default private constructor
    Severity(int fixingDays) {
        this.fixingDays = fixingDays;
    }

    //getter method
    public int getFixingDays() {
        return fixingDays;
    }
}

class Defect {

    public static int getDefectFixingTime(Severity severity) {
        return severity.getFixingDays();
    }
}

public class ReportDefect {
    public static void main(String[] args) {
        int days = Defect.getDefectFixingTime(Severity.CRITICAL);
        System.out.println(days);
    }
}

ğŸ”„How This Works
1. enum Severity:
    â¤ Represents fixed constants MINOR, MAJOR, and CRITICAL.
    â¤ Each constant stores an extra value (number of days) using a field.
    â¤ Constructor assigns this value.
    â¤ Method getFixingDays() retrieves it.

Defect class:
    â¤ Accepts only Severity type â€” prevents invalid arguments.

ReportDefect class:
    â¤ Calls method with an enum constant.
    â¤ Output for Severity.CRITICAL â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ 5.

ğŸŒŸKey Enum Features Used Here
â¤ Parameterized Enums: Storing extra information (fixingDays).
â¤ Type-Safe Method Parameters: Accepting Severity instead of int.

Built-in Enum Methods:
    â¤ values() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns all constants.
    â¤ valueOf(String name) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns constant by name.
    â¤ ordinal() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns index of constant (0-based).

Example:
for (Severity s : Severity.values()) {
    System.out.println(s + " takes " + s.getFixingDays() + " days");
}

ğŸŒŸEnum Memory & Performance
â¤ Each enum constant is a singleton instance created at class load time.
â¤ Performance-friendly â€” Similar to using static final constants but safer and more maintainable.
â¤ No extra overhead for typical usage.

ğŸŒŸTips
â¤ Enums in Java are class-like, not just constants.
â¤ They are more powerful than enums in languages like C/C++.
â¤ Can override methods for individual constants.
â¤ Cannot extend other classes but can implement interfaces.
â¤ Best practice: Use enums instead of int constants for fixed sets of values.    

| Aspect             | Int Constants (final static)                                            Enums                                                                  |
| Readability        | Less clear â€” values appear as numbers, meaning must be remembered or checked in code | Very clear â€” values have meaningful names               |
| Type Safety        | None â€” any integer can be passed accidentally                       | Strong â€” only predefined enum constants can be used                      |
| Maintainability    | Difficult â€” changing values may break multiple places silently      | Easy â€” changes are localized, compiler helps catch errors                |
| Extensibility      | Limited â€” adding new constants requires careful changes everywhere  | Easy â€” just add new enum constants without affecting existing logic much |
| Error Prevention   | Low â€” invalid integers may go unnoticed until runtime               | High â€” compile-time validation prevents most mistakes                    |
| Debugging          | Hard â€” logs show numbers without context                            | Easy â€” logs show constant names directly                                 |
| Refactoring Safety | Risky â€” renaming or reordering constants may cause logical issues   | Safe â€” compiler enforces correct usage                                   |
| Performance        | Slightly better in raw speed (no object creation)                   | Negligible performance difference for most applications                  |
| Business Risk      | Higher â€” more prone to bugs due to wrong values                     | Lower â€” safer to maintain and extend                                     |
| Best Use Case      | When extreme performance or memory constraints demand               | When a fixed set of named values is needed                               |

ğŸ”—Code using Built-in methods of Enums
enum Severity {
    LOW,
    MEDIUM,
    HIGH,
    CRITICAL
}

public class EnumExample {
    public static void main(String[] args) {

        // values()
        System.out.println("All constants:");
        for (Severity s : Severity.values()) {
            System.out.println(s);
        }

        // valueOf()
        Severity sev = Severity.valueOf("HIGH");
        System.out.println("\nValueOf(\"HIGH\") = " + sev);

        // ordinal()
        System.out.println("\nOrdinal positions:");
        for (Severity s : Severity.values()) {
            System.out.println(s + " -> " + s.ordinal());
        }
    }
}

âœ…Output:
All constants:
LOW
MEDIUM
HIGH
CRITICAL

ValueOf("HIGH") = HIGH

Ordinal positions:
LOW -> 0
MEDIUM -> 1
HIGH -> 2
CRITICAL -> 3


============
ğŸ”· Strings
============
A String in Java is an object that represents a sequence of characters.
Strings are immutable, meaning their value cannot be changed once created.

âœ… Ways to Create a String
â¤ Method 1: Using String Literal
String x1 = "mike";
Stored in String Pool (special area in heap memory).

Reuses memory if the same literal already exists.

â¤ Method 2: Using new Keyword
String x2 = new String("mike");
Always creates a new object in heap memory, outside the String Pool.

ğŸ§  String Pool (String Constant Pool)
A special memory region inside the heap that stores string literals.
Benefit: Saves memory by reusing existing string literals instead of creating new ones.

ğŸ” Reuse Example:
String s1 = "mike";
String s2 = "mike";
System.out.println(s1 == s2); // true (same reference in pool)

âš ï¸ When using new:
String s3 = new String("mike");
System.out.println(s1 == s3); // false (different memory locations)

âœï¸ Important:
Operations like == compare references, not values.
Use .equals() to compare values of strings.

ğŸ” Code Example: Comparing References vs Values
String x1 = "mike";
String x2 = "mike";
String x3 = new String("mike");

System.out.println(x1 == x2);        // true (same pool reference)
System.out.println(x2 == x3);        // false (heap vs pool)
System.out.println(x2.equals(x3));   // true (same content)

String str1 = new String("Ankur");
String str2 = new String("Ankur");

System.out.println(str1 == str2);    // false
System.out.println(str1.equals(str2)); // true

ğŸ’¡ intern() Method
Syntax:
String interned = new String("mike").intern();

What it does:
â¤ Checks if the value exists in the String Pool.
â¤ If yes, returns reference from the pool.
â¤ If no, adds the value to the pool and returns that reference.

â¤ Code Example:
String x1 = "mike";
String x3 = new String("mike").intern();

System.out.println(x1 == x3);       // true
System.out.println(x1.equals(x3));  // true

ğŸ“ Check if a String is Empty or Null
String str4 = null;
String str5 = "";

System.out.println(str5.length()); // 0
System.out.println(str4.length()); // âŒ NullPointerException

âš–ï¸ Difference: Null vs Empty String
| Property         | `null`                | `""` (Empty String)     |
| ---------------- | --------------------- | ----------------------- |
| Memory allocated | âŒ No                  | âœ… Yes                   |
| Object created   | âŒ No                  | âœ… Yes                   |
| `.length()`      | âŒ Throws Exception    | âœ… Returns 0             |
| Usability        | Can't call any method | Can call String methods |


ğŸ” How to Check if a String is Empty
âœ… Method 1: isEmpty()
Checks if string length is 0.
Returns: true if empty.

Code Example:
String x1 = "";
System.out.println(x1.isEmpty()); // true

âœ… Method 2: length()
You can manually check if the length is 0.
System.out.println(x1.length() == 0); // true

âœ… Method 3: isBlank()
Returns true if string is:
Empty ("") or
Contains only whitespaces (spaces, tabs, etc.)
Code Example:
String x2 = "   ";
System.out.println(x2.isBlank()); // true
ğŸ”¸ isBlank() is available from Java 11 onwards.

ğŸ§ª String Comparisons
Strings are case-sensitive by default.

âœ… Using equals() method
String str1 = "mike";
String str2 = "mike";
String str3 = "Mike";

System.out.println(str1.equals(str2)); // true
System.out.println(str1.equals(str3)); // false

âœ… Using equalsIgnoreCase() method
Ignores case differences.
System.out.println(str1.equalsIgnoreCase(str3)); // true

ğŸ“Š compareTo() Method
Compares strings lexicographically.
String str6 = "java";
String str7 = "python";

System.out.println(str6.compareTo(str7)); // -6

â¤ Output Meaning:
0 â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Both strings are equal.
< 0 â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ First string is lexicographically smaller.
> 0 â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ First string is lexicographically greater.

ğŸ”„ String Case Conversion
âœ… toUpperCase()
Converts all characters to uppercase.
"java".toUpperCase(); // "JAVA"

âœ… toLowerCase()
Converts all characters to lowercase.
"JAVa".toLowerCase(); // "java"


âœ‚ï¸ trim() Method
Removes:
Leading (front) and trailing (end) whitespaces.
Does NOT remove spaces or special characters in between the string.
String s = "   hello!@#   ";
System.out.println(s.trim()); // "hello!@#"

âŒ trim() does not remove special characters.
ğŸ”¸ lTrim() and rTrim() are not built-in in Java. You must use regex or custom code to achieve that.

ğŸ”¤ charAt(index)
Returns character at the given index.
String x1 = "aabaacv";
System.out.println(x1.charAt(2)); // 'b'

âœ… Example: Count frequency of a character
String x1 = "aabaacv";
int count = 0;

for (int i = 0; i < x1.length(); i++) {
    if (x1.charAt(i) == 'a') count++;
}
System.out.println(count); // 4

ğŸ”¹ startsWith() & endsWith() Methods
âœ… Definition:
Both methods return boolean values.

Used to check prefixes or suffixes of a string.

â¤ Syntax:
str.startsWith("prefix");  // true if string starts with "prefix"
str.endsWith("suffix");    // true if string ends with "suffix"

âœ… Code Example:
String s = "Hello World!";
System.out.println(s.startsWith("He"));     // true
System.out.println(s.endsWith("!"));        // true
System.out.println(s.endsWith("World"));    // false

ğŸ” Convert Primitive Data Type to String
âœ… Method 1: Add Empty String
int x = 10;
String y = "" + x;
System.out.println(y);                     // "10"
System.out.println(y instanceof String);   // true

âœ… Method 2: Use String.valueOf()
float z = 10.3f;
String s1 = String.valueOf(z);
System.out.println(s1); // "10.3"

boolean b = true;
String s2 = String.valueOf(b); // "true"

char ch = 'z';
String s3 = String.valueOf(ch); // "z"

System.out.println(s2); // true
System.out.println(s3); // z
System.out.println(s2 instanceof String); // true
System.out.println(s3 instanceof String); // true
ğŸ”¸ String.valueOf() works for all primitives: int, float, char, boolean, double, long, etc.

ğŸ” Search in a String
ğŸ” contains() Method
â¤ Checks whether a string contains a specific sequence of characters.
â¤ Returns: true or false
â¤ Case-sensitive

String str = "My name is Ankur Veram";
System.out.println(str.contains("name"));   // true
System.out.println(str.contains("Name"));   // false

ğŸ”¢ indexOf() Method
â¤ Returns the index of first occurrence of a substring/character.
â¤ If not found, returns -1
â¤ Case-sensitive

â¤ Syntax:
int index = str.indexOf("substring");

âœ… Code Example:
String str = "My name is Ankur Veram";

System.out.println(str.indexOf("name"));   // 3
System.out.println(str.indexOf("Name"));   // -1
System.out.println(str.indexOf(" Ankur")); // 11    

If two parameter is given then it will start the search after the index of the second parameter.
System.out.println(str.indexOf("e",8));    

ğŸ”¹ join() Method
â¤ Used to join elements of an array or any Iterable into a single string.
â¤ Requires a delimiter to separate the elements.

Syntax:
String result = String.join(delimiter, elements...);

âœ… Example:
String[] words = {"Hello", "World", "Java", "Programming"};
String result = String.join(" ", words);
System.out.println(result); // Output: Hello World Java Programming
ğŸ”¸ join() is available from Java 8 onwards.

ğŸ” replace() Method
â¤ Used to replace characters or substrings within a string.
â¤ Returns a new string with replacements applied (original string remains unchanged).

âœ… Method 1: Replace Substring
String s = "Hello World with new Word";
String str = s.replace("Word", "Duniya");
System.out.println(str); // Output: Hello World with new Duniya

âœ… Method 2: Replace Character
String str2 = s.replace('o', '*');
System.out.println(str2); // Output: Hell* W*rld with new W*rd

ğŸ”— Ways of String Concatenation
âœ… Way 1: Using + Operator
String s1 = "Hello";
String s2 = "World";
String result = s1 + " " + s2;
System.out.println(result); // Hello World

âœ… Way 2: Using concat() Method
String result = s1.concat(s2); // HelloWorld

â• Add whitespace between
String result = s1.concat(" ").concat(s2); // Hello World
What is Mutable and Immutable class

ğŸ§  Mutable vs Immutable Classes
| Property        | Immutable Class                             | Mutable Class                             |
| --------------- | ------------------------------------------- | ----------------------------------------- |
| Definition      | Object cannot be changed after creation | Object can be modified after creation |
| Example         | `String`                                    | `StringBuilder`, `StringBuffer`           |
| Thread-safe?    | Yes (`String`)                              | Only `StringBuffer` is thread-safe        |
| Performance     | Slower (new object on change)               | Faster for frequent modifications         |
| Common Use Case | Constant values, keys in Map                | Dynamic strings in loops or editors       |


==================================
ğŸ”· StringBuilder and StringBuffer
==================================
| Feature                 | StringBuilder                             | StringBuffer                       |
| ----------------------- | --------------------------------------------- | -------------------------------------- |
| Mutability          | Mutable                                       | Mutable                                |
| Thread Safety       | âŒ Not thread-safe                            | âœ”ï¸ Thread-safe (synchronized)         |
| Performance         | Faster                                        | Slower (sync overhead)                 |
| Use Case            | Single-thread environment                     | Multi-thread environment               |
| Synchronization     | No                                            | Yes (all methods synchronized)         |
| Introduced In       | Java 5 (JDK 1.5)                              | Java 1.0                               |
| Default Capacity    | 16 chars                                      | 16 chars                               |
| Expansion Mechanism | `(oldCapacity * 2) + 2`                       | Same                                   |
| Efficiency in Loops | More efficient                                | Less efficient due to locking          |
| toString() Behavior | Returns string of internal buffer             | Same                                   |
| Suitable For        | Heavy modifications in single-thread programs | Modifications in multi-thread programs |


âœ… Code Example Showing StringBuilder Functioning (Fast, Non-Synchronized)
public class StringBuilderDemo {
    public static void main(String[] args) {
        StringBuilder sb = new StringBuilder("Hello");

        sb.append(" World");
        sb.insert(5, ",");
        sb.delete(0, 1);
        sb.reverse();

        System.out.println("Final Output Using StringBuilder: " + sb);
    }
}
â¤ No locking/synchronization â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ fastest performance.
â¤ Used where only one thread modifies the data.

âœ… Code Example Showing StringBuffer Functioning (Thread-Safe via Synchronization)
public class StringBufferDemo {
    public static void main(String[] args) {
        StringBuffer sbf = new StringBuffer("Hello");

        sbf.append(" World");
        sbf.insert(5, ",");
        sbf.delete(0, 1);
        sbf.reverse();

        System.out.println("Final Output Using StringBuffer: " + sbf);
    }
}
â¤ Same methods as StringBuilder.
â¤ Each method is synchronized, making operations thread-safe but slower.

âœ… Multi-threading Example to Show the Real Difference
âœ”ï¸ StringBuilder (Not Safe)
public class BuilderThreadDemo {
    static StringBuilder sb = new StringBuilder();

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) sb.append("A");
        });

        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) sb.append("B");
        });

        t1.start();
        t2.start();
        t1.join();
        t2.join();

        System.out.println("StringBuilder length = " + sb.length());
        System.out.println("Output (Corrupted): " + sb);
    }
}
âœ…Output:
Output may be corrupted or inconsistent.
Race conditions occur because both threads modify the same object without sync.

âœ”ï¸ StringBuffer (Safe Output)
public class BufferThreadDemo {
    static StringBuffer sbf = new StringBuffer();

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) sbf.append("A");
        });

        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) sbf.append("B");
        });

        t1.start();
        t2.start();
        t1.join();
        t2.join();

        System.out.println("StringBuffer length = " + sbf.length());
        System.out.println("Output (Non-corrupted): " + sbf);
    }
}
âœ…Output:
â¤ Always consistent because methods are synchronized.
â¤ State remains safe even when both threads modify simultaneously.


âœ‚ï¸ substring() Method in Java
The substring() method is used to extract a part of the string.

âœ… Syntax Variants:
substring(int start)
Returns substring from start (inclusive) to the end of the string.
String s = "JavaProgramming";
System.out.println(s.substring(4)); // Output: Programming

substring(int start, int end)
Returns substring from start (inclusive) to end (exclusive).
System.out.println(s.substring(0, 4)); // Output: Java

ğŸ§  Remember:
Index starts from 0.
end index is excluded.
Throws StringIndexOutOfBoundsException if indices are invalid.

ğŸ”¹ Method 1: Using \n Escape Character
You can insert line breaks using the newline character \n.
String x = "Hi my name is\nAnkur\nVerma";
System.out.println(x);

âš ï¸ Limitation:
â¤ Becomes tedious and less readable when writing large multi-line strings.
â¤ Manual escaping needed for quotes, line breaks, and indentation.

ğŸ”¹ Method 2: Using Text Blocks (""")
âœ… Introduced in Java 13 (preview), Java 15+ (standard).

Multiline string literal that maintains formatting and is easy to write.
String x2 = """
            Hi 
            My 
            Name 
            is 
            Ankur Verma
            """;
System.out.println(x2);
âœ… Benefits of Text Blocks:
â¤ Easy to write and maintain multiline text (like JSON, SQL, XML, HTML).
â¤ Preserves formatting and indentation.
â¤ No need to use \n for new lines.
â¤ Avoids escaping double quotes in many cases.
