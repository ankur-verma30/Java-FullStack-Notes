=============
ğŸ”· Generics
=============
â¤ Generics allow you to define classes, interfaces, and methods with type parameters instead of fixed data types.
â¤ They bring compile-time type safety and code reusability to Java collections and other custom classes.


ğŸ”„ Why use Generics
| **Purpose**                 | **Explanation**                                                        |
| --------------------------- | ---------------------------------------------------------------------- |
| **Type Safety**             | Detects invalid data types at compile time                             |
| **Code Reusability**        | Allows writing one class or method that works with multiple data types |
| **Eliminates Type Casting** | Removes the need for explicit `(Type)` casting while retrieving data   |
| **Compile-Time Checking**   | Prevents runtime errors such as `ClassCastException`                   |


âœ… Example:
List<String> names = new ArrayList<>();
names.add("Ankur");
names.add(100); // âŒ Compile-time error (Type safety)
ğŸ‘‰ Without Generics, this would only fail at runtime.


ğŸ”„ Syntax
We use angle brackets <> to define a generic type.
class ClassName<T> { // T is a type parameter
}
Here:
â¤ T â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Type parameter (can be replaced by any object type when using the class).
â¤ You can have multiple parameters: <T, U, V>.
â¤ Conventionally used letters:
    âœ”ï¸ T â†’ Type
    âœ”ï¸ E â†’ Element (used in collections)
    âœ”ï¸ K â†’ Key
    âœ”ï¸ V â†’ Value
    âœ”ï¸ N â†’ Number


âœ… Example â€“ Generic Class
public class GenericsIntro<T, U> {
    private T name;
    private U id;

    public GenericsIntro(T name, U id) {
        this.name = name;
        this.id = id;
    }

    public T getName() { return name; }
    public U getId() { return id; }
}

public class GenericsImpl {
    public static void main(String[] args) {
        GenericsIntro<String, Integer> a1 = new GenericsIntro<>("Ankur", 120);
        System.out.println(a1.getName()); â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Ankur
        System.out.println(a1.getId());   â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ 120
    }
}

âœ… Advantages shown:
    âœ”ï¸ Same class works for different data types.
    âœ”ï¸ Compile-time safety.
    âœ”ï¸ No casting needed.


ğŸ”„ Generic Methods
A method can have its own type parameter even if the class is not generic.
public class Util {
    public static <T> void printArray(T[] array) {
        for (T element : array)
            System.out.println(element);
    }

    public static void main(String[] args) {
        Integer[] numbers = {1, 2, 3};
        String[] names = {"Ankur", "Verma"};
        printArray(numbers);
        printArray(names);
    }
}
â¤ Key<T> before return type indicates that is a generic method.


=============================
ğŸ”· Wildcards in Generics (?)
=============================
â¤ The wildcard ? is an unknown type.
â¤ Used when the exact type parameter is not important.
â¤ Wildcards allow flexibility when you don't know the exact type.

1ï¸âƒ£ Unbounded Wildcard â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ <?>
â¤ Means â€œany typeâ€.
public void printList(List<?> list) {
    for (Object obj : list) {
        System.out.println(obj);
    }
}
âœ… Can read data
âŒ Cannot write(expect null).


2ï¸âƒ£ Upper Bounded Wildcard â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ <? extends Type>
â¤ Means â€œType or any subclass of Typeâ€.
â¤ Use when: You want to read data but not modify it.
public void processNumbers(List<? extends Number> list) {
    for (Number num : list) {
        System.out.println(num.doubleValue());
    }
}
âœ… Can read as Number
âŒ Cannot add new elements(because it might be List<Double> or List<Integer> â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ not safe).


3ï¸âƒ£ Lower Bounded Wildcard â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ <? super Type>
â¤ Means â€œType or any superclass of Typeâ€.
â¤ Use when: You want to write data.
public void addIntegers(List<? super Integer> list) {
    list.add(10);
    list.add(20);
}

ğŸ”„ Producer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ extends
â¤ If the list gives you data, use extends
ğŸ‘‰ Think: I am only taking things out of the list

âœ… Example: List<? extends Animal> animals;
ğŸ‘‰ This means:
    âœ”ï¸ The list contains Animal or its children(Dog, Labrador etc.)
    âœ”ï¸ You don't know the exact type.
    âœ”ï¸ But whatever you get is at least an Animal.

ğŸ”„ What you can do
Animal a=animals.get(0); //âœ… allowed
animals.add(new Animal()); //âŒ not allowed

ğŸ”„ Why?
Because Java doesn't know:
    âœ”ï¸ Is it a List<Dog>?
    âœ”ï¸ Is it a List<Cat>?
    âœ”ï¸ Is it a List<Animal>?

ğŸ”„ Consumer â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ super
"If the list takes your data, use super"
ğŸ‘‰ Think: I am putting things into the list

âœ… Example:
List<? super Dog>dogs;
This means:
    âœ”ï¸ List<Dog>
    âœ”ï¸ List<Labrador>
    âœ”ï¸ List<Animal>
    âœ”ï¸ List<Object>

ğŸ”„ What you can do
dogs.add(new Dog());       // âœ… allowed
dogs.add(new Labrador()); // âœ… allowed

ğŸ”„ What you CANNOT safely do
Dog d=dogs.get(0); //âŒ not allowed
dogs.add(new Animal()); //âŒ not allowed


â“ Why?
Because Java doesn't know: This list can hold Dogs, but I don't know what it actually stores."
    âœ”ï¸ Is it a List<Dog>?
    âœ”ï¸ Is it a List<Cat>?
    âœ”ï¸ Is it a List<Animal>?


ğŸ”„ Why not use both read and write?
| **Type**                 | **Can Read**              | **Can Write** |
| ------------------------ | ----------------------    | ------------- |
| `extends`                | âœ… Yes (as parent type) | âŒ No          |
| `super`                  | âŒ No (only `Object`)   | âœ… Yes         |
| Exact type (`List<Dog>`) | âœ… Yes                  | âœ… Yes         |
ğŸ‘‰ Only exact type gives full freedom


ğŸ”„ PECS(Producer Extends, Consumer Super) rule
| **Situation**                      | **Wildcard to Use** | **Reason**                           |
| ---------------------------------- | ------------------- | ------------------------------------ |
| You only **read / produce** items  | `<? extends T>`     | Guarantees type safety while reading |
| You only **write / consume** items | `<? super T>`       | Guarantees type safety while adding  |


ğŸ”„ Trap Questions
| **Trap**                                                 | **Explanation**                                                     |
| -------------------------------------------------------  | ------------------------------------------------------------------- |
| âŒ You canâ€™t use primitive types with generics           | `List<int>` is invalid; use wrapper types like `List<Integer>`      |
| âŒ Generic type info is erased at runtime (Type Erasure) | JVM removes generic type information after compilation              |
| âŒ Cannot create instances of type parameter             | `T obj = new T();` âŒ not allowed due to type erasure               |
| âŒ Cannot use static variables of generic type           | Static members are shared across all instantiations, but `T` varies |
| âŒ Arrays and Generics donâ€™t mix well                    | `new List<String>[10]` âŒ causes type-safety issues                 |

ğŸ”„ Type Erasure
Java removes generic type information at runtime and replaces it with Object(or a bound).
ğŸ‘‰ Generics are only for compile-time saftey, not runtime.


ğŸ”„ Why does Java use Type Erasure?
Main reason:
âœ”ï¸ Backward compatibility
â¤ Java generics were introduced in Java 5.
â¤ Old Java code (pre-generics) should still work.
â¤ So the JVM:
    âœ”ï¸ Does not know List<String> or List<Integer>
    âœ”ï¸ It only sees List


âœ… Example:
Code you write:
List<String> names=new ArrayList<>();
names.add("Ankur");

What JVM actually sees:
List names=new ArrayList();
names.add("Ankur");
ğŸ‘‰ The <String> part is erased


ğŸ”„ Another Example
List<String> list1 = new ArrayList<>();
List<Integer> list2 = new ArrayList<>();

System.out.println(list1.getClass() == list2.getClass());

âœ… Output: true

ğŸ”„ Why?
Because after type erasure, both become: List


ğŸ”„ How Type Erasure Works Internally
1ï¸âƒ£ Unbounded generics
class Box<T>{
    T value;
}

After type erasure:
class Box{
    Object value;
}


2ï¸âƒ£ Bounded generics
class Box<T extends Number>{
    T value;
}

After type erasure:
class Box{
    Number value;
}
ğŸ‘‰ Bound replaces Object


ğŸ” Why Some Things Are NOT Allowed in Generics
Because type info is gone at runtime

âŒ Cannot create generic arrays
T[] arr=new T[10]; //âŒ not allowed
â¤ JVM doesn't know what T is at runtime

âŒ Cannot use instanceof with generics
if (obj instanceof List<String>) // âŒ not allowed

But this is allowed:
if (obj instanceof List<?>) // âœ… allowed

âŒ Cannot overload methods only by generic type
void print(List<String> list)
void print(List<Integer> list) // âŒ compile-time error

Add erasure, both look like: void print(List list)


=====================================
ğŸ”·How Java Still Ensures Type Safety
=====================================
ğŸ”„ Using compile-time checks + casting
List<String> names = new ArrayList<>();
names.add("Ankur");

String name = names.get(0); // implicit cast

ğŸ‘‰ After erasure: String name=(String )names.get(0);


================
ğŸ”· Collections
================
â¤ Collections in Java refer to a framework (set of classes and interfaces) that provide ready-made data structures for storing, retrieving, and manipulating groups of objects efficiently.
â¤ It is defined in the package: java.util
â¤ Think of Collections Framework as a toolbox of reusable data structures (like Lists, Sets, Queues, Maps) that save you from writing custom logic for storage and searching.


ğŸ”„ Why Collections Framework?
Before Java 1.2, developers used arrays, Vectors, or Hashtables â€” which were:
    âœ”ï¸ Fixed in size
    âœ”ï¸ Lacked type safety
    âœ”ï¸ Hard to manipulate

The Java Collections Framework (JCF) unified these into a consistent architecture.


âŒDrawbacks or limitations
1. Inconsistency: Each class had a different way of managing collections, leading to confusion and a steep learning curve.
2. Lack of inter-operability: These classes were not designed to work together seamlessly.
3. No common Interface: There was no common interface for all these classes which meant you couldn't write generic algorithms that could operate on different types of collections.

To solve those problems, the Collection Framework was introduced in JDK 1.2.


ğŸ”„ Key Features of Collections Framework
1ï¸âƒ£ Consistent Interfaces â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Common methods across all collections (add(), remove(), size())
2ï¸âƒ£ Dynamic Size â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Can grow or shrink at runtime
3ï¸âƒ£ Type Safety â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Supports Generics
4ï¸âƒ£ Polymorphic Algorithms â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Works with all types of collections (Collections.sort(), Collections.reverse())
5ï¸âƒ£ Ready Implementations â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Efficient, tested data structures
6ï¸âƒ£ Thread-Safe Options â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Concurrent collections (ConcurrentHashMap, CopyOnWriteArrayList)


ğŸ”· Key Interfaces in Collection Framework
The hierarchy starts from the top-level interface Iterable and branches into key interfaces:

1ï¸âƒ£ Iterable
â¤ Root interface of the collection hierarchy.
â¤ All collection classes implement this indirectly.
â¤ Provides iterator() to traverse elements using Iterator.
Iterator<T> iterator();


2ï¸âƒ£ Collection
â¤ Extends Iterable.
â¤ The base interface for all collections except Map.
â¤ Defines basic operations like add(), remove(), clear(), size().

âœ… Example:
boolean add(E e);
boolean remove(Object o);
int size();

ğŸ”„ Subinterfaces of Collection:
1ï¸âƒ£ List
2ï¸âƒ£ Set
3ï¸âƒ£ Queue
4ï¸âƒ£ (Since Java 21) SequencedCollection


3ï¸âƒ£ List Interface
â¤ Ordered collection (elements have index).
â¤ Allows duplicates.
â¤ Can access elements by index.

Implementations:
âœ”ï¸ ArrayList
âœ”ï¸ LinkedList
âœ”ï¸ Vector
âœ”ï¸ Stack
âœ”ï¸ CopyOnWriteArrayList


4ï¸âƒ£ Set Interface
â¤ Unordered and unique elements (no duplicates).
â¤ Follows mathematical set behavior.

Implementations:
    âœ”ï¸ HashSet
    âœ”ï¸ LinkedHashSet
    âœ”ï¸ TreeSet
    âœ”ï¸ EnumSet
    âœ”ï¸ CopyOnWriteArraySet


5ï¸âƒ£ Queue Interface
â¤ Follows FIFO (First In, First Out) order.
â¤ Used to hold elements before processing.

Implementations:
    âœ”ï¸ LinkedList
    âœ”ï¸ PriorityQueue
    âœ”ï¸ ArrayDeque
    âœ”ï¸ ConcurrentLinkedQueue
    âœ”ï¸ BlockingQueue (and its subclasses)


6ï¸âƒ£ Deque Interface (extends Queue)
 Double-ended queue â†’ allows insertion/removal from both ends.
 Supports both FIFO and LIFO behaviors.

Implementations:
    âœ”ï¸ ArrayDeque
    âœ”ï¸ LinkedList
    âœ”ï¸ ConcurrentLinkedDeque


7ï¸âƒ£ Map Interface (Separate Hierarchy)
â¤ Stores keyâ€“value pairs.
â¤ Unique keys, values can be duplicated.
â¤ Not a subtype of Collection.

Implementations:
    âœ”ï¸HashMap
    âœ”ï¸LinkedHashMap
    âœ”ï¸TreeMap
    âœ”ï¸WeakHashMap
    âœ”ï¸ConcurrentHashMap
    âœ”ï¸Hashtable
    âœ”ï¸EnumMap


======================================
ğŸ”· Hierarchy of Collection Framework
======================================
Iterable
â””â”€â”€ Collection
    â”œâ”€â”€ SequencedCollection
            â”œâ”€â”€ List
            |    â”œâ”€â”€ ArrayList
            |    â”œâ”€â”€ LinkedList
            |    â”œâ”€â”€ Vector
            |    â”œâ”€â”€ Stack
            |    â””â”€â”€ CopyOnWriteArrayList
            â”‚
            â”œâ”€â”€ Set
            â”‚   â”œâ”€â”€ HashSet
            â”‚   â”œâ”€â”€ LinkedHashSet
            â”‚   â”œâ”€â”€ TreeSet
            â”‚   â”œâ”€â”€ EnumSet
            â”‚   â”œâ”€â”€ ConcurrentSkipListSet
            â”‚   â”œâ”€â”€ SortedSet
            â”‚   â””â”€â”€ CopyOnWriteArraySet
            â”‚
            â””â”€â”€ Queue
                â”œâ”€â”€ LinkedList
                â”œâ”€â”€ PriorityQueue
                â”œâ”€â”€ Deque
                â”‚   â”œâ”€â”€ ArrayDeque
                â”‚   |â”€â”€ LinkedList (also Deque)
                |   |â”€â”€ ConcurrentLinkedDeque
                â”œâ”€â”€ BlockingQueue
                â”‚   â”œâ”€â”€ ArrayBlockingQueue
                â”‚   â”œâ”€â”€ LinkedBlockingQueue
                â”‚   â”œâ”€â”€ PriorityBlockingQueue
                â”‚   â”œâ”€â”€ SynchronousQueue
                â”‚   â””â”€â”€ DelayQueue
                â””â”€â”€ ConcurrentLinkedQueue

 The hierarchy flows from Iterable â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Collection â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ SequencedCollection â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ List â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ ArrayList.

Letâ€™s break this down step by step:
ğŸ”· Iterable<E> (Interface)
â¤ Iterable is the top-most interface in the Java Collections Framework hierarchy.
â¤ Every collection class in Java (like List, Set, Queue, etc.) implements Iterable directly or indirectly.

âš¡Package: java.lang
â¤ Introduced in: Java 5 (as part of Generics & enhanced for-loop support)

ğŸ”„ Syntax:
public interface Iterable<T> {
    Iterator<T> iterator();
}
ğŸ‘‰ Here:
    âœ”ï¸ T â†’ Generic type parameter (the type of elements to iterate).
    âœ”ï¸ Any class implementing Iterable must provide an implementation for the iterator() method.


ğŸ”„ Purpose of Iterable
â¤ The main purpose of the Iterable interface is to provide a standard way to traverse elements of a collection, one by one.
â¤ It allows:
    âœ”ï¸ Iteration using Iterator
    âœ”ï¸ Enhanced for-loop (for-each loop)
    âœ”ï¸ Stream creation (Java 8+)


ğŸ”„ Key Methods of Iterable
| **Method**                                         | **Description**                                                          | **Since** |
| -------------------------------------------------- | ------------------------------------------------------------------------ | --------- |
| `Iterator<T> iterator()`                           | Returns an **Iterator** over elements of type `T`.                       | Java 5    |
| `default void forEach(Consumer<? super T> action)` | Performs the given action for each element (commonly used with lambdas). | Java 8    |


ğŸ”„ Method 1ï¸âƒ£:iterator()
This is the core abstract method every implementing class must define.
Iterator<T> iterator();

It returns an Iterator, which has the following methods:
ğŸ”— boolean hasNext();
ğŸ”— T next();
ğŸ”— void remove(); // optional

âœ…Example:
List<String> names = new ArrayList<>();
names.add("Ankur");
names.add("Verma");

Iterator<String> it = names.iterator();
while (it.hasNext()) {
    System.out.println(it.next());
}


â¤ Removal of elements is allowed while iterating.
Iterator<Integer> itr=numbers.iterator();
while(itr.hasNext()){
    Integer i=itr.next();
    if(i%2==0){
        itr.remove();
    }
}
â¤ Use of ListIterator: ListIterator<E> listIterator();
//When to use ListIterator

ğŸ”„ Core Methods:
ğŸ”— boolean hasNext();
ğŸ”— boolean hasPrevious();
ğŸ”— E next();
ğŸ”— E previous();
ğŸ”— int nextIndex();
ğŸ”— int previousIndex();
ğŸ”— void add(E e);
ğŸ”— void set(E e);
ğŸ”— void remove();


ğŸ”„ Method2: forEach()
Introduced in Java 8- provides a functional way to iterate
default void  forEach(Consumer<? super T> action)

âœ…Example: names.forEach(n -> System.out.println(n.toUpperCase()));
âœ”ï¸ Simplifies iteration
âœ”ï¸ Works well with Lambda expressions and Streams

â¤ Enables use of the enhanced for-each loop:
âœ”ï¸ for (String s : someCollection) {}
âœ… So, any class implementing Iterable automatically supports enhanced for-loops.


âœ… Custom Iterable Example
Can create our own class implementing Iterable:
import java.util.Iterator;
import java.util.NoSuchElementException;

public class MyIterable implements Iterable<Integer> {
    private int[] data = {10, 20, 30, 40};

    @Override
    public Iterator<Integer> iterator() {
        return new Iterator<Integer>() {
            int index = 0;
            public boolean hasNext() {
                return index < data.length;
            }
            public Integer next() {
                if (!hasNext()) throw new NoSuchElementException();
                return data[index++];
            }
        };
    }

    public static void main(String[] args) {
        MyIterable obj = new MyIterable();
        for (int val : obj) {
            System.out.println(val);
        }
    }
}
âœ… Output:
10
20
30
40


ğŸ”„ Relationship with Iterator
| **Feature** | **Iterable**                               | **Iterator**                         |
| ----------- | ------------------------------------------ | ------------------------------------ |
| **Type**    | Interface that provides `iterator()`       | Interface used to traverse elements  |
| **Purpose** | Supplies an `Iterator` object              | Performs the actual iteration        |
| **Methods** | `iterator()`, `forEach()`, `spliterator()` | `hasNext()`, `next()`, `remove()`    |
| **Usage**   | Implemented by collection classes          | Used by `for-each` and `while` loops |



ğŸ“š 2. Collection<E> (Interface)
â¤ Root interface for all collection types (except maps).
â¤ Extends: Iterable<E>
â¤ Common Subinterfaces: List, Set, Queue, etc.

â¤ Key Methods:
add(E e), remove(Object o), clear(), size(), contains(Object o), etc.

â¤ Does not maintain order or index-based access (depends on implementation).

ğŸ”„ 3. SequencedCollection<E> (Interface â€“ âœ… New in Java 21 / Finalized in Java 24)
â¤ Extends: Collection<E>
â¤ Purpose: Provides a standardized way to handle ordered collections (like first and last elements).

â¤ Key Methods Introduced:
getFirst(), getLast()
addFirst(E e), addLast(E e)
removeFirst(), removeLast()
reversed()

ğŸ”¸ Applies to: List-like or deque-like structures where order matters.
ğŸ”¹ This brings better symmetry and consistency in ordered collections.

ğŸ”· List Interface
â¤ Extends: SequencedCollection<E>
â¤ Represents an ordered collection with index-based access.
â¤ Duplicates allowed, insertion order preserved.
â¤ Common Implementations: ArrayList, LinkedList, Vector, Stack

â¤ Key Methods:
get(int index), set(int index, E e), add(E e), remove(int index),indexOf(Object o), subList(), listIterator()

âœ… Key Features of the List Interface:
â¤ Ordered
â¤ Index-Based access
â¤ Allows duplicates

ğŸŒŸ ArrayList
An ArrayList is a resizable array implementation of the List interface. 
Unlike arrays in Java, which have a fixed size, ArrayList can change its size dynamically as elements are added or removed.
This flexibility makes it a popular choice when the number of elements in a list isn't known in advance.

â¤ Implements: List<E>, hence also a SequencedCollection, Collection, and Iterable.

âœ”ï¸ Ways to Create ArrayList
ğŸ”„Default constructor
ArrayList<Integer> list = new ArrayList<>();
System.out.println(list.getClass().getName());
âœ…Output: java.util.ArrayList
ğŸ‘‰ Creates an empty list with default capacity 10.

ğŸ”„With Initial Capacity
ArrayList<String> list = new ArrayList<>(20);
ğŸ‘‰Useful when you know approx. number of elements.

ğŸ”„ From Another Collection
List<Integer> numbers = new ArrayList<>(List.of(1, 2, 3, 4));
ğŸ‘‰Copies elements from existing collection.

ğŸ”„ Using Arrays.asList (Fixed-size list backed by array)
List<String> names = new ArrayList<>(Arrays.asList("A", "B", "C"));
System.out.println(names.getClass().getName());
âœ…Output: java.util.ArrayList

â¤ This is NOT java.util.ArrayList
â¤ It is an inner static class of java.util.Arrays called Arrays$ArrayList.
â¤ Characteristics:
    1. Fixed-size list (backed by the given array).
    2. You can modify elements (set()), but cannot add() or remove().
    3. Trying list.add("D") will throw UnsupportedOperationException.

ğŸ”„ Using Arrays.asList() on an existing array
String[] array = {"Apple", "Banana", "Cherry"};
List<String> list2 = Arrays.asList(array);
System.out.println(list2.getClass().getName());
âœ… Output: java.util.Arrays$ArrayList

â¤ Same as above: backed by the array itself.
â¤ Any changes in list2 are reflected in the original array (because they share memory).

list2.set(0, "Mango"); 
System.out.println(array[0]); // Output: Mango (array updated too!)
0
ğŸ”„Immutable List Using List.of() (Java 9+) // Unmodifiable list can't even replace the elements unlike list made from Arrays.asList()
List<Integer> list3 = List.of(1, 2, 3);
System.out.println(list3.getClass().getName());

âœ… Output: java.util.ImmutableCollections$ListN

âœ… Key Points
â¤ new ArrayList<>() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ java.util.ArrayList (fully dynamic, resizable).
â¤ Arrays.asList() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ java.util.Arrays$ArrayList (fixed-size, backed by array).
â¤ With an existing array, modifications affect both list and array.
â¤ Arrays$ArrayList is an inner class only meant as a lightweight adapter.

âœ”ï¸ Common Operations on ArrayList
1ï¸âƒ£ Add Elements
list.add(10);          // add at end
list.add(1, 20);       // add at specific index
list.addAll(otherList); // add all elements

2ï¸âƒ£ Access Elements
int x = list.get(0);   // get element at index

3ï¸âƒ£ Update Elements
list.set(1, 50);       // update index 1 to value 50

4ï¸âƒ£ Remove Elements
list.remove(2);        // remove by index
list.remove(Integer.valueOf(10)); // remove by value if element is not present it will do nothing or else remove the element from the list
list.clear();          // remove all elements

5ï¸âƒ£ Search Operations
boolean present = list.contains(30); // check existence
int idx = list.indexOf(50);          // first index
int lastIdx = list.lastIndexOf(50);  // last index

6ï¸âƒ£ Iteration
// for-each loop
for(Integer val : list) { System.out.println(val); }

// using Iterator
Iterator<Integer> it = list.iterator();
while(it.hasNext()) System.out.println(it.next());

// using ListIterator (forward & backward)
ListIterator<Integer> itr = list.listIterator();
while(itr.hasNext()) System.out.println(itr.next());
while(itr.hasPrevious()) System.out.println(itr.previous());

// using forEach + lambda
list.forEach(System.out::println);

7ï¸âƒ£ Size & Capacity
int size = list.size();
boolean empty = list.isEmpty();

8ï¸âƒ£ Conversion
// ArrayList -> Array
Integer[] arr = list.toArray(new Integer[0]);

// Array -> ArrayList
ArrayList<Integer> list2 = new ArrayList<>(Arrays.asList(arr));

ğŸ”· Internal Working of ArrayList
â¤ Unlike a regular array, which has a fixed size, an ArrayList can grow and shrink as elements are added or removed. 
â¤ This dynamic resizing is achieved by creating a new array when the current array is full and copying the elements to the new array.
â¤ Internally the ArrayList is implemented as an array of Object references. 
â¤ When you add elements to an ArrayList, you're essentially storing these elements in this internal array.
â¤ When you create an ArrayList, it has an initial capacity(default is 10). The capacity refers to the size of the internal array that holds the elements before needing to resize.

ğŸ”· Adding elements
When we add an element to an ArrayList, the following steps occur:

1. Checking Capacity: Before adding the new element, ArrayList checks if there is enough space in the internal array(elementData). IF the array is full, it needs to be resized.
2. Resize if necessary: If the internal array is full, the ArrayList will create a new array with a larger capacity (usually 1.5 times the current capacity) and copy the existing elements from the old array to the new array.
3. Add the Element: The new element is added to the internal array at the appropriate index, and the size is incremented.

ğŸ”· Resizing the Array
1. Initial Capacity: By default, the initial capacityis 10. This means the internal array can hold 10 elements before it needs to grow.
2. Growth Factor: When the internal array is full, a new array is created with a size 1.5 times the old array. This growth factor balances memory efficiency and resizing cost.
3. Copying Elements: When resizing occurs, all elements from the old array are copied to the new array, which is an O(n) operation, where n is the number of elements in the ArrayList.

ğŸ”· Removing Elements
1. Check Bounds: The ArrayList  checks if the index is within the valid range (0 to size - 1).
2. Remove the Element: The element is removed, and all elements to the right of the removed element are shifted to the left to fill the gap.
3. Reduce Size: The size is decremented by 1.

ğŸ”· Converting List to Array
String [] array = arr.toArray(new String[0]);
ğŸ‘‰ This creates a new array of the same type as the list and copies the elements into it.        
ğŸ‘‰ We pass new String[0] to tell the compiler the type of the array we are passing as a argument (Convention).

ğŸ”· Sorting the List
âœ…Method 1: Collections.sort(arr);
ğŸ‘‰ This sorts the list in ascending order using the natural ordering of the elements.

âœ…Method 2: arr.sort(null);
ğŸ‘‰ This sorts the list in ascending order using the natural ordering of 
the elements.
ğŸ‘‰ null is defined here because no custom comparator is used

Collections.sort(list);                   // ascending
list.sort(Collections.reverseOrder());    // descending

ğŸ”Ÿ Retain / Remove All
list.removeAll(otherList);   // remove all common elements
list.retainAll(otherList);   // keep only common elements

ğŸ”· Time Complexity of Operations in List
â¤ Accessing by index (get) is O(1).
â¤ Adding an element is O(n) in the worst case when resizing occurs.
â¤ Removing elements can be O(n) because it may involve shifting elements.
â¤ Iteration is O(n).

ğŸ”· Comparator
It is an interface that defines a method for comparing two objects of the same type.
It is used to sort objects in a custom order.

ğŸ”· How to use Comparator
public class ArrayListIntro {

	public static void main(String[] args) {
		List<Integer>arr=new ArrayList<>();
		arr.add(1);
		arr.add(2);
		arr.add(3);
		
		List<Integer>list1=List.of(4,5,6,7,8,9);
		//adding all the elements
		arr.addAll(2,list1);
		
		arr.sort(new CustomComparator());
		System.out.println(arr); // Output: [9, 8, 7, 6, 5, 4, 3, 2, 1]
	}
}
class CustomComparator implements Comparator<Integer>{

	@Override
	public int compare(Integer o1, Integer o2) {
		return o2-o1;
	}
}
ğŸ‘‰ If we do o1-o2, it will sort in ascending order

ğŸ”· Using lambda expression
âœ… Example 1: Sorting Lexicographically
		List<String>str=Arrays.asList("Apple", "Mango","Banana");
		str.sort((a,b)-> a.compareTo(b));
		//if gives negative then first will come
		System.out.println(str); // Output: [Apple, Banana, Mango]

âœ… Example 2: Sorting by Length		
		List<String>str2=Arrays.asList("Apple", "Plum","Banana");
		str2.sort((a,b)-> a.length()-b.length());
		System.out.println(str2);// Output: [Plum, Apple, Banana]


###############
ğŸŒŸ LinkedList
###############
A LinkedList is a doubly-linked list implementation of the List and Deque interfaces.
It allows for efficient insertion and removal of elements at both ends of the list.

âœ…Custom Made LinkedList Implementation
package collections;

public class LinkedListIntro {

	public static void main(String[] args) {
		Node node1=new Node();
		node1.value=10;
		node1.next=null;
		
		Node node2=new Node();
		node2.value=2;
		node2.next=null;
		node1.next=node2;
		
		Node temp=node1;
		while(temp!=null) {
			System.out.println(temp.value);
			temp=temp.next;
		}
	}
}

class Node{
	public int value;
	public Node next;
}

ğŸ‘‰ A LinkedList is a linear data structure where each element is a seperate object called a node. Each node contains two parts:
1. Data: The value stored in the node.
2. Pointer/Reference: Two Pointers, one points to the next node(next) and the other pointing to the previous node(previous).

âš¡ Performance Considerations
â¤ LinkedList has different performance characteristics compared to ArrayList:

ğŸ”„Insertion and Deletion: LinkedList is better for frequent insertions and deletions in the middle of the list because it does not require shifting elements, as in ArrayList.

ğŸ”„ Random Access: LinkedList has slower random access(get(int index)) compared to ArrayList because it has to traverse the list from the beginning to reach the desired index.

ğŸ”„ Memory Overhead: LinkedList requires more memory than ArrayList because each node in a LinkedList requires extra memory to store references to the next and the previous node.

âœ… Using LinkedList Collection Framework

package collections;

import java.util.LinkedList;

public class LinkedListIntro {

	public static void main(String[] args) {
		LinkedList<Integer>linkedlist=new LinkedList<>();
		âœ…Adding elements and getting elements
		linkedlist.add(1);//O(1)
		linkedlist.add(2);
		linkedlist.add(3);
		
		System.out.println(linkedlist);
		
		//getting the value at 0th index
		System.out.println(linkedlist.get(0)); //O(n)
		
		//adding the value at specific index
		linkedlist.add(2, 5); // O(1)
		
		//adding at the first of the linkedlist
		linkedlist.addFirst(0); // O(1)
		
		//adding at the last of the linkedlist
		linkedlist.addLast(10); // O(1)
		
		System.out.println(linkedlist);
		
		//getting the first element
		System.out.println(linkedlist.getFirst());
		//getting the last element
		System.out.println(linkedlist.getLast());

		âœ…Removing elements
		//removing element on specific index
		int removedElement=linkedlist.remove(0);
		System.out.println(removedElement);
		
		System.out.println(linkedlist);
		
		//removing the first element
		int removed=linkedlist.removeFirst();
		System.out.println(removed);
		
		System.out.println(linkedlist);
		
		//removing first and last element
		int val1=linkedlist.removeFirst();
		int val2=linkedlist.removeLast();
		
		System.out.println(val1+" "+val2);
		System.out.println(linkedlist);
		
		//Java 8 feature
		boolean flag=linkedlist.removeIf(x->x%2!=0);// 5 is removed
		System.out.println(flag); //tells that removal has taken place or not
		
		System.out.println(linkedlist);
		
		LinkedList<String> animals=new LinkedList<>(Arrays.asList("Cat","Dog","Elephant"));
		LinkedList<String> animalsToRemove=new LinkedList<>(Arrays.asList("Dog")); //works if there is ArrayList also
		
		boolean removedAnimals=animals.removeAll(animalsToRemove);
		System.out.println(removedAnimals);
		System.out.println(animals);// Dog is removed
	}
}

#############
ğŸŒŸ Vectors
#############
â¤ A Vector in Java is a part of the java.util package and is one of the legacy classes in Java that implements the List interface.
â¤ It was introduced in JDK 1.0 before collection framework and is synchronized, making it thread-safe.
â¤ Now it is a part of the collection framework.
â¤ Howeever, due to its synchronization overhead, it's generally recommended to use other modern alternatives like ArrayList in single-threaded scenarios.
â¤ Despite this, vectors is still useful in certain situations, particularly when thread safety is a concern.

ğŸ”· Key Features of Vectors
ğŸ”„ Dynamic Array: Like ArrayList, vector is a dynamic array that grows automatically when more elements are added than its current capacity.

ğŸ”„Synchronized: All the methods in Vector are synchronized, which make it thread-safe. This means multiple thread can work on a Vector without the risk of corrupting the data. However, this can introduce performance overhead in single-threaded environments.

ğŸ”„ Legacy Class: Vector was part of Java's original release and is considered a legacy class. It's generally recommended to use ArrayList in single-threaded environments due to performance Considerations.

ğŸ”„ Resizing Mechanisms: When the current capacity of the vector is excedded, it doubles its size by default(or increases by a specific capacity increment if provided).

ğŸ”„ Random Access: Similary to arrays and ArrayList, Vector allows random access to elements, making it efficient for accessing elements using index.

ğŸ”· Constructor of Vectors
ğŸ‘‰ Vector(): Creates a vector with an initial capacity of 10.
ğŸ‘‰ Vector(int initialCapacity): Creates a vector with specified initial capacity.
ğŸ‘‰ Vector(int initialCapacity, int capacityIncrement): Creates a vector with an initial capacity and capacity increment(how much the vector should grow when its capacity is exceeded).
ğŸ‘‰Vector(<Collections<? extends E>c): Creates a vector containing the elements of the specified collection.

âœ…Code Implementation of Vector
package collections;

import java.util.Vector;

public class VectorDemo {
	public static void main(String[] args) {
		Vector<Integer> vector = new Vector<>(3);

		// can check the initial capacity
		System.out.println(vector.capacity());

		vector.add(1);
		vector.add(1);
		vector.add(1);
		vector.add(1);

		// New capacity=initialCapacity+capacityIncrement;
		// By default capacityIncrement is initalValue it doubles the capacity
		System.out.println(vector.capacity());

	}
}

âœ…Methods of Vector
â¤ add(E e): Add an element to the end of the vector.
â¤ add(int index, E element): Insert an element at a specific index.
â¤ get(int index): Retrieve an element at a specific index.
â¤ set(int index, E element): Replace an element at a specific index.
â¤ remove(int index): Remove an element at a specific index.		
â¤ remove(Object o): Remove the first occurrence of the specified element.
â¤ size(): Return the number of elements in the vector.
â¤ isEmpty(): Check if the vector is empty.
â¤ contains(Object o): Check if the vector contains a specific element.
â¤ clear(): Remove all elements from the vector.

âœ…Code Implementation of Vector Methods
import java.util.Vector;

public class VectorDemo {
    public static void main(String[] args) {
        // Create a Vector of Strings
        Vector<String> vector = new Vector<>();

        // 1. add(E e) - add element at the end
        vector.add("Apple");
        vector.add("Banana");
        vector.add("Cherry");
        System.out.println("After add: " + vector);

        // 2. add(int index, E element) - insert at specific index
        vector.add(1, "Mango");
        System.out.println("After add at index 1: " + vector);

        // 3. get(int index) - retrieve element at index
        System.out.println("Element at index 2: " + vector.get(2));

        // 4. set(int index, E element) - replace element
        vector.set(2, "Orange");
        System.out.println("After set at index 2: " + vector);

        // 5. remove(int index) - remove element by index
        vector.remove(3); // removes element at index 3
        System.out.println("After remove at index 3: " + vector);

        // 6. remove(Object o) - remove by value
        vector.remove("Apple"); 
        System.out.println("After removing 'Apple': " + vector);

        // 7. size() - get number of elements
        System.out.println("Size of vector: " + vector.size());

        // 8. isEmpty() - check if empty
        System.out.println("Is vector empty? " + vector.isEmpty());

        // 9. contains(Object o) - check if element exists
        System.out.println("Contains 'Banana'? " + vector.contains("Banana"));
        System.out.println("Contains 'Apple'? " + vector.contains("Apple"));

        // 10. clear() - remove all elements
        vector.clear();
        System.out.println("After clear: " + vector);
        System.out.println("Is vector empty after clear? " + vector.isEmpty());
    }
}

âœ…Output of above code:
After add: [Apple, Banana, Cherry]
After add at index 1: [Apple, Mango, Banana, Cherry]
Element at index 2: Banana
After set at index 2: [Apple, Mango, Orange, Cherry]
After remove at index 3: [Apple, Mango, Orange]
After removing 'Apple': [Mango, Orange]
Size of vector: 2
Is vector empty? false
Contains 'Banana'? false
Contains 'Apple'? false
After clear: []
Is vector empty after clear? true

ğŸ”· Synchronization and Performance
ğŸ‘‰ Since vector methods are synchronized, it ensures that only one thread can access the vector at a time. This makes it thread-safe but cna introduce performance overhead in single-threaded environments because synchronization adds locking and unlocking costs.

ğŸ‘‰ In moder Java applications, ArrayList is generally preferred over Vector when synchronization isn't required. For thread-safe collections, the CopyOnWriteArrayList or ConcurrentHashMap from the java.util.concurrent package are often recommended.

ğŸŒŸ Stack
ğŸ‘‰ Stack extends Vector, it is synchronized making it thread-safe.
ğŸ‘‰ LIFO structure: Stack follows the Last-In-First-Out(LIFO) principle, where the last element added is the first one to be removed.
ğŸ‘‰ Inheritance: Stack is a subclass of Vector, which means it inherits all the features of a dynamic array but is constrained by the stack's LIFO nature.


âœ…Code Implementation
ğŸ“Method 1
package collections;

import java.util.Stack;

public class StackDemo {

	public static void main(String[] args) {
		Stack<Integer> st = new Stack<>();

		// to add the elements in the stack
		st.push(1);
		st.push(2);
		st.push(3);
		st.push(4);
		st.push(5);

		// to remove the top element
		int removedElement = st.pop();
		System.out.println(removedElement);
		System.out.println(st);

		// to see what the top element
		System.out.println(st.peek());

		// to check whether the stack is empty or not
		System.out.println(st.isEmpty());

		// to check the size of the stack
		System.out.println(st.size());

		//to search the element
		//Gives the index from the top
		System.out.println(st);
//		3 is at the 2nd index from the top
		System.out.println(st.search(3));	
	}
}

ğŸ“Method 2:
package collections;

import java.util.LinkedList;
import java.util.Stack;

public class StackDemo {

	public static void main(String[] args) {
		LinkedList<Integer> linkedlist = new LinkedList<>();

		// adding element in the LIFO manner
		linkedlist.addLast(1);
		linkedlist.addLast(2);
		linkedlist.addLast(3);
		linkedlist.addLast(4);
		linkedlist.addLast(5);

		// removing elements
		linkedlist.removeLast();

		// peek at the top element
		linkedlist.getLast();

		// return boolean whether the linkedlist is empty or not
		linkedlist.isEmpty();
	}
}

ğŸŒŸ CopyOnWriteArrayList
ğŸ‘‰ Copy on Write means that whenever an element is added or removed from the ArrayList, a new copy is created. This ensures that the ArrayList remains thread-safe even if multiple threads are accessing it concurrently.

ğŸ‘‰ Read Operations: Fast and direct, since they happen on a stable list without interference from modifications.
ğŸ‘‰ Write Operations: A new copy of the list is created for every modification. 
ğŸ‘‰ The reference to the list is then updated so that subsequent reads use this new list.
ğŸ‘‰ Useful when read operations are more in comparison to write operations because on writing each time a new copy is created hence memory consumption take place.

âŒ Problem with List and ArrayList
package collections;

import java.util.ArrayList;
import java.util.List;

public class CopyOnWriteArrayListDemo {

	public static void main(String[] args) {
List<String>copyArrayList=new ArrayList<>();
		copyArrayList.add("Milk");
		copyArrayList.add("Eggs");
		copyArrayList.add("Bread");
		copyArrayList.add("Meat");
		
		for(String item:copyArrayList) {
			System.out.println(item);
			if(item.equals("Eggs")) {
				copyArrayList.add("Butter");
				System.out.println("Added Butter while Reading");
			}
		}
		System.out.println("The new udpated Array List");
		System.out.println(copyArrayList);
	}
}

âŒOutput:
Milk
Eggs
Added Butter while Reading
Exception in thread "main" java.util.ConcurrentModificationException
	at java.base/java.util.ArrayList$Itr.checkForComodification(ArrayList.java:1096)
	at java.base/java.util.ArrayList$Itr.next(ArrayList.java:1050)
	at CollectionFramework/collections.CopyOnWriteArrayListDemo.main(CopyOnWriteArrayListDemo.java:15)

While Iterating we cannot modify the list, it will throw an exception.

âœ… Using CopyOnWriteArrayList:
List<String>copyArrayList=new CopyOnWriteArrayList<>(); //using this we will get the

âš¡Output:
Milk
Eggs
Added Butter while Reading
Bread
Meat
The new udpated Array List
[Milk, Eggs, Bread, Meat, Butter]

ğŸ”· Maps in Java
In Java, a Map is an object that maps keys to values. It cannot contain duplicate keys, and each key can map to at most one value. Thik of it as a dictionary where you look up a word(key ) to find its defintion(value).

Map does not extends collection interface. It extends Map interface.

ğŸŒŸ Key Characteristics of the Map Interface
â¤ Key-Value Pair: Each entry in a Map consists of a key and a value.
â¤ Unique Keys: No two entries can have the same key.
â¤ One Value per key: Each key maps to a single value.
â¤ Order: Some implementations maintain insertion order(LinkedHashMap), nature order(TreeMap), or no order(HashMap).

ğŸŒŸ HashMap
âœ… Code Snippet:
package collections;

import java.util.HashMap;
import java.util.Map.Entry;
import java.util.Set;

public class HashMapDemo {

	public static void main(String[] args) {
		HashMap<Integer, String> hs = new HashMap<>();
		hs.put(1, "Ankur");
		hs.put(2, "Deepak");
		hs.put(3, "Suraj");
		hs.put(4, "Harsh");
		System.out.println(hs);

		System.out.println(hs.get(3));
		// if not present gives null
		System.out.println(hs.get(5));

		if (hs.containsKey(2)) {
			System.out.println("Key is present in the map");
		} else {
			System.out.println("Key is not present in the map");
		}

		if (hs.containsValue("Ankur")) {
			System.out.println("Value is present");
		} else {
			System.out.println("Value is not present");
		}

		// iterating the map Method 1
		System.out.println("Iterating on the map by keySet Method");
		// Set<Integer> keys=hs.keySet();
		for (int i : hs.keySet()) {
			System.out.println(i + " -> " + hs.get(i));
		}

		// Method 2
		System.out.println("Iterating on the map using entrySet Method");
		Set<Entry<Integer, String>> entrySet = hs.entrySet();
		for (Entry<Integer, String> entry : entrySet) {
			System.out.println(entry.getKey() + " -> " + entry.getValue().toUpperCase());
		}

		//hs.remove(1); //removing element based on key
		boolean isRemoved=hs.remove(1, "Deepak"); //removing based on key and value
		System.out.println(isRemoved); //because no entry exist of that type

	}
}

âŒOutput:
{1=Ankur, 2=Deepak, 3=Suraj, 4=Harsh}
Deepak
null
Key is not present in the map
Value is present
Iterating on the map by keySet Method
1 -> Ankur
2 -> Deepak
3 -> Suraj
4 -> Harsh
Iterating on the map using entrySet Method
1 -> ANKUR
2 -> DEEPAK
3 -> SURAJ	
4 -> HARSH
false

ğŸŒŸ Key Characteristics of HashMap
â¤ Unordered: Does not maintain any order of its elements.
â¤ Allows null keys and Values: Can have one null key and multiple null values.
â¤ Not Synchhronized: Not thread-safe, requires external synchronization if used in a multi-threaded context.
â¤ Performance: Offers constant time performance(O(1)) for basic operations like get and put, assuming the hash function disperses elements properly.

ğŸ”„ Internal Structure of HashMap
Basic components:
âœ”ï¸ Key: The identifer used to retrieve a value.
âœ”ï¸ Value:The data associated with the key.
âœ”ï¸ Bucket: A place where key-value paris are stored. Think of buckets as cells in a list(array).
âœ”ï¸ Hash function: Converts a key into an index(bucket location) for storage.
â¤ A hash function is an algorithm that takes an input(or key) and returns a fixed-size string of bytes, typically a numerical value. The output is known as the hash code, hash value or simply hash. The primary purpose of a hash function is to map data of arbitrary size to a fixed-size value.

Characteristics of Hash Function:
âœ”ï¸ Deterministic: Given the same input, the hash function always produces the same output.
âœ”ï¸ Fixed Output size: The output of the hash function is a fixed-size string of bytes.
âœ”ï¸ Efficient Computation: The hash function is fast to compute.

ğŸ§  How Data is Stored in HashMap
âš¡ Step 1: Hashing the Key: 
The key is passed through a hash function to generate a unique hash code(an integer number). This hash code helps determine where the key-value pair will be stored in the array(called a "bucket array").

âš¡ Step 2: Calculating the Index:
The hash code is then used to calculate an index in the array(bucket location) using
int index= hashCode % array.length;
The index decides which bucket will hold the key-value pair.
âœ… For example: If the array size is 16, the key's hash code will be divided by `16, and the remainder will be the index.

âš¡ Step 3: Storing in the Bucket:
The key-value pair is stored in the bucket at the calculated index.
Each bucket can hold multiple key-value pairs.
(this is called a collision handling mechanism).

ğŸ§  How HashMap Retrieves Data
When we call get(Key), the HashMap follows the following steps:
âš¡ Hashing the key: Similar to insertion, the key is hashed using the same hash function to calculate its hash code.
âš¡ Finding the index: The hash code is used to find the index of the bucket where the key-value pair is stored.
âš¡ Searching in the Bucket: Once the correct bucket is found, it checks for the key in that bucket. If found, it returns the value associated with the key.	

ğŸ†šHandling Collisions
â¤ Since different keys can generate the same index(called a collision)
HashMap uses a technique to handle this situation. Java's HashMap uses Linked List(or balanced Red-Black Tree(self balancing binary search tree) after Java 8) to resolve collisions.

â¤ If multiple key-value paris map to the same bucket, they are stored i a linked list inside the bucket.
â¤ This is called Separate Chaining.

â¤ When a key-value pair is retrieved, the HashMap traverse the linked list to find the value associated with the key.

ğŸ”„ HashMap Resizing(Rehashing)
â¤ HashMap has an internal array size, which is by default is 16.
When the number of elements(key-value pairs) grows and exceeds a certain load factor(default is 0.75), HashMap automatically resizes the array to hold more data. This process is called rehashing.

â¤ The default size of the array is 16, so when more than 12 elements(16*0.75) are inserted, the HashMap will resize.

â—During rehashing
â¤ The array size is doubled
â¤ All existing entries are rehashed(i.e., their positions are recalculated)
and placed in the new array.
â¤ This ensures the HashMap continues to work efficiently even after more data is added.

âš¡Time Compplexity
â¤ Average: O(1) for insertion, deletion, search.
â¤ Worst case (all collisions in same bucket): O(logn) (but rare in practice).
But after Java 8, if there are too many elements in the bucket, HashMap switches to a balanced tree instead of a linked list to ensure better performance.
TREEFY_THRESHOLD = 8 for converting linked list to balanced tree.

â—Problem:
â¤ When you create a custom class Person with fields like id and name, and put it into a HashMap, then:
â¤ By default, Object's implementation of hashCode() and equals() is used.
â¤ That implementation uses memory address â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ so two objects with the same values (id=1, name="Ankur") are considered different keys.

Example (Problem Case):
import java.util.*;

class Person {
    private int id;
    private String name;

    public Person(int id, String name) {
        this.id = id;
        this.name = name;
    }
}

public class Main {
    public static void main(String[] args) {
        Map<Person, String> map = new HashMap<>();

        Person p1 = new Person(1, "Ankur");
        Person p2 = new Person(1, "Ankur");

        map.put(p1, "Developer");
        map.put(p2, "Manager");

        System.out.println("Map size: " + map.size());
        System.out.println(map);
    }
}
ğŸ‘‰ Output:
Map size: 2

â¤ Even though both objects have the same id and name, they are treated as different keys.

âœ… Fix:
To fix this, override hashCode() and equals() in the Person class.
ğŸ”„ Correct Implementation:
import java.util.*;

class Person {
    private int id;
    private String name;

    public Person(int id, String name) {
        this.id = id;
        this.name = name;
    }

    // Override equals
    @Override
    public boolean equals(Object o) {
        if (this == o) return true; // same reference
        if (o == null || getClass() != o.getClass()) return false;

        Person person = (Person) o;
        return id == person.id && Objects.equals(name, person.name);
    }

    // Override hashCode
    @Override
    public int hashCode() {
        return Objects.hash(id, name);
    }

    @Override
    public String toString() {
        return "Person{id=" + id + ", name='" + name + "'}";
    }
}

public class Main {
    public static void main(String[] args) {
        Map<Person, String> map = new HashMap<>();

        Person p1 = new Person(1, "Ankur");
        Person p2 = new Person(1, "Ankur");

        map.put(p1, "Developer");
        map.put(p2, "Manager");

        System.out.println("Map size: " + map.size());
        System.out.println(map);
    }
}
ğŸ‘‰ Output:
Map size: 1
{Person{id=1, name='Ankur'}=Manager}

â¤ Now both objects are considered the same key because hashCode() is same and equals() says they are equal.
â¤ The second put() overwrites the value (Manager replaces Developer).

âœ”ï¸ Key Notes 
â¤ Always override both equals() and hashCode() together (not just one).
â¤ If you only override equals() but not hashCode(), HashMap may still treat them as different keys.
â¤ Use Objects.hash() and Objects.equals() (Java 7+) to simplify.
â¤ Consistency rule: if a.equals(b) == true, then a.hashCode() == b.hashCode() must also hold.

âœ… Working of getOrDefault() Method:
package collections;

import java.util.HashMap;

public class HashMapDemo {

	public static void main(String[] args) {
		HashMap<String, Integer> hashMap = new HashMap<>();
		hashMap.put("Ankur", 100);
		hashMap.put("Alice", 99);
		hashMap.put("Bob", 101);

		Integer res1 = hashMap.getOrDefault("Ankur", -1);
		if (res1 != -1) {
			System.out.println("Ankur is present in the map");
		} else {
			System.out.println("Ankur Not present");
		}

		Integer res2 = hashMap.getOrDefault("Sam", -1);
		if (res2 != -1) {
			System.out.println("Sam is present in the map");
		} else {
			System.out.println("Sam Not present");
		}

	}
}

âœ…Output:
Ankur is present in the map
Sam Not present

âœ…Method: putIfAbsent()
Example:
package collections;

import java.util.HashMap;

public class HashMapDemo {

	public static void main(String[] args) {
		HashMap<String, Integer> hashMap = new HashMap<>();
		hashMap.put("Ankur", 100);
		hashMap.put("Alice", 99);
		hashMap.put("Bob", 101);

		hashMap.putIfAbsent("Ankur", 200);
		hashMap.putIfAbsent("Sam", 201);
		System.out.println(hashMap);
	}
}

âœ…Output:
{Ankur=200, Alice=99, Bob=101, Sam=201}

ğŸ”· LinkedHashMap
package collections;

import java.util.LinkedHashMap;
import java.util.Map;

public class LinkedHashMapDemo {

	public static void main(String[] args) {
		LinkedHashMap<String, Integer> linkedHashMap = new LinkedHashMap<>();
		linkedHashMap.put("Orange", 10);
		linkedHashMap.put("Apple", 20);
		linkedHashMap.put("Mango", 30);
		
		for(Map.Entry<String, Integer>entry:linkedHashMap.entrySet()) {
			System.out.println(entry.getKey()+" -> "+ entry.getValue());
		}
	}
}

ğŸ“Œ Constructor
LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)

â¤ initialCapacity â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ number of buckets initially.
â¤ loadFactor â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ controls resizing.
â¤ accessOrder â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶
	âœ”ï¸ false â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ maintains insertion order.
	âœ”ï¸ true â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ maintains access order (order changes when an entry is accessed with get() or put()).

âœ… Example 1: accessOrder = false (Insertion Order)
import java.util.*;

public class Main {
    public static void main(String[] args) {
        // Insertion order
        Map<Integer, String> map = new LinkedHashMap<>(16, 0.75f, false);

        map.put(1, "A");
        map.put(2, "B");
        map.put(3, "C");

        // Access element
        map.get(2); // does NOT change order

        System.out.println("Insertion Order: " + map);
    }
}
ğŸ‘‰ Output:
Insertion Order: {1=A, 2=B, 3=C}
Even though we accessed key 2, the order remains insertion order.

âœ… Example 2: accessOrder = true (Access Order)
import java.util.*;

public class Main {
    public static void main(String[] args) {
        // Access order
        Map<Integer, String> map = new LinkedHashMap<>(16, 0.75f, true);

        map.put(1, "A");
        map.put(2, "B");
        map.put(3, "C");

        // Access element
        map.get(2); // moves 2 to end
        map.get(1); // moves 1 to end

        System.out.println("Access Order: " + map);
    }
}
ğŸ‘‰ Output:
Access Order: {3=C, 2=B, 1=A}

First inserted order: {1=A, 2=B, 3=C}
After map.get(2) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ 2 moves to end â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ {1=A, 3=C, 2=B}
After map.get(1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ 1 moves to end â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ {3=C, 2=B, 1=A}

âš¡Tip
âœ”ï¸ accessOrder = true is often used to implement LRU Cache (Least Recently Used).
âœ”ï¸ removeEldestEntry() method can be overridden to auto-remove the oldest entry.

LinkedHashMap is a combination of HashMap + Doubly Linked List.

âœ… Constructor Method:
LinkedHashMap linkedHashMap= new LinkedHashMap(hashMap);

ğŸ”·WeakHashMap
â¤ WeakHashMap<K,V> is a special implementation of Map where keys are stored as weak references.
â¤ If a key is not strongly referenced elsewhere in the program, the GC (Garbage Collector) can reclaim it.
â¤ Once GC collects the key, the corresponding entry is automatically removed from the map.

ğŸ”„ Use of WeakHashMap
â¤ Commonly used for caches where you donâ€™t want unused objects to prevent GC.
â¤ If the key object is no longer in use anywhere else â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ its entry is automatically removed.

âœ… Example
import java.util.WeakHashMap;

public class WeakHashMapDemo {

	public static void main(String[] args) {
		WeakHashMap<String, Image> imageCache = new WeakHashMap<>();
		imageCache.put(new String("img1"), new Image("Image 1"));
		imageCache.put(new String("img2"), new Image("Image 2"));
		imageCache.put(new String("img3"), new Image("Image 3"));
		System.out.println(imageCache);
		System.gc();
		simulation();
		System.out.println("Cache after running(some entries may be cleared): " + imageCache);
	}

	private static void simulation() {
		try {
			System.out.println("Simulating application running...");
			Thread.sleep(10000);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

class Image {
	private String name;

	public Image(String name) {
		this.name = name;
	}

	@Override
	public String toString() {
		return name;
	}
}
âœ…Output:
{img1=Image 1, img2=Image 2, img3=Image 3}
Simulating application running...
Cache after running(some entries may be cleared): {}

ğŸ§ Explaination
ğŸ‘‰WeakHashMap<String, Image> imageCache = new WeakHashMap<>();
Creates a WeakHashMap where:
	âœ”ï¸ Key = String (weakly referenced)
	âœ”ï¸ Value = Image object (normal strong reference)

ğŸ‘‰imageCache.put(new String("img1"), new Image("Image 1"));
â¤ Uses new String("img1") â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ ensures the key is not from String pool (important!).
â¤ If we had used "img1" directly, it would come from the string pool (strongly referenced by JVM), and GC wouldnâ€™t clear it.

ğŸ‘‰System.gc();
Suggests JVM to run garbage collection (not guaranteed, but usually works in demos).

ğŸ‘‰simulation();
Sleeps for 10 seconds â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ gives JVM time to clear weakly referenced keys.

ğŸ‘‰ Class Image
â¤ Just a wrapper with a name field.
â¤ toString() overridden â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ so when map is printed, values show as "Image 1", "Image 2", etc.

ğŸ‘‰ Output Explaination:
â¤ The second print may show {} or partially cleared entries depending on GC.
â¤ Because keys (new String("imgX")) are weakly referenced â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ once GC runs, they vanish.

âš¡ Important Points
âœ”ï¸ WeakHashMap removes entries automatically when keys are weakly referenced and GC runs.
ğŸ†š Difference from HashMap:
â¤ HashMap â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ keys are strongly referenced (never removed unless explicitly).
â¤ WeakHashMap â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ keys are weak references (removed after GC if no strong reference exists).
âœ”ï¸ Values (Image) are still strongly referenced, but without a strong key reference, they become unreachable.
âœ”ï¸ Useful for memory-sensitive caching.

ğŸ§  Trap Question
package collections;

import java.util.HashMap;
import java.util.Map;

public class IdentityHashMapDemo {

	public static void main(String[] args) {
		String key1 = new String("Key");
		String key2 = new String("Key");
		Map<String, Integer> map = new HashMap<>();
		map.put(key1, 1);
		map.put(key2, 2);
		System.out.println(map);
	}

}
âœ… Output: {key=2};
ğŸ§ Explaination: Even though string is made through new keyword, that hashcode will not be generated based on the memory address, as string already has a function to calculate hashcode based on the value stored inside the string so both the values are same. 
Therefore, inside the map it will use the key1.equals(key2) and it will return true so it will return the value of key2 which is 2.

If we want output like {key=1, key=2} then we can use IdentityHashMap.

ğŸ”·IdentityHashMap
â¤ IdentityHashMap is a special implementation of Map in Java where keys are compared using reference equality (==) instead of equals().
â¤ It is part of java.util package.

ğŸŒŸ Key Features
â¤ Uses reference equality (==) for both key comparison and hashing.
â¤ Allows null keys and null values.
â¤ Performance is similar to HashMap.
â¤ Not synchronized (like HashMap).
â¤ It breaks the general contract of Map because two logically equal keys (according to .equals()) may not be treated as equal here.

ğŸ†š Difference from HashMap
| Feature        | `HashMap`                     | `IdentityHashMap`                |
| -------------- | ----------------------------- | -------------------------------- |
| Key comparison | Uses `equals()`               | Uses `==` (reference equality)   |
| Hashing        | Uses `hashCode()` of key      | Uses `System.identityHashCode()` |
| Usage          | When logical equality matters | When reference identity matters  |

âœ… Example 1:
import java.util.*;

public class IdentityHashMapDemo {
    public static void main(String[] args) {
        Map<String, String> map = new IdentityHashMap<>();

        String a = new String("hello");
        String b = new String("hello");

        map.put(a, "Value A");
        map.put(b, "Value B");

        System.out.println("Size: " + map.size());
        System.out.println(map);
    }
}

âœ… Output:
Size: 2
{hello=Value A, hello=Value B}
ğŸ‘‰ Even though a.equals(b) is true, IdentityHashMap treats them as different keys because a != b (different objects in memory).

ğŸŒŸ Use Cases
âœ”ï¸ When you need object identity instead of equality.
âœ”ï¸ Caching frameworks (where reference equality is important).
âœ”ï¸ Serialization/deserialization where temporary objects need unique tracking.
âœ”ï¸ Graph processing (tracking visited nodes by identity).
âœ”ï¸ Object pools.

âœ… Example: What will happen if you put two equal String objects as keys?
package collections;

import java.util.IdentityHashMap;
import java.util.Map;

public class IdentityHashMapDemo {

	public static void main(String[] args) {
		String key1 = new String("Key");
		String key2 = new String("Key");
		Map<String, Integer> map = new IdentityHashMap<>();
		map.put(key1, 1);
		map.put(key2, 2);
		System.out.println(map);
	}
}
âœ…Output : {Key=2}

ğŸ”· Comparable
â¤ Belongs to java.lang package.
â¤ Used to define the natural/default ordering of objects.
â¤ A class implements Comparable to provide its own comparison logic.
â¤ It has one method:
ğŸ”— public int compareTo(T o):
Returns:
	âœ”ï¸ 0 â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ equal
	âœ”ï¸ <0 â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ current object < given object
	âœ”ï¸ >0 â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ current object > given object

ğŸ”¸ Example: Student sorting by age (natural order)
class Student implements Comparable<Student> {
    String name;
    int age;

    Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public int compareTo(Student s) {
        return this.age - s.age; // ascending order
    }
}

âœ… Comparator (Interface)
â¤ Belongs to java.util package.
â¤ Used when we want to define multiple sorting strategies or sorting logic outside the class.
â¤ It has two main methods Java 8 added comparing() and thenComparing() for chaining.:
	âœ”ï¸ public int compare(T o1, T o2);
	âœ”ï¸ public boolean equals(Object obj); // rarely overridden
â¤ Can be used with lambda/method references for concise sorting.

ğŸ”¸ Example: Sorting Student by name
import java.util.*;

class Student {
    String name;
    int age;
    Student(String name, int age) {
        this.name = name;
        this.age = age;
    }
}

class NameComparator implements Comparator<Student> {
    public int compare(Student s1, Student s2) {
        return s1.name.compareTo(s2.name);
    }
}
ğŸ”„ Usage: Collections.sort(list, new NameComparator());

ğŸ†š Comparable vs Comparator â€” Differences
| Feature             | Comparable                              | Comparator                                          |
| ------------------- | --------------------------------------- | --------------------------------------------------- |
| Package             | `java.lang`                             | `java.util`                                         |
| Method              | `compareTo(Object o)`                   | `compare(Object o1, Object o2)`                     |
| Sorting logic       | Defined **inside the class**            | Defined **outside the class**                       |
| Natural Order       | Provides **default (natural)** ordering | Provides **custom/multiple** orderings              |
| Modifies class code | Yes (must implement inside class)       | No (separate comparator class or lambda)            |
| One vs Many         | One natural order only                  | Many possible comparators                           |
| Java 8 support      | No enhancements                         | Added `comparing()`, `thenComparing()` for chaining |

âœ… Example with Both
import java.util.*;

class Student implements Comparable<Student> {
    String name;
    int age;
    Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // Natural order: by age
    @Override
    public int compareTo(Student s) {
        return this.age - s.age;
    }

    @Override
    public String toString() {
        return name + " (" + age + ")";
    }
}

public class Main {
    public static void main(String[] args) {
        List<Student> list = new ArrayList<>();
        list.add(new Student("John", 25));
        list.add(new Student("Alice", 22));
        list.add(new Student("Bob", 30));

        // Using Comparable (natural order: by age)
        Collections.sort(list);
        System.out.println("Sorted by age: " + list);

        // Using Comparator (custom order: by name)
        Collections.sort(list, (s1, s2) -> s1.name.compareTo(s2.name));
        System.out.println("Sorted by name: " + list);
    }
}

ğŸŒŸ Insights
â¤ Comparable â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ "I have a natural order, built inside the class."
â¤ Comparator â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ "I allow multiple sorting logics, outside the class."
â¤ Common trick: â€œCan a class implement both?â€ â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ âœ… Yes, a class can have a natural order (Comparable) and also be sorted by different comparators when needed.

ğŸ”· SortedMap
An interface in Java that extends Map and guarantees ordering of keys in ascending order (natural ordering or custom Comparator).

ğŸŒŸ Key Features:
â¤ Maintains elements in sorted order of keys.
â¤ Duplicate keys âŒ not allowed.
â¤ Backed by implementations like TreeMap.
â¤ Provides range-view methods (headMap, tailMap, subMap).

Important Methods:
â¤ K firstKey() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ returns lowest key.
â¤ K lastKey() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ returns highest key.
â¤ SortedMap<K,V> headMap(K toKey) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ view of keys < toKey.
â¤ SortedMap<K,V> tailMap(K fromKey) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ view of keys >= fromKey.
â¤ SortedMap<K,V> subMap(K fromKey, K toKey) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ view between fromKey and toKey.
â¤ Comparator<? super K> comparator() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ returns comparator used, or null if natural ordering.

Use Cases:
âœ”ï¸ Maintaining sorted dictionaries.
âœ”ï¸ Range-based operations (e.g., retrieving values within a range of keys).
âœ”ï¸ Implementing priority-like behavior using keys.

âœ…Code Implementation:
import java.util.*;

public class SortedMapDemo {
    public static void main(String[] args) {
        // Creating a SortedMap
        SortedMap<Integer, String> sortedMap = new TreeMap<>();

        // Adding elements
        sortedMap.put(3, "Banana");
        sortedMap.put(1, "Apple");
        sortedMap.put(5, "Mango");
        sortedMap.put(2, "Orange");
        sortedMap.put(4, "Grapes");

        // Displaying map (sorted automatically by keys)
        System.out.println("SortedMap: " + sortedMap);

        // Methods of SortedMap
        System.out.println("First Key: " + sortedMap.firstKey());
        System.out.println("Last Key: " + sortedMap.lastKey());
        System.out.println("HeadMap (<3): " + sortedMap.headMap(3));
        System.out.println("TailMap (>=3): " + sortedMap.tailMap(3));
        System.out.println("SubMap (2 to 5): " + sortedMap.subMap(2, 5));
        System.out.println("Comparator Used: " + sortedMap.comparator()); // null â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ natural ordering
    }
}

âœ…Output
{1=Apple, 2=Orange, 3=Banana, 4=Grapes, 5=Mango}
First Key: 1
Last Key: 5
HeadMap(<3): {1=Apple, 2=Orange}
TailMap(>=3): {3=Banana, 4=Grapes, 5=Mango}
SubMap(2 to 5): {2=Orange, 3=Banana, 4=Grapes}
Comparator Used: null

ğŸ”· NavigableMap
An interface that extends SortedMap, providing navigation methods for key search and traversal.

ğŸŒŸ Key Features:
â¤ Allows finding closest matches (floorKey, ceilingKey, etc.).
â¤ Can return reverse order views of the map.
â¤ Common implementation: TreeMap.

ğŸŒŸ Important Methods:
â¤ K lowerKey(K key) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ greatest key < key.
â¤ K floorKey(K key) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ greatest key <= key.
â¤ K ceilingKey(K key) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ least key >= key.
â¤ K higherKey(K key) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ least key > key.
â¤ Map.Entry<K,V> firstEntry() / lastEntry() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ first and last entry.
â¤ Map.Entry<K,V> pollFirstEntry() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ removes and returns first entry.
â¤ NavigableMap<K,V> descendingMap() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ reverse order view.

ğŸ”„ Use Cases:
â¤ Efficient searching for nearest values.
â¤ Implementing caches, scheduling systems, range queries.
â¤ Situations where ordering + navigation are critical.

âœ…Code Implementation:
import java.util.*;

public class NavigableMapDemo {
    public static void main(String[] args) {
        // Creating a NavigableMap
        NavigableMap<Integer, String> navMap = new TreeMap<>();

        // Adding elements
        navMap.put(1, "Apple");
        navMap.put(2, "Orange");
        navMap.put(3, "Banana");
        navMap.put(4, "Grapes");
        navMap.put(5, "Mango");

        // Displaying map
        System.out.println("NavigableMap: " + navMap);

        // Methods of NavigableMap
        System.out.println("Lower Key(3): " + navMap.lowerKey(3));    // < 3
        System.out.println("Floor Key(3): " + navMap.floorKey(3));    // <= 3
        System.out.println("Ceiling Key(3): " + navMap.ceilingKey(3));// >= 3
        System.out.println("Higher Key(3): " + navMap.higherKey(3));  // > 3

        System.out.println("First Entry: " + navMap.firstEntry());
        System.out.println("Last Entry: " + navMap.lastEntry());
        System.out.println("Descending Map: " + navMap.descendingMap());

        // Polling entries (removes from map)
        System.out.println("Poll First Entry: " + navMap.pollFirstEntry());
        System.out.println("Poll Last Entry: " + navMap.pollLastEntry());
        System.out.println("Remaining Map: " + navMap);
    }
}
âœ…Output:
{1=Apple, 2=Orange, 3=Banana, 4=Grapes, 5=Mango}
Lower Key(3): 2
Floor Key(3): 3
Ceiling Key(3): 3
Higher Key(3): 4
Descending Map: {5=Mango, 4=Grapes, 3=Banana, 2=Orange, 1=Apple}
Poll First Entry: 1=Apple
Poll Last Entry: 5=Mango
Remaining Map: {2=Orange, 3=Banana, 4=Grapes}

ğŸ”· Hashtable
A legacy class (from JDK 1.0) that implements Map, storing key-value pairs in hash table form.

ğŸ”„ Key Features:
â¤ âœ… Thread-safe (all methods synchronized).
â¤ âŒ Null keys/values not allowed (unlike HashMap).
â¤ Slower than HashMap due to synchronization.
â¤ Introduced before Java Collections Framework â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ considered legacy.
â¤ Replaced by ConcurrentHashMap in modern concurrent apps.

ğŸ”„ Internal Working:
â¤ Uses array of buckets where each bucket stores a linked list of entries.
â¤ On collision â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ new entry appended to linked list of that bucket.
â¤ Since Java 8, HashMap/ConcurrentHashMap optimize collision handling with balanced trees, but Hashtable still uses only linked list.

ğŸ”„ Important Methods:
â¤ V put(K key, V value) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ insert key-value.
â¤ V get(Object key) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ retrieve value.
â¤ boolean containsKey(Object key) / containsValue(Object value) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ check existence.
â¤ Enumeration<K> keys() / elements() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ legacy iteration methods.

ğŸ”„ Use Cases:
â¤ Very limited today â€” mostly in legacy systems.
â¤ For thread-safe maps â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ use ConcurrentHashMap.

ğŸ”„ Comparison with HashMap:
â¤ Hashtable â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ synchronized, no null keys/values, slower.
â¤ HashMap â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ not synchronized, allows one null key & multiple null values, faster.

âœ…Code Implementation:
import java.util.*;

public class HashtableDemo {
    public static void main(String[] args) {
        // Creating a Hashtable
        Hashtable<Integer, String> hashtable = new Hashtable<>();

        // Adding elements
        hashtable.put(101, "Java");
        hashtable.put(102, "Python");
        hashtable.put(103, "C++");
        hashtable.put(104, "JavaScript");

        // Displaying Hashtable
        System.out.println("Hashtable: " + hashtable);

        // Access methods
        System.out.println("Value at key 102: " + hashtable.get(102));
        System.out.println("Contains key 103? " + hashtable.containsKey(103));
        System.out.println("Contains value 'C#'? " + hashtable.containsValue("C#"));

        // Iterating with Enumeration (legacy style)
        System.out.println("Iterating using Enumeration:");
        Enumeration<Integer> keys = hashtable.keys();
        while (keys.hasMoreElements()) {
            Integer key = keys.nextElement();
            System.out.println(key + " -> " + hashtable.get(key));
        }
    }
}

âœ…Output:
{104=JavaScript, 103=C++, 102=Python, 101=Java}
Value at key 102: Python
Contains key 103? true
Contains value 'C#'? false
Iterating with Enumeration:
104 -> JavaScript
103 -> C++
102 -> Python
101 -> Java

ğŸ”· ConcurrentHashMap
âœ… Java 7
â¤ Used segment-based locking (default: 16 segments â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ 16 smaller hash tables).
â¤ Only the segment being modified/read is locked.
â¤ Read: doesnâ€™t require locking unless concurrent write is happening.
â¤ Write: locks only that segment (better concurrency than Hashtable).

âœ… Java 8
â¤ Removed segmentation â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ now uses bucket-level locks.
â¤ Uses CAS (Compare-And-Swap) for updates (almost lock-free).
â¤ Locking only occurs during resizing or treeification (when collision chains convert to balanced trees).
â¤ Much faster than Java 7 implementation.

âœ…Code Implementation:
import java.util.concurrent.*;

public class ConcurrentHashMapDemo {
    public static void main(String[] args) {
        ConcurrentHashMap<Integer, String> chm = new ConcurrentHashMap<>();

        // Adding elements
        chm.put(1, "Apple");
        chm.put(2, "Banana");
        chm.put(3, "Mango");

        // Retrieving
        System.out.println("ConcurrentHashMap: " + chm);

        // Key already exists â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ old value replaced
        chm.put(2, "Orange");
        System.out.println("After update: " + chm);

        // Safe iteration during modification
        chm.forEach((k, v) -> System.out.println(k + " -> " + v));
    }
}

âœ…Output:
ConcurrentHashMap: {1=Apple, 2=Banana, 3=Mango}
After update: {1=Apple, 2=Orange, 3=Mango}
1 -> Apple
2 -> Orange
3 -> Mango

ğŸ”· ConcurrentSkipListMap
â¤ Thread-safe, Sorted Map implementation.
â¤ Backed by a SkipList, which is a probabilistic data structure with multiple layers (like â€œexpress lanesâ€ in a linked list).
â¤ Allows logarithmic time search, insert, delete.

âœ… Key Features
â¤ Maintains sorted order of keys (like TreeMap).
â¤ Concurrent access supported.
â¤ Non-blocking reads, fine-grained locking on writes.

âœ…Code Implementation
import java.util.concurrent.*;

public class ConcurrentSkipListMapDemo {
    public static void main(String[] args) {
        ConcurrentSkipListMap<Integer, String> cslm = new ConcurrentSkipListMap<>();

        // Adding elements
        cslm.put(5, "Mango");
        cslm.put(2, "Apple");
        cslm.put(4, "Banana");
        cslm.put(1, "Orange");

        // Sorted automatically
        System.out.println("ConcurrentSkipListMap: " + cslm);

        // Methods
        System.out.println("First Key: " + cslm.firstKey());
        System.out.println("Last Key: " + cslm.lastKey());
        System.out.println("HeadMap (<4): " + cslm.headMap(4));
        System.out.println("TailMap (>=2): " + cslm.tailMap(2));
    }
}

âœ…Output:
ConcurrentSkipListMap: {1=Orange, 2=Apple, 4=Banana, 5=Mango}
First Key: 1
Last Key: 5
HeadMap (<4): {1=Orange, 2=Apple}
TailMap (>=2): {2=Apple, 4=Banana, 5=Mango}


ğŸ”· EnumMap
â¤ A specialized Map implementation where keys must be enum constants.
â¤ Internally uses an array of values, indexed by enumâ€™s ordinal().
â¤ Very fast (no hashing) and memory-efficient.
â¤ Null keys âŒ not allowed.

âœ…Code Implementation:
import java.util.*;

enum Day { MON, TUE, WED, THU, FRI, SAT, SUN }

public class EnumMapDemo {
    public static void main(String[] args) {
        EnumMap<Day, String> em = new EnumMap<>(Day.class);

        // Adding elements
        em.put(Day.MON, "Start of week");
        em.put(Day.FRI, "Weekend is near");
        em.put(Day.SUN, "Holiday");

        // Displaying map
        System.out.println("EnumMap: " + em);

        // Access
        System.out.println("Message for FRI: " + em.get(Day.FRI));
    }
}

âœ…Output:
EnumMap: {MON=Start of week, FRI=Weekend is near, SUN=Holiday}
Message for FRI: Weekend is near

ğŸ”· ImmutableMap
â¤ Map that cannot be modified once created.
â¤ Any attempt to add/remove/update will throw UnsupportedOperationException.

âœ… Ways to Create ImmutableMap
1. Guavaâ€™s ImmutableMap (Google library):
// Guava ImmutableMap
// ImmutableMap<String, Integer> map1 = ImmutableMap.of("A", 1, "B", 2, "C", 3);

2.Using Collections.unmodifiableMap():
âœ…Code Implementation:
import java.util.*;

public class ImmutableMapDemo1 {
    public static void main(String[] args) {
        Map<String, Integer> normalMap = new HashMap<>();
        normalMap.put("A", 1);
        normalMap.put("B", 2);

        Map<String, Integer> immutableMap = Collections.unmodifiableMap(normalMap);
        System.out.println("ImmutableMap: " + immutableMap);

        // immutableMap.put("C", 3); // âŒ Throws UnsupportedOperationException
    }
}

âœ…Output:
ImmutableMap: {A=1, B=2}

3. Using Java 9+ Map.of() (limited to 10 pairs):
âœ…Code Implementation:
import java.util.*;

public class ImmutableMapDemo2 {
    public static void main(String[] args) {
        Map<String, Integer> map2 = Map.of("A", 1, "B", 2, "C", 3);
        System.out.println("Map.of: " + map2);

        // map2.put("D", 4); // âŒ Throws UnsupportedOperationException
    }
}

âœ…Output:
Map.of: {A=1, B=2, C=3}

4. Using Map.ofEntries() for larger maps:
âœ…Code Implementation:
import java.util.*;

public class ImmutableMapDemo3 {
    public static void main(String[] args) {
        Map<String, Integer> map3 = Map.ofEntries(
            Map.entry("A", 1),
            Map.entry("B", 2),
            Map.entry("C", 3),
            Map.entry("D", 4)
        );

        System.out.println("Map.ofEntries: " + map3);

        // map3.remove("A"); // âŒ UnsupportedOperationException
    }
}

âœ…Output:
Map.ofEntries: {A=1, B=2, C=3, D=4}

 
 ğŸ”· Set
â¤ Set is a collection of unique elements (no duplicates).
â¤ Unordered by default (HashSet).
â¤ Extends Collection interface.
â¤ Not thread-safe by default.

ğŸ”„ Common Implementations:
â¤ HashSet â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ backed by HashMap, no order guarantee.
â¤ LinkedHashSet â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ maintains insertion order.
â¤ TreeSet â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ maintains sorted order (uses Red-Black Tree).
â¤ EnumSet â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ optimized for enum constants.

ğŸ‘‰ For thread-safety, we have special implementations:
â¤ Collections.synchronizedSet(set) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ synchronized wrapper (rarely used).
â¤ ConcurrentSkipListSet â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ concurrent + sorted.
â¤ CopyOnWriteArraySet â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ concurrent + copy-on-write


ğŸ”· LinkedHashSet
â¤ Hash table + doubly linked list implementation.
â¤ Maintains insertion order.
â¤ Slightly slower than HashSet due to maintaining linked list.

âœ… Code Implementation:
import java.util.*;

public class LinkedHashSetDemo {
    public static void main(String[] args) {
        LinkedHashSet<String> lhs = new LinkedHashSet<>();

        lhs.add("Apple");
        lhs.add("Banana");
        lhs.add("Mango");
        lhs.add("Banana"); // duplicate ignored

        System.out.println("LinkedHashSet: " + lhs);
    }
}

âœ… Output:
LinkedHashSet: [Apple, Banana, Mango]

ğŸ”· TreeSet
â¤ Backed by a Red-Black Tree (self-balancing BST).
â¤ Maintains sorted order (ascending by default).
â¤ Can accept a Comparator for custom order.

âœ… Code Implementation:
import java.util.*;

public class TreeSetDemo {
    public static void main(String[] args) {
        TreeSet<Integer> ts = new TreeSet<>();

        ts.add(30);
        ts.add(10);
        ts.add(20);
        ts.add(40);

        System.out.println("TreeSet: " + ts); // Sorted order
        System.out.println("First: " + ts.first());
        System.out.println("Last: " + ts.last());
        System.out.println("HeadSet(<30): " + ts.headSet(30));
        System.out.println("TailSet(>=20): " + ts.tailSet(20));
        System.out.println("SubSet(10 to 30): " + ts.subSet(10, 30));
    }
}

âœ… Output:
TreeSet: [10, 20, 30, 40]
First: 10
Last: 40
HeadSet(<30): [10, 20]
TailSet(>=20): [20, 30, 40]
SubSet(10 to 30): [10, 20]


ğŸ”· ConcurrentSkipListSet
â¤ A concurrent, sorted, thread-safe set.
â¤ Backed by ConcurrentSkipListMap internally.
â¤ Maintains ascending sorted order.
â¤ Good for range-based operations (subSet, headSet, tailSet).
â¤ Weakly consistent iterators â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ do not throw ConcurrentModificationException, but may miss new updates.

âœ…Code Implementation:
import java.util.concurrent.*;

public class ConcurrentSkipListSetDemo {
    public static void main(String[] args) {
        ConcurrentSkipListSet<Integer> csls = new ConcurrentSkipListSet<>();

        csls.add(50);
        csls.add(20);
        csls.add(10);
        csls.add(40);

        System.out.println("ConcurrentSkipListSet: " + csls);
        System.out.println("HeadSet(<40): " + csls.headSet(40));
        System.out.println("TailSet(>=20): " + csls.tailSet(20));
        System.out.println("SubSet(10 to 40): " + csls.subSet(10, 40));
    }
}

âœ… Output:
ConcurrentSkipListSet: [10, 20, 40, 50]
HeadSet(<40): [10, 20]
TailSet(>=20): [20, 40, 50]
SubSet(10 to 40): [10, 20]

ğŸ”· CopyOnWriteArraySet
â¤ Backed by CopyOnWriteArrayList.
â¤ Thread-safe set.
â¤ On every write operation (add/remove) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ creates a new copy of the underlying array.
â¤ Reads are fast (no lock needed), but writes are expensive.
â¤ Best suited for:
	âœ”ï¸ Read-heavy, write-light scenarios.
	âœ”ï¸ Avoiding ConcurrentModificationException.

ğŸ”„ Iterator Behavior
â¤ Iterators are fail-safe (donâ€™t throw ConcurrentModificationException).
â¤ Iterators work on a snapshot of the array at the time of iteration â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ modifications made after iterator creation are not reflected.

âœ…Code Implementation
import java.util.concurrent.*;
import java.util.*;

public class CopyOnWriteArraySetDemo {
    public static void main(String[] args) {
        CopyOnWriteArraySet<String> cowSet = new CopyOnWriteArraySet<>();

        cowSet.add("Java");
        cowSet.add("Python");
        cowSet.add("C++");
        cowSet.add("Java"); // duplicate ignored

        System.out.println("CopyOnWriteArraySet: " + cowSet);

        // Iterating while modifying (safe)
        Iterator<String> it = cowSet.iterator();
        cowSet.add("Go"); // modification after iterator creation

        System.out.println("Iterator Snapshot:");
        while (it.hasNext()) {
            System.out.println(it.next()); // "Go" wonâ€™t appear here
        }

        System.out.println("After modification: " + cowSet); // "Go" appears in actual set
    }
}


âœ… Output:
CopyOnWriteArraySet: [Java, Python, C++]
Iterator Snapshot:
Java
Python
C++
After modification: [Java, Python, C++, Go]


ğŸ”· Queue Interface
â¤ A linear data structure that works on FIFO (First In First Out) principle.
â¤ Elements are added at the end (rear) and removed from the front (head).
â¤ Declared in java.util package.
â¤ Common implementations:
	âœ”ï¸ LinkedList
	âœ”ï¸ PriorityQueue
	âœ”ï¸ ArrayDeque
	âœ”ï¸ Concurrent Queues (ConcurrentLinkedQueue, BlockingQueue, etc.)

âœ… Common Queue Methods
| Method      | Description     | Behavior when queue is empty / full      |
| ----------- | --------------- | ---------------------------------------- |
| `add(e)`    | Inserts element | Throws exception if full                 |
| `offer(e)`  | Inserts element | Returns `false` if full (no exception)   |
| `remove()`  | Removes head    | Throws `NoSuchElementException` if empty |
| `poll()`    | Removes head    | Returns `null` if empty                  |
| `element()` | Retrieves head  | Throws `NoSuchElementException` if empty |
| `peek()`    | Retrieves head  | Returns `null` if empty                  |


âœ…Code Implementation:
import java.util.*;

public class QueueDemo {
    public static void main(String[] args) {
        Queue<Integer> q = new LinkedList<>();

        // Enqueue (add/offer)
        q.add(10);       // throws exception if fails
        q.offer(20);     // returns false if fails
        q.add(30);

        System.out.println("Queue: " + q);

        // Peek operations
        System.out.println("Peek: " + q.peek());     // returns 10, does not remove
        System.out.println("Element: " + q.element()); // returns 10, throws exception if empty

        // Dequeue (remove/poll)
        System.out.println("Removed using poll: " + q.poll());   // removes 10
        System.out.println("Removed using remove: " + q.remove()); // removes 20

        System.out.println("Queue after removals: " + q);

        // Edge cases
        q.clear(); // empty queue
        System.out.println("Poll on empty: " + q.poll());   // null
        try {
            System.out.println("Remove on empty: " + q.remove()); // exception
        } catch (Exception e) {
            System.out.println("Exception: " + e);
        }
    }
}

âœ… Output:
Queue: [10, 20, 30]
Peek: 10
Element: 10
Removed using poll: 10
Removed using remove: 20
Queue after removals: [30]
Poll on empty: null
Remove on empty: java.util.NoSuchElementException


ğŸ”· PriorityQueue in Java
A Queue implementation that orders elements by priority instead of FIFO.
Located in java.util package.
By default:
	âœ”ï¸ Uses natural ordering (ascending for numbers, alphabetical for strings).
	âœ”ï¸ Internally implemented as a Min-Heap (binary heap).
Key Features:
	âœ”ï¸ Does not allow null elements.
	âœ”ï¸ Duplicate elements are allowed.
	âœ”ï¸ Can use a custom Comparator to define ordering (e.g., Max-Heap).


ğŸŒŸ Internal Working
â¤ Implemented using a binary heap stored in an array.
â¤ For natural ordering â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ acts as a Min-Heap.
â¤ For reverse order (Comparator.reverseOrder()) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ acts as a Max-Heap.
â¤ Operations like insertion and deletion work in O(log n).
â¤ The head element of the queue is always the smallest (min-heap) or largest (max-heap) based on comparator.


ğŸŒŸCommon Methods
| Method                | Description                                       |
| --------------------- | ------------------------------------------------- |
| `add(e)` / `offer(e)` | Insert element                                    |
| `peek()`              | Returns highest-priority element without removing |
| `poll()`              | Removes and returns highest-priority element      |
| `remove()`            | Removes head, throws exception if empty           |
| `size()`              | Returns number of elements                        |

âœ…Code Implementation 1:Natural Ordering (Min-Heap)
import java.util.*;

public class PriorityQueueMinHeap {
    public static void main(String[] args) {
        PriorityQueue<Integer> pq = new PriorityQueue<>(); // min-heap

        pq.add(40);
        pq.add(10);
        pq.add(30);
        pq.add(20);

        System.out.println("PriorityQueue (Min-Heap): " + pq);
        System.out.println("Peek (smallest): " + pq.peek()); // 10

        while (!pq.isEmpty()) {
            System.out.println("Poll: " + pq.poll());
        }
    }
}

âœ… Output:
PriorityQueue (Min-Heap): [10, 20, 30, 40]
Peek (smallest): 10
Poll: 10
Poll: 20
Poll: 30
Poll: 40

âœ…Code Implementation 2:Reverse Order (Max-Heap)
import java.util.*;

public class PriorityQueueMaxHeap {
    public static void main(String[] args) {
        // Max-Heap using Comparator
        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());

        pq.offer(40);
        pq.offer(10);
        pq.offer(30);
        pq.offer(20);

        System.out.println("PriorityQueue (Max-Heap): " + pq);
        System.out.println("Peek (largest): " + pq.peek()); // 40

        while (!pq.isEmpty()) {
            System.out.println("Poll: " + pq.poll());
        }
    }
}

âœ… Code Example 3: PriorityQueue with Custom Objects
import java.util.*;

class Task {
    String name;
    int priority; // smaller value = higher priority

    Task(String name, int priority) {
        this.name = name;
        this.priority = priority;
    }

    @Override
    public String toString() {
        return name + " (priority " + priority + ")";
    }
}

public class PriorityQueueCustom {
    public static void main(String[] args) {
        PriorityQueue<Task> taskQueue = new PriorityQueue<>(
            Comparator.comparingInt(t -> t.priority) // custom comparator
        );

        taskQueue.add(new Task("Write report", 3));
        taskQueue.add(new Task("Fix bug", 1));
        taskQueue.add(new Task("Email client", 2));

        System.out.println("Task Queue: " + taskQueue);

        while (!taskQueue.isEmpty()) {
            System.out.println("Processing: " + taskQueue.poll());
        }
    }
}

âœ… Insights
ğŸ‘‰ PriorityQueue is not thread-safe â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ use PriorityBlockingQueue for concurrent cases.
ğŸ‘‰ Backed by a binary heap, not a balanced tree.
ğŸ‘‰ The iterator of PriorityQueue does not guarantee sorted order â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ only the head follows priority.
ğŸ‘‰ If ordering is important when iterating, use poll() repeatedly or move to a TreeSet/TreeMap.

ğŸ”· Deque (Double Ended Queue)
â¤ A linear data structure that allows insertion & deletion at both ends (front & rear).
â¤ More versatile than Queue and Stack:
    âœ”ï¸ Queue â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Insert at rear, delete at front
    âœ”ï¸ Stack â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Insert & delete at same end (LIFO)
    âœ”ï¸ Deque â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Supports both behaviors.

ğŸ”„ Implementations in Java
Interface: Deque<E> (extends Queue<E> from java.util).

ğŸŒŸ Common Implementations:
âœ”ï¸ ArrayDeque<E> â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Resizable circular array
    â¤ Fast iteration, no null allowed, better cache locality
    â¤ Preferred in most cases over LinkedList

âœ”ï¸ LinkedList<E> â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Doubly linked list
    â¤ Allows null values, higher memory usage
    â¤ Slower iteration than ArrayDeque

ğŸ”„ Methods in Deque
âš¡ Insertion
ğŸ”— addFirst(E e) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Insert at front (throws exception if fails)
ğŸ”— addLast(E e) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Insert at end (throws exception if fails)
ğŸ”— offerFirst(E e) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Insert at front (returns false if fails)
ğŸ”— offerLast(E e) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Insert at end (returns false if fails)

âš¡ Removal
ğŸ”— removeFirst() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Remove & return front (throws exception if empty)
ğŸ”— removLast() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Remove & return end (throws exception if empty)
ğŸ”— pollFirst() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Remove & return front (returns null if empty)
ğŸ”— pollLast() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Remove & return end (returns null if empty)

âš¡ Examination (Access without removal, exception if empty)
ğŸ”— getFirst() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Retrieve front element
ğŸ”— getLast() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Retrieve last element

âš¡ Peeking (Access without removal, safe)
ğŸ”— peekFirst() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Peek front element
ğŸ”— peekLast() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Peek last element

âš¡ Other Important Methods
ğŸ”— size() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Number of elements
ğŸ”— isEmpty() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Check if empty
ğŸ”— contains(Object o) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Check existence
ğŸ”— iterator() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Iterates from front â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ end
ğŸ”— descendingIterator() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Iterates from end â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ front

4. Example (Using ArrayDeque)
import java.util.*;

public class DequeExample {
    public static void main(String[] args) {
        Deque<Integer> deque1 = new ArrayDeque<>(); 

        // Insertions
        deque1.addFirst(10);    // [10]
        deque1.addLast(20);     // [10, 20]
        deque1.offerFirst(30);  // [30, 10, 20]
        deque1.offerLast(40);   // [30, 10, 20, 40]

        System.out.println(deque1);  // [30, 10, 20, 40]

        // Access elements
        System.out.println(deque1.getFirst()); // 30
        System.out.println(deque1.getLast());  // 40

        // Removals
        deque1.removeFirst();   // removes 30 â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ [10, 20, 40]
        deque1.pollLast();      // removes 40 â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ [10, 20]

        System.out.println(deque1);  // [10, 20]
    }
}

ğŸ”„ Special Usages
ğŸ‘‰ As Queue â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Only use addLast(), removeFirst()
ğŸ‘‰ As Stack â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Use push(), pop(), peek()
    â¤ Internally mapped as addFirst(), removeFirst(), peekFirst()

âœ… Example:
Deque<Integer> stack = new ArrayDeque<>();
stack.push(1);   // addFirst(1)
stack.push(2);   // addFirst(2)
System.out.println(stack.pop()); // removeFirst() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ 2

ğŸ”„ Key Differences Between Implementations
âœ”ï¸ ArrayDeque
    â¤ Backed by resizable circular array
    â¤ Doesnâ€™t allow null
    â¤ Faster than LinkedList (less memory, no node overhead)

âœ”ï¸ LinkedList
    â¤ Doubly linked list
    â¤ Allows null
    â¤ More memory overhead

ğŸ§  Traps / Notes
â¤ add/remove methods â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Throw exceptions on failure
â¤ offer/poll methods â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Return special values (false / null) instead of exception
â¤ Prefer ArrayDeque unless null values are required
â¤ Iteration order:
    âœ”ï¸ iterator() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ head â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ tail
    âœ”ï¸ descendingIterator() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ tail â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ head


ğŸ”· BlockingQueue in Java
â¤ Interface in java.util.concurrent package.
â¤ A thread-safe queue designed for concurrent programming.
â¤ Unlike normal queues:
    âœ”ï¸ Blocks when trying to add to a full queue.
    âœ”ï¸ Blocks when trying to remove from an empty queue.
â¤ Simplifies classic concurrency problems like Producerâ€“Consumer.

ğŸ”„ Implementations
ğŸ‘‰ ArrayBlockingQueue â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ bounded, circular array-backed
ğŸ‘‰ LinkedBlockingQueue â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ optional capacity (unbounded by default), linked nodes
ğŸ‘‰ PriorityBlockingQueue â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ priority-based (like PriorityQueue, but thread-safe)
ğŸ‘‰ DelayQueue, SynchronousQueue, etc. (specialized cases)

ğŸ”„ Core Methods
âš¡ Insertion
ğŸ”— put(E e) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Blocks if queue is full until space is available.
ğŸ”— offer(E e) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Immediately returns false if queue is full.
ğŸ”— offer(E e, long timeout, TimeUnit unit) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Waits up to timeout for space.

âš¡ Removal
ğŸ”— take() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Blocks if queue is empty until element is available.
ğŸ”— poll() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns null if queue is empty.
ğŸ”— poll(long timeout, TimeUnit unit) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Waits up to timeout for an element.

âš¡ Others
ğŸ”— peek() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Retrieves head without removing (null if empty).
ğŸ”— size() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns number of elements.
ğŸ”— remainingCapacity() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Available space before full.

ğŸ”„ Key Difference with Normal Queue
â¤ Normal Queue: No waiting â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ add/remove fail immediately if full/empty.
â¤ BlockingQueue: Waits (blocks) until space or element becomes available.

ğŸŒŸ Using ArrayBlockingQueue
â¤ A bounded, blocking queue backed by a circular array.
â¤ Low memory overhead.
â¤ Uses a single lock for both Enqueue and Dequeue operations.
â¤ More threads can casuse contention on the lock.

âœ… Example: 
import java.util.concurrent.*;

public class BlockingQueueExample {
    public static void main(String[] args) throws InterruptedException {
        BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(5);

        // Producer thread
        Thread producer = new Thread(() -> {
            try {
                for (int i = 1; i <= 7; i++) {
                    System.out.println("Producing: " + i);
                    queue.put(i); // Blocks if full
                    Thread.sleep(500); // simulate work
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        // Consumer thread
        Thread consumer = new Thread(() -> {
            try {
                for (int i = 1; i <= 7; i++) {
                    int item = queue.take(); // Blocks if empty
                    System.out.println("Consuming: " + item);
                    Thread.sleep(1000); // simulate work
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        producer.start();
        consumer.start();

        producer.join();
        consumer.join();
    }
}

ğŸ”¹ Sample Output (Producerâ€“Consumer)
Producing: 1
Consuming: 1
Producing: 2
Producing: 3
Consuming: 2
Producing: 4
Producing: 5
Producing: 6  // Producer blocks if queue is full
Consuming: 3  // Consumer frees space â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Producer resumes

ğŸ§  Traps & Notes
â¤ put() and take() are blocking, unlike normal queue ops.
â¤ Thread-safe: no need for manual synchronization.
â¤ Bounded queues (like ArrayBlockingQueue) prevent memory overflow.
â¤ Useful in multi-threading scenarios:
    âœ”ï¸ Producerâ€“Consumer problem
    âœ”ï¸ Task scheduling systems
    âœ”ï¸ Thread pools
    âœ”ï¸ LinkedBlockingQueue


ğŸŒŸ LinkedBlockingQueue
â¤ A thread-safe blocking queue based on a linked list.
â¤ Optionally bounded:
    âœ”ï¸ Default = unbounded (capacity = Integer.MAX_VALUE)
    âœ”ï¸ Can be bounded at creation â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ safer (prevents memory issues).
â¤ Located in java.util.concurrent package.

ğŸ”„ Characteristics
â¤ Unbounded by default â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ may cause OutOfMemoryError if producers are much faster than consumers.
â¤ Bounded form recommended â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ use constructor new LinkedBlockingQueue<>(capacity).
â¤ Backed by linked list â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ memory allocated per node.
â¤ Two separate locks:
    âœ”ï¸ One for enqueue (put/offer)
    âœ”ï¸ One for dequeue (take/poll)
    âœ”ï¸ â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Allows higher concurrency between producers and consumers.
â¤ Supports more threads compared to ArrayBlockingQueue due to reduced contention.

ğŸ”„ Core Methods (Same as BlockingQueue)

âœ…Code Example: Bounded LinkedBlockingQueue
import java.util.concurrent.*;

public class LinkedBlockingQueueExample {
    public static void main(String[] args) throws InterruptedException {
        BlockingQueue<Integer> queue = new LinkedBlockingQueue<>(3); // bounded

        Thread producer = new Thread(() -> {
            try {
                for (int i = 1; i <= 6; i++) {
                    System.out.println("Producing: " + i);
                    queue.put(i); // blocks if full
                    Thread.sleep(300);
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        Thread consumer = new Thread(() -> {
            try {
                for (int i = 1; i <= 6; i++) {
                    int item = queue.take(); // blocks if empty
                    System.out.println("Consuming: " + item);
                    Thread.sleep(800);
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        producer.start();
        consumer.start();

        producer.join();
        consumer.join();
    }
}

LinkedBlockingQueue ğŸ†š ArrayBlockingQueue
Feature                  LinkedBlockingQueue                      ArrayBlockingQueue
------------------------------------------------------------------------------------------
Capacity                 Unbounded by default / Can be bounded    Always bounded (fixed size)
Backing                  Linked list (dynamic nodes)              Circular array
Locks                    Two locks (enqueue & dequeue)            Single lock (both ops)
Concurrency              Higher (better producer-consumer)        Lower (more contention)
Throughput               Better in high-thread scenarios          Better in low contention
Memory Usage             Higher (node overhead per element)       Lower (contiguous array)
Null Allowed?            No                                       No

ğŸ§  Traps & Notes
â¤ Default is unbounded â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ may cause OutOfMemoryError. Always set capacity in real-world use.
â¤ Higher concurrency because producers and consumers donâ€™t block each other as much (separate locks).
â¤ Preferred for high producer-consumer traffic.
â¤ ArrayBlockingQueue is preferred for predictable, bounded workloads with better memory efficiency.


ğŸŒŸ PriorityBlockingQueue
â¤,A thread-safe, unbounded blocking queue that orders elements based on:
    âœ”ï¸ Natural ordering (Comparable) at head OR
    âœ”ï¸ Custom Comparator provided at construction.
â¤ Default initial capacity = 11, grows dynamically (like PriorityQueue).
â¤ Implemented using a binary heap (array-backed).

ğŸ”„ Characteristics
â¤ Unbounded â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ capacity can grow dynamically (but bounded by memory).
â¤ put() wonâ€™t block (unlike ArrayBlockingQueue or LinkedBlockingQueue) because the queue never becomes â€œfull.â€
â¤ take() will block if the queue is empty until an element is available.
â¤ Head = least element according to ordering.
â¤ Null elements not allowed.

ğŸ”„ Core Methods (same as BlockingQueue)

âœ…Code Example:
import java.util.concurrent.*;

public class PriorityBlockingQueueExample {
    public static void main(String[] args) throws InterruptedException {
        BlockingQueue<Integer> pq = new PriorityBlockingQueue<>();

        // Producer
        Thread producer = new Thread(() -> {
            try {
                int[] nums = {50, 10, 30, 20, 40};
                for (int n : nums) {
                    System.out.println("Producing: " + n);
                    pq.put(n);  // never blocks
                    Thread.sleep(300);
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        // Consumer
        Thread consumer = new Thread(() -> {
            try {
                for (int i = 0; i < 5; i++) {
                    int item = pq.take(); // retrieves in natural order
                    System.out.println("Consuming: " + item);
                    Thread.sleep(700);
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        producer.start();
        consumer.start();

        producer.join();
        consumer.join();
    }
}

âœ…Output:
Producing: 50
Producing: 10
Consuming: 10   // smallest first
Producing: 30
Producing: 20
Consuming: 20
Producing: 40
Consuming: 30
Consuming: 40
Consuming: 50

ğŸ§  Traps / Notes
â¤ Difference from other BlockingQueues:
    âœ”ï¸ put() never blocks because itâ€™s unbounded.
    âœ”ï¸ Only take() blocks when queue is empty.
â¤ Ordering:
    âœ”ï¸ Natural (via Comparable) OR custom (via Comparator).
    âœ”ï¸ No FIFO guarantee for same-priority elements.
â¤ Use cases:
    âœ”ï¸ Task scheduling (e.g., priority-based job execution).
    âœ”ï¸ Message prioritization systems.

ğŸŒŸ SynchronousQueue
â¤ A special type of BlockingQueue in java.util.concurrent.
â¤ Capacity = 0 (or conceptually 1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ it cannot hold elements.
â¤ Each put() must wait for a take() by another thread (and vice versa).
â¤ Think of it as a handoff queue between threads.

ğŸ”„ Characteristics
â¤ No element storage â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ acts as a direct handoff.
â¤ Producer and consumer must rendezvous (meet) for an element transfer.
â¤ Good for scenarios like thread pools, work handoff, or when tasks should not be queued.
â¤ Has two modes internally:
    âœ”ï¸ Fair mode (FIFO order, true constructor flag)
    âœ”ï¸ Non-fair mode (default, higher throughput, not strictly ordered)


ğŸ”„Methods Behavior
â¤ put(E e) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Blocks until another thread calls take().
â¤ take() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Blocks until another thread calls put().
â¤ offer(E e, timeout, unit) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Waits for a consumer within timeout, else fails.
â¤ poll(timeout, unit) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Waits for a producer within timeout, else returns null.
    
âœ…Code Example:
import java.util.concurrent.*;

public class SynchronousQueueExample {
    public static void main(String[] args) {
        BlockingQueue<String> queue = new SynchronousQueue<>();

        // Producer
        new Thread(() -> {
            try {
                System.out.println("Producer: trying to put A");
                queue.put("A");
                System.out.println("Producer: put A successfully");

                System.out.println("Producer: trying to put B");
                queue.put("B");
                System.out.println("Producer: put B successfully");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();

        // Consumer
        new Thread(() -> {
            try {
                Thread.sleep(1000); // Delay to show blocking
                System.out.println("Consumer: took " + queue.take());

                Thread.sleep(1000);
                System.out.println("Consumer: took " + queue.take());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
    }
}

âœ…Output:
Producer: trying to put A
(Producer blocks until Consumer takes)
Consumer: took A
Producer: put A successfully
Producer: trying to put B
(Producer blocks again)
Consumer: took B
Producer: put B successfully


ğŸ”„ Interview Traps / Notes
â¤ Unlike ArrayBlockingQueue or LinkedBlockingQueue, it does not store data.
â¤ Ensures direct synchronization between producer and consumer.
â¤ Use case:
    âœ”ï¸ Task handoff in thread pools (Executors.newCachedThreadPool() uses it internally).
    âœ”ï¸ Workflows where queueing is undesirable.
â¤ Constructor: new SynchronousQueue<>(true) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ fair mode (FIFO order).


ğŸŒŸ DelayQueue
â¤ A thread-safe, unbounded blocking queue in java.util.concurrent.
â¤ Stores elements that implement the Delayed interface.
â¤ Elements can be retrieved only when their delay has expired.
â¤ Internally backed by a priority queue (ordered by remaining delay).

Characteristics
â¤ Unbounded â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ grows dynamically (bounded by memory).
â¤ Ordering â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ element with the least remaining delay is at the head.
â¤ Blocking behavior:
    âœ”ï¸ take() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ waits until head elementâ€™s delay has expired.
    âœ”ï¸ poll() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ returns element if delay expired, else null.
â¤ Cannot contain null elements.
â¤ Useful for task scheduling, caching with timeouts, rate limiting.

ğŸ”„ Core Methods
â¤ put(E e) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Inserts element (no blocking since unbounded).
â¤ take() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Blocks until an element with expired delay is available.
â¤ poll() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns head if delay expired, else null.
â¤ peek() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns head (even if delay not expired), does not remove.

ğŸ”„ Implementing Delayed Elements
To use DelayQueue, elements must implement:
    âœ”ï¸ getDelay(TimeUnit unit) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Remaining delay.
    âœ”ï¸ compareTo(Delayed other) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Ordering (usually based on delay expiry time).

âœ…Code Example: DelayQueue with Delayed Tasks    
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;

class DelayedTask implements Delayed {
    private final long startTime;
    private final String taskName;

    public DelayedTask(String taskName, long delayMillis) {
        this.taskName = taskName;
        this.startTime = System.currentTimeMillis() + delayMillis;
    }

    @Override
    public long getDelay(TimeUnit unit) {
        long diff = startTime - System.currentTimeMillis();
        return unit.convert(diff, TimeUnit.MILLISECONDS);
    }

    @Override
    public int compareTo(Delayed other) {
        return Long.compare(this.startTime, ((DelayedTask) other).startTime);
    }

    @Override
    public String toString() {
        return taskName;
    }
}

public class DelayQueueExample {
    public static void main(String[] args) throws InterruptedException {
        DelayQueue<DelayedTask> queue = new DelayQueue<>();

        queue.put(new DelayedTask("Task-1", 2000)); // 2 sec delay
        queue.put(new DelayedTask("Task-2", 1000)); // 1 sec delay
        queue.put(new DelayedTask("Task-3", 3000)); // 3 sec delay

        for (int i = 0; i < 3; i++) {
            DelayedTask task = queue.take(); // blocks until delay expires
            System.out.println("Executed: " + task + " at " + System.currentTimeMillis());
        }
    }
}

âœ…Output:
Executed: Task-2 at 1001
Executed: Task-1 at 2002
Executed: Task-3 at 3003
(Execution order depends on delay expiry, not insertion order).


ğŸ”„ Interview Traps / Notes
â¤ Unlike PriorityBlockingQueue, an element is not available immediately â€” it must expire first.
â¤ Always unbounded â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ possible memory issues if too many delayed tasks are queued.
â¤ Common use cases:
    âœ”ï¸ Scheduling tasks after a delay.
    âœ”ï¸ Implementing retry mechanisms.
    âœ”ï¸ Session timeouts / cache eviction.

ğŸŒŸ ConcurrentLinkedQueue
â¤ A lock-free, thread-safe implementation of Queue interface.
â¤ Located in java.util.concurrent.
â¤ Based on non-blocking algorithms (uses CAS â€“ Compare-And-Swap) instead of locks.
â¤ Suitable for high-concurrency scenarios where blocking is undesirable.

ğŸ”„ Characteristics
â¤ Unbounded â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ grows dynamically (bounded by memory).
â¤ Non-blocking:
    âœ”ï¸ If empty â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ poll() returns null (does not wait).
    âœ”ï¸ If full (theoretically never, since unbounded) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ inserts always succeed.
â¤ FIFO order maintained.
â¤ Better scalability than synchronized collections (Vector, Collections.synchronizedList).
â¤ Null elements not allowed.

ğŸ”„ Core Methods
ğŸ”— add(E e) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Inserts element at tail (same as offer()).
ğŸ”— offer(E e) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Inserts element at tail.
ğŸ”— poll() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Retrieves & removes head, returns null if empty.
ğŸ”— peek() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Retrieves head without removing, returns null if empty.
ğŸ”— size() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns current size (but not constant-time, may be expensive).
ğŸ”— isEmpty() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Check if queue is empty.

âœ…Code Example:Task Submission System
import java.util.concurrent.*;

class Task implements Runnable {
    private final String taskName;

    public Task(String name) {
        this.taskName = name;
    }

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + " executing " + taskName);
    }
}

public class ConcurrentLinkedQueueExample {
    public static void main(String[] args) throws InterruptedException {
        ConcurrentLinkedQueue<Task> taskQueue = new ConcurrentLinkedQueue<>();

        // Producer threads (submitting tasks)
        Thread producer1 = new Thread(() -> {
            for (int i = 1; i <= 5; i++) {
                Task t = new Task("Task-P1-" + i);
                taskQueue.offer(t);
                System.out.println("Producer1 submitted " + t);
            }
        });

        Thread producer2 = new Thread(() -> {
            for (int i = 1; i <= 5; i++) {
                Task t = new Task("Task-P2-" + i);
                taskQueue.offer(t);
                System.out.println("Producer2 submitted " + t);
            }
        });

        // Consumer thread (executing tasks)
        Thread consumer = new Thread(() -> {
            while (true) {
                Task t = taskQueue.poll();
                if (t != null) {
                    t.run();
                } else {
                    break; // exit when no tasks left
                }
            }
        });

        producer1.start();
        producer2.start();
        producer1.join();
        producer2.join();

        consumer.start();
        consumer.join();
    }
}

âœ…Output:
Producer1 submitted Task-P1-1
Producer2 submitted Task-P2-1
Producer1 submitted Task-P1-2
Producer2 submitted Task-P2-2
Thread-2 executing Task-P1-1
Thread-2 executing Task-P2-1
Thread-2 executing Task-P1-2
Thread-2 executing Task-P2-2
...

ğŸ§  Traps & Notes
â¤ Non-blocking: no put() / take() like BlockingQueue.
â¤ CAS (Compare-And-Swap) ensures atomic updates without locks â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ high throughput.
â¤ Best for message passing systems, task submission, event queues where blocking is not needed.
â¤ size() is not constant time â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ avoid in performance-critical code.

ğŸŒŸ ConcurrentLinkedDeque
â¤ A non-blocking, thread-safe, double-ended queue (Deque).
â¤ Located in java.util.concurrent.
â¤ Backed by lock-free, linked nodes with CAS (Compare-And-Swap) operations.
â¤ Allows concurrent insertions and removals at both ends.

ğŸ”„ Characteristics
â¤ Unbounded â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ grows dynamically (limited by memory).
â¤ Non-blocking:
    âœ”ï¸ No waiting (unlike BlockingDeque).
    âœ”ï¸ If empty â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ retrieval methods return null.
â¤ Thread-safe â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ multiple producers/consumers can work simultaneously.
â¤ Maintains FIFO order when used as a queue, or LIFO order when used as a stack.
â¤ Null elements not allowed.

ğŸ”„ Core Methods (Same as Deque, but thread-safe & lock-free)
â¤ Insertion
ğŸ”—  addFirst(E e) / offerFirst(E e) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Insert at head.
ğŸ”—  addLast(E e) / offerLast(E e) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Insert at tail.

â¤ Removal
ğŸ”—  pollFirst() / removeFirst() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Retrieve & remove head.
ğŸ”—  pollLast() / removeLast() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Retrieve & remove tail.

â¤ Access (no removal)
ğŸ”—  peekFirst() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Head element, or null if empty.
ğŸ”—  peekLast() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Tail element, or null if empty.

âœ…Code Example: Concurrent Task Queue
import java.util.concurrent.*;

public class ConcurrentLinkedDequeExample {
    public static void main(String[] args) throws InterruptedException {
        ConcurrentLinkedDeque<String> deque = new ConcurrentLinkedDeque<>();

        // Producer thread adds tasks at both ends
        Thread producer = new Thread(() -> {
            for (int i = 1; i <= 5; i++) {
                deque.addLast("Task-" + i);
                System.out.println("Produced Task-" + i);
            }
        });

        // Consumer thread processes tasks from the front
        Thread consumer = new Thread(() -> {
            while (true) {
                String task = deque.pollFirst();
                if (task != null) {
                    System.out.println("Consumed " + task);
                } else {
                    break;
                }
            }
        });

        producer.start();
        producer.join();

        consumer.start();
        consumer.join();
    }
}

âœ…Output:
Produced Task-1
Produced Task-2
Produced Task-3
Produced Task-4
Produced Task-5
Consumed Task-1
Consumed Task-2
Consumed Task-3
Consumed Task-4
Consumed Task-5


ğŸ§  Traps & Notes
â¤ Difference from BlockingDeque:
    âœ”ï¸ ConcurrentLinkedDeque â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ non-blocking (returns null if empty).
    âœ”ï¸ BlockingDeque â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ blocking (take() waits if empty).
â¤ Best for highly concurrent producer-consumer systems where waiting is not required.
â¤ Often used in work-stealing algorithms (threads can take tasks from both ends).
â¤ Provides lock-free scalability for multiple threads.


ğŸ”· Enums in Java 
Enum (short for enumeration) is a special data type in Java used to represent a fixed set of named constants.

Introduced in Java 5.

Syntax:
enum EnumName {
    CONSTANT1, CONSTANT2, CONSTANT3
}

ğŸŒŸCharacteristics
â¤ Each constant in an enum is public, static, and final by default.
â¤ Enum extends java.lang.Enum internally.
â¤ Cannot extend another class because enums already extend Enum.
â¤ Can implement interfaces.
â¤ Can have fields, constructors, and methods.
â¤ Enum constants are singleton objects.

3. When to Use
1. When you have a predefined set of related constants, such as:
   â¤ Days of the week (MONDAY, TUESDAY, â€¦)
   â¤ States in a process (STARTED, IN_PROGRESS, COMPLETED)
   â¤ Severity levels (MINOR, MAJOR, CRITICAL)
2. Avoids "magic numbers" and string literals in code.

ğŸŒŸ Issues Without Enums (Your Current Code Problems)
â¤ Constants like MINOR=0, MAJOR=1 require manual mapping.
â¤ Risk of passing invalid values (e.g., 5 for severity).
â¤ Poor readability: You have to remember what 1 or 2 means.
â¤ No type safety â€” any int can be passed to methods.
â¤ Switching over raw numbers is error-prone.
â¤ Difficult to maintain â€” adding/removing constants requires editing multiple locations.

ğŸŒŸ Benefits of Using Enums
âœ… Type Safety â€” Compiler ensures only valid enum constants are used.
âœ… Readability â€” Constants have meaningful names.
âœ… No invalid values â€” Cannot pass unrelated numbers/strings.
âœ… Easy to maintain â€” Adding new constants is straightforward.
âœ… Can store data & behavior â€” Enums can have fields, constructors, and methods.

âŒ Code without Enums

public class Severity{
    final static int MINOR=0;
    final static int MAJOR=1;
    final static int CRITICAL=2;
}

public class Defect{
    public static int getDefectFixingTime( int severity){
        return switch(severity){
            case 0 -> 1;
            case 1->  3;
            case 2 -> 5;
            default -> thorw new IllegalArgumentException("Unexpected Value);
        }
    }
}

public class ReportDefect {
public static void main(String[] args) {
	int days=Defect.getDefectFixingTime(2);
	System.out.println(days);
}
}

âœ… Rewritten Using Enums
enum Severity {
    MINOR(1), MAJOR(3), CRITICAL(5);

    private final int fixingDays;

    //by default private constructor
    Severity(int fixingDays) {
        this.fixingDays = fixingDays;
    }

    //getter method
    public int getFixingDays() {
        return fixingDays;
    }
}

class Defect {

    public static int getDefectFixingTime(Severity severity) {
        return severity.getFixingDays();
    }
}

public class ReportDefect {
    public static void main(String[] args) {
        int days = Defect.getDefectFixingTime(Severity.CRITICAL);
        System.out.println(days);
    }
}

ğŸ”„How This Works
1. enum Severity:
    â¤ Represents fixed constants MINOR, MAJOR, and CRITICAL.
    â¤ Each constant stores an extra value (number of days) using a field.
    â¤ Constructor assigns this value.
    â¤ Method getFixingDays() retrieves it.

Defect class:
    â¤ Accepts only Severity type â€” prevents invalid arguments.

ReportDefect class:
    â¤ Calls method with an enum constant.
    â¤ Output for Severity.CRITICAL â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ 5.

ğŸŒŸKey Enum Features Used Here
â¤ Parameterized Enums: Storing extra information (fixingDays).
â¤ Type-Safe Method Parameters: Accepting Severity instead of int.

Built-in Enum Methods:
    â¤ values() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns all constants.
    â¤ valueOf(String name) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns constant by name.
    â¤ ordinal() â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Returns index of constant (0-based).

Example:
for (Severity s : Severity.values()) {
    System.out.println(s + " takes " + s.getFixingDays() + " days");
}

ğŸŒŸEnum Memory & Performance
â¤ Each enum constant is a singleton instance created at class load time.
â¤ Performance-friendly â€” Similar to using static final constants but safer and more maintainable.
â¤ No extra overhead for typical usage.

ğŸŒŸTips
â¤ Enums in Java are class-like, not just constants.
â¤ They are more powerful than enums in languages like C/C++.
â¤ Can override methods for individual constants.
â¤ Cannot extend other classes but can implement interfaces.
â¤ Best practice: Use enums instead of int constants for fixed sets of values.    

| Aspect             | Int Constants (final static)                                            Enums                                                                  |
| Readability        | Less clear â€” values appear as numbers, meaning must be remembered or checked in code | Very clear â€” values have meaningful names               |
| Type Safety        | None â€” any integer can be passed accidentally                       | Strong â€” only predefined enum constants can be used                      |
| Maintainability    | Difficult â€” changing values may break multiple places silently      | Easy â€” changes are localized, compiler helps catch errors                |
| Extensibility      | Limited â€” adding new constants requires careful changes everywhere  | Easy â€” just add new enum constants without affecting existing logic much |
| Error Prevention   | Low â€” invalid integers may go unnoticed until runtime               | High â€” compile-time validation prevents most mistakes                    |
| Debugging          | Hard â€” logs show numbers without context                            | Easy â€” logs show constant names directly                                 |
| Refactoring Safety | Risky â€” renaming or reordering constants may cause logical issues   | Safe â€” compiler enforces correct usage                                   |
| Performance        | Slightly better in raw speed (no object creation)                   | Negligible performance difference for most applications                  |
| Business Risk      | Higher â€” more prone to bugs due to wrong values                     | Lower â€” safer to maintain and extend                                     |
| Best Use Case      | When extreme performance or memory constraints demand               | When a fixed set of named values is needed                               |

ğŸ”—Code using Built-in methods of Enums
enum Severity {
    LOW,
    MEDIUM,
    HIGH,
    CRITICAL
}

public class EnumExample {
    public static void main(String[] args) {

        // values()
        System.out.println("All constants:");
        for (Severity s : Severity.values()) {
            System.out.println(s);
        }

        // valueOf()
        Severity sev = Severity.valueOf("HIGH");
        System.out.println("\nValueOf(\"HIGH\") = " + sev);

        // ordinal()
        System.out.println("\nOrdinal positions:");
        for (Severity s : Severity.values()) {
            System.out.println(s + " -> " + s.ordinal());
        }
    }
}

âœ…Output:
All constants:
LOW
MEDIUM
HIGH
CRITICAL

ValueOf("HIGH") = HIGH

Ordinal positions:
LOW -> 0
MEDIUM -> 1
HIGH -> 2
CRITICAL -> 3


ğŸ”¹ What is a String in Java?
A String in Java is an object that represents a sequence of characters.
Strings are immutable, meaning their value cannot be changed once created.

âœ… Ways to Create a String
â¤ Method 1: Using String Literal
String x1 = "mike";
Stored in String Pool (special area in heap memory).

Reuses memory if the same literal already exists.

â¤ Method 2: Using new Keyword
String x2 = new String("mike");
Always creates a new object in heap memory, outside the String Pool.

ğŸ§  String Pool (String Constant Pool)
A special memory region inside the heap that stores string literals.
Benefit: Saves memory by reusing existing string literals instead of creating new ones.

ğŸ” Reuse Example:
String s1 = "mike";
String s2 = "mike";
System.out.println(s1 == s2); // true (same reference in pool)

âš ï¸ When using new:
String s3 = new String("mike");
System.out.println(s1 == s3); // false (different memory locations)

âœï¸ Important:
Operations like == compare references, not values.
Use .equals() to compare values of strings.

ğŸ” Code Example: Comparing References vs Values
String x1 = "mike";
String x2 = "mike";
String x3 = new String("mike");

System.out.println(x1 == x2);        // true (same pool reference)
System.out.println(x2 == x3);        // false (heap vs pool)
System.out.println(x2.equals(x3));   // true (same content)

String str1 = new String("Ankur");
String str2 = new String("Ankur");

System.out.println(str1 == str2);    // false
System.out.println(str1.equals(str2)); // true

ğŸ’¡ intern() Method
Syntax:
String interned = new String("mike").intern();

What it does:
â¤ Checks if the value exists in the String Pool.
â¤ If yes, returns reference from the pool.
â¤ If no, adds the value to the pool and returns that reference.

â¤ Code Example:
String x1 = "mike";
String x3 = new String("mike").intern();

System.out.println(x1 == x3);       // true
System.out.println(x1.equals(x3));  // true

ğŸ“ Check if a String is Empty or Null
String str4 = null;
String str5 = "";

System.out.println(str5.length()); // 0
System.out.println(str4.length()); // âŒ NullPointerException

âš–ï¸ Difference: Null vs Empty String
| Property         | `null`                | `""` (Empty String)     |
| ---------------- | --------------------- | ----------------------- |
| Memory allocated | âŒ No                  | âœ… Yes                   |
| Object created   | âŒ No                  | âœ… Yes                   |
| `.length()`      | âŒ Throws Exception    | âœ… Returns 0             |
| Usability        | Can't call any method | Can call String methods |


ğŸ” How to Check if a String is Empty
âœ… Method 1: isEmpty()
Checks if string length is 0.
Returns: true if empty.

Code Example:
String x1 = "";
System.out.println(x1.isEmpty()); // true

âœ… Method 2: length()
You can manually check if the length is 0.
System.out.println(x1.length() == 0); // true

âœ… Method 3: isBlank()
Returns true if string is:
Empty ("") or
Contains only whitespaces (spaces, tabs, etc.)
Code Example:
String x2 = "   ";
System.out.println(x2.isBlank()); // true
ğŸ”¸ isBlank() is available from Java 11 onwards.

ğŸ§ª String Comparisons
Strings are case-sensitive by default.

âœ… Using equals() method
String str1 = "mike";
String str2 = "mike";
String str3 = "Mike";

System.out.println(str1.equals(str2)); // true
System.out.println(str1.equals(str3)); // false

âœ… Using equalsIgnoreCase() method
Ignores case differences.
System.out.println(str1.equalsIgnoreCase(str3)); // true

ğŸ“Š compareTo() Method
Compares strings lexicographically.
String str6 = "java";
String str7 = "python";

System.out.println(str6.compareTo(str7)); // -6

â¤ Output Meaning:
0 â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Both strings are equal.
< 0 â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ First string is lexicographically smaller.
> 0 â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ First string is lexicographically greater.

ğŸ”„ String Case Conversion
âœ… toUpperCase()
Converts all characters to uppercase.
"java".toUpperCase(); // "JAVA"

âœ… toLowerCase()
Converts all characters to lowercase.
"JAVa".toLowerCase(); // "java"


âœ‚ï¸ trim() Method
Removes:
Leading (front) and trailing (end) whitespaces.
Does NOT remove spaces or special characters in between the string.
String s = "   hello!@#   ";
System.out.println(s.trim()); // "hello!@#"

âŒ trim() does not remove special characters.
ğŸ”¸ lTrim() and rTrim() are not built-in in Java. You must use regex or custom code to achieve that.

ğŸ”¤ charAt(index)
Returns character at the given index.
String x1 = "aabaacv";
System.out.println(x1.charAt(2)); // 'b'

âœ… Example: Count frequency of a character
String x1 = "aabaacv";
int count = 0;

for (int i = 0; i < x1.length(); i++) {
    if (x1.charAt(i) == 'a') count++;
}
System.out.println(count); // 4

ğŸ”¹ startsWith() & endsWith() Methods
âœ… Definition:
Both methods return boolean values.

Used to check prefixes or suffixes of a string.

â¤ Syntax:
str.startsWith("prefix");  // true if string starts with "prefix"
str.endsWith("suffix");    // true if string ends with "suffix"

âœ… Code Example:
String s = "Hello World!";
System.out.println(s.startsWith("He"));     // true
System.out.println(s.endsWith("!"));        // true
System.out.println(s.endsWith("World"));    // false

ğŸ” Convert Primitive Data Type to String
âœ… Method 1: Add Empty String
int x = 10;
String y = "" + x;
System.out.println(y);                     // "10"
System.out.println(y instanceof String);   // true

âœ… Method 2: Use String.valueOf()
float z = 10.3f;
String s1 = String.valueOf(z);
System.out.println(s1); // "10.3"

boolean b = true;
String s2 = String.valueOf(b); // "true"

char ch = 'z';
String s3 = String.valueOf(ch); // "z"

System.out.println(s2); // true
System.out.println(s3); // z
System.out.println(s2 instanceof String); // true
System.out.println(s3 instanceof String); // true
ğŸ”¸ String.valueOf() works for all primitives: int, float, char, boolean, double, long, etc.

ğŸ” Search in a String
ğŸ” contains() Method
â¤ Checks whether a string contains a specific sequence of characters.
â¤ Returns: true or false
â¤ Case-sensitive

String str = "My name is Ankur Veram";
System.out.println(str.contains("name"));   // true
System.out.println(str.contains("Name"));   // false

ğŸ”¢ indexOf() Method
â¤ Returns the index of first occurrence of a substring/character.
â¤ If not found, returns -1
â¤ Case-sensitive

â¤ Syntax:
int index = str.indexOf("substring");

âœ… Code Example:
String str = "My name is Ankur Veram";

System.out.println(str.indexOf("name"));   // 3
System.out.println(str.indexOf("Name"));   // -1
System.out.println(str.indexOf(" Ankur")); // 11    

If two parameter is given then it will start the search after the index of the second parameter.
System.out.println(str.indexOf("e",8));    

ğŸ”¹ join() Method
â¤ Used to join elements of an array or any Iterable into a single string.
â¤ Requires a delimiter to separate the elements.

Syntax:
String result = String.join(delimiter, elements...);

âœ… Example:
String[] words = {"Hello", "World", "Java", "Programming"};
String result = String.join(" ", words);
System.out.println(result); // Output: Hello World Java Programming
ğŸ”¸ join() is available from Java 8 onwards.

ğŸ” replace() Method
â¤ Used to replace characters or substrings within a string.
â¤ Returns a new string with replacements applied (original string remains unchanged).

âœ… Method 1: Replace Substring
String s = "Hello World with new Word";
String str = s.replace("Word", "Duniya");
System.out.println(str); // Output: Hello World with new Duniya

âœ… Method 2: Replace Character
String str2 = s.replace('o', '*');
System.out.println(str2); // Output: Hell* W*rld with new W*rd

ğŸ”— Ways of String Concatenation
âœ… Way 1: Using + Operator
String s1 = "Hello";
String s2 = "World";
String result = s1 + " " + s2;
System.out.println(result); // Hello World

âœ… Way 2: Using concat() Method
String result = s1.concat(s2); // HelloWorld

â• Add whitespace between
String result = s1.concat(" ").concat(s2); // Hello World
What is Mutable and Immutable class

ğŸ§  Mutable vs Immutable Classes
| Property        | Immutable Class                             | Mutable Class                             |
| --------------- | ------------------------------------------- | ----------------------------------------- |
| Definition      | Object **cannot be changed** after creation | Object **can be modified** after creation |
| Example         | `String`                                    | `StringBuilder`, `StringBuffer`           |
| Thread-safe?    | Yes (`String`)                              | Only `StringBuffer` is thread-safe        |
| Performance     | Slower (new object on change)               | Faster for frequent modifications         |
| Common Use Case | Constant values, keys in Map                | Dynamic strings in loops or editors       |


ğŸ”· StringBuilder and StringBuffer
| Feature                 | **StringBuilder**                             | **StringBuffer**                       |
| ----------------------- | --------------------------------------------- | -------------------------------------- |
| **Mutability**          | Mutable                                       | Mutable                                |
| **Thread Safety**       | âŒ Not thread-safe                            | âœ”ï¸ Thread-safe (synchronized)         |
| **Performance**         | Faster                                        | Slower (sync overhead)                 |
| **Use Case**            | Single-thread environment                     | Multi-thread environment               |
| **Synchronization**     | No                                            | Yes (all methods synchronized)         |
| **Introduced In**       | Java 5 (JDK 1.5)                              | Java 1.0                               |
| **Default Capacity**    | 16 chars                                      | 16 chars                               |
| **Expansion Mechanism** | `(oldCapacity * 2) + 2`                       | Same                                   |
| **Efficiency in Loops** | More efficient                                | Less efficient due to locking          |
| **toString() Behavior** | Returns string of internal buffer             | Same                                   |
| **Suitable For**        | Heavy modifications in single-thread programs | Modifications in multi-thread programs |


âœ… Code Example Showing StringBuilder Functioning (Fast, Non-Synchronized)
public class StringBuilderDemo {
    public static void main(String[] args) {
        StringBuilder sb = new StringBuilder("Hello");

        sb.append(" World");
        sb.insert(5, ",");
        sb.delete(0, 1);
        sb.reverse();

        System.out.println("Final Output Using StringBuilder: " + sb);
    }
}
â¤ No locking/synchronization â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ fastest performance.
â¤ Used where only one thread modifies the data.

âœ… Code Example Showing StringBuffer Functioning (Thread-Safe via Synchronization)
public class StringBufferDemo {
    public static void main(String[] args) {
        StringBuffer sbf = new StringBuffer("Hello");

        sbf.append(" World");
        sbf.insert(5, ",");
        sbf.delete(0, 1);
        sbf.reverse();

        System.out.println("Final Output Using StringBuffer: " + sbf);
    }
}
â¤ Same methods as StringBuilder.
â¤ Each method is synchronized, making operations thread-safe but slower.

âœ… Multi-threading Example to Show the Real Difference
âœ”ï¸ StringBuilder (Not Safe)
public class BuilderThreadDemo {
    static StringBuilder sb = new StringBuilder();

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) sb.append("A");
        });

        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) sb.append("B");
        });

        t1.start();
        t2.start();
        t1.join();
        t2.join();

        System.out.println("StringBuilder length = " + sb.length());
        System.out.println("Output (Corrupted): " + sb);
    }
}
âœ…Output:
Output may be corrupted or inconsistent.
Race conditions occur because both threads modify the same object without sync.

âœ”ï¸ StringBuffer (Safe Output)
public class BufferThreadDemo {
    static StringBuffer sbf = new StringBuffer();

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) sbf.append("A");
        });

        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) sbf.append("B");
        });

        t1.start();
        t2.start();
        t1.join();
        t2.join();

        System.out.println("StringBuffer length = " + sbf.length());
        System.out.println("Output (Non-corrupted): " + sbf);
    }
}
âœ…Output:
â¤ Always consistent because methods are synchronized.
â¤ State remains safe even when both threads modify simultaneously.


âœ‚ï¸ substring() Method in Java
The substring() method is used to extract a part of the string.

âœ… Syntax Variants:
substring(int start)
Returns substring from start (inclusive) to the end of the string.
String s = "JavaProgramming";
System.out.println(s.substring(4)); // Output: Programming

substring(int start, int end)
Returns substring from start (inclusive) to end (exclusive).
System.out.println(s.substring(0, 4)); // Output: Java

ğŸ§  Remember:
Index starts from 0.
end index is excluded.
Throws StringIndexOutOfBoundsException if indices are invalid.

ğŸ”¹ Method 1: Using \n Escape Character
You can insert line breaks using the newline character \n.
String x = "Hi my name is\nAnkur\nVerma";
System.out.println(x);

âš ï¸ Limitation:
â¤ Becomes tedious and less readable when writing large multi-line strings.
â¤ Manual escaping needed for quotes, line breaks, and indentation.

ğŸ”¹ Method 2: Using Text Blocks (""")
âœ… Introduced in Java 13 (preview), Java 15+ (standard).

Multiline string literal that maintains formatting and is easy to write.
String x2 = """
            Hi 
            My 
            Name 
            is 
            Ankur Verma
            """;
System.out.println(x2);
âœ… Benefits of Text Blocks:
â¤ Easy to write and maintain multiline text (like JSON, SQL, XML, HTML).
â¤ Preserves formatting and indentation.
â¤ No need to use \n for new lines.
â¤ Avoids escaping double quotes in many cases.
