################
ğŸ”· OOP in Java
################
Object-Oriented Programming (OOP) is a programming paradigm that organizes code using objects, which are instances of classes.
Java is a pure object-oriented language (except for primitive types). To overcome the lack of object orientation in primitives, Java provides Wrapper Classes.
Properties (State) â€“ Data/attributes
Methods (Behavior) â€“ Functions/actions


######################
ğŸ”· Features of Java
######################
1ï¸âƒ£ Object-Oriented
â¤ Everything is modeled as objects with clear abstraction.
â¤ Key OOP principles supported: Abstraction, Encapsulation, Inheritance, Polymorphism.

2ï¸âƒ£ Platform Independent
â¤ Java code â†’ compiled to bytecode â†’ runs on JVM, not on OS.
â¤ â€œWrite Once, Run Anywhere (WORA)â€ using JVM architecture.

3ï¸âƒ£ Secure
â¤ No explicit pointers â†’ prevents memory corruption.
â¤ Bytecode verification, sandboxing, and Security Manager protect against malicious code.
â¤ Strong support for cryptography, secure classloading, JVM-level security.


#######################
ğŸ”· Sandboxing in Java
#######################
Sandboxing is a Java security mechanism that restricts the actions of untrusted code by running it in a controlled environment called a sandbox.
This ensures that code downloaded from the internet (like applets in earlier Java days) cannot harm the host system.

â“ How Sandboxing Works
When Java loads untrusted code:
1ï¸âƒ£ Bytecode Verifier
â¤ Checks code for illegal operations (buffer overflow, stack corruption etc.)

2ï¸âƒ£ Class Loader
â¤ Separates system classes from untrusted classes
â¤ Prevents unauthorized access to internal APIs

3ï¸âƒ£ Security Manager
â¤ Controls what the code is allowed to do
âœ… Example: block file access, network access, system commands

ğŸš« Restrictions in Sandbox
Untrusted Java code cannot:
	âœ”ï¸ Read/Write local files
	âœ”ï¸ Access sensitive OS resources
	âœ”ï¸ Open socket connections to unauthorized locations
	âœ”ï¸ Execute system commands (Runtime.exec)
	âœ”ï¸ Modify environment variables
Basically, it locks the code inside a safe virtual room ğŸ§±.


4ï¸âƒ£ Multithreaded
â¤ Built-in support for creating and managing threads.
â¤ Provides high-level APIs:
	âœ”ï¸ Thread class, Runnable interface
	âœ”ï¸ Executors framework
	âœ”ï¸ Concurrent API (java.util.concurrent)

5ï¸âƒ£ High Performance
â¤ Bytecode runs faster than traditional interpreted languages.
â¤ JIT (Just-In-Time) Compiler optimizes bytecode to machine code at runtime.
â¤ JVM uses adaptive optimizations and advanced garbage collectors.

6ï¸âƒ£ Dynamic
â¤ Java can dynamically load classes at runtime (class loaders).
â¤ Reflection API allows runtime inspection and modification of classes.
â¤ JVM supports dynamic linking of class libraries.

7ï¸âƒ£ Automatic Memory Management (Garbage Collection)
â¤ JVM automatically allocates and releases memory.
â¤ Developers donâ€™t need to manually free memory (unlike C/C++).

ğŸ”· Key Goals of OOPs:
â¤ Code reusability
â¤ Modularity
â¤ Data hiding and security
â¤ Scalability and maintainability


########################################
ğŸ”· Medical Shop Example to Explain OOP
########################################
ğŸ§± Class: A class is like a blueprint or design.

âœ… Example:
â¤ Think of a medicine form in a medical shop that says:
	âœ”ï¸ Medicine Name
	âœ”ï¸ Company Name
	âœ”ï¸ Price
	âœ”ï¸ Expiry Date
â¤ This form isnâ€™t a real medicine â€“ it's just a template/design.
â¡ In OOP, a class defines what details an object will have.


ğŸ’Š Object: An object is a real-world thing created from the class blueprint.

âœ… Example:
â¤ Actual medicines in the shop:
	âœ”ï¸ Paracetamol â€“ â‚¹25, Expiry: Dec 2025
	âœ”ï¸ Crocin â€“ â‚¹30, Expiry: Jan 2026
	âœ”ï¸ These are real medicines, so they are objects of the medicine class.
â¡ Many objects can be made from one class.

ğŸŒŸ 4 Pillars of OOP
Letâ€™s understand them using the same medical shop example:

1ï¸âƒ£ Encapsulation â€” Medicine bottle with a sealed cover
â¤ All ingredients of a medicine are sealed inside the bottle.
âœ”ï¸ You can use the tabletâ€¦
âœ”ï¸ â€¦but cannot change its chemical formula.

â¡ Keeping internal details safe and allowing access only in the right way.
â¤ Real-world: Medicine bottle protects what's inside.
â¤ In code: Data is kept safe inside the class.


2ï¸âƒ£ Abstraction â€” What you need to know only
When you buy medicine:
	âœ”ï¸ You donâ€™t need to know how it's made in the factory
	âœ”ï¸ You only need to see name, dose, expiry, etc.

â¡ Showing only the important things, hiding the complex stuff
â¤ Real-world: We see the label, not the manufacturing chemistry.
â¤ In code: Only useful functions/data are shown to the user.


3ï¸âƒ£ Inheritance â€” Generic â†’ Specific Medicines
Suppose there is a general class Medicine
	âœ”ï¸ Name
	âœ”ï¸ Price
	âœ”ï¸ Expiry

Now, special medicines can inherit from it:
	âœ”ï¸ Tablet (extra: number of tablets)
	âœ”ï¸ Syrup (extra: volume)
	âœ”ï¸ Injection (extra: needle size)

â¡ Child items inherit features from parent.
â¤ Real-world: All are medicines but types differ.
â¤ In code: One class shares its properties with other classes.

4ï¸âƒ£ Polymorphism â€” Same name, different behavior
At different times and for different people:
	âœ”ï¸ Paracetamol treats fever
	âœ”ï¸ Same paracetamol can reduce pain
	âœ”ï¸ Same paracetamol can help cold symptoms
â¡ One thing behaving differently based on the situation.
â¤ Real-world: Same medicine â€” different uses.
â¤ In code: Same functionâ€”different implementations.


######################
ğŸ”· JDK, JRE, and JVM
######################
1ï¸âƒ£ JVM (Java Virtual Machine)
â¤ JVM is an abstract machine that provides a runtime environment to execute Java bytecode.

âš¡Responsibilities:
âœ”ï¸ Converts bytecode â†’ machine code using JIT (Just-In-Time compiler).
âœ”ï¸ Provides platform independence (â€œWrite Once, Run Anywhereâ€).
âœ”ï¸ Manages memory (heap, stack, method area, GC).
âœ”ï¸ Ensures security via bytecode verification.
ğŸ”§ Key Point: JVM is platform-dependent (different implementations for Windows/Linux/Mac), but bytecode is platform-independent.

â¡ï¸ Insight:
Many confuse JVM = Java compiler â†’ Wrong! Compiler (javac) converts Java code â†’ bytecode; JVM executes that bytecode.

ğŸ”· Java Compilation and Execution Process
ğŸ”— Compile Time
â¤ This is the phase where source code is checked and translated into bytecode.
â¤ Java source files (.java) are compiled by the Java Compiler (javac).
â¤ The compiler checks for syntax errors and converts the code into bytecode (platform-independent code).

[Source Code (.java file)]
             |
             v
[JDK - javac Compiler]
   (Compiles to Bytecode)
             |
             v
[.class File (Bytecode)]
             |
             v
[JVM Class Loader]
   (Loads class into memory)
             |
             v
[Bytecode Verifier]
   (Validates bytecode)
             |
             v
[Execution by JVM]
     /           \
    v             v
[Interpreter]   [JIT Compiler]
 (line-by-line)   (compiles hot code to native)
             |
             v
[Native Machine Code]
             |
             v
[CPU Executes Code â†’ Output]

The JVM uses both an interpreter and a JIT (Just-In-Time) compiler because itâ€™s designed to balance fast startup with high runtime performance.

1ï¸âƒ£ Roles of Each
Interpreter
â¤ Reads bytecode line by line and executes it directly.
â¤ Advantage: Immediate execution â†’ fast startup.
â¤ Disadvantage: Slower in the long run because every instruction has to be interpreted again and again.

JIT Compiler
â¤ Detects â€œhot codeâ€ (frequently executed methods/loops).
â¤ Translates those bytecode parts into native machine code.
â¤ Advantage: Native code runs much faster (close to C/C++ speeds).
â¤ Disadvantage: Compilation takes time and memory.

2ï¸âƒ£ Why JVM Combines Them
If the JVM only used:
â¤ Interpreter only â†’ Quick startup but poor long-term performance.
â¤ JIT only â†’ Very slow startup (needs to compile everything first).

By combining:
â¤ Start with the interpreter â†’ get the program running instantly.
â¤ Monitor execution â†’ detect methods/loops used often.
â¤ Switch to JIT for those hot parts â†’ gain native-speed execution.

This is called adaptive optimization.

3ï¸âƒ£ Real-Life Analogy
â¤ Interpreter = You read a speech word-by-word from paper â†’ you can start immediately, but itâ€™s slow if you have to repeat it.
â¤ JIT = You memorize the speech (compile to native) â†’ takes time initially, but then you can say it much faster.
â¤ JVM = First read it from the paper, and for parts you repeat often, memorize them.

4ï¸âƒ£ Execution Flow in JVM
â¤ Bytecode Verifier checks safety.
â¤ Interpreter starts running bytecode.
â¤ JVM profiling detects â€œhotâ€ methods.
â¤ JIT compiles those into native code.
â¤ Native code replaces the interpreted version for future calls.

Command: javac MyProgram.java
Result: Creates MyProgram.class file.

ğŸ”— Run Time
â¤ This is the phase where the compiled bytecode is executed by the Java Virtual Machine (JVM).
â¤ The JVM loads the .class file and executes the bytecode.
â¤ Any exceptions or logical errors may occur during this phase.

Command: java MyProgram
Result: Runs the program using the bytecode inside MyProgram.class.

âœ… What Makes Java Platform Independent?
Java is platform-independent because of its "Write Once, Run Anywhere" capability.
This is mainly due to:
ğŸ”‘ 1. Bytecode
When you compile a Java program (.java file), the Java compiler (javac) doesn't generate platform-specific machine code.
It generates bytecode (.class file) â€” an intermediate, platform-neutral code.

// You write this
HelloWorld.java
â†“
// Compiled by javac to
HelloWorld.class (bytecode)


2ï¸âƒ£ JRE (Java Runtime Environment)
â¤ JRE provides libraries, JVM, and other components to run Java applications.

Includes:
âœ”ï¸ JVM
âœ”ï¸ Core libraries (like java.lang, java.util, java.io)
âœ”ï¸ Supporting files
ğŸ”§ Key Point: JRE does not include development tools (compiler, debugger). Itâ€™s only for running Java programs.

â¡ï¸ Trap:
If asked, â€œCan you run Java code with just JRE?â€ â†’ Yes, if you already have compiled bytecode. But you cannot compile .java files with JRE.


3ï¸âƒ£ JDK (Java Development Kit)
â¤ JDK is the full package required for Java development.

Includes:
âœ”ï¸ JRE (which has JVM + libraries)
âœ”ï¸ Development tools â†’ javac (compiler), jdb (debugger), javadoc, jar, etc.
ğŸ”§ Key Point: JDK is for developers; JRE is for users.

â¡ï¸ Trap:
Some interviewers ask: â€œIf JDK contains JRE, and JRE contains JVM, can we say JDK = JVM?â€
Answer: No. JDK = JRE + Development Tools. JVM is just part of JRE.


ğŸ”„ Hierarchy Diagram
JDK 
 â””â”€â”€ JRE 
      â””â”€â”€ JVM

ğŸ”„ One-Liner for Revision
â¤ JVM â†’ Runs bytecode.
â¤ JRE â†’ JVM + Libraries (to run Java apps).
â¤ JDK â†’ JRE + Tools (to develop Java apps).


###########
ğŸ”· Class
###########
â¤ A class in Java is a blueprint or template for creating objects.
â¤ It defines the data (fields/attributes) and the behavior (methods/functions) that the objects created from the class will have.
â¤ Class helps us to create objects in Java.

ğŸ§ª Class Naming Convention
â¤ In Java, we use the class keyword to create a class, and the class keyword should be in lowercase. The class name should start with an uppercase letter only.
â¤ If more than one word is used, then we should use camel casing.

Note: Class names cannot start with a number, but they can begin with a dollar sign ($) or an underscore (_), although this is not recommended.

âœ… Example :
class A {}
â¤ We define the boundary of a class using curly brackets.
  
âœ… Example :
â¤ Will execute without any error
public class Bank_Account_Number {}// Snake Casing-->Should not use for Java

Note:
1. Do not use specials characters like #,@ % & etc while creating class.
2. $Class name will execute. However, never create a class with a special character.


######################
ğŸ”· Breakdown of PSVM
######################
public static void main(String[] args)
Itâ€™s the starting point of any Java program, and each keyword has a specific purpose.
1ï¸âƒ£ public
â¤ It's an access modifier.
â¤ Makes the main method accessible by the JVM from outside the class.
â¤ If you make it private, JVM wonâ€™t be able to access it, and the program wonâ€™t run.

2ï¸âƒ£ static
â¤ Means it belongs to the class, not the object.
â¤ JVM doesnâ€™t create an object of the class to call main() â€” it just calls it via the class name directly.
â¤ Thatâ€™s why it must be static.

3ï¸âƒ£ void
â¤ Specifies that the method does not return any value.
â¤ You canâ€™t return anything from main() in standard Java execution.

4ï¸âƒ£ main
â¤ This is the method name.
â¤ JVM looks specifically for a method with this name as the entry point to start program execution.

5ï¸âƒ£ String[] args
â¤ Represents command-line arguments.
â¤ It is an array of Strings, which means you can pass values when running the program:

java MyProgram Hello World
Then args[0] = "Hello", args[1] = "World"  


â“ Why Use Command-Line Arguments? (Use Cases)
â¤ Dynamic input without Scanner or BufferedReader
â¤ Script automation (e.g., batch processing, config values)
â¤ File input/output paths
â¤ Running test cases with different inputs
â¤ Avoid hardcoding data into programs

âœ… Example: Add two numbers using command-line arguments
public class CommandLineCalculator {
    public static void main(String[] args) {
        if(args.length < 2) {
            System.out.println("Please provide two numbers.");
            return;
        }

        // Convert strings to integers
        int num1 = Integer.parseInt(args[0]);
        int num2 = Integer.parseInt(args[1]);

        int sum = num1 + num2;
        System.out.println("Sum = " + sum);
    }
}

ğŸ”· How to Run This Program?
Step 1ï¸âƒ£: Compile
javac CommandLineCalculator.java

Step 2ï¸âƒ£: Run with arguments
java CommandLineCalculator 10 20

Output:
Sum = 30

ğŸš« Trap 
Can we pass primitive values as command-line arguments?
No, command-line arguments are always String types. You need to manually parse them using Integer.parseInt(), Double.parseDouble(), etc.

ğŸ” JVM Looks for This Exact Signature:
public static void main(String[] args)
âš ï¸ If the signature is different (e.g., not public, not static, or missing parameters), the program will compile but not run, and youâ€™ll get a "Main method not found" error.


################
ğŸ”· new keyword
################
â¤ The new keyword in Java is used to create objects (instances) of a class. 
â¤ Using the new keyword, we send a request to the class to create an object
â¤ Once the object is created, the new keyword will retrieve the object's address and store it in a reference variable.

Syntax to create an object:
ClassName variableName = new ClassName();

âš¡ Two types of camel casing:
â¤ UpperCase Camel Casing: Used for naming class, interface, abstract class, etc
â¤ lowerCase Camel Casing: Used for creating methods, variables, etc


#############################################################
ğŸ”· Non-static Variable/ Instance Variable /Object Variables
#############################################################
It is a variable declared inside a class, but outside any method, and without the static keyword.
ğŸ“Œ It belongs to:
â¤ An instance of the class (not the class itself)
â¤ Every object has its copy
â¤ Without creating an object, we cannot access non-static variables.

âœ… Example :
public class A {
	int x = 10;
	int y = 20;
 	int z;
	public static void main(String[] args) {
		A a1 = new A();
		System.out.println(a1.x); // Output :10
		System.out.println(a1.y); // Output :20

    		A a2 = new A();
		System.out.println(a2.x); // Output :10
    		System.out.println(a2.z); // Output :0 //default value of int is 0
	}
}
â¤ Every time we create an object non-static variable copy is loaded into that object.
â¤ A copy of the variable in this object is different. That is, if you change the value of a variable in one object, those changes cannot be seen in another object.
â¤ It is not mandatory to initialize a non-static variable. Depending on the data type, the default value will be automatically stored in it.


#####################
ğŸ”· Static variables
#####################
A static variable is a class-level variable.
â¤ It belongs to the class, not the object.
â¤ It is shared among all instances of the class.
â¤ Only one copy exists in memory, regardless of how many objects are created.
â¤ If you donâ€™t initialize a static variable, Java automatically assigns a default value based on its data type.
â¤ We should create static variables inside a class but outside a method with the static keyword

ğŸ”„ To access a static variable, we will use the following options:
1ï¸âƒ£ ClassName.variableName
public class Main {
    static int x = 10;
    public static void main(String[] args) {
        System.out.println(Main.x);  // âœ… Recommended Output: 10
    }
}

2ï¸âƒ£ Accessing via variableName directly (With Constraints)
class A {
    static int x = 10;
    void show() {
        System.out.println(x); 
    }
}
You can directly use x without the class name only when:
â¤ You're inside the same class where the static variable is declared.
â¤ Or the static variable is imported statically (in some special cases).

This is allowed because the compiler understands the scope.

â— Constraints:
â¤ This only works within the same class unless,
â¤ You use import static (less common).

âœ… Example Without import static:
public class MyClass {
    public static int count = 42;
}

public class Test {
    public static void main(String[] args) {
        System.out.println(MyClass.count); // ğŸ‘ˆ Must use class name
    }
}

âœ… Example with import static:
import static java.lang.Math.*;

public class Demo {
    public static void main(String[] args) {
        System.out.println(sqrt(16)); // instead of Math.sqrt(16)
        System.out.println(PI);       // instead of Math.PI
    }
}
Outside the class, you need to use either:
â¤ ClassName.x (best), or
â¤ object.x (works but discouraged).


3ï¸âƒ£ objectAddress.variableName (Wrong Approach, but will work)
â¤ This works because the object refers to the class, and the static variable belongs to the class.
â¤ When you do a1.x, Java still resolves it as A.x internally.
â¤ But it's misleading because it looks like x is instance-specific when it's shared across all instances.

ğŸ” Bonus Tip:
A a1 = null;
System.out.println(a1.x); // Still works!

âœ…Example:
public class A {
	static int x=10 ;
	public static void main(String[] args) {
		System.out.println(A.x);// Output :10
		System.out.println(x);// Output :10
    
		//Wrong
		A a1 = new A();
		System.out.println(a1.x);//A.x, but will give the Output:10
                A.x = 30;
		System.out.println(A.x); //Ouput :30 
  }
}


ğŸ”· Types of variables in Java
1ï¸âƒ£ Local Variable
â¤ Local variables should be created inside methods
â¤ We should use local variables within the created method only
â¤ Without initialization, if you are using a local variable, you will get an error.
  
âœ…Example:
public class A {
	static int y=10;
	public static void main(String[] args) {
		int x = 100;
		System.out.println(x);
    		System.out.println(A.y);// Output :10
		A a1 = new A();
         	a1.test();
    		System.out.println(y);//Output: 10
	}
	public void test() {
        int z=100;
	System.out.println(x);	//âŒ Error because it is not present in this method
        System.out.println(z); //âœ… Correct
        System.out.println(A.y);	//âœ… Correct because y is a static variable
	}
}

âœ… Trap Question based on Local Variable
public class Test {
    public static void main(String[] args) {
        int x = 100;
        {
            int x = 200;
            System.out.println(x);
        }
    }
}
â¤ The code will give a compile-time error, but not because of creating a new scope â€” that is allowed in Java.
The actual issue is:
â¤ You are declaring two local variables with the same name, x, in overlapping scopes.
â¤ Even though you're trying to redeclare int x = 200; in an inner block, Java does not allow hiding a local variable in an inner block with the same name.
ğŸ‘‰ Also each method has its stack frame, and local variables are stored there, so naming conflicts like this are not allowed even in nested blocks.


2ï¸âƒ£ Static variable
â¤ Itâ€™s not mandatory to initialize the static variable.
â¤ If you donâ€™t initialize, Java provides default values:
	âœ”ï¸ 0 â†’ numeric types (int, long, double, etc.)
	âœ”ï¸ false â†’ boolean
	âœ”ï¸ null â†’ reference types


ğŸ”„ Storage of Stack Variables
â¤ In Java, memory is divided into different areas managed by the JVM (Java Virtual Machine):
â¤ Heap â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ For objects.
â¤ Stack â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ For local variables and method calls.
â¤ Method Area / Metaspace (Java 8+) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ For class-level data like:
	âœ”ï¸ Class metadata (name, methods, fields)
	âœ”ï¸ Static variables
	âœ”ï¸ Constant pool
â¤ PC Register â†’ Keeps track of execution in threads.
â¤ Native Method Stack â†’ For native (C/C++) calls.


3ï¸âƒ£ Non-static variable/instance variable
4ï¸âƒ£ Reference Variable
A reference variable in Java is a variable that stores the memory address(reference) of an object, not the actual object itself.
a. Can hold either an Object address or a null value.
b. The datatype of the reference variable is the class.

In the example below, "a1" is created inside main, hence it is a local variable. We cannot access that outside the main method
âš¡ If we do not initialize a static reference variable, then by default null value will be stored in it.
âœ… Example:
public class A {
	static A a4;  â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ null
	public static void main(String[] args) {
		A a1 = null;
		A a2 = new A();
    	A a3; â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Reference Local Variable
    	System.out.println(a3); â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Error because "a3" is local variable and not initialized
	}
  	public void test() {
		System.out.println(a1); â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Error
	}
}


ğŸ§± Stack Memory â€“ LIFO (Last In First Out)
â¤ Stores:
	âœ”ï¸ Method calls,
	âœ”ï¸ local variables,
	âœ”ï¸ reference variables (not actual objects).
â¤ Memory is automatically managed (pushed and popped as methods are called or returned).
â¤ Operates in LIFO (Last-In, First-Out) order, where the last is the first one to return.
â¤ Faster but limited in size.

âœ… Example:
When a method is called, its variables go on the stack. When it returns, theyâ€™re removed.


################
ğŸŒŠ Heap Memory
################
â¤ Used to store objects/instance variables.
â¤ Every time you do new ClassName(), it creates an object in the heap.
â¤ Objects stay in memory until they're no longer referenced.

âš¡ Note: All reference variables (in the stack) point to objects in the heap.


###############################
ğŸŒŠ Garbage Collection in Java
###############################
â¤ Garbage Collection is a process by which the Java Virtual Machine (JVM) automatically removes unused objects (objects that are no longer reachable) from memory to free up space and avoid memory leaks.
â¤ Java developers donâ€™t manually free memory (unlike in C/C++). Instead, the Garbage Collector (GC) handles it.

ğŸ§© Key Goals of GC:
â¤ Reclaim memory used by unreachable objects
â¤ Prevent memory leaks
â¤ Keep the heap memory clean and efficient

ğŸ”„ When Does GC Run?
â¤ GC runs automatically in the background.
â¤ It is non-deterministic â€” you can't predict exactly when it will run.
â¤ You can suggest GC using System.gc(), but the JVM may ignore it.
â¤ Only Heap memory is subject to GC.


ğŸ”· Object Lifecycle in Java
1ï¸âƒ£ The object is created using new
2ï¸âƒ£ The reference variable holds the object
3ï¸âƒ£ Once the reference is lost or goes out of scope, the object becomes unreachable
4ï¸âƒ£ The JVM marks it as garbage
5ï¸âƒ£ GC reclaims that memory


####################
ğŸ”· Methods in Java
####################
void keyword: A void method cannot return any value

âœ… Example :
public class C {
	public static void main(String[] args) {
		C c1 = new C();
		int x = c1.test1(); â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Error
    		int y= c1.test2();
		System.out.println(y); â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Output :100
	}
	public void test1() {
		return 100;//Error
 	 }
	public int test2() {
		return 100;
  	}
}


ğŸ”„ Return without value vs Return value in Java
The difference between return and return value lies in what you're returning and why.

return without value keyword:
â¤ A method has to be void
â¤ It is optional
â¤ It will return control to the method calling statement

Note: If we write code after the return keyword, then that code will 100% not run. This error is called an unreachable code error

âœ… Example:
public class C {
	public static void main(String[] args) {
	  C c1 = new C();
	  c1.test();
	}	
	public void test() {
	      System.out.println(100);
	      return;
	      System.out.println(200);
	}
}
âœ… Output: unreachable code error


ğŸ”„ Returning "value"
â¤ The method has to be non-void.
â¤ It is mandatory to use a return "value" statement inside a non-void method
â¤ It will return control and value to the method calling statement

public class C {
	public static void main(String[] args) {}
	public int test1() {} â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Error
  	public int test2() {
		return 100; 
		System.out.println(300); â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Unreachable code error
	}
}

ğŸ”„ Method Arguments
â¤ Using method arguments, we supply values to the method when we call it
â¤ The method argument is a local variable
â¤ Arguments inside the method values that you supply to the method should match

âœ… Example:
public class C {
	public static void main(String[] args) {
	 C c1 = new C();
     C c2 = new C();
	 c1.test1(100);
     c2.test2(100,"mike");
	}
	public void test1(int x) {
	  System.out.println(x);
	}
  public void test2(int x,String y) {
	  System.out.println(x);
	}
}
ğŸ‘‰ Note: When the method argument type is Object, then we can supply any value to it.

âœ… Example
public class C {
	public static void main(String[] args) {
	  C c1 = new C();
	  c1.test('a');
	}
	public void test(Object x) {
	   System.out.println(x);
	}
}

ğŸ”„ Using Varargs (Variable Arguments)
âœ… Example:
public class C {
	public static void main(String[] args) {
	  C c1 = new C();
	  c1.test("mike",100,200,300);
	}
	public void test(String y,int... x) { 
		System.out.println(x[0]);// Output :100
		System.out.println(x[1]);// Output :200
		System.out.println(x[2]);// Output :300
		System.out.println(y);// Output :mike
	}
}

ğŸ”„ Static Methods in Java
â¤ A static method belongs to the class, not to instances (objects) of the class.
â¤ This means you can call a static method without creating an object of that class.
âœ… Example:
public class C {
	public static void main(String[] args) {
	    C.test1();// Output :599
    	int x =  C.test2();
	    System.out.println(x);// Output :100  
	}
	public static void test1() {
		System.out.println(599);
	}
 	public static int test2() {
		return 100;
	}
}  

###################
ğŸ”· Java Data Types 
###################
Java data types are divided into 2 main categories:

1ï¸âƒ£ Primitive Data Types (8 types)
Built-in, fixed-size types that store actual values directly.

ğŸ”¸ Integer Types (for whole numbers)
Type	       Size     	  Default Value	      		Range
byte	       1 byte	            0	              -128 to 127
short	       2 bytes	   	        0	              -32,768 to 32,767
int	       	   4 bytes	            0	              -2,147,483,648 to 2,147,483,647
long           8 bytes	            0	              -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807

ğŸ”¸ Floating Point Types (for decimals)
Type	    Size	      Default Value	        Range
float	    4 bytes	      0.0f	              Â±3.40282347E+38F (single-precision)
double	    8 bytes	      0.0d	              Â±1.79769313486231570E+308 (double-precision)

ğŸ”„ Find the size of the datatype
âœ… Example:
public class Main {
    public static void main(String[] args) {
        System.out.println("Size of int in bytes: " + Integer.BYTES);//4 INTEGER is a wrapper class of int (discussed later)
        System.out.println("Size of int in bits: " + Integer.SIZE);//32
    }
}

ğŸ”¸ Other Primitive Types
Type	    Size	            Default Value	          Description
boolean	    (JVM dependent)	    false                   Only true or false
char	    2 bytes	            ' ' (blank)	            0 to 65,535 (Unicode characters)


2ï¸âƒ£ Non-Primitive / Reference Data Types
Type	               Description	                        Default Value
String	        A class (sequence of characters)	          null
Array	        Object that holds multiple values	          null
Custom Classes	User-defined types	                          null

ğŸ“Œ Notes:
String is not a primitive type, but a class in java.lang package.
All reference types default to null.
â¤ Use long literals with L or l: long x = 123456789L;
â¤ Use float literals with F or f: float y = 3.14F;


################
ğŸ”· String Pool
################
Creating a String object with new String("literal") always creates two distinct String instances: one in the heap (the actual object referenced by your variable) and one in the String Constant Pool (the literal itself).
â€‹
ğŸ”„ Object Creation Process
When executing String s1 = new String("Hello");, Java first checks the String pool for "Hello". 
Since it's a literal, JVM creates it in the pool if absent, then new String() allocates a separate copy in heap memory, referencing the pool's char array internally. 
The variable s1 points to the heap object, not the pool one, so s1 == "Hello" returns false despite identical content.
â€‹
âœ… Memory Layout Example
String pool: ["Hello"] â† Literal created first
Heap: [String object â†’ references pool's "Hello"] â† new String() object
A second String s2 = new String("Hello"); creates another heap object (total 3 Strings: 1 pool + 2 heap), proving new bypasses pooling. Use intern() on heap objects to return pool reference and save memory.
â€‹
â“ Why two objects?
Literal mandates pool entry for sharing; new guarantees distinct heap instance for explicit control.
â€‹â€‹
ğŸ”— Verification Code
String s1 = new String("Hello");
String s2 = "Hello";
System.out.println(s1 == s2);       // false (different objects)
System.out.println(s1.intern() == s2); // true (both pool refs)


ğŸ”„ A new type was introduced in Java version 10
ğŸŸ¢ var type
â¤ This was introduced in Java version 10
â¤ It is a dynamic datatype concept. Depending on the value stored inside the variable, the datatype is allocated to it internally.

âœ… Example:
public class C {
	public static void main(String[] args) {
		var x1 =100;
		var x2 =100.3;
		var x3 ="mike";
		var x4 =new C();
		System.out.println(x1);
		System.out.println(x2);
		System.out.println(x3);
		System.out.println(x4);
	}
  public var test(var x3) {}//Error
}

ğŸŒŸ Properties and Constraints on the var keyword
â¤ The var type can only be a local variable
â¤ It cannot be a static / non-static variable
â¤ It cannot be a method argument
â¤ It cannot be a method return type


###################
ğŸ”· Wrapper Classes
###################
â¤ Java is object-oriented, but primitive types (int, float, char, etc.) are not objects.
â¤ To treat them as objects, Java provides Wrapper Classes in the java.lang package.
â¤ A wrapper class wraps (encloses) a primitive type inside an object.

ğŸ”„ List of Primitive Types and Their Wrapper Classes:
| Primitive Type | Wrapper Class |
| -------------- | ------------- |
| byte           | Byte          |
| short          | Short         |
| int            | Integer       |
| long           | Long          |
| float          | Float         |
| double         | Double        |
| char           | Character     |
| boolean        | Boolean       |

ğŸ”„ Why Do We Need Wrapper Classes?
â¤ To store primitives in collections like ArrayList, which accept only objects.
â¤ For object manipulation (e.g., in multithreading, generics, reflection).
â¤ Useful in parsing strings into numeric values.
â¤ Enable the use of utility methods like Integer.parseInt(), Double.compare(), etc.

â“ Are wrapper classes immutable?
âœ… Yes, all wrapper classes are immutable.

ğŸ”„ Key Concepts
1. Boxing (Manual Conversion) Depreciated
Converting primitive â†’ object
int a = 10;
Integer i = new Integer(a); //Boxing

2. Unboxing (Manual Conversion)
Converting object â†’ primitive
Integer i = new Integer(10);
int a = i.intValue(); //Unboxing

3. Autoboxing- Mostly Used
The compiler automatically converts a primitive â†’ wrapper object
int x = 5;
Integer obj = x;  //Autoboxing

4. Auto-unboxing
The compiler automatically converts wrapper â†’ primitive
Integer y = 100;
int value = y;  //Auto-unboxing

ğŸ”„ Commonly Used Wrapper Class Methods
Integer.parseInt(String) â†’ Converts string to int
Double.parseDouble(String) â†’ Converts string to double
Character.isDigit(char) â†’ Checks if the char is a digit
Boolean.valueOf(String) â†’ Converts string to Boolean object

âœ… Code Examples
public class WrapperExample1 {
    public static void main(String[] args) {
        int a = 100;
        Integer obj = new Integer(a); // Boxing
        int b = obj.intValue();       // Unboxing
        System.out.println("Boxed: " + obj + ", Unboxed: " + b);
		Integer num = 50;     // Autoboxing
        int val = num + 20;   // Auto-unboxing
        System.out.println("Value: " + val);
    }
}

ğŸ”¸ Conceptual Trick Questions
â“ What will happen here?
Integer a = 128;
Integer b = 128;
System.out.println(a == b); âŒ Output: false compare refrences
System.out.println(a.equals(b)); // true âœ… compare actual values.

ğŸ” What's happening step-by-step
Autoboxing
Integer a = 128;
Integer b = 128;
â¤ Here, 128 (a primitive int) is automatically boxed into an Integer object by Java.

ğŸ”§ Integer Cache
â¤ Java maintains an internal Integer cache for values from -128 to 127.
â¤ When you assign a value in this range to an Integer, Java reuses the same object from the cache.
â¤ For values outside this range (like 128), new Integer objects are created.
So here:
a â†’ new Integer(128)  
b â†’ new Integer(128)  
(two different objects in memory)

ğŸ”„.equals() ğŸ†š ==
== â†’ compares references (memory addresses) for objects.
â¤ Since a and b are different objects, a == b â†’ false.
â¤ .equals() â†’ in the Integer class is overridden to compare the actual int values.
â¤ Both a and b hold the same value (128), so a.equals(b) â†’ true.

ğŸ”¸ Deep Understanding
â“ Difference between parseInt() and valueOf()?
 parseInt() returns a primitive int
 valueOf() returns an Integer object

â“ Can you override methods in wrapper classes?
âŒ No, they are final classes

â“ What is the default value of Integer vs int?
 int â†’ 0, Integer â†’ null


########################
ğŸ”· Constructors in Java
########################
Constructors are special methods used to initialize objects when they are created.

ğŸ”„ Basic Rules:
â¤ The constructor name must match the class name
â¤ Constructors do not have a return type, not even void
â¤ If you write void before a constructor, it becomes a method, not a constructor

Example 1:
public class C {
	C(){
		System.out.println(100);//will execute successfully Output :100
		return 100;//Error
	}
	public static void main(String[] args) {
		C c1 = new C();
	}	
}
âš¡ Note: Method, Variable name can be the same as the class name


###################################
ğŸ”· Constructor Overloading in Java
###################################
Constructor overloading refers to having more than one constructor in the same class, but with different parameter lists.

âœ… Why Use Constructor Overloading?
To create objects with different levels of information or default values, depending on whatâ€™s available.

Example:
public class A {
	A(){//NoofArgs=0
		System.out.println("A");
	}
	A(int x){//NoofArgs=1
		System.out.println(x);
	}
	A(int x,int y){//NoofArgs=2
		System.out.println(x);
		System.out.println(y);
	}
	public static void main(String[] args) {
		A a1 = new A();
		A a2  = new A(100);
		A a3 = new A(200,300);
	}
}


########################
ğŸ”· This keyword in Java
########################
This keyword in Java is a reference variable that refers to the current object â€” the object whose method or constructor is being executed.

ğŸ”„ Uses of this Keyword
1ï¸âƒ£ Differentiate Between Instance and Local Variables
When local variable names are the same as instance variables, use this to refer to the instance variable.
âœ… Example:
class Student {
    String name;
    Student(String name) {
        this.name = name;  // 'this.name' is the instance variable, 'name' is the parameter
    }
}

2ï¸âƒ£ Call One Constructor from Another (Constructor Chaining)
Use this() to call another constructor within the same class.
âœ… Example:
class Student {
    String name;
    int age;
    Student(String name) {
        this(name, 18);  // calls the second constructor
    }
    Student(String name, int age) {
        this.name = name;
        this.age = age;
    }
}

3ï¸âƒ£ Pass the Current Object as an Argument
âœ… Example:
class Student {
    void display() {
        Helper.printStudent(this);  // pass current object
    }
}
class Helper {
    static void printStudent(Student s) {
        System.out.println("Student object: " + s);
    }
}

4ï¸âƒ£ Return Current Object
Useful in method chaining.
âœ… Example:
class Person {
    private String name;
    private int age;

    Person setName(String name) {
        this.name = name; // Set name and return current object
        return this;
    }

    Person setAge(int age) {
        this.age = age; // Set age and return current object
        return this;
    }

    public static void main(String[] args) {
        Person p1 = new Person();
        
        // Method chaining in action
        p1.setName("Ankur").setAge(22).show();
    }
}

5ï¸âƒ£ Access Instance Methods and Variables
You can use this to call other instance methods or access fields within the class explicitly.

void print() {
    this.show();  // same as just calling show()
}

void show() {
    System.out.println("Hello");
}

â¤ This keyword is a special reference variable that holds the current object's address.
âœ… Example:
public class A {
	public static void main(String[] args) {
		A a1 = new A();
		System.out.println(a1);
		a1.test();
	}
	public void test() {
		System.out.println(this);
	}
}

â¤ Using this keyword, we can access non-static members of the class
âœ… Example:
public class A {
	int x = 10;
	public static void main(String[] args) {
		A a1 = new A();
		System.out.println(a1.x);
		a1.test();
	}
	public void test() {
		System.out.println(this.x);
	}
}

âŒ We cannot use this keyword inside a "static method"
âœ… Example: 
public class A {
	int x=10;
	public static void main(String[] args) {
		A a1 = new A();
		System.out.println(this);//Error
	}
	public static void test() {
		System.out.println(this);// Error
		System.out.println(this.x);// Error 
	}
}

this()- This syntax is used to call the constructor
â¤ Using this() keyword, we can call a constructor
âœ… Example:
public class A {
	A(){
		System.out.println("A");
	}
	A(int x){
		this();
	}
	public static void main(String[] args) {
	   A a1 = new A(100);
	}	
}

â¤ While calling a constructor using this() keyword, ensure calling is done from another constructor only
âœ… Example 1:
public class A {
	A(){
		System.out.println("A");
	}
	A(int x){
		this();
	}
	public static void main(String[] args) {
	   A a1 = new A(100);
	}
	public void test() {
		this();//Error, we cannot call the constructor from a method
	}	
}

âœ… Example 2:
public class A {
	A(int x){
		System.out.println(x);
	}
	A(){
		this(100);
	}
	public static void main(String[] args) {
	   A a1 = new A();
	}	
}

â¤ While calling a constructor using this() keyword, ensure it is always the first statement inside another constructor
âœ… Example 1:
public class A {
	A(int x){
		System.out.println(x);
	}
	A(){
		System.out.println(200);
		this(100);//Error because it cannot be the second statement while calling the constructor	
	}
	public static void main(String[] args) {
	   A a1 = new A();
	}	
}

âœ… Example 2:
public class A {
	int x;//-->0
	A(int x){////Step 4-->x=100
		this.x=x;//Step 5
		System.out.println(this.x);//Step 6===>100
	}
	A(){//Step 2
		this(100);//Step 3
	}
	public static void main(String[] args) {
	   A a1 = new A();//Step 1
	}	
}

âœ… Types of Constructor Chaining
â¤ When we call one constructor from another constructor, it will form a chain-like flow structure. This is called constructor chaining.

1ï¸âƒ£ Within the Same Class â†’ Use this().
You can use this() to call another constructor in the same class.
âœ… Example:
class Student {
    String name;
    int age;
    Student() {
        this("Unknown", 18);  // calls 2-arg constructor
        System.out.println("Default constructor called");
    }

    Student(String name) {
        this(name, 18);  // calls 2-arg constructor
    }

    Student(String name, int age) {
        this.name = name;
        this.age = age;
        System.out.println("Parameterized constructor called");
    }

    void display() {
        System.out.println("Name: " + name + ", Age: " + age);
    }
}
â–¶ï¸ Output:
The parameterized constructor called  
The default constructor is called 


2ï¸âƒ£ From Subclass to Superclass â†’ Use super()
You can call a constructor from the parent class using super().
âœ… Example:
class Person {
    Person() {
        System.out.println("Person constructor");
    }
}

class Student extends Person {
    Student() {
        super(); // calls Person constructor
        System.out.println("Student constructor");
    }
}

âš ï¸ Rules of Constructor Chaining
âœ… Only one constructor can be called using this() or super()	
âœ… Must be the first statement in the constructor	
âŒ Cannot mix this() and super() in the same constructor


#####################
ğŸ“¦ Packages in Java
#####################
A package in Java is a namespace that organizes classes and interfaces into a structured folder system, making code modular, reusable, and easy to manage.

ğŸ”· Naming Convention for packages
âŒ Package name cannot be a keyword like - new, static, public, etc...
âŒ Do not start the package name with capital letters
âŒ Package name not to be given as java

â¤ When you create a class inside a package, you have to define the package keyword in your program as shown below:
âœ… Example:
package p1;
public class A {}

â¤ Create 2 classes in the same package and perform inheritance. Import is not required.
âœ… Example 1:
package p1;
public class A {}

package p1;
public class B extends A {}

â¤ Create 2 classes in different packages and perform inheritance. "Import required".
âœ… Example 2:
package p1;
public class A {}

package p2;
import p1.A;
public class C extends A{}

âœ… Example 3:
package p1;
public class A {}

package p2;
public class C {}

package p1;
import p2.C;
public class B {
	public static void main(String[] args) {
		A a1 = new A();
		C c1 = new C();
	}
}

âœ… Example 4:
package p1;
public class A {}

package p1;
public class B {}

package p2;
import p1.*;
public class C {
	public static void main(String[] args) {
		A a1 = new A();
		B b1 = new B();
	}
}

âœ… Example 5:
package p1;
public class A {}

package p2;
public class A {}

package p3;
public class B {
	public static void main(String[] args) {
		p1.A a1 = new p1.A();//---> p1
		p2.A a2 = new p2.A();//---> p2
	}
}

ğŸ”· Object-Oriented Programming 
1ï¸âƒ£ Inheritance
2ï¸âƒ£ Polymorphism
3ï¸âƒ£ Encapsulation
4ï¸âƒ£ Abstraction


################
ğŸŒŸ Inheritance
################
âœ”ï¸ Inheritance is one of the core pillars of Object-Oriented Programming (OOP).
âœ”ï¸ It allows a class (subclass) to inherit fields and methods from another class (superclass).

âœ… Why Use Inheritance?
â¤ Code reusability
â¤ Improves maintainability
â¤ Supports method overriding & polymorphism

âœ… Example :
package app_java_1;
public class Animal {
	public void eat() {
		System.out.println("Eating");
	}
	public void sleep() {
		System.out.println("sleeping");
	}
}

package app_java_1;
public class Dog extends Animal{
	//eat(),sleep()--->Animal
}

package app_java_1;
public class Cow extends Animal{
	//eat(),sleep()--->Animal
}

package app_java_1;
public class Root {
	public static void main(String[] args) {
		Dog d = new Dog();
		d.eat();
		d.sleep();
		System.out.println("_______");
		Cow cow = new Cow();
		cow.eat();
		cow.sleep();
	}
}


ğŸ”„ Multilevel inheritance
âœ… Example:
package app_java_1;
public class A {
	public void test1() {
		System.out.println(1);
	}
}
package app_java_1;
public class B extends A{
	public void test2() {
		System.out.println(2);
	}
}
package app_java_1;
public class C extends B{
	public static void main(String[] args) {
		C c1 = new C();
		c1.test1();//Output :1
		c1.test2();//Output :2
	}
}


ğŸ”„ Multiple inheritance
When a child class has more than one parent class, it is called multiple inheritance
â¤ Java classes do not support multiple inheritance because of the diamond problem.

â—Diamond Problem in Java (Multiple Inheritance Problem)
â¤ The Diamond Problem occurs in multiple inheritance when a class inherits from two classes that have a common superclass, leading to ambiguity about which method to inherit.
â¤ Suppose we inherit a method from A->B->D,  and the same method is inherited from A->C->D, then confusion arises from which parent class method is inherited by the child class D. This is called as DIAMOND PROBLEM. Hence, in Java, classes do not support multiple inheritance.

Note: We can do multiple inheritance on an interface.

âœ… Example: Multiple inheritance errorâŒ
package app_java_1;
public class A {}

package app_java_1;
public class B{}

package app_java_1;
public class C extends A, B{ âŒError	
}


ğŸ”· Access Specifiers in Java
| Access Context                | `public` |         `protected`          | `default` (no modifier)   | `private`  |
| ------------------------------| :------: | :------------------------:   | :---------------------:   | :-------:  |
| Same Class                    |     âœ…   |              âœ…             |            âœ…            |     âœ…     |
| Same Package                  |     âœ…   |              âœ…             |            âœ…            |     âŒ     |
| Subclass in Same Package      |     âœ…   |              âœ…             |            âœ…            |     âŒ     |
| Non-Subclass in Same Package  |     âœ…   |              âœ…             |            âœ…            |     âŒ     |
| Subclass in Other Package     |     âœ…   | âœ… (via inheritance only)   |            âŒ            |     âŒ     |
| Non-Subclass in Other Package |     âœ…   |              âŒ             |            âŒ            |     âŒ     |

1ï¸âƒ£ private: When a variable/method is made private, then we can access it in the same class but not outside the class
2ï¸âƒ£ default: A variable/method with a default access specifier can work only inside the same class or the same package, but cannot be accessed in a different package
3ï¸âƒ£ protected: We can access variables/methods in the same class/same package, and inside different packages only when inheritance is done
4ï¸âƒ£ public: When we make a variable/method public, then we can access that in the same class/the same package/different package


ğŸ”· Access Specifier on Constructors
â“ Can we inherit the Constructor?
No, constructors cannot be inherited in Java.
Even though a subclass gets access to all public and protected members of the superclass, constructors are not part of inheritance.

â“ Why Are Constructors Not Inherited?
1ï¸âƒ£ Constructors are not members
Constructors are not inherited because they are not class members, such as methods or fields.

2ï¸âƒ£ Constructors are class-specific
A constructor is tightly bound to its class name.

3ï¸âƒ£ Subclass should define how it initializes its members
A subclass may have new fields or different logic for initialization.
Therefore, it requires a constructor to control its initialization.

4ï¸âƒ£ Java automatically provides a default constructor
If you don't define any constructors, Java will insert a default no-arg constructor.
But this doesn't mean the superclass constructor is inherited â€” it's just that Java calls the superclass constructor from the subclass constructor.
They are special blocks used to initialize objects of a specific class.


ğŸ” Private Constructor in Java
A private constructor is a constructor that cannot be accessed outside its class.

âœ… Why Use a Private Constructor?
âŒ Prevent object creation	        for utility or helper classes
âœ… Implement Singleton Pattern		Ensure only one instance is created
ğŸ” Hide object instantiation		Force object creation through factory methods
â¤ If a constructor is made private, then its object cannot be created outside the class.


ğŸ” Singleton Pattern Implementation
â¤ A Singleton pattern is a design pattern that ensures that a class has only one instance, and provides a global point of access to it.


âœ… Example 1:
package p1;
public class A {
	private A() {}
	public static void main(String[] args) {
		A a1 = new A();
	}
}

package p1;
public class B {
	public static void main(String[] args) {
		A a1 = new A(); â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ ErrorâŒ
	}
}

package p2;
import p1.A;
public class C {
	public static void main(String[] args) {
		A a1 = new A(); â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ ErrorâŒ
	}
}
â¤ When a constructor is made private, then inheritance of that class is not allowed


âœ… Example 2:
package p1;
public class A {
	private A() {}	
}

package p1;
public class B extends A{ â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ErrorâŒ	
}

package p2;
import p1.A;
public class C extends A{ â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ErrorâŒ	
}


ğŸ—ï¸ Default Constructor in Java
A default constructor is a no-argument constructor that the Java compiler automatically provides if you do not define any constructors in your class.

âœ… Key Features:
Feature							Description
No parameters. 					Takes zero arguments
Provided automatically			Only if no constructor is defined by the user
Initializes variables,			sets fields to default values (e.g., 0, null)
Used for object creation		Allows creation of objects without parameters
â¤ If a constructor is made default, then its object can be created in the same class/same package, but not outside the package.

âœ… Example 1:
package p1;
public class A {
	A() {}
	public static void main(String[] args) {
		A a1 = new A();
	}
}
package p1;
public class B {
	public static void main(String[] args) {
		A a1 = new A();
	}
}
package p2;
import p1.A;
public class C{
	public static void main(String[] args) {
		A a1 = new A();//-->Error
	}
}


âœ… Example 2:
package p1;
public class A {
	A() {}
}
package p1;
public class B extends A {}

package p2;
import p1.A;
public class C extends A{//-->Error	
}


ğŸ” Protected Constructor in Java
A protected constructor means the constructor can only be accessed:
âœ… Within the same package
âœ… From subclasses (even in other packages)

âœ… Why Use a Protected Constructor?
â¤ To restrict object creation outside the package
â¤ To allow subclassing but prevent direct instantiation from unrelated classes
â¤ Often used in inheritance-based designs, frameworks, or abstract factories

âœ… Example 1:
package p1;
public class A {
	protected A() {}
	public static void main(String[] args) {
		A a1 = new A();
	}
}

package p1;
public class B  {
	public static void main(String[] args) {
		A a1 = new A();
	}
}

package p2;
import p1.A;
public class C {
	public static void main(String[] args) {
		A a1 = new A();//-->âŒ Error
	}
}
â¤ When a constructor is made protected, then inheritance of that class is allowed in the same package / outside the package (both).


âœ… Example 2:
package p1;
public class A {
	protected A() {}
}

package p1;
public class B extends A {}

package p2;
import p1.A;
public class C extends A {}


===========================================
ğŸ”· Access Specifiers on Top-Level Classes
===========================================
Access Specifier				Usage							Visibility
public							public class ClassName {}		Visible to all classes everywhere (within the same package or other packages).
Default (no modifier)			class ClassName {}				Visible to classes within the same package only.

âŒ Not allowed on top-level classes:
1ï¸âƒ£ private
2ï¸âƒ£ protected


ğŸ”„ Java's Design Philosophy
âœ… 1. Top-level classes must be accessible to the JVM & compiler
â¤ If you declare a class as private or protected, no other class can access it, not even the class loader or main method (in another file).
â¤ That breaks the point of having it at the top level â€” it becomes useless.

âœ… 2. Protected and private only make sense in class hierarchies
â¤ Protected is meaningful only within inheritance (i.e., subclass access).
â¤ Private is meaningful only within the enclosing class.
â¤ For a top-level class, there is no enclosing class, so these modifiers make no logical sense.

âœ… Example 1:
package p1;
class A {}

package p1;
public class B extends A{} â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Because A is default and inherited in B

package p2;
import p1.A;	â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶	âŒ Error
public class C extends A{	â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶	âŒ Error
}

âœ… Example 2:
package p1;
class A {
	public static void main(String[] args) {
		A a1 = new A();
	}
}

package p1;
public class B {
	public static void main(String[] args) {
		A a1 = new A();
	}
}

package p2;
import p1.A;//--->Error because A is default and cannot be inherited in another package
public class C {
	public static void main(String[] args) {
		A a1 = new A();//--->Error
	}
}

ğŸ”„ Polymorphism
Two types of polymorphism:

1ï¸âƒ£ Method Overriding (Run-time polymorphism):
â¤ Overriding occurs when a subclass provides a specific implementation of a method that is already defined in its superclass.
â¤ It is used to achieve Run-time Polymorphism.
â¤ The method signature (name + parameters) must be the same in both parent and child classes.
â¤ The decision of which method to call is made at run-time, not compile-time.

ğŸ”¸ Key Rules of Method Overriding:
Rule													Description
Same method signature									Method name, return type, and parameters must be the same.
Access modifier											Child method must have the same or more accessible modifier (e.g., canâ€™t override public with private).
Can't override final, static, or private methods		These are either not inherited or cannot be changed.
Return type												should be the same or covariant (child class return type).
Use @Override											Optional, but recommended to catch errors at compile time.

âœ… Example:
package p1;
public class GoldAccount {
	public void onlineBanking() {
		System.out.println("yes");
	}
	public void rateOfInterest() {
		System.out.println("nill");
	}
}

package p1;
public class PlatinumAccount extends GoldAccount {
	public void rateOfInterest() {
		System.out.println("6% PA");
	}
	public static void main(String[] args) {
		PlatinumAccount p = new PlatinumAccount();
		p.onlineBanking();
		p.rateOfInterest(); â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Output: 6% PA
		GoldAccount g = new GoldAccount();
		g.onlineBanking();
		g.rateOfInterest(); â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Output: nill
	}
}

===============
ğŸ”· Annotations
===============
â¤ Introduced in Java 5, annotations are metadata that provide information to the compiler or runtime environment.
â¤ They do not directly affect program logic but can instruct the compiler or tools to perform specific actions.

 Common Use: @Override
â¤ @Override is used to indicate that a method is intended to override a method in the superclass.
â¤ It helps the compiler catch errors if the method does not override anything (e.g., due to a typo or mismatch in method signature).

package p1;
	public class GoldAccount {	
		public void rateOfInterest() {
			System.out.println("nill");
		}
	}

package p1;
public class PlatinumAccount extends GoldAccount {
	@Override
	public void rateOfInterests() { â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ âŒ Error because method name mismatch
		System.out.println("6% PA");
	}	
}

â—Access Specifier should be the same, or can it be different during Overriding?
During overriding, we can increase the scope of the access specifier, but we cannot reduce the scope of the access specifier

âœ… Example 1:
package p1;
public class GoldAccount {
	void rateOfInterest() {
		System.out.println("nill");
	}
}

package p1;
public class PlatinumAccount extends GoldAccount {
ğŸ‘‰ // â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ No Error Because the default scope is increased to public	
	@Override
	public void rateOfInterest() {
		System.out.println("6% PA");
	}
}

âœ… Example 2:
package p1;
public class GoldAccount {
	public void rateOfInterest() {
		System.out.println("nill");
	}
}

package p1;
public class PlatinumAccount extends GoldAccount {
	@Override
	void rateOfInterest() { â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ âŒError: Because the public scope is reduced to the default
		System.out.println("6% PA");
	}
}

ğŸ”— Order of Access Specifiers: Private â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Default â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Proctected â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Public

âœ… Example 3:
package p1;
public class GoldAccount {
	private void rateOfInterest() {
		System.out.println("nill");
	}
}

package p1;
public class PlatinumAccount extends GoldAccount {
	@Override
	protected void rateOfInterest(){  â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ âŒError: Because private methods cannot be inherited, without inheritance, overriding cannot be done
		System.out.println("6% PA");
	}
}

â“ Are Static Members Inherited in Java?
âœ… Technically, static members are inherited â€” but they are not polymorphic, and they do not behave like instance members in inheritance.

ğŸ”¥ Common Misconception:âŒ "Static members cannot be inherited." But that's not entirely accurate.

âœ… What Happens:
1. Static members belong to the class, not to objects.
They are class-level members, not instance-level.
So they are shared across the inheritance hierarchy.
So yes, static members are accessible in the subclass, but they are not inherited in the object-oriented sense (no polymorphism).

âš ï¸ Why Static Members Are Not "Truly" Inherited:
1ï¸âƒ£ They donâ€™t participate in runtime polymorphism

class A {
    static void show() {
        System.out.println("A");
    }
}

class B extends A {
    static void show() {
        System.out.println("B");
    }
}

public class Main {
    public static void main(String[] args) {
        A obj = new B();// Upcasting 
        obj.show(); // Output: A (not B)
    }
}

Is this overriding?
âŒ No. This is method hiding, not method overriding, because the methods are static
â¤ Even though obj is of type B, A.show() gets called because static methods are resolved at compile time, based on the reference type, not the object.

Imagine static methods are like TV channels fixed on the remote brand, not on who's holding the remote.

A obj = new B();
â¤ Here, you're using a remote (reference) of brand A, so Java checks what methods belong to A, not B.
â¤ Even though you created a B object, the method called depends on what reference type you're using.
static = class-based decision (compile-time)
non-static = object-based decision (run-time)

2ï¸âƒ£ They're not part of the instance, so â€œinheritanceâ€ isnâ€™t meaningful
Since they donâ€™t get copied to each object or act differently per subclass instance, calling it "inheritance" is misleading.

âœ… Example:
A parent class: GoldAccount (in package p1)
A child class: PlatinumAccount extends GoldAccount

package p1;
public class GoldAccount {
    static int x = 100;
    public static void rateOfInterest() {
        System.out.println("nill");
    }
}

package p1;
public class PlatinumAccount extends GoldAccount {
    public static void main(String[] args) {
        PlatinumAccount.rateOfInterest();      // Output:  nill
        System.out.println(PlatinumAccount.x); // Outuput: 100
    }
}
ğŸ”„ Overview of Above Program
1ï¸âƒ£ Static Methods and Variables Are Not Polymorphic. Even though PlatinumAccount inherits from GoldAccount, calling PlatinumAccount.rateOfInterest();
It is resolved at compile time based on the class name, not the object type.

2ï¸âƒ£ Since PlatinumAccount does not override the method (it doesnâ€™t define its rateOfInterest()), calling: PlatinumAccount.rateOfInterest(); 
is effectively the same as: GoldAccount.rateOfInterest();

3ï¸âƒ£ The same logic applies to the static variable x: PlatinumAccount.x; â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ resolves to GoldAccount.x (100)


=====================================================
ğŸ”· Overloading in Java (Compile-Time Polymorphism)
=====================================================
â¤ Method Overloading means defining multiple methods with the same name in a class but with different parameter lists (type, number, or order of parameters).
â¤ It allows compile-time polymorphism, where the method to be called is determined at compile time based on the method signature.

| Feature                     | Allowed in Overloading?  | Explanation                              |
| --------------------------- | -----------------------  | ---------------------------------------  |
| Change number of parameters | âœ… Yes                   | Different arity                         |
| Change type of parameters   | âœ… Yes                   | Different signatures                    |
| Change order of parameters  | âœ… Yes                   | Only if types are different             |
| Change return type only     | âŒ No                    | Causes compile-time error               |
| Change access modifier only | âŒ No                    | Doesn't affect method signature         |
| Change method name          | âŒ No                    | It's not overloading, it's a new method |

ğŸ”„ Characteristics of Overloading:
Feature						Description
Method name					must be the same
Parameter list				must be different (type, number, or order)
Return type					can be the same or different, but doesn't affect overloading
Access modifier				can be the same or different
Inheritance					is not required for overloading

âœ… Example:
package p1;

public class EmailService {
	public void sendEmail(String to, String subject, String message) {
		System.out.println("Email sending....");
	}
	public void sendEmail(String to, String subject, String message, String filePath) {
		System.out.println("Email sending with attachment.....");
	}
	public static void main(String[] args) {
		EmailService service = new EmailService();
		service.sendEmail("mike@gmail.com", "Welcome", "Some Message","G:\\image.png");
	}
}


==================
ğŸ”· Final Keyword
==================
â¤ If you make a variable final, then we cannot change its value(Just like constant variables).
â¤ If you make a static/non-static variable final, then initialization is mandatory.

âœ… Example:
package p1;
public interface A {
	int MAX_VAL=100;
	static final int MIN_VAL=0;
}

package p1;
public class B {
	public static void main(String[] args) {
		System.out.println(A.MAX_VAL); â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Output: 100
		System.out.println(A.MIN_VAL); â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Output: 0
	}
}
â¤ If you make a method final, then overriding is not allowed, but inheritance is allowed

ğŸ”’ Why Use final on a Method?
1ï¸âƒ£ You want to prevent subclasses from changing the logic of a method.
2ï¸âƒ£ You're building secure or stable base classes (e.g., Java API classes like String, Integer, etc.)


â¤ If you make a class final, then inheritance is not allowed
A final class:
âŒ Cannot be extended/inherited.
âœ… Can have regular (non-final) methods.
âœ… Can have final methods too.
ğŸ‘‰ But since the class itself cannot be inherited: No methods inside it â€” final or not â€” can ever be overridden.

âœ… Example 1: 
package p1;

public class A {
	public static void main(String[] args) {
		final int x = 10;
		x=20; â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Cannot change the value of a final variable
		final int y; â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ final mandatory to be initialized
	        final static int z;â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ final mandatory to be initialized
		//âŒThe above errors are called blank field errors
		System.out.println(y);
	}
}

âœ… Example 2:
package p1;

public class A {
	final public void test() {
		System.out.println(100);
	}
}
package p1;

public class B extends A{
	@Override
	public void test() { â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ âŒ Error because we cannot override final methods
		System.out.println(100);
	}
}

âœ… Example 3:
package p1;
final public class A {}

package p1;
public class B extends A{ â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ âŒ Error because we cannot inherit final class	
}

â“ What Happens When a Reference Variable is marked final?
final Student s = new Student();
â¤ You can't reassign s to point to another object.
â¤ But you can still modify the object that refers to(if it is mutable). unless the class itself is immutable(like String).

âœ… Example:
class Student {
    int marks = 80;
}

public class Test {
    public static void main(String[] args) {
        final Student s = new Student();
        s.marks = 90;         â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ âœ… Allowed
        // s = new Student(); â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ âŒ Not allowed (Compile-time error)
        System.out.println(s.marks); // 90
    }
}

â“ Why do you use the final for references?
To prevent reassignment, ensure safe dependency injection, and make code more thread-safe and readable. Itâ€™s also a key part of writing immutable classes and predictable lambdas.


==========================================
ğŸ”· How to Make a Class Immutable in Java
==========================================
To make class immutable, follow these 7 rules:
1ï¸âƒ£ Declare the class as final
Prevents subclassing (inheriting) because subclass can add setters and break immutability.

public final class Student { ... }

2ï¸âƒ£ Make all fields private and final
â¤ private â†’ no direct access from outside.
â¤ final â†’ value assigned only once, in constructor.

private final String name;


3ï¸âƒ£ Donâ€™t provide any setter methods
Only allow initialization through constructor.


4ï¸âƒ£ Initialize all fields through a constructor
Constructor assigns values once, cannot be changed later.

public Student(String name, int age) {
    this.name = name;
    this.age = age;
}


5ï¸âƒ£ Ensure deep copy for mutable fields
If a field is mutable (e.g., Date, List, Map) never expose the original reference.

ğŸ‘‰ Why?
If you expose the original object, someone can change it â†’ your class is no longer immutable.

âœ… Solution
Clone the object inside the constructor.
Clone again inside the getter.

âœ… Example:
this.joiningDate = new Date(joiningDate.getTime()); // deep copy

âœ… Getter:
public Date getJoiningDate() {
    return new Date(joiningDate.getTime()); // return copy
}


6ï¸âƒ£ Donâ€™t allow subclasses to override methods
Already solved with final class, but if class is not final:
	âœ”ï¸ Make methods final or
	âœ”ï¸ Make constructor private and use static factory.


7ï¸âƒ£ Donâ€™t expose internal references
â¤ Never return internal collections directly.
â¤ Return unmodifiable:

return Collections.unmodifiableList(new ArrayList<>(subjects));

âœ…Example:
public final class Student {

    private final String name;
    private final int age;
    private final Date joiningDate; // mutable field

    public Student(String name, int age, Date joiningDate) {
        this.name = name;
        this.age = age;

        // Deep copy for mutable field
        this.joiningDate = new Date(joiningDate.getTime());
    }

    public String getName() {
        return name; // immutable
    }

    public int getAge() {
        return age;  // immutable
    }

    public Date getJoiningDate() {
        // Return a new copy to avoid modification
        return new Date(joiningDate.getTime());
    }
}

ğŸ”· Inner Class
An inner class is a class declared inside another class.

â“ Why Inner Class?
â¤ To logically group classes used only by one outer class
â¤ To access private members of outer class
â¤ To write more readable and maintainable code
â¤ To implement data-hiding

ğŸ”„ Types of Inner Classes
1ï¸âƒ£ Non-static Inner Class (Member Inner Class)
â¤ Declared inside class but outside methods
â¤ Cannot define static members inside it
â¤ Has access to all outer class members (even private)

âœ…Example:
class Outer {
    private int data = 10;

    class Inner {
        void show() {
            System.out.println("Data = " + data);
        }
    }

    public static void main(String[] args) {
        Outer o = new Outer();
        Inner i = o.new Inner();
        i.show();
    }
}

2ï¸âƒ£ Static Inner Class
â¤ Declared as static
â¤ Does NOT need outer class object
â¤ Cannot access non-static members of outer class

âœ…Example:
class Outer {
    static int x = 100;

    static class Inner {
        void show() {
            System.out.println(x);
        }
    }

    public static void main(String[] args) {
        Outer.Inner i = new Outer.Inner();
        i.show();
    }
}

3ï¸âƒ£ Local Inner Class
â¤ Class declared inside a method
â¤ Scope restricted only to method
â¤ Cannot have access modifiers
â¤ Can access final or effectively final variables of method

âœ…Example:
class Outer {
    void display() {
        int x = 10; // effectively final

        class Inner {
            void show() { System.out.println(x); }
        }

        new Inner().show();
    }
}

4ï¸âƒ£ Anonymous Inner Class
â¤ Class without a name
â¤ Used when we need one-time implementation
â¤ Commonly used for interfaces, abstract classes, and event handling

âœ…Example implementing interface:
interface A { void show(); }

class Test {
    public static void main(String[] args) {
        A obj = new A() {
            public void show() {
                System.out.println("Anonymous class implementation");
            }
        };
        obj.show();
    }
}


ğŸ”· Inner Interface
An interface declared inside a class or interface.

ğŸ” Rules
â¤ Can be public, private, protected
â¤ Usually used to group interfaces logically
â¤ Accessed using Outer.Interface

âœ…Example:
class Outer {
    interface Inner {
        void show();
    }
}

class Test implements Outer.Inner {
    public void show() {
        System.out.println("Inner interface implemented");
    }
}


ğŸ”· Anonymous Class
A class created without a name, used to provide instant implementation.

ğŸ‘‰ Used for:
â¤ When making a class only once
â¤ When overriding methods quickly
â¤ In event listeners
â¤ In comparator logic
â¤ For implementing Runnable in threads

1ï¸âƒ£ Anonymous Class extending a class
class A {
    void show() { System.out.println("A show"); }
}

public class Test {
    public static void main(String[] args) {
        A a = new A() {
            void show() {
                System.out.println("Anonymous override");
            }
        };
        a.show();
    }
}


2ï¸âƒ£ Anonymous Class implementing an interface
interface B {
    void run();
}

public class Test {
    public static void main(String[] args) {
        B b = new B() {
            public void run() {
                System.out.println("Anonymous interface implementation");
            }
        };
        b.run();
    }
}


3ï¸âƒ£ Anonymous Runnable in Thread
public class Demo {
    public static void main(String[] args) {
        new Thread(new Runnable() {
            public void run() {
                System.out.println("Thread running");
            }
        }).start();
    }
}


ğŸ”· Interfaces in Java - Abstraction
Interfaces are a fundamental feature in Java used to achieve abstraction and enforce design contracts between classes.

ğŸ”„ Key Points:
Complete Abstraction (Java 7)
â¤ In Java 7 and earlier, interfaces could only have abstract methods (no method bodies).
â¤ They define what should be done, not how.

â¤ All Variables are public static final.
â¤ No need to specify these modifiersâ€”they are applied by default.
â¤ No Object creation

â— Drawback of Inheritance â€“ Tightly Coupled Programming
â¤ When two or more classes are highly dependent on each other's implementation, they are said to be tightly coupled.
â¤ In such a setup, changing one class often requires changes in the other, reducing flexibility, maintainability, and scalability.

ğŸ”¸ How Inheritance Causes Tight Coupling:
Child class depends heavily on the parent class:
â¤ In inheritance, the child class inherits both behavior and structure from the parent.
â¤ If the parent class changes, it can break or affect the behavior of all child classes.

Strong binding:
â¤ The child class is strongly bound to the specific parent class.
â¤ You cannot easily switch to a different parent or change the inheritance hierarchy without impacting the child classes.

Hard to maintain and extend:
â¤ Over time, inherited code becomes fragile.
â¤ Multiple levels of inheritance (deep hierarchy) make debugging and updates difficult.

âœ… Example 1:
package p1;

public interface A {
	public void test1() {} //âŒ Error because complete methods are not allowed in an interface	
	public void test2();  // âœ… Correct version
}

âœ… Example 2:
package p1;

public interface NotificationService {
	public void emailService();
	public void whatsAppService();
	public void smsService();
}

package p1;

public class NotificationServiceImpl implements NotificationService {
	@Override
	public void emailService() {
		System.out.println("Email Sending");
	}
	@Override
	public void whatsAppService() {
		System.out.println("Whats app Sending");
	}
	@Override
	public void smsService() {
		System.out.println("SMS Sending");
	}
	public static void main(String[] args) {
		NotificationServiceImpl impl = new NotificationServiceImpl();
		impl.emailService();
		impl.smsService();
		impl.whatsAppService();
	}
}

âœ… Example:
package p1;

public interface Calculator {
	public void add(int x, int y);
	public void mul(int x, int y);
}

package p1;
public class OrdinaryCalc implements Calculator{
	@Override
	public void add(int x, int y) {
		System.out.println(x+y);
	}
	@Override
	public void mul(int x, int y) {
		System.out.println(x*y);
	}
}

package p1;

public class SciCalc implements Calculator{
	@Override
	public void add(int x, int y) {
		System.out.println(x*x+y*y);
	}
	@Override
	public void mul(int x, int y) {
		int num1 = x*x;
		int num2 = y*y;
		System.out.println(num1*num2);
	}
}
package p1;

public class MainCalc {
	public static void main(String[] args) {
		OrdinaryCalc oc = new OrdinaryCalc();
		oc.add(10, 20);
		oc.mul(10, 20);
		SciCalc sc = new SciCalc();
		sc.add(10, 20);
		sc.mul(10, 20);
	}
}

ğŸ§  Interview Questions:
â“ Question 1. Could this have been done with an abstract class?
âœ… Yes â€” abstract classes allow incomplete methods and inheritance.
But the real reason for using an interface here is that you're defining pure behavior (what calculators must do), not common implementation logic.
So:
Interface â†’ for capabilities
Abstract class â†’ for partial implementation + common state

â“ Question 2. Biggest advantage of using an interface instead of an Abstract Class?
âœ… Loose coupling and flexibility.
Interfaces let you add new types of calculators later without changing the existing hierarchy.
Also, Java allows multiple interfaces, but only single inheritance with abstract classes.

âœ… Advantages of Interfaces in Java
1ï¸âƒ£ Abstraction
â¤ Interfaces facilitate complete abstraction.
â¤ They allow you to hide implementation details and only expose what needs to be done, not how.

âœ… Example: A Database interface may define connect(), disconnect(), but not how these are implemented.

2ï¸âƒ£ Contract Enforcement
â¤ When a class implements an interface, it must implement all its methods.
â¤ This imposes a strict contract on the class, ensuring consistency in structure and behavior across multiple classes.

3ï¸âƒ£ Good Design Practices
â¤ Interfaces promote clear separation of responsibilities.
â¤ They lead to clean, modular, and testable code.
â¤ Developers can work independently on the interface and its implementations.

4ï¸âƒ£ Loose Coupling
â¤ Classes that use interfaces depend only on method signatures, not on concrete implementations.
â¤ This allows changes in implementations without affecting dependent classes.
â¤ Enhances flexibility, extensibility, and maintainability of the system.

5ï¸âƒ£ Multiple Inheritance
â¤ Java doesnâ€™t support multiple inheritance with classes, but a class can implement multiple interfaces.
â¤ This allows a class to inherit behavioral capabilities from multiple sources.

6ï¸âƒ£ Supports Plug-and-Play Architecture
â¤ Interface-based design makes it easy to swap implementations (e.g., using different payment gateways, databases, or services) without changing the dependent code.

Note:
â¤ Class to Class Inheritance --> extends
â¤ Interface to Interface Inheritance --> extends
â¤ Interface to Class Inheritance --> implements
âš¡ Similar type then extends otherwise implements

âœ… Example :
package p1;
public interface A {
	public void test1();
}

package p1;
public interface B extends A{
	public void test2();
}

public interface D{
	public void test3();
}

package p1;
public class C implements B, D { //If you do multiple inheritance on a class, then its parent should be interfaces only

	@Override
	public void test1() {
		System.out.println("From test1");
	}
	@Override
	public void test2() {
		System.out.println("From test2");
	}

	public static void main(String[] args) {
		C c1 = new C();
		c1.test1();
		c1.test2();
	}
}

âœ… Example 4:
â¤ In class, can we perform extends and implements together
â¤ But ensure the extends is used first and then implementes

package p1;
public interface A {
	public void test2();
}

package p1;
public class B {
	public void test1() {
		System.out.println("From test1");
	}
}

package p1;
public class C extends B implements A {
	@Override
	public void test2() {
		System.out.println("From test2");		
	}
	public static void main(String[] args) {
		C c1 = new C();
		c1.test1();
		c1.test2();
	}
}

âœ…Example:
interface A {
    default void show() {
        System.out.println("A");
    }
}

interface B {
    default void show() {
        System.out.println("B");
    }
}

class C implements A, B {
    // ??----------------->// It does not compile
}
ğŸ§ Interview Question on the above example
â“ Will this compile?
â“ If not, what do you do in class C to fix it?
â“ Why does Java force you to resolve this?

ğŸ§ It will not compile. Why ??
âœ”ï¸ Because both interfaces A and B define a default void show() method.
âœ”ï¸ When C implements both, Java doesnâ€™t know which one to inherit â†’ ğŸ”º Diamond Problem (method ambiguity).

âœ… Fix in Class C:
class C implements A, B {
    public void show() {
        A.super.show();  // or B.super.show();
    }
}

âœ”ï¸ You resolve the conflict by explicitly choosing which interfaceâ€™s show() to call.
ğŸ“Œ Why Java Forces This?
Because, unlike classes (which canâ€™t be inherited from more than one), interfaces can be â€” so Java must protect against silent conflicts, especially now that interfaces can have default (concrete) methods since Java 8.

Javaâ€™s philosophy:
âœ³ï¸ â€œExplicit is better than implicit in cases of ambiguity.â€

â“ Why A.super.show() works with interfaces
â¤ In interfaces, methods are abstract by default.
â¤ Since Java 8, interfaces can also have default methods (with a body).
â¤ If a class implements multiple interfaces that define the same default method, thereâ€™s an ambiguity (diamond problem).
â¤ To resolve it, Java allows calling specific interfaceâ€™s default implementation using:

âœ…Example: 
interface A {
    default void show() {
        System.out.println("A's show");
    }
}

interface B {
    default void show() {
        System.out.println("B's show");
    }
}

class C implements A, B {
    public void show() {
        A.super.show(); // disambiguation
    }
}
âœ”ï¸ Allowed, because A.super.show() means â€œuse the default implementation of show() defined in interface Aâ€.

â“ Why we cannot do this with classes
Now imagine multiple inheritance with classes:

âœ…Example:
class A {
    void show() {
        System.out.println("A's show");
    }
}

class B {
    void show() {
        System.out.println("B's show");
    }
}

// âŒ Not allowed
class C extends A, B {
    // Java does not support this
}

âŒ Problem:
â¤ Both A and B are concrete classes, they may have fields, constructors, and state.
â¤ If Java allowed class C extends A, B, then:
	âœ”ï¸ Which parentâ€™s constructor would run first?
	âœ”ï¸ What if both classes had the same field int x? Which one would C.x refer to?
	âœ”ï¸ Which method would super.show() call? (Ambiguity again, but worse because fields + constructors are also involved.)
â¤ Thatâ€™s why Java forbids multiple inheritance of classes entirely
â¤ So thereâ€™s no syntax like A.super.show() with classes, because Java never allows a class to inherit from two classes in the first place.

ğŸ”„ Core Difference
â¤ Interfaces â†’ only method declarations (and optional default methods). No state (except static/final constants). Ambiguities are easy to resolve with InterfaceName.super.method().
â¤ Classes â†’ can have full state (fields, constructors, method implementations). Resolving conflicts here is way more complex and risky â†’ so Java designers disallowed multiple class inheritance.

â“ Can I develop an incomplete static method in an interface?
We cannot inherit static methods & override, hence incomplete static methods are not allowed in an interface.

Example:
package p1;
public interface A {
	public static void test2();//âŒ Error
}

ğŸ”· Java 8 Features
1ï¸âƒ£ default keyword:
â¤ We can create complete methods inside an interface. This was introduced in Java version 8.

âœ… Example:
package javaconcepts.p3;
public interface A {
	default public void test1() {
		System.out.println("From test1");
	}
	public void test2();
}

package javaconcepts.p3;
public class B implements A {
	public static void main(String[] args) {
		B b1 = new B();
		b1.test1();
		b1.test2();
	}
	@Override
	public void test2() {
		System.out.println("From Overrided test2");
	}	
	@Override
	public void test1() { //we can override the method
		System.out.println("From Overrided Test1");
	}
}
Output
From Overrided Test1
From Overrided test2

Before Java 8:
â¤ Interfaces could only contain abstract methods (no body).
â¤ If you added a new method to an interface, all implementing classes would break unless they implemented the new method.

âœ… Benefits of default Methods in Interfaces
1. Backward Compatibility
â¤ You can add new methods to interfaces without breaking existing implementations.
â¤ Existing classes donâ€™t need to override the new default method.

âœ…Example:
interface A {
    void m1();  // originally
    default void m2() { // added later
        System.out.println("Default m2");
    }
}

â¤ Even if old classes only implement m1(), they wonâ€™t break because m2() has a default body.
âœ… Example:
interface A {
    default void greet() {
        System.out.println("Hello from A");
    }
}
interface B {
    default void greet() {
        System.out.println("Hello from B");
    }
}
class C implements A, B {
    public void greet() {
        A.super.greet();  // resolve conflict
    }
}
â¤ This allows controlled multiple behavior inheritance.

2ï¸âƒ£ Functional Interface
â¤ A Functional Interface is an interface that has exactly one abstract (incomplete) method.
â¤ Can have multiple default or static methods (complete methods).
â¤ It enables lambda expressions and functional programming in Java.

ğŸ”¸ Key Points:
â¤ A functional interface must contain only one abstract method.
â¤ You can add any number of default or static methods (they're considered complete methods).
â¤ If the interface inherits more than one abstract method (from multiple interfaces), it no longer remains a functional interface, and the compiler throws an error.
â¤ Use @FunctionalInterface annotation to enforce the rule at compile-time.

âœ… Example 1:
@FunctionalInterface
public interface A {//âŒ Error Because it cannot have a ZERO incomplete method
}

âœ… Example 2:
@FunctionalInterface
public interface A {
	public void test1();
}
Output:  No Error because it has exactly one incomplete method

âœ… Example 3:
@FunctionalInterface
public interface A {//âŒ Error->A functional interface should consist of exactly one //incomplete method inside it
	public void test1();
	public void test2();
}

âœ… Example 4:
package p1;
@FunctionalInterface
public interface A {
	public void test1();
	default public void test2() {
		System.out.println("From Test 2");
	}
	default public void test3() {
		System.out.println("From Test 3");
	}
}
package p1;
public class B implements A {
	public static void main(String[] args) {
		B b1 = new B();
		b1.test1();
		b1.test2();
		b1.test3();
	}
	@Override
	public void test1() {
		System.out.println("From test 1");
	}
		
}
Output:
From test 1
From Test 2
From Test 3

âœ… Example 5:
package p1;
public interface A {
	public void test1();
}

package p1;
@FunctionalInterface
public interface B extends A{}
Output: No Error

âœ… Example 6:
package p1;
public interface A {
	public void test1();
	public void test2();
}

package p1;
@FunctionalInterface
public interface B extends A{}

Output:âŒ Error because we are inheriting 2 methods to a functional interface

âœ… Example 7:
package p1;
public interface A {
	public void test1();	
}

package p1;
@FunctionalInterface
public interface B extends A{
	public void test2();
}
Output:âŒ Error because we are inheriting 1 method from a functional interface, and a functional interface has 1 method, which totals to 2 methods in an interface

ğŸ”„Lambda Expression:
A Lambda Expression is a short block of code that:
â¤ Takes in parameters
â¤ Executes a body
â¤ Can be used in place of anonymous classes
â¤ Requires a functional interface to work

ğŸ”¸ Key Points:
â¤ Introduced in Java 8 â†’  Part of Javaâ€™s functional programming enhancements.
â¤ Reduces Code Length â†’ Allows writing concise code by eliminating boilerplate like anonymous class syntax.
â¤ Works With Functional Interfaces â†’ Lambda expressions can only be used where a functional interface (i.e., one abstract method) is expected.
â¤ Commonly Used in Stream API â†’ Lambdas  are widely used in filtering, mapping, sorting, and reducing data in the Java Stream API.

ğŸ”„ Syntax of Lambda Expression:
(parameters) -> { body }

Examples:
(x, y) -> x + y
name -> System.out.println("Hello " + name)
() -> System.out.println("No parameters")

âœ… How Lambda Expressions Work in Java?
â¤ It creates an anonymous class behind the scenes. A class without any name is called Anonymous.
â¤ Then the lambda expression creates an object and loads the method by implementing it inside the object.
â¤ Then we use an object reference to call that implemented method
â¤ Replacing instances of anonymous classes that implement functional interfaces with a concise, inline function-like syntax.

Example:
@FunctionalInterface
interface MyOperation {
    void perform(int x);
}

âœ… Lambda Expression
MyOperation op = () -> System.out.println("Hello");
op.perform();

â“ Why does this work without new?
âœ”ï¸ Yes â€” a lambda expression automatically creates an instance of the functional interface.
ğŸ”§ But technically: Itâ€™s not creating an anonymous class; it creates a synthetic implementation of the interface using invokedynamic bytecode â€” more lightweight and efficient than anonymous inner classes.

So: MyOperation op = (int x) -> { ... };

is syntactic sugar for:
MyOperation op = new MyOperation() {
    public void perform(int x) {
        // your lambda logic
    }
};

But the lambda version is shorter, cleaner, and faster.
âš¡ Note: Functional Programming defines you to say "what you want, not how to do it step-by-step"

âœ… Example 1:
package p1;
@FunctionalInterface
public interface A {
	public void test1();	
}
package p1;
public class B{
	public static void main(String[] args) {
		A a1 = ()->{
			System.out.println(100);
		};
		a1.test1();//Output: 100
	}
}

âœ… Example 2:
package p1;
@FunctionalInterface
public interface A {
	public void test1(int x);
	default public void test2() {
		System.out.println("test2");
	}
}
package p1;
public class B{
	public static void main(String[] args) {
		A a1 = (int y) -> {
			System.out.println(y);
		};
		a1.test1(100);// Output: 100
		a1.test2();// Output: test2
	}
}

âœ… Why were private methods added to interfaces in Java 9?
ğŸ” Types of Private Interface Methods (Java 9)
| Modifier         | Can Call From         | Description                         |
| ---------------- | --------------------- | ----------------------------------- |
| `private`        | Other default methods | Helps share common logic internally |
| `private static` | Other static methods  | Helps static methods reuse logic    |

âœ… Example: Private Methods in Interface
interface MyInterface {
    default void greet() {
        log("Hello from default method");
    }
    static void staticGreet() {
        logStatic("Hello from static method");
    }
    // âœ… Private instance method
    private void log(String message) {
        System.out.println("LOG: " + message);
    }
    // âœ… Private static method
    private static void logStatic(String message) {
        System.out.println("STATIC LOG: " + message);
    }
}

ğŸ‘‰ Usage:
public class Test implements MyInterface {
    public static void main(String[] args) {
        Test t = new Test();
        t.greet();
        MyInterface.staticGreet();
    }
}

âœ… Output:
LOG: Hello from the default method
STATIC LOG: Hello from static method

ğŸ¯ Key Benefits
â¤ Code reusability: Avoids repeating logic in multiple default/static methods.
â¤ Encapsulation: Keeps helper methods hidden from implementing classes.
â¤ Cleaner design: Interfaces can now follow DRY (Don't Repeat Yourself) more cleanly.

â“ Can private interface methods be accessed outside the interface?
âŒ No, only accessible within the interface for reuse by default/static methods.

â“ Can we override private interface methods?
âŒ No, private methods cannot be inherited or overridden.

â“ Are private methods mandatory in interfaces?
âŒ No, they are optionalâ€”use them to clean up repeated logic.

ğŸ”· Marker interface 
â¤ An empty interface is called a marker interface
â¤ Purpose: To mark a class as having a specific property so that JVM or frameworks can handle it differently at runtime.
Example:
1. java.io.Serializable
2. java.lang.Cloneable
3. java.util.RandomAccess

âœ… Abstract Class in Java
An abstract class in Java is a class that is declared with the abstract keyword. It cannot be instantiated directly and is typically used to provide a partial implementation that its subclasses must complete.

ğŸ”„ Key Features of Abstract Class
1ï¸âƒ£ Can Have Both Complete and Incomplete Methods
An abstract class can contain:
â¤ Complete methods (methods with body)
â¤ Incomplete methods (methods without a body)
â¤ To declare an incomplete method, the abstract keyword is mandatory.

abstract class Shape {
    abstract void draw();        // Incomplete method
    void color() {               // Complete method
        System.out.println("Coloring shape");
    }
}

2ï¸âƒ£ Can Have Both Static and Non-Static Members
You can define:
â¤ Static variables and methods
â¤ Non-static variables and methods

abstract class Demo {
    static int count = 0;
    int id;
    static void showCount() {
        System.out.println("Count = " + count);
    }
}

3ï¸âƒ£ Static Methods Must Be Complete
You cannot define abstract static methods.
â¤ Because static methods belong to the class, and abstract methods must be overridden, this contradicts the purpose.

abstract class Test {
    // abstract static void display(); âŒ Not allowed
    static void show() {         // âœ… Allowed
        System.out.println("Static method");
    }
}

4ï¸âƒ£ Can Have main() Method
â¤ An abstract class can contain the main() method and be used as the entry point of a Java program.

abstract class Launcher {
    public static void main(String[] args) {
        System.out.println("Main inside abstract class");
    }
}

5ï¸âƒ£ âŒ Cannot Instantiate an Abstract Class
â¤ You cannot create an object of an abstract class directly.
â¤ It may contain incomplete methods, so Java doesnâ€™t allow creating an object of something thatâ€™s not fully defined.

abstract class Animal {
    abstract void makeSound();
}

// Animal a = new Animal(); // âŒ Compile-time error

6ï¸âƒ£ Does Not Support Multiple Inheritance with Classes
â¤ Java does not allow multiple inheritance with classes (i.e., a class cannot extend more than one class, abstract or not).
â¤ This is to avoid ambiguity and diamond problems.

abstract class A {
    abstract void show();
}

abstract class B {
    abstract void show();
}

// class C extends A, B { } // âŒ Not allowed
Java solves this limitation using interfaces, which do support multiple inheritance.

âœ… Example 1:
package p1;
abstract public class A {
	public void test1() {}
	abstract public void test2();
	public static void test3() {}
	public static void test4();//âŒ Error
	public static void main(String[] args) {
		A a1 = new A();//âŒ Error
	}
}

âœ… Example 2: Error because multiple inheritance cannot be done
package p1;
abstract public class A {}
package p1;
abstract public class B{}

package p1;
public abstract class C extends A,B{//âŒ Error
}

ğŸ§  So, Why Use an Interface if an Abstract Class Can Have Abstract Methods?
â¤ Java doesn't support multiple inheritance for classes; interfaces allow it.
â¤ Interfaces are ideal for defining APIs and contracts, not implementations.
â¤ Use abstract classes when you want to provide a common base with shared code.
â¤ Use interfaces when you want to enforce a common behavior across unrelated classes.
â¤ All variables in an interface by default are final & static, whereas inside an abstract class, we can create static/non-static/final variables

âœ… Real-World Analogy:
| Concept        | Example                                                                     |
| -------------- | --------------------------------------------------------------------------- |
| Interface      | RemoteControl: defines buttons (on/off) â€” any brand can follow              |
| Abstract class | SamsungRemote: provides partial button logic, common to all Samsung remotes |

âœ… Example 1:
package p1;
abstract public class A {
	static int x = 10;
	public static void test() {
		System.out.println(100);
	}
	public static void main(String[] args) {
		System.out.println(A.x);//Output :10
		A.test();// Output: 100
	}
}

âœ… Example 2:
package p1;
abstract public class A {
	int x = 10;
	public void test() {
		System.out.println(100);
	}
}
package p1;
public class B extends A {
	public static void main(String[] args) {
		B b1 = new B();
		System.out.println(b1.x);// Outupt: 10
		b1.test();// Output: 100
	}
}

âœ… Example: Inheritance from interface-->abstract class-->class
package p1;
public interface A {
	public void test1();
}

package p1;
abstract public class B implements A {
	abstract public void test2();
}

package p1;
public class C extends B{
	@Override
	public void test1() {
		System.out.println("From test1");
	}
	@Override
	public void test2() {
		System.out.println("From test2");
	}
	public static void main(String[] args) {
		C c1 = new C();
		c1.test1();
		c1.test2();
	}
}

âš¡ Note: In Java 8, we can develop complete static methods & main method in an interface

âœ… Example:
package p1;
public interface A {
	static int x = 100;
	public static void test1() {
		System.out.println("From test1");
	}
	public static void main(String[] args) {
		System.out.println(A.x);// Output :100
		A.test1();// Output: From test1
	}
}

âœ… Exception and Exception Handling in Java
â“ What is an Exception?
â¤ An exception is an unexpected event that occurs during the execution of a program.
â¤ It disrupts the normal flow of the program and may cause it to terminate abruptly if not handled properly.

â“ Why Do Exceptions Occur?
They occur due to unforeseen errors like:
â¤ Invalid user input (e.g., dividing by zero)
â¤ Trying to access a null object
â¤ File not found
â¤ Network failure
â¤ They can happen at runtime, even if the code compiles successfully.

âœ… Example 1:
package p1;
public class A {
	public static void main(String[] args) {
		int x = 10;
		int y = 0;
		int z = x / y;//Stop Program Here
		System.out.println(z);
		System.out.println("Welcome");
	}
}
âœ… Output:
Exception in thread "main" java.lang.ArithmeticException: / by zero

ğŸ”· Exception handling
â¤ To handle exceptions, we will use a "try & catch" block in Java
â¤ When an exception occurs in the try block, it will create an exception object, and that object's address is given to the catch block. The catch block will suppress that exception, and further code will continue to execute

âœ… Example:
package p1;
public class A {
	public static void main(String[] args) {
		try {
			int x = 10;
			int y = 0;
			int z = x/y;
			System.out.println(z);
		} catch (Exception e) {
			e.printStackTrace();
		}
		System.out.println("Welcome");
	}
}

ğŸ”„ Types of Exception in Java
There are two types of exceptions in Java:
â¤ Compile Time / Checked Exception - These exceptions will occur when a .java file is compiled to a .class file. That is, during compilation, we will get this exception.
â¤ Runtime / Unchecked Exception - These exceptions will occur when we run a .class file. That is during runtime

ğŸ”· Runtime / unchecked Exceptions
1ï¸âƒ£ ArithmeticException: This exception will occur when invalid mathematical operations are performed

âœ… Example:
package p1;
public class A {
	public static void main(String[] args) {
		try {
			int x = 10;
			int y = 0;
			int z = x/y;// same for modulus %0
			System.out.println(z);
		} catch (ArithmeticException a) {
			a.printStackTrace();
		}
		System.out.println("Welcome");
	}
}
âœ… Output:
java.lang.ArithmeticException: / by zero
Welcome

2ï¸âƒ£ Null Pointer Exception: This exception will occur when with null reference variable we try to access non-static members of the class
âœ… Example 1:
package p1;
public class A {
	int x = 10;
	public static void main(String[] args) {
		try {
			A a1 = null;
			System.out.println(a1.x);
		} catch (NullPointerException e) {
			e.printStackTrace();
		}
		System.out.println("Welcome");
	}
}
âœ… Output:
java.lang.NullPointerException: Cannot read field "x" because "a1" is null
Welcome

âœ… Example 2: Can access static members without the object creation
package p1;
public class A {
	static int x = 10;
	public static void main(String[] args) {
		try {
			A a1 = null;
			System.out.println(a1.x);//A.x  Output: 10
		} catch (NullPointerException e) {
			e.printStackTrace();
		}
		System.out.println("Welcome");//Output: Welcome
	}
}

ğŸ”· Unary Operators in Java
1ï¸âƒ£ Increment Operator
   âœ”ï¸  Post-Increment: Increment the value of the variable next time you see the same variable
âœ… Example 1:
package p1;

public class A {
	public static void main(String[] args) {
		int i=0;
		int j = i++;
		int k=10;
		int l=k++ + k++ + k++;
		System.out.println(i);//Output: 1
		System.out.println(j);// Output: 0
		System.out.println(k);//Output: 13
		System.out.println(l);// Output: 33
	} 
}
   âœ”ï¸ Pre-Increment: Increment the value of the variable in the same step
âœ… Example 1:
package p1;

public class A {
	public static void main(String[] args) {
		int i=10;		
		int j = ++i;
		int k=10;
		int l=++k + ++k + ++k;
		System.out.println(i);// Output: 11
		System.out.println(j);// Output: 11
		System.out.println(k);// Output: 13
		System.out.println(l);// Output: 36
	} 	
}
2ï¸âƒ£ Decrement Operator
   âœ”ï¸ Post Decrement: Here we decrement the value of i by 1 when we next time see the same variable:

âœ… Example:
package p1;

public class A {
    public static void main(String[] args) {
        int a = 10;
        int b = a-- + a--; 
	int x = 10;
        int y = x-- + x++ + x-- + x--; 
        System.out.println(a); //Output: 8
        System.out.println(b); //Output: 19
        System.out.println(x); //Output: 8
        System.out.println(y); //Output: 38
    }
}
   âœ”ï¸ Pre Decrement: Here we decrement the value of the variable in the same step by 1

âœ… Example 1:
package p1;

public class A {
	public static void main(String[] args) {
		int i=10;		
		int j = --i + --i;
		System.out.println(i);
		System.out.println(j);
	} 
}

âœ… Type Casting of Data Types in Java
In Java, type casting is used to convert a variable of one data type into another. This is commonly done between primitive types or object references (in case of inheritance).

ğŸ”„ 1. Type Casting Between Primitive Data Types
There are two types:

1ï¸âƒ£ Widening Casting (Implicit & Upcasting)
â¤ Smaller type â†’ Larger type
â¤ Safe, automatic, without any loss of data

byte â†’ short â†’ int â†’ long â†’ float â†’ double

âœ… Example:
int a = 10;
double b = a;  // int to double (widening)
double x=10.3d;
long y=x; // Larger -> Smaller, there is a loss of data so it will give an error.

2ï¸âƒ£ Narrowing Casting (Explicit & Downcasting)
â¤ Larger type â†’ Smaller type
â¤ Risky, must be done manually using cast () 
â¤ Loss of data can take place

double â†’ float â†’ long â†’ int â†’ short â†’ byte

âœ… Example:
double x = 10.99;
long i=10;
int y = (int) x;  // output: 10 double to int (narrowing)
byte j=i; // ----------> âŒ Throws error

âœ… Example:
long i=100;
byte j=(byte)(int)i; //multiple downcasting is possible

âœ… Example:
int i=100;
long j=(long)i; // No error

ğŸ” Why is float â†’ long considered downcasting, even though size increases?
Because type casting in Java is not only about memory size, but also about type compatibility and precision:

â— float â†’ long is narrowing because:
â¤ You are going from floating-point to integer, which involves:
â¤ Loss of precision (decimal part is truncated)
â¤ Potential data loss if the value is too large
â¤ Even if you're increasing memory size, you're going from a more complex representation (float) to a simpler one (integer).

Primitive    Wrapper Class
byte		Byte
short		Short
int			Integer
long		Long
float		Float
double		Double
char		Character

âœ… Example 1: I want to convert a String to an Integer
public class A {
	public static void main(String[] args) {
		String x = "100";
		int  y = Integer.parseInt(x);
		System.out.println(y);
	}
}

âœ… Example 2:I want to convert a String to a Float
float  y = Float.parseFloat(x);

âœ… Example 3:I want to convert a String to a Double
double  y = Double.parseDouble(x);

âœ… Example 4:
package p1;

public class A {
	public static void main(String[] args) {
		try {
			String x = "10.3dasdsd";
			double  y = Double.parseDouble(x);
			System.out.println(y);
		} catch (NumberFormatException e) {
			e.printStackTrace();
		}
		System.out.println("Welcome");
		
	}
}
âœ… Output:
java.lang.NumberFormatException: For input string: "10.3dasdsd"
Welcome

â“ What is class upcasting?
â¤ Here we store the child class object address into the parent class reference variable, so that the reference variable becomes reusable

âœ… Example: Reusing a reference variable

public class A {}
public class B extends A{}

public class C extends A{
	public static void main(String[] args) {
		A a1 = new B();
		System.out.println(a1);
		a1 = new C();
		System.out.println(a1);
	}
}

âœ… Example 2: How can we implement polymorphism for multiple child classes by using the same reference variable
public class A {
	void display() {
        System.out.println("Inside class A");
    }
}

public class B extends A{
	 @Override
	    void display() {
	        System.out.println("Inside class B");
	    }
}

public class C extends A{
	  @Override
	    void display() {
	        System.out.println("Inside class C");
	    }
	public static void main(String[] args) {		
		A a1 = new B();
		a1.display();    // Calls B's version => "Inside class B"
		a1 = new C();
		a1.display();    // Calls C's version => "Inside class C"
	}
}

â“ Why do we do it?
â¤ To reuse the parent class reference for multiple child class objects.
â¤ To enable polymorphism on multiple child classes.
â¤ To write generic, flexible code that works with different subclasses.

âœ…Example:
class A {
    void display() {
        System.out.println("Inside A");
    }
    void onlyInA() {
        System.out.println("Method only in A");
    }
}

class B extends A {
    @Override
    void display() {
        System.out.println("Inside B");
    }
    void onlyInB() {
        System.out.println("Method only in B");
    }
}

public class Test {
    public static void main(String[] args) {
        A a1 = new B();   // Reference of A, object of B

        a1.display();   // âœ… Allowed, prints "Inside B" (runtime polymorphism)
        a1.onlyInA();   // âœ… Allowed, prints "Method only in A"
        
        // a1.onlyInB(); // âŒ Compile-time error (reference type A doesnâ€™t know Bâ€™s extra methods)
    }
}


Note:
âœ”ï¸ instanceof - It will check which class object address is present inside the reference variable

âœ… Example:

public class A {}

public class B extends A{}

public class C extends A{	 
	public static void main(String[] args) {
				
	  A a1 = new B();
	  System.out.println(a1 instanceof B);// Output: true
	}
}

What is class downcasting?
â¤ Here we store the parent class object address into the child class reference variable
â¤ To perform downcasting, first do upcasting and then perform downcasting
âœ… Example:
public class A {}
public class B extends A{}

public class C extends A{	 
	public static void main(String[] args) {
		A a1 = new B();
		if(a1 instanceof B) {
			B b1 = (B)a1;
			System.out.println("Downcasting successful!");
		}
	}
}

âœ… Example:
class Vehicle {
    void start() {
        System.out.println("Vehicle started");
    }
}

class Car extends Vehicle {
    void openTrunk() {
        System.out.println("Trunk is open");
    }
}

class Bike extends Vehicle {
    void kickStart() {
        System.out.println("Bike started with a kick");
    }
}

public class DowncastingDemo {
    public static void main(String[] args) {
        Vehicle v1 = new Car();   // Upcasting (Car â†’ Vehicle)
        Vehicle v2 = new Bike();  // Upcasting (Bike â†’ Vehicle)

        v1.start();  // Vehicle started
        v2.start();  // Vehicle started

        // âœ… Downcasting to access Car-specific method
        if(v1 instanceof Car) {
            Car c = (Car) v1;
            c.openTrunk();   // "Trunk is open"
        }

        // âœ… Downcasting to access Bike-specific method
        if(v2 instanceof Bike) {
            Bike b = (Bike) v2;
            b.kickStart();   // "Bike started with a kick"
        }
    }
}

Note:
â¤ Using upcasting, we can access only parent class members, you cannot access child class members
â¤ After upcasting to access child class members, we have to perform downcasting


ğŸ”· Arrays in Java
ğŸ”„ Arrays Hold a Collection of Values
â¤ An array is a container object that can hold a fixed number of elements of the same data type.
â¤ Instead of creating multiple individual variables for related values (like 10 integers), we can store all of them in one array.

ğŸ”„ Anything That Holds a Collection of Values is Called a Data Structure
â¤ Arrays are one of the simplest and most fundamental data structures.
â¤ A data structure is a way to organize and store data efficiently for easy access and modification.
â¤ Arrays serve as the base for many advanced data structures (like lists, stacks, queues, etc.).

ğŸ”„ An array in Java is Treated as an Object
â¤ In Java, arrays are not primitive types (like int, char, etc.)â€”they are objects.
â¤ This means they are created using the new keyword internally.
â¤ Being objects, they:
	âœ”ï¸ Have a runtime class type
	âœ”ï¸ Inherit methods from the Object class
	âœ”ï¸ Have properties like .length to determine their size

ğŸ”„ Arrays Start With Index Zero
â¤ Array indexing in Java is zero-based.
â¤ The first element is accessed with index 0, the second with 1, and so on.
â¤ So, for an array of size n, the last valid index is n-1.

ğŸ”„ To Store and Read Values We Use: start_address + index Ã— memory_size
â¤ Internally, the array elements are stored sequentially in memory.
â¤ The memory address of any element can be calculated using:

ğŸ”— Address = BaseÂ Address + (IndexÃ—SizeÂ ofÂ EachÂ Element)
â¤ This allows direct access to any element using its index in constant time O(1), which makes arrays efficient for random access.

ğŸ”„ Memory Allocation Happens in Sequence (Contiguous Allocation)
â¤ When an array is created, Java allocates a block of continuous memory locations to store its elements.
â¤ This contiguous allocation ensures that:
	âœ”ï¸ Each element is placed right after the previous one in memory.
	âœ”ï¸ Accessing any element is fast using index-based computation.
	âœ”ï¸ But the array size cannot change after creation (fixed size limitation).

âœ… Example 1:
package p1;
public class A {
	public static void main(String[] args) {
		int[] age = new int[4];
		age[0] = 90;
		age[1] = 89;
		System.out.println(age[0]);
		System.out.println(age[1]);
	} 
}
â¤ To find the size of an array dynamically, we will use the  public final field "length". When the array is created this variable will get initialized

âœ… Example 2:
package p1;

public class A {
	public static void main(String[] args) {
		int[] age = new int[40];
		System.out.println(age.length);// Output :40
	} 
}

ğŸ”· Scanner class - Is used to provide user input

âœ… Example 1:
package p1;
import java.util.Scanner;
public class A {
	public static void main(String[] args) {
		
		Scanner scan = new Scanner(System.in);
		System.out.println("Enter your name:");
		String name = scan.next();//Can read one String word only
		System.out.println("Your name is "+name);
		System.out.println("Enter your age:");
		int age = scan.nextInt();//Can read on Integer value only
		System.out.println("Your age is "+age);
		System.out.println("Enter your weight:");
		float weight = scan.nextFloat();//Can read on float values
		System.out.println("Your weight is "+weight);
		System.out.println("Enter your Answer:");
		boolean ans = scan.nextBoolean();//Can read on boolean values
		System.out.println("Your ans is "+ans);
		scan.close();
		
	} 
	
}

âœ… Output:
Enter your name:
mike
Your name is Mike
Enter your age:
100
Your age is 100
Enter your weight:
98.34
Your weight is 98.34
Enter your Answer:
true
Your ans is true

âœ… Example 2: How to read multiple String words using the nextLine() method
package p1;
import java.util.Scanner;
public class A {
	public static void main(String[] args) {	
		Scanner scan = new Scanner(System.in);
		System.out.println("Enter your name:");
		String name = scan.nextLine(); //Can read Multiple String words
		System.out.println(name);
		scan.close();
	} 	
}
âš ï¸ Note:
â¤ Always close the scanner with sc.close() to free system resources.
â¤ Use nextLine() carefully after nextInt() or next() due to newline issues.

âš ï¸ Issue: nextLine() after nextInt() or next() doesn't behave as expected.
âš ï¸ Root Cause:
â¤ Methods like nextInt(), nextDouble(), and next() do not consume the newline character (\n) at the end of user input.
â¤ But nextLine() does consume the full line, including the newline.

So, if you call nextLine() immediately after nextInt() or next(), it may read the leftover newline from the previous input, resulting in an empty string.

âœ… Example:
Scanner sc = new Scanner(System.in);

System.out.print("Enter age: ");
int age = sc.nextInt();  // user enters: 25 + [Enter]

System.out.print("Enter name: ");
String name = sc.nextLine();  // reads leftover '\n' from above

System.out.println("Age: " + age);
System.out.println("Name: " + name);

âœ… Output:
Enter age: 25
Enter name:
Age: 25
Name:
â—Oops! name is empty because nextLine() consumed the leftover newline from nextInt().

âœ… How to Fix It:
Solution: Add a sc.nextLine() dummy call after nextInt() or next() to consume the leftover newline.

System.out.print("Enter age: ");
int age = sc.nextInt();
sc.nextLine(); // â† eat the leftover newline

System.out.print("Enter name: ");
String name = sc.nextLine();

ğŸ”· IIB â€” Instance Initialization Block
â¤ It runs every time an object is created, before the constructor, and is used to initialize instance (non-static) data.
â¤ You can think of an IIB as an anonymous constructor fragment that runs before the real constructor.
âœ…Example:
package p1;

public class iiBTutorial {
	int i;
	int j;
	static int k;
	static void test() {
		System.out.println("Test method called");
	}
	{
		i = 10;
		j = 20;
		System.out.println("Intance Initialization Block 1 called");
		System.out.println("The value of i: " + i);
		System.out.println("The value of j: " + j);
		System.out.println("The value of k: " + k);
		test();
		// new iiBTutorial();-----------> recursive calling of IIB stack overflow, cannot create object inside IIB
	}
	{
		System.out.println("Intance Initialization Block 2 called");
	}

	iiBTutorial() {
		System.out.println("B constructor called");
	}

	public static void main(String[] args) {
		iiBTutorial b1 = new iiBTutorial();
		test();
	}
}

When you create an object, Java executes:
1ï¸âƒ£ Instance variable initializations
2ï¸âƒ£ IIB block(s) (in the order they appear)
3ï¸âƒ£ Constructor

â¤ Use Case: To initialize instance variables or logic common to all constructors.
â¤ Runs whenever an object creation takes place.
â¤ Every time a new object is created, IIB runs.

âœ… When to Use IIB?
â¤ When all constructors need to run some common code.
â¤ To reduce duplication across overloaded constructors.

Note: A Static variable/method can be accessed inside the IIB

ğŸ”· SIB â€” Static Initialization Block
â¤ It runs once when the class is loaded, before the main() method or any static method/variable is accessed.

âœ…Example:
package p1;
public class SIBTutorial {
	static int i;
	int j;
	static {
		System.out.println("Static Initialization Block-1 called");
		System.out.println("The value of i "+i);
		i=20;
		j=10;//âŒ cannot initialize instance variable inside SIB
		System.out.println("The value of i "+i);	
	}
	static {
		System.out.println("Static Initialization Block-2 called");
	}
	public static void main(String[] args) {}
}

Order of Execution:
â¤ Static variable initializations
â¤ SIB block(s) (in the order they appear)
â¤ Main method

ğŸ”¥ Use Case:
â¤ Initialize static variables
â¤ Load configuration, logging, or static resources
â¤ Run a one-time setup for the class

âœ… Example 2: We can create an object inside SIB through which IIB and the constructor can be called.
package p1;
public class A {
	{
		System.out.println("IIB");// Print 1
	}
	static {
		new A();
		System.out.println("SIB"); // Print 3
	}
	A(){
		System.out.println("Constructor of A called");// Print 2
	}
	public static void main(String[] args) {
		System.out.println("Entered Main");// Print 4
	}
}

âœ… Output 
IIB
Constructor of A called
SIB
Entered Main

ğŸ”· Super in Java
â¤ The super keyword is a reference variable used within a subclass to refer to its immediate parent class (superclass) members, including variables, methods, and constructors.
â¤ It helps achieve proper inheritance behavior and overriding control.

ğŸ”„ Uses of super in Java
1ï¸âƒ£ Access Parent Class Fields (Variables)
When the subclass has a variable with the same name as the parent class, super helps distinguish the parent class version.
It cannot access the private members of the super class.

ğŸ“ Real-World Analogy
Imagine super as saying:
"Hey, I want the version of this thing that came from my parent class."
Just like a child might say:
"I want to use my dadâ€™s phone, not mine â€” because it's different."

âœ… Example:
class A {
    int num = 10;
}
class B extends A {
    int num = 20;
    void display() {
        System.out.println("Child num: " + num);       // 20
        System.out.println("Parent num: " + super.num); // 10
    }
}

2ï¸âƒ£ Call Parent Class Methods
If the child class overrides a method, but you still want to call the parent version, use super.methodName().

âœ… Example:
public class A {
	 int x = 10;
	 static int y=20;
	  static void display() {
		  System.out.println("This is a static display method");
	  }
	    void show() {
	        System.out.println("In class A");
	    }
}

public class B extends A {
	public static void main(String[] args) {
		B b1=new B();
		b1.test();	
	}
	public void test() {
		super.display();
		System.out.println(super.x);
		System.out.println(super.y);	
	}
}

âœ… What This Means:
â¤ Super is meant to refer to instance (non-static) members of a superclass.
â¤ Even though it is technically possible to write super.staticMethod() in Java, it is discouraged, and Java treats it the same as ParentClass.staticMethod() internally.
â¤ So, it's not a compiler error, but a bad practice.

âœ… Best Practice:
Always access static members using the class name, not super or this.
ğŸ”— ParentClass.staticMethod(); // Good
ğŸ”— super.staticMethod(); // Bad (misleading)

3ï¸âƒ£ Call Parent Class Constructor
â¤ super() is used to call the constructor of the parent class from the child class constructor only.
â¤ This must be the first statement in the subclass constructor; Hence, super and this keyword cannot be used at the same time.
â¤ If in the Child class constructor, this keyword is used, then in that constructor super keyword will not be automatically placed.

âœ… Example:
class A {
    A() {
        System.out.println("Constructor of A");
    }
}
class B extends A {
    B() {
        super();  // Must be first statement
        System.out.println("Constructor of B");
    }
}
âœ… Output:
Constructor of A
Constructor of B

â¤ Even though you didnâ€™t write super() in class B, Java internally adds it:
	âœ”ï¸ Even If we don't explicitly write the constructor, Java internally calls the constructor and add the super() keyword inside it(but only calls the default constructor of the parent class).

B() {
    super(); // inserted automatically by compiler
    System.out.println("Constructor of B");
}

ğŸ¯ Why use it?
â¤ To ensure proper construction of the inheritance chain
â¤ To pass values to a parameterized parent constructor

4ï¸âƒ£ Use with Parameterized Constructors
class A {
    A(String msg) {
        System.out.println("Message from A: " + msg);
    }
}
class B extends A {
    B() {
        super("Hello"); // Pass value to superclass constructor
        System.out.println("Constructor of B");
    }
}

âŒ super is not allowed in static methods
â¤ The super keyword refers to the current objectâ€™s superclass, but static methods belong to the class, not to any object.

âœ… Example:
class A {
    int x = 10;
    static void staticShow() {
        System.out.println("Static method in A");
    }
}
class B extends A {
    static void staticTest() {
        // System.out.println(super.x); âŒ Compile-time error
        // super.staticShow();          âŒ Compile-time error
    }
}
ğŸš« Both lines give:
Cannot use 'super' in a static context

â“ Why This Causes an ErrorâŒ
â¤ Static methods do not have a this reference, because they can be called without creating an object.
â¤ Since super is used to refer to the parent of this object, and this doesn't exist in a static context, super becomes invalid there.

âœ… What You Can Do in Static Methods:
If you need to access static members of the parent class in a static method:
A.staticShow();  // âœ… Correct
System.out.println(A.someStaticVariable);  // âœ… Correct

ğŸ”· Loops in Java
1ï¸âƒ£ for loop

âœ… Example 1;
public class A {
	public static void main(String[] args) {
		for (int i = 0; i < 4; i++) { //0 to 3
			System.out.println(i);
		}
	} 
}

ğŸ”„ break keyword
â¤ Can be used only inside loops and switch case statements
â¤ It stops the for loop execution

âœ… Example 2:
â¤ The user will enter the PIN 1234
â¤ If the entered PIN is valid, then the program should print Welcome and stop
â¤ If the PIN is invalid, the user can attempt to enter it a maximum of three times.
â¤ If all 3 times the PIN is invalid, then the card is blocked message we should get

package p1;
import java.util.Scanner;
public class A {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		
		for(int i=0;i<3;i++) {//0 to 2
			System.out.println("Enter the pin number");
			int pinNumber = scan.nextInt();
			if(pinNumber==1234) {
				System.out.println("Welcome");
				break;
			}else {
				System.out.println("Invalid Pin number");
				if(i==2) {
					System.out.println("Card is blocked");
				}
			}
		}
		scan.close();
	} 
}

2ï¸âƒ£ while loop
âœ… Example 1:
package p1;
public class A {
	public static void main(String[] args) {
		int i=0;
		while(i<3) {//If condition true will enter while loop
			System.out.println(i);
			i++;
		}
	}	
}

âœ… Example 2:
â¤ Enter the amount, and we should get a message, please collect cash
â¤ Then prompt a message: Do you want to continue(yes or no)
â¤ If yes, again enter the amount, and we should get a message, please collect cash
â¤ If no program is entered, it should stop

import java.util.Scanner;

public class A {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		String i="yes";
		while(i.equals("yes")) {//If condition true will enter while loop
			System.out.println("Enter the amount");
			int amount = scan.nextInt();
			System.out.println("Please collect the cash: rs. "+amount);
			System.out.println("Do you want to continue(yes/no)?");
			i = scan.next();
			
			if(i.equals("no")) {
				System.out.println("Thank you. Visit again");
			}
		}
	}
}

3ï¸âƒ£ do while loop -  Will run first time without condition check. For the second iteration, the condition will be evaluated

âœ… Example 1:

package p1;
public class A {
	public static void main(String[] args) {
		int i=100;
		do {
			System.out.println(i);
			i++;
		}while(i<3);
	}	
}

âœ… Example 2:
package p1;
public class A {
	public static void main(String[] args) {
		int i=0;
		do {
			System.out.println(i);
			i++;
		}while(i<3);
	}	
}

4ï¸âƒ£ for each loop - 
â¤ Works only with a data structure
â¤ Can only read the value of the data structure one by one
â¤ The loop will run until all values are read in the given data structure

âœ… Example:
package p1;
public class A {
	public static void main(String[] args) {
		int[] age = new int[3];
		age[0] = 100;
		age[1] = 101;
		age[2] = 120;
		
		for(int x:age) {
			System.out.println(x);
		}
	}
}

ğŸ”„ Continuation of Arrays using Loops:
âœ… Example 1:
package p1;
public class A {
	public static void main(String[] args) {
		int[] age = new int[3];
		age[0] = 100;
		age[1] = 101;
		age[2] = 120;
		
		for (int i = 0; i < age.length; i++) {//0 to 2
			System.out.println(age[i]);
		}
	}
}

ğŸ”„ ArrayIndexOutOfBoundsException
â¤ When we exceed the array size, we get this exception

âœ… Example:
package p1;
public class A {
	public static void main(String[] args) {
		try {
			int[] age = new int[3];
			age[0] = 100;
			age[1] = 101;
			age[2] = 120;
			age[3] = 103;
		} catch (Exception e) {
			e.printStackTrace();
		}
		System.out.println("Welcome");
	}
}

âœ… Output:
java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3
Welcome

ğŸ”„ Continue Keyword in Java
â¤ The continue keyword is used inside loops (for, while, or do-while) to skip the current iteration and jump to the next one.

âœ…Example:
package p1;
public class A {
	public static void main(String[] args) {
		for (int i = 0; i < 5; i++) {
			
			if(i==3) {
				continue;
			}
			System.out.println(i);//0 1 2 4
		}
	}
}
âœ… Output:
0
1
2
4

ğŸ”„ else-if ladder statement
â¤ If the user enters yes, it should print pass
â¤ If the user enters no, it should print fail
â¤ If the user enters something else, it should print invalid input

âœ… Example:
package p1;

import java.util.Scanner;

public class A {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		System.out.println("Enter the input(yes/no)");
		String value = scan.next();
		if(value.equals("yes")) {
			System.out.println("Pass");
		} else if(value.equals("no")) {
			System.out.println("Fail");
		} else {
			System.out.println("Invalid Input");
		}
	}	
}

ğŸ”„ Switch Case
âœ…Example:
package p1;

import java.util.Scanner;

public class A {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		System.out.println("Enter the floor number");
		int key=scan.nextInt();
		switch (key) {
		case 1:
			System.out.println("1st Floor");
			break;
		case 2:
			System.out.println("2nd Floor");
			break;
		case 3:
			System.out.println("3rd Floor");
			break;
		default:
			System.out.println("Invalid input");
			break;
		}
	}	
}

ğŸ”· Coding Questions
1ï¸âƒ£ Removing Duplicate elements from an array
â¤ For the below logic array should be sorted

Steps:
1. Create a temp array which same size as that of x
int[] x = {3,3,4,5,6,6,7};
int[] temp = new int[x.length];

2. Compare i with i+1 of array x, if not equal copy the value from x[i] to temp[j] and increment j by 1

3. When you reach last index of array x, copy that value directly to temp[j];

ğŸ”— Code:

package p1;
public class A {
	public static void main(String[] args) {
		int[] x = {3,3,4,5,6,6};
		int[] temp = new int[x.length];
		int j=0;
		for(int i=0;i<x.length-1;i++) {//i=5
			if(x[i]!=x[i+1]) {//with index 5 to 6
				temp[j] = x[i];
				j++;
			}
		}
		temp[j] = x[x.length-1];
		
		for(int arr:temp) {
			System.out.println(arr);
		}
	}
}

2ï¸âƒ£ Logic For Swapping

ğŸ”— Code:
package p1;
public class A {
	public static void main(String[] args) {
		int x = 10;
		int y = 20;
		int temp;
		temp=y;
		y=x;
		x=temp;
		System.out.println(x);
		System.out.println(y);
	}
}

ğŸ”· File Handling in Java
â¤ File handling allows Java programs to create, read, write, and delete files or directories stored on disk.
â¤ Java uses the java.io, java.nio.file, and java.util packages for file operations.

âœ… Example:

package p1;
import java.io.File;
public class A {
	public static void main(String[] args) {
		File f = new File("E:\\april\\t1.txt");
		System.out.println(f);
	}
}

File f = new File("E:\\april\\t1.txt");
â¤ This line does not check whether the file exists.
â¤ It simply creates a File object representing the given path.
â¤ That means you're just wrapping a file path inside a File object.

System.out.println(f);
â¤ This prints the path stored in the object â€” it does not interact with the actual file.

âœ… exists() Method in Java
â¤ It is a non-static method present inside the File class
â¤ The return type of this method is boolean
â¤ It checks whether the file exists in the given path.

ğŸ’¡ Interview Insights
â“ Does it check only files or also directories?
â¤ It checks both files and directories.
â¤ exists() does not distinguish between files and directories.
â¤ Use isFile() or isDirectory() to differentiate.

ğŸ”— Code:
if (f.exists()) {
    if (f.isFile()) System.out.println("It's a file.");
    if (f.isDirectory()) System.out.println("It's a directory.");
}
â¤ If the file exists, it will return true, else false.

ğŸ” Syntax
File f = new File("path_to_file");
boolean result = f.exists(); //if exist then true otherwise than false

âœ… Example:

package p1;
import java.io.File;
public class A {
	public static void main(String[] args) {
		File f = new File("G:\\april\\t100.txt");
		boolean val = f.exists();
		System.out.println(val); // true or false based on file existence
	}
}

âœ… delete() Method in Java
â¤ It is a non-static method present inside the File class
â¤ The return type of this method is boolean
â¤ It deletes the file that exists in the given path.
â¤ If the file is deleted, it will return true, else false

ğŸ” Syntax
File f = new File("path_to_file");
boolean result = f.delete();

ğŸ’¡ Interview Insights
â“ How can you delete a directory with files in it?
You must recursively delete all contents before deleting the directory.

âœ… Example:

package p1;
import java.io.File;
public class A {
	public static void main(String[] args) {
		File f = new File("G:\\april\\t1.txt");
		boolean val = f.delete();
		System.out.println(val);
	}
}

âš™ï¸ Interview Exercise
â“ How would you delete a non-empty folder in Java?

ğŸ”— Code:
public static void deleteDirectory(File dir) {
    if (dir.isDirectory()) {
        for (File file : dir.listFiles()) {
            deleteDirectory(file);
        }
    }
    dir.delete(); // delete files/subdirs and finally the directory itself
}

âœ… mkdir() Method in Java
â¤ It is a non-static method present inside the File class
â¤ The return type of this method is boolean
â¤ It creates a folder in the given path.
â¤ If a folder is created, it will return true, else false
â¤ It will neither replace the existing folder nor overwrite it.

ğŸ” Syntax
File f = new File("path_to_directory");
boolean created = f.mkdir();

ğŸ’¡ Interview Insights
â“ Will mkdir() create parent folders if they donâ€™t exist?
âŒ No. It will return false if the parent directory is missing.

â“ Whatâ€™s the difference between mkdir() and mkdirs()?
â¤ mkdir() â†’ Creates only the last directory if the parent exists
â¤ mkdirs() â†’ Creates entire directory hierarchy if needed

ğŸ§  Bonus Tip for Interviews
If you want to create nested directories like G:\\april\\p2\\test\\demo, use:

File f = new File("G:\\april\\p2\\test\\demo");
f.mkdirs();  // creates all non-existing parent directories

âœ… Example:
package p1;
import java.io.File;
public class A {
	public static void main(String[] args) {
		File f = new File("G:\\april\\p2");
		boolean val = f.mkdir(); // true if created, false if already exists or parent missing
		System.out.println(val);
	}
}

âœ… Deleting Folders Using delete() in Java
ğŸ” Syntax
File f = new File("path_to_folder");
boolean result = f.delete();

ğŸ’¡ Interview Insights
â“ What happens if the folder contains files/subfolders?
âŒ delete() will fail and return false.
â¤ We have to use the recursive deletion method to delete a non-empty directory.

ğŸ”— Code:
public class A {
	public static void main(String[] args) {
		File f = new File("G:\\april\\p2"); // p2 must be empty
		boolean val = f.delete();
		System.out.println(val);
	}
}

Note: The delete() method can delete both folders/files

âœ… length() Method in Java
â¤ It is a non-static method present inside the File class
â¤ The return type of this method is long
â¤ length() returns size in bytes, not characters.
1 character â‰  1 byte always (especially in UTF-8 or Unicode encoding)
â¤ White spaces and new lines are also counted as bytes.
â¤ Not valid for directories â†’ returns 0 if used on a directory.

ğŸ” Syntax
File f = new File("path_to_file");
long size = f.length();

ğŸ’¡ Interview Insights
â“ What if the file doesn't exist?
â¤ Returns 0, doesn't throw an exception.

â“ Can length() be used to measure file upload size?
â¤ Yes, if used carefully. But beware of file encoding differences.

â“ Is length() affected by file encoding?
â¤ Yes â€” different encodings may change the byte count.

âœ… Example:
package p1;
import java.io.File;
public class A {
	public static void main(String[] args) {
		File f = new File("G:\\april\\t1.txt");
		long val = f.length();
		System.out.println(val);
	}
}

ğŸ§ª Bonus Tip: For Directory Size (Advanced)
ğŸ”— Code:
public static long folderSize(File folder) {
    long total = 0;
    for (File f: folder.listFiles()) {
        if (f.isFile())
            total += f.length();
        else
            total += folderSize(f);
    }
    return total;
}

ğŸ”· Compile-time Exception/Checked Exception
â¤ Checked Exceptions are exceptions that are checked at compile time.
â¤ The Java compiler forces you to either handle them using try-catch or declare them using throws.
â¤ These exceptions must be addressed in code; otherwise, the code will not compile.

âœ… createNewFile()
â¤ createNewFile() is a non-static method in the java.io.File class.
â¤ It attempts to create a new file in the specified path.
â¤ If the file already exists, it does not replace it â€” instead, it returns false.

âœ… Example:
package p1;
import java.io.File;
import java.io.IOException;
public class A {
	public static void main(String[] args) {
		try {
			File f = new File("G:\\april\\t1.txt");
			boolean val = f.createNewFile();
			System.out.println(val);
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}

ğŸ§  Insights
â“ Will the file be created if the path doesn't exist?
âŒ No, intermediate folders must already exist. Otherwise, it throws an exception.

â“ Can createNewFile() create folders?
âŒ No, it is only for creating files, not directories. Use mkdir() for folders.

ğŸ”· IOException in Java
â¤ IOException is a checked exception in Java.
â¤ It is part of the java.io package.
â¤ It is thrown when an Input/Output operation fails or is interrupted.

ğŸ“Œ Class Signature
public class IOException extends Exception

ğŸ“‚ Common Scenarios Where IOException Occurs
| ğŸ” Scenario            | ğŸ’¡ Example                                           |
| ----------------------  | -----------------------------------------------------|
| ğŸ“ File not found      | Reading a file that doesn't exist (`FileInputStream`) |
| ğŸ”’ File not readable   | Accessing a file without permission                   |
| ğŸŒ Network I/O failure | Socket gets disconnected during data transfer         |
| âŒ Stream closed       | Reading from or writing to a closed stream            |
| ğŸ’¾ Full disk           | Writing to disk when no space is available            |

âœ… list() Method
â¤ list() is a non-static method present in the java.io.File class.
â¤ It returns a String[] array containing the names of files and directories in the current directory.
â¤ It does not include absolute or full pathsâ€”just the names.
â¤ To get the full path use listFiles() instead of list().

ğŸ“Œ Syntax
public String[] list()

âœ… Example:
package p1;
import java.io.File;
public class A {
	public static void main(String[] args) {
			File f = new File("G:\\april\\");
			String[] val = f.list();
			for(String x: val) {
				System.out.println(x);
			}
			System.out.println(val.length);
	}
}

ğŸ§  Insights
â“ What is returned if the file object is not a directory?
âŒ null is returned, not an empty array â€” interview trap

ğŸ§ª Common Mistakes (Interview Traps)
| âŒ Mistake                                                | âœ… Correct Understanding                                               |
| --------------------------------------------------------- | ----------------------------------------------------------------------- |
| Assuming `list()` works on files                          | `list()` only works on directories                                      |
| Expecting full paths                                      | It returns only names, not full paths                                   |
| Not checking for `null`                                   | Always check if `list()` returns `null` to avoid `NullPointerException` |
| Not handling security exceptions (e.g., read permissions) | `SecurityException` may occur â€” though itâ€™s unchecked                   |


2ï¸âƒ£ FileReader:
â¤ FileReader is a class in the java.io package used to read character-based files.
â¤ It is typically used for reading text files (e.g., .txt, .csv).
â¤ Return type is int, but it returns Unicode/ASCII value, so we often cast it to char.
â¤ It return -1(indicates EOF- End of file) when the file ends.
â¤ Not efficient for large files because it reads one character at a time. Prefer BufferReader.

ğŸ§± Constructor Signature
FileReader fr = new FileReader(String filePath);

âœ… Example 1:
package app_java_3;
import java.io.FileReader;

public class A {
	public static void main(String[] args) {
		try {
			FileReader fr = new FileReader("G:\\april\\t1.txt");
			System.out.println((char)fr.read());  // Reads only 1 character
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

âœ… Example 2:
package app_java_3;
import java.io.File;
import java.io.FileReader;
public class A {
	public static void main(String[] args) {
		try {
			FileReader fr = new FileReader("file.txt");
			int c;
			while ((c = fr.read()) != -1) {
   			 System.out.print((char)c);
			}
			fr.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

âš ï¸ Interview Trap â€“ Donâ€™t Use f.length() with Unicode Files
âœ… It works for simple English text files (ASCII), where 1 byte = 1 character
âŒ NOT SAFE for files with Unicode (multi-byte) characters like Hindi, Chinese, or emojis â€” f.length() returns byte size, not character count.

File f = new File("file_with_à¤¹à¤¿à¤‚à¤¦à¥€.txt");
System.out.println(f.length());  // May return 18 bytes
// But the actual number of characters could be < 18

âœ… Better alternative:
int c;
while ((c = fr.read()) != -1) {
    System.out.print((char)c);
}

ğŸ“Œ 2. Is FileReader character-based or byte-based?
âœ… FileReader is character-based
âš ï¸ It automatically converts bytes to characters using the platform's default charset

âœ… FileReader read(char[] ch)

char[] ch = new char[(int)f.length()];//type case to int because f.length returns long and array index only takes int values.

â¤ Allocates a character array whose size is equal to the file size in bytes.
â¤ (int)f.length() returns the size in bytes, not characters.
â¤ Risk: Unicode/multibyte characters can break this logic.

fr.read(ch);
â¡ï¸ It reads all the characters from the file into a character array and then prints them one by one.

âš ï¸ Common Mistakes 
âŒ Assuming file length = number of characters
char[] ch = new char[(int)f.length()]; // Problematic for UTF-8

âŒ Ignoring return value of read(ch)
fr.read(ch);  // BAD â€” may not fill array completely

âœ… Better Practice:
int len = fr.read(ch);
for (int i = 0; i < len; i++) {
    System.out.print(ch[i]);
}

âœ… Example
package app_java_3;
import java.io.File;
import java.io.FileReader;
public class A {
	public static void main(String[] args) {
		try {
			File f = new File("G:\\april\\t1.txt");
			FileReader fr = new FileReader(f);
			char[] ch = new char[(int)f.length()];
			fr.read(ch);
			
			for(char c:ch) {
				System.out.print(c);
			}
			fr.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

3ï¸âƒ£ FileWriter Class (java.io)
â¤ Used to write character data to a file.
â¤ Belongs to the java.io package.
â¤ Can create a new file if it doesnâ€™t exist.
â¤ The default behavior is to replace (overwrite) the existing file content.
â¤ You can append to existing content by passing true as a second parameter during object creation.

ğŸ”¸ Constructor Variants
1. FileWriter fw = new FileWriter("path")
Overwrites content if the file exists.
Creates the file if it doesnâ€™t exist.

2. FileWriter fw = new FileWriter("path", false)
Same as above â€” explicitly overwrites content.

3. FileWriter fw = new FileWriter("path", true)
Appends to the existing file content if present.
Creates a new file if it doesnâ€™t exist.

ğŸ”„ Common Methods
1. write(int ch): Writes a single character (based on ASCII value).
2. write(String str): Writes an entire string.
3. write(char[] ch): Write a character array.

close()
â¤ Saves written content and closes the stream.
â¤ Must be called to avoid data loss or resource leakage.

â“ "What happens if the file does not exist?" â†’ FileWriter will create it only if the directory structure already exists; otherwise, it will throw a FileNotFoundException.

âœ… Example 1 â€“ Overwriting a file
package app_java_3;

import java.io.FileWriter;

public class A {
	public static void main(String[] args) {
		try {
			FileWriter fw = new FileWriter("G:\\april\\t4.txt", false);
			fw.write(97);            // Writes: a
			fw.write("100");         // Writes: 100
			fw.write(new char[]{'a','b','c'}); // Writes: abc
			fw.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

âœ… Example 2 â€“ Writing multiple lines
package app_java_3;

import java.io.FileWriter;

public class A {
	public static void main(String[] args) {
		try {
			FileWriter fw = new FileWriter("G://april//t1.txt");
			fw.write("mike\n");
			fw.write("stallin\n");
			fw.write("adam\n");
			fw.close();//Save the file content and close the file
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

ğŸ“˜ BufferedReader in Java
â¤ BufferedReader is used to read text from a character-input stream, buffering characters for efficient reading of characters, arrays, and lines.
â¤ It significantly improves performance over using FileReader alone.
â¤ Introduced in the java.io package.

â¤ Improved Performance â†’ Uses a buffer (default size: 8192 characters) to read chunks of data at once, reducing disk I/O.
â¤ Works with FileReader â†’ BufferedReader wraps FileReader. On its own, it cannot read files because it doesnâ€™t handle files directly.
â¤ readLine() Method â†’ Allows reading one full line (till \n) at a time. Returns null when EOF (End Of File) is reached.
â¤ Supports Other Input Types â†’ Can wrap any Reader (e.g., InputStreamReader, StringReader), not just FileReader

ğŸ“Œ Commonly Used Constructors
BufferedReader br = new BufferedReader(new FileReader("path"));
BufferedReader br = new BufferedReader(new FileReader("path"), bufferSize); // optional buffer size

âœ… Example 1: Reading one character
import java.io.BufferedReader;
import java.io.FileReader;

FileReader fr = new FileReader("G://april//t1.txt");
BufferedReader br = new BufferedReader(fr);
System.out.println((char)br.read());  // Reads one character
br.close();
fr.close();

âœ… Example 2: Reading into a char array
FileReader fr = new FileReader("G://f1//t1.txt");
BufferedReader br = new BufferedReader(fr);
char[] ch = new char[4];
br.read(ch); // Reads 4 characters into the array
for(char c: ch) {
    System.out.print(c);
}
br.close();
fr.close();

âœ… Example 3: Reading multiple lines using readLine()
package p1;

import java.io.BufferedReader;
import java.io.FileReader;

public class A{
	public static void main(String[] args) {
		try {
			FileReader fr = new FileReader("file_location");
			BufferedReader br= new BufferedReader(fr);
			String line;
			while ((line = br.readLine()) != null) {
			    System.out.println(line);
			}
			br.close();
		} catch (Exception e) {
			e.printStackTrace();
		}

	}
}

ğŸ”¥ Internal Working
â¤ BufferedReader maintains an internal buffer (char[]).
â¤ When read() or readLine() is called and the buffer is empty, it:
	âœ”ï¸ Pulls a block of characters from the underlying Reader (FileReader)
	âœ”ï¸ Stores them in the buffer
	âœ”ï¸ Serves future reads from this buffer until it's empty again.
	âœ”ï¸ This reduces the number of physical reads from disk, improving performance.

ğŸ¯ Advantages
â¤ Reduces file reading time, especially for large files.
â¤ readLine() makes line-by-line processing much easier.

ğŸ“˜ BufferedWriter in Java
â¤ BufferedWriter is a part of the java.io package.
â¤ It is used to write text efficiently to character output streams by buffering characters.
â¤ Improves performance by minimizing disk interaction (reducing write operations).

ğŸ” Core Features
Buffers characters before writing to the destination (default size: 8192 characters).
Can write:
1. Strings (write(String str))
2. Single characters (write(int c))
3. Character arrays (write(char[] cbuf))

â¤ Supports newLine() to write platform-dependent line separator (\n, \r\n, etc.)
â¤ Must be used with a Writer (e.g., FileWriter, OutputStreamWriter) â€” cannot directly write to files.

âœ… Code Example:
FileWriter fw = new FileWriter("G://april//t1.txt", true); // true = append mode
BufferedWriter bw = new BufferedWriter(fw);
bw.write("mike");
bw.newLine(); //append new line
bw.write(97); // Writes the character with ASCII value 97 ('a')
char[] ch = {'b','c','d'}; //// Writes a char array {'b', 'c', 'd'}
bw.newLine();
bw.write(ch);

bw.close(); // Always close in reverse order of creation
fw.close();

â“ When is the data written to the file?
â¤ When the buffer is full, or flush() / close() is called.
â¤ Prefer flush() if writing in real-time or inside loops.


ğŸ’¾ Serialization & Deserialization in Java
Serialization is the process of converting a Java object into a byte stream.
This byte stream can be:
â¤ Written to a file
â¤ Transmitted over a network
â¤ Saved to a database

Deserialization is the reverse process: Converting a byte stream back into a Java object.

ğŸ”„ Real-World Use Cases
1. Saving the state of an object to a file (e.g., session persistence)
2. Sending objects over a network (e.g., in RMI, sockets)
3. Caching objects in memory/disk
4. Java Messaging Service (JMS)

ğŸ“˜ Key Concepts
| Concept             | Details                                                             |
| ------------------- | ------------------------------------------------------------------- |
| Serializable        | Marker interface (java.io.Serializable) that must be implemented    |
| transient keyword   | Used to skip fields from serialization                              |
| serialVersionUID    | Version control for the class â€” helps avoid InvalidClassException   |

âœ… Example:
package p1;
import java.io.Serializable;

public class User implements Serializable {
    private static final long serialVersionUID = 1L;  // Version control ID
    String username = "mike";
    transient String password = "secret123"; // Will not be serialized
}
â¤ transient: tells JVM to skip this field during serialization
â¤ The password field will be null when deserialized

ğŸ” transient Keyword
Prevents sensitive data (e.g., password, OTP) from being persisted
Prevents circular references or unnecessarily heavy objects from being serialized

Syntax: transient DataType fieldName;

âœ… Example:
import java.io.*;

class Employee implements Serializable {
    private static final long serialVersionUID = 1L;

    int id;
    String name;
    transient double salary; //will not be serialized

    public Employee(int id, String name, double salary) {
        this.id = id;
        this.name = name;
        this.salary = salary;
    }

    @Override
    public String toString() {
        return "Employee{id=" + id + ", name='" + name + "', salary=" + salary + "}";
    }
}

public class TransientDemo {
    public static void main(String[] args) {
        String filename = "employee.ser";

        ğŸ” Serialization
        Employee emp = new Employee(201, "Ankur", 75000.50);
        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(filename))) {
            oos.writeObject(emp);
            System.out.println("Serialization successful: " + emp);
        } catch (IOException e) {
            e.printStackTrace();
        }

        ğŸ” Deserialization
        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename))) {
            Employee deserializedEmp = (Employee) ois.readObject();
            System.out.println("Deserialization successful: " + deserializedEmp);
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}

âš ï¸ Bonus Trap: Changing Class After Serialization
If you serialize an object and later modify the class (add/remove fields), deserialization can fail unless:
â¤ serialVersionUID is unchanged
â¤ Compatible changes are made (adding optional fields is safe)

â“ Can serialVersionUID be anything?
âœ… Yes, you can assign any long value as serialVersionUID.

ğŸ”„ Example
private static final long serialVersionUID = 42L;     // Valid
private static final long serialVersionUID = 1234567890123456789L;  // Also valid

â“ But Why Do We Use It?
serialVersionUID is used to verify that the sender and receiver of a serialized object have loaded classes for that object that are compatible concerning serialization.

â“ What happens without it?
If you donâ€™t define serialVersionUID, the Java compiler automatically generates it based on class structure (fields, methods, modifiers, etc.).
But the auto-generated value is not consistent across:
â¤ Different compilers (javac vs Eclipse)
â¤ Even minor changes in the class (adding/removing a method or variable)

ğŸš¨ Interview Trap
â“ Can I remove or skip defining serialVersionUID if my class implements Serializable?
âŒ Wrong Answer: Yes, it's optional
âœ… Correct Answer: Technically optional, but highly recommended. Without it, even small changes in the class can cause InvalidClassException during deserialization.

ğŸ§  Best Practices
â¤ Always manually declare serialVersionUID for Serializable classes.
â¤ Choose any long value thatâ€™s meaningful to you (version number, timestamp, or arbitrary value).

âœ”ï¸ If class doesnâ€™t implement Serializable	âŒ NotSerializableException will be thrown at runtime
âœ”ï¸ Can static fields be serialized			âŒ No. Static fields are class-level, not object-level, so not serialized.


ğŸ”· JDBC - Java Database Connectivity
â¤ Database: Here we store data in the form of tables permanently
â¤ Popular Databases: MySQL, PostgreSQL, Oracle, SQL Server, MongoDB, Derby, h2Database
â¤ Install MySQL Database
ğŸ”— Download from here: https://dev.mysql.com/downloads/windows/installer/8.0.html
â¤  When you download MySQL Workbench, you will get the following: 
	âœ”ï¸ IDE - To Write SQL Query (SQL query is used to interact with the database)
	âœ”ï¸ MySQL Server

Installation Doc: https://www.prowesstics.com/blogs/mysql-workbench-installation/

âœ”ï¸ Launch MySQL Workbench
âœ”ï¸ Create psaDB connection
âœ”ï¸ Create Database: Create Database psaDB
âœ”ï¸ Connect to Database: use psaDB
âœ”ï¸ Create Table Student: 
Create table student(
	name varchar(45),
    email varchar(128),
    mobile varchar(10)
)
â¤ Read Table Content: Select * from student
â¤ Insert data to table: insert into student values('mike','mike@gmail.com','9632629033')
â¤ Read Table Content: Select * from student

ğŸ‘‰ After installing MySQL Workbench, we can now start with the JDBC Concept
â¤ Interacting with the database using Java program
â¤ Download Connector File for MySQL: https://dev.mysql.com/downloads/file/?id=538917
â¤ Create a folder with the name lib inside the root path of your Java project & paste the connector jar file inside it
â¤ Right click on project ---->> Go to properties ---->> select java build path ---->> click on libraries tab --->>Click on add jar ---->>navigate to lib folder and select mysql connector j jar ---->> click apply + close

âœ… Example 1: JDBC code to insert data
package jdbc_examples;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.Statement;

public class A {
	public static void main(String[] args) {
		try {
//Connect to database - use psaDB (SQL)		
Connection con=DriverManager.getConnection("jdbc:mysql://localhost:3306/psadb1","root","test");

//Write & execute SQl query
Statement stmnt =  con.createStatement();
stmnt.executeUpdate("insert into student values('adam','adam@gmail.com','9632629555')");
			
//Close database connection
con.close();
} catch (Exception e) {
	e.printStackTrace();
}
}
}
 
âœ… Example 2: JDBC Code to delete a record
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.Statement;

public class B {
	public static void main(String[] args) {
		try {
			Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/psadb1","root","test");
			Statement stmnt =  con.createStatement();
			stmnt.executeUpdate("Delete from student where email='adam@gmail.com'");

			con.close();
		}catch (Exception e) {
			e.printStackTrace();
		}
	}
}

âœ… Example 3: JDBC Code to update a Record
import java.sql.*;

public class C {
	public static void main(String[] args) {
		try {
			Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/psadb1", "root", "test");
			
			Statement stmnt = con.createStatement();
			stmnt.executeUpdate("Update student set mobile='9632882052' where email='mike@gmail.com'");
			
			con.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

âœ… Example 4: JDBC Code to read data from the database
package p1;

import java.sql.*;

public class D {
	public static void main(String[] args) {
		try {
			//Step Connect to Database
			Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/psadb1", "root", "test");
			
			Statement stmnt = con.createStatement();
			ResultSet result = stmnt.executeQuery("Select * from student");
			
			while(result.next()) {
				System.out.println(result.getString(1));
				System.out.println(result.getString(2));
				System.out.println(result.getString(3));
			}		
			con.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

ğŸ”·  Custom Exception in Java
Custom exceptions are user-defined exceptions that extend either the Exception class (for checked exceptions) or the RuntimeException class (for unchecked exceptions).

ğŸ”„ Syntax for Custom Exception
1ï¸âƒ£ Checked Exception (extends Exception)
public class MyCheckedException extends Exception {
    public MyCheckedException(String message) {
        super(message);
    }
}

2ï¸âƒ£ Unchecked Exception (extends RuntimeException)
public class MyUncheckedException extends RuntimeException {
    public MyUncheckedException(String message) {
        super(message);
    }
}

âœ… Example: Creating and Using a Checked Exception
class AgeInvalidException extends Exception {
    public AgeInvalidException(String message) {
        super(message);
    }
}

public class CustomExceptionDemo {
    public static void validateAge(int age) throws AgeInvalidException {
        if (age < 18) {
            throw new AgeInvalidException("âŒ Age is not valid for voting!");
        } else {
            System.out.println("âœ… You are eligible to vote.");
        }
    }

    public static void main(String[] args) {
        try {
            validateAge(15);
        } catch (AgeInvalidException e) {
            System.out.println("Caught Exception: " + e.getMessage());
        }
    }
}

ğŸ“˜ Best Practices for Custom Exceptions
â¤ Always extend Exception or RuntimeException.
â¤ Provide constructors for messages and causes.
â¤ Use descriptive names (InvalidAgeException, UserNotFoundException).
â¤ Donâ€™t overuse â€” prefer standard exceptions when they fit.

ğŸ§  Tips & Traps
| â“ Question                                                    | âœ… Good Answer                                                 |
| ------------------------------------------------------         | -------------------------------------------------------------   |
| Should I extend `Throwable` directly?                  		 | âŒ No, use `Exception` or `RuntimeException`.                  |
| Can I throw a custom exception without the `throws` keyword?   | âœ… Yes, but only if it extends `RuntimeException` (unchecked). |
| Why create custom exceptions?                          		 | To handle specific business logic and improve code clarity.     |
| Can custom exceptions have multiple constructors?      	     | âœ… Yes, just like any class (with message, cause, etc.).       |


ğŸ†š Difference between throw and throws in Java
| Feature                  | `throw`                                       | `throws`                                                |
| ------------------------ | --------------------------------------------- | ------------------------------------------------------- |
| Purpose              	   | Used to explicitly throw an exception         | Used to declare exceptions a method might throw         |
| Location             	   | Inside method or block                        | In method signature                                     |
| Number of Exceptions     | Can throw only one exception at a time        | Can declare multiple exceptions separated by commas 	 |
| Type                     | Followed by an object of `Throwable` type     | Followed by one or more **exception class names       	 |
| Usage                    | Used for triggering exception                 | Used for declaring exception handling responsibility    |
| Syntax                   | `throw new ExceptionType("msg");`             | `public void method() throws IOException`               |

âœ… Syntax and Example
ğŸ”„ throw keyword example (used inside method)
public class ThrowExample {
    public static void main(String[] args) {
        int age = 16;
        if (age < 18) {
            throw new ArithmeticException("âŒ Age must be 18+ to vote");
        }
        System.out.println("âœ… You can vote");
    }
}

ğŸ”„ throws keyword example (used in method declaration)
import java.io.*;

public class ThrowsExample {
    public static void readFile() throws IOException {
        FileReader fr = new FileReader("file.txt"); // may throw IOException
        BufferedReader br = new BufferedReader(fr);
        System.out.println(br.readLine());
    }

    public static void main(String[] args) {
        try {
            readFile(); // handle the exception
        } catch (IOException e) {
            System.out.println("Caught IOException: " + e.getMessage());
        }
    }
}

ğŸ” Key Points
â¤ throw is used within a method, while throws is used in the method declaration.
â¤ throws a single instance of an exception.
â¤ throws can declare multiple exceptions that a method might throw.
â¤ Use throw to generate an exception during custom logic validation.
â¤ Use throws to inform the caller method to handle the exception.

âš ï¸ Common Traps
| â“ Trap Question                                               | âœ… Correct  Clarification                                                  
| Can we use `throw` without creating exception object?          | âŒ No, `throw` must be followed by a `Throwable` object.                  |
| Can we write `throws` inside method body?                      | âŒ No, `throws` is only used in method signature**.                       |
| Can we throw multiple exceptions with `throw`?                 | âŒ No, only one exception object at a time.                               |
| What happens if method declares throws but doesn't actually throw?| âœ… Thatâ€™s allowed â€” declaration is just a promise, not a requirement.  |

âœ… Best Practices
â¤ Use throws for checked exceptions that you donâ€™t want to handle in the method.
â¤ Use throw for custom exception logic or early exits.
â¤ Always handle checked exceptions using try-catch or declare them using throws.

ğŸ”„ Multi-catch blocks:
â¤ We can create multiple catch blocks.
â¤ Always start with the  child exception class, followed by the parent exception class

âœ… Example:
package p1;

public class E {
	int x = 10;
	public static void main(String[] args) {
		try {
			Integer.parseInt("ahsjkdhas687");
			E a1 = null;
			System.out.println(a1.x);
			int x = 10/0;
		}catch (ArithmeticException e) {
			System.out.println(1);
		}catch (NullPointerException e) {
			System.out.println(2);
		}catch (Exception e) {
			System.out.println(3);
		}
	}
}

ğŸ”„ Finally block in Java
â¤ This is an  extension of try try-catch block
â¤ The code that we write in the finally block will run 100%, regardless of the exception

âœ… Example:
public class E {
	int x = 10;
	public static void main(String[] args) {
		try {
			int x = 100/0;
		}catch (Exception e) {
			e.printStackTrace();
		}finally {
			System.out.println("Finally");//Output: Finally
		}	
	}
}

âœ… Example:
public class E {
	int x = 10;
	public static void main(String[] args) {
		try {
			int x = 100/2;
		}catch (Exception e) {
			e.printStackTrace();
		}finally {
			System.out.println("Finally")//;Output: Finally
		}
		
	}
}

âœ… Example: Can we write only a try-finally block: yes
public class E {
	int x = 10;
	public static void main(String[] args) {
		try {
			int x = 100/0;
		}finally {
			System.out.println("Finally");
		}
		System.out.println("Welcome");
	}
}
Output: Finally
Exception in thread "main" java.lang.ArithmeticException: / by zero
	at jdbc_examples.E.main(E.java:7)


â“ where the finally block can be used?
â¤ We can perform a database closing operation
â¤ We can perform a file closing operation / Database closing Operation

âœ… Example :
package p1;

import java.sql.*;

public class A {
	public static void main(String[] args) {
		Connection con = null;
		try {
			con = DriverManager.getConnection("jdbc:mysql://localhost:3306/psadb1", "root", "test");
			Statement stmnt = con.createStatement();
			stmnt.executeUpdate("insert into student values('adam','adam@gmail.com','9632629455')");				
		} catch (Exception e) {
			e.printStackTrace();
		}finally {
			try {
				con.close();
			} catch (Exception e2) {
				e2.printStackTrace();
			}
		}
	}
}

â— Trap Question:
public class Test {
    public static void main(String[] args) {
        System.out.println(test());
    }

    static int test() {
        try {
            return 1;
        } catch (Exception e) {
            return 2;
        } finally {
            return 3;
        }
    }
}
âœ… Output is: 3

â“ Why does finally override the return in try?
â¤ Because the finally block is always executed, and if it contains a return, it overrides any previous return values, even from try or catch.
â¤ So even though try says return 1, and there's no exception, the finally block's return 3 overrides it.
ğŸ§¨ This is often called "return suppression".

â“ What if finally didnâ€™t have a return?
Then the return from try (or catch, if an exception occurs) would go through as normal.

So if finally it is:
finally {
    System.out.println("Cleaning up");
}
Then the output would be:
Cleaning up 	----> Output from finally  
1 				----> returned output from try-catch block

âœ… Example 2:
public class Main {
    public static void main(String[] args) {
        try {
            int a = 5 / 0;
        } catch (ArithmeticException e) {
            System.out.println("A");
        } finally {
            System.out.println("B");
        }
    }
}
âœ… Output:
A
B

And what if you remove the catch block â€” will it still print B? Why or why not?
âœ… Output:B  
Exception in thread "main" java.lang.ArithmeticException: / by zero.
âœ”ï¸ Finally runs.
Even when there's no catch, the finally block executes before the exception is thrown back to the JVM.

ğŸ”„ final Keyword:
â¤ final makes variable constant
â¤ final prevents overriding
â¤ final on class stops inheritance

ğŸ”„ finally:
â¤ This is an extension of a try-catch block.
â¤ The code that we write in the finally block will run 100%, regardless of the exception.

ğŸ”„ finalize():
â¤ This is a method inside the Object class, and here, the Garbage collection logic is implemented.
â¤ We can try calling the garbage collector using System.gc(). But it will not guarantee 100% execution.
