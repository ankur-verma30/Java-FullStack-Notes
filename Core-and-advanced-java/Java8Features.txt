ğŸ§  Method Referencing in Java
â¤ A shorthand syntax of lambda expressions when the lambda body only calls an existing method.
â¤ Improves readability and makes code look cleaner.
â¤ Introduced in Java 8 with functional programming features.

ğŸ”¹ Syntax
ClassName::methodName
object::methodName
ClassName::new  (for constructors)

ğŸ”¹ Types of Method References
âœ…Type 1: Reference to a static method

list.forEach(System.out::println);  
// equivalent to: list.forEach(x -> System.out.println(x));

âœ…Type 2: Reference to an instance method of a particular object
String str = "hello";
Supplier<Integer> s = str::length;
System.out.println(s.get());  // 5

âœ…Type 3: Reference to an instance method of an arbitrary object of a particular type
List<String> names = Arrays.asList("Ankur", "Ravi", "Megha");
names.sort(String::compareToIgnoreCase);
// equivalent to (a, b) -> a.compareToIgnoreCase(b)

âœ…Type 4: Reference to a constructor
Supplier<Student> s = Student::new;
Student st = s.get();

ğŸ”¹ Why Method Reference?
â¤ Makes lambda shorter and cleaner.
â¤ Avoids boilerplate (param) -> obj.method(param).
â¤ Improves readability in sorting, filtering, mapping, etc.

ğŸ”¹ Example: Sorting with Method Reference
students.sort(Comparator.comparingInt(Student::getAge));

Equivalent lambda:
students.sort((s1, s2) -> Integer.compare(s1.getAge(), s2.getAge()));

âš¡ Tips
â¤ Method reference is just syntactic sugar for lambdas.
â¤ Works only when the method signature matches the functional interface method.
â¤ Commonly used in Streams API (map, filter, forEach) and Comparator.

âœ… Example Code Snippet
package collections;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;

class Student {
	String name;
	double gpa;

	Student(String name, double gpa) {
		this.name = name;
		this.gpa = gpa;
	}

	String getName() {
		return this.name;
	}

	double getGpa() {
		return this.gpa;
	}

} 
public class ArrayListIntro {

	public static void main(String[] args) {
		List<Student> students = new ArrayList<>();
		students.add(new Student("Charlie", 3.5));
		students.add(new Student("Bob", 3.7));
		students.add(new Student("Alice", 3.5));
		students.add(new Student("Ankur", 3.9));

		Comparator<Student> comparator = Comparator.comparing(Student::getGpa).reversed()
				.thenComparing(Student::getName);

		students.sort(comparator);
		for (Student s : students) {
			System.out.println(s.getName() + " " + s.getGpa());
		}

	}
}


ğŸ”· Java 8 Basics
â¤ Introduced to write minimal code and improve developer productivity.
â¤ Functional Programming. For Example: lambda expressions, method references, streams, etc.

ğŸŒŸ Lambda expression
// Functional interface
@FunctionalInterface
interface MathOperation {
    int operate(int a, int b);
}

public class LambdaMathOperation {
    public static void main(String[] args) {

        // Addition
        MathOperation add = (a, b) -> a + b;

        // Subtraction
        MathOperation subtract = (a, b) -> a - b;

        // Multiplication
        MathOperation multiply = (a, b) -> a * b;

        // Division (with check for divide by zero)
        MathOperation divide = (a, b) -> b != 0 ? a / b : 0;

        // Testing
        System.out.println("10 + 5 = " + add.operate(10, 5));
        System.out.println("10 - 5 = " + subtract.operate(10, 5));
        System.out.println("10 * 5 = " + multiply.operate(10, 5));
        System.out.println("10 / 5 = " + divide.operate(10, 5));
    }
}
âœ… Output:
10 + 5 = 15
10 - 5 = 5
10 * 5 = 50
10 / 5 = 2


ğŸŒŸPredicate
â¤ A functional interface in java.util.function.
â¤ Represents a boolean-valued function of one argument.
â¤ Contains one abstract method:
ğŸ”— boolean test(T t);

ğŸ”„ Common Usage
â¤ Filtering collections (Stream.filter()).
â¤ Validation checks (like input checks, number checks, etc.).
â¤ Combining multiple conditions.

âœ…Code Example:
import java.util.function.Predicate;

public class PredicateExample {
    public static void main(String[] args) {
        Predicate<Integer> isEven = x -> x % 2 == 0;
        Predicate<Integer> isPositive = x -> x > 0;

        System.out.println(isEven.test(4));   // true
        System.out.println(isPositive.test(-3)); // false
    }
}

ğŸ”„ Combining Predicates
Predicate provides default methods to combine multiple conditions:

ğŸ‘‰ and() â†’ Returns true if both predicates are true.
âœ…Code Example:
Predicate<Integer> isEven = x -> x % 2 == 0;
Predicate<Integer> isPositive = x -> x > 0;

Predicate<Integer> isEvenAndPositive = isEven.and(isPositive);
System.out.println(isEvenAndPositive.test(4));  // true
System.out.println(isEvenAndPositive.test(-2)); // false

ğŸ‘‰ or() â†’ Returns true if any one predicate is true.
âœ…Code Example:
Predicate<Integer> isEven = x -> x % 2 == 0;
Predicate<Integer> isNegative = x -> x < 0;

Predicate<Integer> isEvenOrNegative = isEven.or(isNegative);
System.out.println(isEvenOrNegative.test(3));   // false
System.out.println(isEvenOrNegative.test(-5));  // true

ğŸ‘‰ negate() â†’ Returns the opposite of the predicate.
âœ…Code Example:
Predicate<Integer> isEven = x -> x % 2 == 0;

Predicate<Integer> isOdd = isEven.negate();
System.out.println(isOdd.test(5));  // true

ğŸ‘‰ isEqual() â†’ Static method, checks if an object is equal to another.
âœ…Code Example:
Predicate<String> isHello = Predicate.isEqual("Hello");
System.out.println(isHello.test("Hello")); // true
System.out.println(isHello.test("Hi"));    // false

âœ…Real-Life Example: Filtering a List
import java.util.*;
import java.util.function.Predicate;
import java.util.stream.Collectors;

public class PredicateFilterExample {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(10, -3, 4, -7, 8, 15);

        Predicate<Integer> isPositive = x -> x > 0;
        Predicate<Integer> isEven = x -> x % 2 == 0;

        // Filter only positive even numbers
        List<Integer> result = numbers.stream()
                                      .filter(isPositive.and(isEven))
                                      .collect(Collectors.toList());

        System.out.println(result); // [10, 4, 8]
    }
}

ğŸ§  Tips & Traps
âœ… Predicate is mostly used in Streams API (e.g., filter() needs Predicate).
âœ… Can be combined using .and(), .or(), .negate().
âŒ Null values: Predicate can throw NullPointerException if not handled.
â“ Trick Q: How is Predicate<T> different from Function<T, Boolean>?
âœ”ï¸ Predicate<T> is specialized for boolean-returning conditions, while Function<T, Boolean> is generic.


ğŸŒŸ Function
â¤ A functional interface from java.util.function.
â¤ Represents a function that takes one argument and returns a result.
â¤ Abstract method:
ğŸ”— R apply(T t);

âœ…Code Example:
import java.util.function.Function;

public class FunctionExample {
    public static void main(String[] args) {
        Function<Integer, Integer> square = x -> x * x;

        System.out.println(square.apply(5)); // 25
    }
}

When both input and output types are the same, use UnaryOperator<T> instead of Function<T, T>.
âœ… Example: 
import java.util.function.Function;

public class FunctionExample {
    public static void main(String[] args) {
        UnaryOperator<Integer> square = x -> x * x;

        System.out.println(square.apply(5)); // 25
    }
}

ğŸ”„ Default Methods (Combining Functions)
ğŸ‘‰ andThen()
â¤ Executes the current function first, then applies another function.
âœ…Code Example
Function<Integer, Integer> multiplyBy2 = x -> x * 2;
Function<Integer, Integer> square = x -> x * x;

// First multiply by 2, then square
Function<Integer, Integer> resultFunc = multiplyBy2.andThen(square);

System.out.println(resultFunc.apply(3)); // (3*2)^2 = 36

ğŸ‘‰ compose()
â¤ Opposite of andThen(). Executes the given function first, then applies the current one.
âœ…Code Example
Function<Integer, Integer> multiplyBy2 = x -> x * 2;
Function<Integer, Integer> square = x -> x * x;

// First square, then multiply by 2
Function<Integer, Integer> resultFunc = multiplyBy2.compose(square);

System.out.println(resultFunc.apply(3)); // (3^2)*2 = 18

ğŸ‘‰ identity() (Static Method)
â¤ Returns a function that always returns its input.
âœ…Code Example
Function<String, String> identityFunc = Function.identity();
System.out.println(identityFunc.apply("Hello")); // Hello

âœ… Real-Life Example: Convert & Process Data
import java.util.function.Function;

public class FunctionChainExample {
    public static void main(String[] args) {
        // Step 1: Convert string to integer
        Function<String, Integer> strToInt = Integer::parseInt;

        // Step 2: Square the integer
        Function<Integer, Integer> square = x -> x * x;

        // Chain them
        Function<String, Integer> process = strToInt.andThen(square);

        System.out.println(process.apply("6")); // 36
    }
}

ğŸ§  Notes
âœ… andThen() vs compose() â†’ Order of execution is key (common trick Q).
âœ… Function.identity() â†’ used in collectors (e.g., toMap() in Streams).
âŒ Be careful with NumberFormatException when using Integer::parseInt.
ğŸ”¥ Advanced: Thereâ€™s also BiFunction<T,U,R> for functions with two arguments.


ğŸŒŸ Consumer
â¤ A functional interface from java.util.function.
â¤ Represents an operation that takes one argument but returns no result.
â¤ Abstract method:
ğŸ”— void accept(T t);

âœ… Example:
import java.util.function.Consumer;

public class ConsumerExample {
    public static void main(String[] args) {
        Consumer<Integer> printSquare = x -> System.out.println(x * x);
        printSquare.accept(5); // 25
    }
}

ğŸ”„ Chaining Consumers
Consumer provides andThen() to chain operations.
âœ… Example:
import java.util.function.Consumer;

public class ConsumerChainExample {
    public static void main(String[] args) {
        Consumer<String> printUpper = s -> System.out.println(s.toUpperCase());
        Consumer<String> printLength = s -> System.out.println("Length: " + s.length());

        Consumer<String> combined = printUpper.andThen(printLength);

        combined.accept("hello");
    }
}
âœ… Output
HELLO
Length: 5

âœ… Real-Life Example
import java.util.*;
import java.util.function.Consumer;

public class ConsumerListExample {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

        Consumer<String> printName = name -> System.out.println("Hello, " + name);

        // forEach accepts a Consumer
        names.forEach(printName);
    }
}

âš¡Notes
âœ… Consumer is mostly used in forEach() (Streams + Collections).
âœ… Can be chained with .andThen().
âŒ Returns void, so canâ€™t be used for transformations (thatâ€™s Function<T,R>).
ğŸ”¥ Advanced variants:
â¤ BiConsumer<T,U> â†’ accepts two arguments.
â¤ IntConsumer, LongConsumer, DoubleConsumer â†’ primitive specializations (avoid boxing).


ğŸŒŸSupplier
â¤ A functional interface from java.util.function.
â¤ Represents a supplier of results â†’ takes no argument and returns a value.
â¤ Abstract method:
ğŸ”— T get();

âœ… Example:
import java.util.function.Supplier;

public class SupplierExample {
    public static void main(String[] args) {
        Supplier<Double> randomValue = () -> Math.random();

        System.out.println(randomValue.get()); // e.g., 0.527896123
    }
}

Real-Life Examples
âœ… Generate Current Time
import java.time.LocalDateTime;
import java.util.function.Supplier;

public class TimeSupplier {
    public static void main(String[] args) {
        Supplier<LocalDateTime> currentTime = () -> LocalDateTime.now();

        System.out.println("Current Time: " + currentTime.get());
    }
}

âœ… Fallback Values (e.g., default config)
import java.util.function.Supplier;

public class ConfigSupplier {
    public static void main(String[] args) {
        Supplier<String> defaultConfig = () -> "DEFAULT-CONFIG";

        String config = null;
        String result = (config != null) ? config : defaultConfig.get();

        System.out.println(result); // DEFAULT-CONFIG
    }
}

âš¡ Notes
âœ… Supplier is useful for lazy initialization (create objects only when needed).
âœ… Used in Streams API (e.g., Stream.generate(Supplier<T>)).
âŒ No input â†’ only returns.
ğŸ”¥ Advanced variants:
BooleanSupplier, IntSupplier, LongSupplier, DoubleSupplier (primitive specializations).

ğŸŒŸ BiPredicate
â¤ Boolean-valued function of two arguments.
â¤ Abstract method:
ğŸ”— boolean test(T t, U u);

âœ… Example
import java.util.function.BiPredicate;

public class BiPredicateExample {
    public static void main(String[] args) {
        BiPredicate<String, String> areEqual = (s1, s2) -> s1.equalsIgnoreCase(s2);

        System.out.println(areEqual.test("Java", "java")); // true
        System.out.println(areEqual.test("Java", "Python")); // false
    }
}
ğŸ‘‰ Use Case: String comparisons, validation checks involving two values.

ğŸŒŸ BiConsumer
â¤ Represents an operation that takes two arguments and returns no result.
â¤ Abstract method:
ğŸ”— void accept(T t, U u);

âœ… Example
import java.util.function.BiConsumer;

public class BiConsumerExample {
    public static void main(String[] args) {
        BiConsumer<String, Integer> printNameAge = 
            (name, age) -> System.out.println(name + " is " + age + " years old");

        printNameAge.accept("Alice", 25);
    }
}
ğŸ‘‰ Use Case: Logging, printing, updating maps (Map.forEach(BiConsumer)).

ğŸŒŸ BiFunction
â¤ Represents a function that takes two arguments and returns a result.
â¤ Abstract method:
ğŸ”— R apply(T t, U u);

âœ… Example
import java.util.function.BiFunction;

public class BiFunctionExample {
    public static void main(String[] args) {
        BiFunction<Integer, Integer, Integer> add = (a, b) -> a + b;

        System.out.println(add.apply(10, 20)); // 30
    }
}
ğŸ‘‰ Use Case: Arithmetic operations, combining two inputs to produce an output.

âš¡ Pro Tip:
If both the input type and return type is of same Wrapper class then use BinaryOperator<T>
âœ… Example:
import java.util.function.BinaryOperator;

public class BinaryOperatorExample {
    public static void main(String[] args) {
        BinaryOperator<Integer> add = (a,b)-> a+b;

        System.out.println(add.apply(10, 20)); // 30
    }
}


ğŸŒŸ Streams (Java 8)
â¤ Process collections of data in a functional & declarative manner.
â¤ Introduced in Java 8.
â¤ Benefits:
    âœ”ï¸ Simplifies data processing & analysis.
    âœ”ï¸ Improves readability & maintainability.
    âœ”ï¸ Encourages functional programming style.
    âœ”ï¸ Enables easy parallelism (parallelStream()).
â¤ A stream = sequence of elements supporting various operations.


Stream Workflow
Source â†’ Intermediate Operations â†’ Terminal Operation
âœ… Example: Count even numbers in a list
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

// Traditional way
int count = 0;
for (int num : numbers) {
    if (num % 2 == 0) count++;
}
System.out.println("Count of even numbers: " + count);

// Stream way
long countStream = numbers.stream()
                          .filter(num -> num % 2 == 0)
                          .count();
System.out.println("Count of even numbers: " + countStream);


ğŸ”„ Creating Streams
âš¡ From Collections
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
Stream<Integer> stream = numbers.stream();

âš¡ From Arrays
int[] arr = {1, 2, 3, 4, 5};
IntStream stream = Arrays.stream(arr);

âš¡ Stream.of()
Stream<Integer> stream = Stream.of(1, 2, 3, 4, 5);

âš¡ Stream.empty()
Stream<Integer> emptyStream = Stream.empty();

âš¡ Stream.generate() â†’ Infinite Stream
Stream<Integer> infiniteStream = Stream.generate(() -> 1);
infiniteStream.limit(5).forEach(System.out::println);

âš¡ Stream.iterate() â†’ Infinite Stream
Stream<Integer> infiniteStream = Stream.iterate(1, n -> n + 1);
infiniteStream.limit(5).forEach(System.out::println); 
// Output: 1 2 3 4 5


ğŸ”„ Intermediate Operations
â¤ This transforms a stream into another stream
â¤ Lazy evaluation â†’ they donâ€™t run until a terminal operation is invoked.

List<String> list = Arrays.asList("Alice", "Bob", "Charlie");
âš¡ Filter: Used to include only elements matching a condition.
long count = list.stream().filter(name -> name.st).count();
System.out.println("Count: " + count);

âš¡ Map: Transforms each element into another form.
list.stream()
    .map(String::toUpperCase)
    .forEach(System.out::println);
âœ… Output: ALICE, BOB, CHARLIE

âš¡ sorted()
â¤ Sorts stream elements.
â¤ Default: natural ordering.
â¤ Can pass custom comparator.

list.stream().sorted().forEach(System.out::println);
âœ… Output: Alice, Bob, Charlie

list.stream()
    .sorted((a, b) -> b.compareTo(a))
    .forEach(System.out::println);
âœ… Output: Charlie, Bob, Alice

âš¡ distinct: Removes duplicate elements.
List<Integer> nums = Arrays.asList(1, 2, 2, 3, 3, 3);
long uniqueCount = nums.stream().distinct().count();
System.out.println(uniqueCount); // 3

âš¡ limit -> to limit the number of output getting from the previous stream
Stream.iterate(1, n -> n + 1).limit(5).forEach(System.out::println);
âœ… Output: 1 2 3 4 5

6. skip -> to skip the first n elements from the previous stream
Stream.iterate(1, n -> n + 1)
      .skip(5)
      .limit(5)
      .forEach(System.out::println);
âœ… Output: 6 7 8 9 10

âš¡ peek -> peek() is an intermediate operation in streams.
â¤ Used mainly for debugging â€” lets you â€œpeekâ€ at elements as they flow through the stream pipeline.
â¤ It does not modify the stream elements.

âœ… Syntax: Stream<T> peek(Consumer<? super T> action)

âœ… Example 1: Debugging Stream
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

names.stream()
     .filter(name -> name.length() > 3)
     .peek(n -> System.out.println("Filtered: " + n)) // debugging
     .map(String::toUpperCase)
     .peek(n -> System.out.println("Mapped: " + n))   // debugging
     .forEach(System.out::println);

âœ… Output:
Filtered: Alice
Mapped: ALICE
ALICE
Filtered: Charlie
Mapped: CHARLIE
CHARLIE     

âœ… Example 2: Difference between peek() and forEach()
List<Integer> numbers = Arrays.asList(1, 2, 3);

numbers.stream()
       .peek(n -> System.out.println("Peek: " + n))   // intermediate
       .map(n -> n * n)
       .forEach(n -> System.out.println("ForEach: " + n)); // terminal


âœ… Output:
Peek: 1
ForEach: 1
Peek: 2
ForEach: 4
Peek: 3
ForEach: 9

âš ï¸ Important Notes
â¤ peek() is lazy â†’ it wonâ€™t run unless thereâ€™s a terminal operation (like forEach, collect, count).
â¤ forEach() is a terminal operation, executes the stream pipeline and consumes it.
â¤ Donâ€™t misuse peek() for business logic â€” itâ€™s intended for debugging/inspection.

ğŸ”„ Terminal Operations in Streams
â¤ Produce a final result (non-stream value like List, int, Optional, etc.).
â¤ Trigger execution of intermediate operations.
â¤ Some are short-circuiting â†’ terminate once the result is found (anyMatch, findFirst, etc.).

âš¡ collect()
Collects elements into a collection (like List, Set, Map).
List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> result = list.stream()
                           .skip(1)
                           .collect(Collectors.toList());
// or Java 16+: .toList()

âš¡ forEach()
Performs action for each element.
list.forEach(System.out::println);

âš¡ reduce()
Reduces elements into a single value.
Optional<Integer> sum1 = list.stream().reduce(0, (a, b) -> a + b);
Optional<Integer> sum2 = list.stream().reduce(Integer::sum);
System.out.println(sum2.get()); // 15

âš¡ count()
Counts elements in the stream.
long c = list.stream().count();
System.out.println(c); // 5

âš¡ anyMatch() (âœ… Short-circuit)
Returns true if any element matches.
boolean isEven = list.stream().anyMatch(num -> num % 2 == 0);
// true

âš¡ allMatch() (âœ… Short-circuit)
Returns true if all elements match.
boolean allEven = list.stream().allMatch(num -> num % 2 == 0);
// false

âš¡ noneMatch() (âœ… Short-circuit)
Returns true if no elements match.
boolean noNegative = list.stream().noneMatch(num -> num < 0);
// true

âš¡ findFirst() (âœ… Short-circuit)
Returns the first element that matches.
Optional<Integer> firstEven = list.stream()
                                  .filter(num -> num % 2 == 0)
                                  .findFirst();

âš¡ findAny() (âœ… Short-circuit, useful with parallel streams)
Returns any matching element.
Optional<Integer> anyEven = list.stream()
                                .filter(num -> num % 2 == 0)
                                .findAny();

âš¡ min()
Returns minimum element using comparator.
Optional<Integer> min = list.stream().min(Integer::compare);

âš¡ max()
Returns maximum element using comparator.
Optional<Integer> max = list.stream().max(Integer::compare);

âš¡ toArray
â¤ A terminal operation in Streams.
â¤ Collects stream elements into an array.
â¤ Two forms:
    âœ”ï¸ Object[] toArray() â†’ returns elements as Object[].
    âœ”ï¸ <A> A[] toArray(IntFunction<A[]> generator) â†’ returns elements in an array of a specific type.

âœ… Example 1: Default toArray()
List<String> names = Arrays.asList("Alice", "Bob", "Charlie"); 
Object[] arr = names.stream().toArray(); 
System.out.println(Arrays.toString(arr)); 

âœ… Output: [Alice, Bob, Charlie]


âœ… Example 2: Typed Array with Generator
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
String[] arr = names.stream().toArray(String[]::new);
System.out.println(Arrays.toString(arr)); 

âœ… Output: [Alice, Bob, Charlie]

âœ… Example 3: Numbers
List<Integer> numbers = Arrays.asList(1, 2, 3, 4);
Integer[] arr = numbers.stream().map(n -> n * n)
                                  .toArray(Integer[]::new);
System.out.println(Arrays.toString(arr)); 
âœ… Output: [1, 4, 9, 16]

ğŸ‘‰ Notes:
â¤ toArray() is terminal, ends the stream pipeline.
â¤ Use toArray(String[]::new) (or similar) for type safety.
â¤ Good when APIs require arrays instead of lists.

âš¡flatMap()
â¤ An intermediate operation that flattens a stream of collections into a single stream.
â¤ Combines map() + flattening.
â¤ Signature:
<R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper)

âœ… Why Use flatMap()?
When each element maps to multiple elements (like a list inside a list).
Instead of having a Stream<Stream<T>>, you get a Stream<T>.

âœ… Example 1: Flatten a List of Lists
List<List<String>> namesList = Arrays.asList(
        Arrays.asList("Alice", "Bob"),
        Arrays.asList("Charlie", "David"),
        Arrays.asList("Eve", "Frank")
);
List<String> flatList = namesList.stream()
                                 .flatMap(List::stream)
                                 .toList();
System.out.println(flatList); 
âœ…Output: [Alice, Bob, Charlie, David, Eve, Frank]

âœ… Example 2: Split Strings into Words
List<String> sentences = Arrays.asList("Java is fun", "Streams are powerful");
List<String> words = sentences.stream()
                              .flatMap(s -> Arrays.stream(s.split(" ")))
                              .toList();
System.out.println(words); 
âœ…Output: [Java, is, fun, Streams, are, powerful]

âœ… Example 3: Mapping with Transformation
List<String> names = Arrays.asList("Ankur", "Verma");
List<String> chars = names.stream()
                          .flatMap(name -> name.chars()
                                               .mapToObj(c -> String.valueOf((char) c)))
                          .toList();
System.out.println(chars);
âœ…Output: [A, n, k, u, r, V, e, r, m, a]

âš¡ map() vs flatMap()
| Feature        | `map()`                                     | `flatMap()`                    |
| -------------- | ------------------------------------------- | ------------------------------ |
| Input â†’ Output | One-to-One                                  | One-to-Many (flattens)         |
| Result Type    | `Stream<R>`                                 | `Stream<R>` (flattened)        |
| Common Pitfall | Leaves nested streams (`Stream<Stream<T>>`) | Removes nesting                |
| Example        | Split strings â†’ Stream\<String\[]>          | Split strings â†’ Stream<String> |


ğŸ“ Interview Notes
â¤ Use map() for simple transformations.
â¤ Use flatMap() when dealing with nested collections.
â¤ Very common in database joins, JSON parsing, text processing.
â¤ In parallel streams, flatMap() helps avoid deep nesting.

âš¡ Short-Circuiting Terminal Operations
Stop early without processing all elements.
âœ… Examples:
ğŸ”— anyMatch()
ğŸ”— allMatch()
ğŸ”— noneMatch()
ğŸ”— findFirst()
ğŸ”— findAny()

âœ… Stream Examples
â“ Filtering and Collecting Names
List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");
List<String> result = names.stream()
                           .filter(name -> name.startsWith("A"))
                           .collect(Collectors.toList());
System.out.println(result); // [Alice]

â“ Squaring and Sorting Numbers
List<Integer> numbers = Arrays.asList(5, 2, 8, 3, 1);
List<Integer> squaredSorted = numbers.stream()
                                     .map(n -> n * n)
                                     .sorted()
                                     .collect(Collectors.toList());
System.out.println(squaredSorted); // [1, 4, 9, 25, 64]

â“ Summing Values
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
int sum = numbers.stream()
                 .reduce(0, Integer::sum);
System.out.println(sum); // 15

â“ Count the Occurrence of a Character
String input = "programming";
long count = input.chars()   // Stream of int (Unicode code points)
                  .filter(ch -> ch == 'm')
                  .count();
System.out.println(count); // 2


ğŸ”· StateFull and Stateless Operations

ğŸ”„ Stateless Operations
â¤ Each element is processed independently.
â¤ Donâ€™t need information about other elements.
â¤ Can process in parallel efficiently.
â¤ Faster and less resource intensive.

Examples:
ğŸ”— filter()
ğŸ”— map()
ğŸ”— forEach()
ğŸ”— peek()

âœ… Code:
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
numbers.stream()
       .filter(n -> n % 2 == 0)   // stateless
       .map(n -> n * n)           // stateless
       .forEach(System.out::println); // stateless
âœ… Output: 4, 16

ğŸ”„ Stateful Operations
â¤ Need to know other elements in the stream to produce a result.
â¤ May require buffering or extra computation.
â¤ Can affect performance in parallel streams.

Examples:
ğŸ”— sorted()
ğŸ”— distinct()
ğŸ”— limit()
ğŸ”— skip()

ğŸ”§ Code:
List<Integer> numbers = Arrays.asList(5, 2, 8, 2, 1);
numbers.stream()
       .distinct()   // stateful (checks all seen elements)
       .sorted()     // stateful (needs to sort all elements)
       .forEach(System.out::println);
âœ… Output: 1, 2, 5, 8

ğŸ“ Notes
Stateless ops â†’ process items as they arrive.
Stateful ops â†’ may need to look at the whole stream (sorting, uniqueness, skipping).
Performance Tip: Be careful with large streams when using stateful operations like sorted() or distinct().

ğŸ”· ParallelStream
â¤ A ParallelStream is a type of Stream that splits the workload into multiple threads for faster processing.
â¤ Useful for large data sets and CPU-intensive tasks where tasks are independent.
â¤ Internally uses the ForkJoinPool (common pool, by default uses available processors).
â¤ They may add overhead for simple tasks or small datasets.

âœ… How to Create Parallel Stream
list.parallelStream()      // from collection
Stream.of(1, 2, 3).parallel();  // from Stream

âœ… Example: Factorials in Parallel
import java.util.List;
import java.util.stream.Stream;

public class ParallelStreamExample {
    public static void main(String[] args) {
        List<Integer> list = Stream.iterate(1, x -> x + 1)
                                   .limit(20_000)
                                   .toList();

        // Parallel processing
        List<Long> results = list.parallelStream()
                                 .map(ParallelStreamExample::factorial)
                                 .toList();

        System.out.println("Computed " + results.size() + " factorials.");
    }

    private static long factorial(int n) {
        long result = 1;
        for (int i = 1; i <= n; i++) {
            result *= i;
        }
        return result;
    }
}

âš¡ Notes
âœ… parallelStream() splits the data into chunks and processes them concurrently.
âœ… Improves performance for large collections but has overhead for small ones.
âŒ Order of results may differ unless you use forEachOrdered().
âŒ Be careful with shared mutable state â†’ race conditions.
âš ï¸ Uses ForkJoinPool.commonPool() â†’ can impact other parallel tasks.
â¤ You can control pool size with:
System.setProperty("java.util.concurrent.ForkJoinPool.common.parallelism", "8");

ğŸš« Where NOT to use ParallelStream
âŒ Shared Mutable State
â¤ Parallel streams split work into multiple threads.
â¤ If you use shared mutable state (like AtomicInteger, ArrayList, HashMap), results become unpredictable.
â¤ Different threads update the shared variable in non-deterministic order â†’ wrong results.

âš¡ Example: Cumulative Sum (Wrong with ParallelStream)
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;

public class ParallelPitfall {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
        AtomicInteger sum = new AtomicInteger(0);

        // Parallel stream with shared mutable state
        List<Integer> cumulativeSum = numbers.parallelStream()
                                             .map(sum::addAndGet)
                                             .toList();

        System.out.println("Expected cumulativeSum: [1, 3, 6, 10, 15]");
        System.out.println("Actual cumulativeSum: " + cumulativeSum);
    }
}

âœ… Possible Output (Non-deterministic):
Expected cumulativeSum: [1, 3, 6, 10, 15]
Actual cumulativeSum: [3, 1, 6, 15, 10]

âœ… Correct Way (Sequential)
List<Integer> cumulativeSum = numbers.stream()
                                     .scan(0, Integer::sum)  // Java 9+
                                     .skip(1)
                                     .toList();
System.out.println(cumulativeSum); // [1, 3, 6, 10, 15]
Or manually with a loop if pre-Java 9.

ğŸ”· forEachOrdered() in Streams
A terminal operation similar to forEach().
Guarantees to process elements in encounter order (the order defined by the source).
Especially important when using parallel streams, where forEach() may produce non-deterministic ordering.

âœ… Syntax
void forEachOrdered(Consumer<? super T> action)

âœ… Example 1: Sequential Stream
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
numbers.stream()
       .forEachOrdered(System.out::print); 
âœ… Output: 12345

ğŸ‘‰ Same as forEach() here, since stream is sequential.
âœ… Example 2: Parallel Stream (Key Difference)
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
System.out.print("forEach: ");
numbers.parallelStream()
       .forEach(System.out::print);  
System.out.println();
System.out.print("forEachOrdered: ");
numbers.parallelStream()
       .forEachOrdered(System.out::print);
âœ… Possible Output:
    âœ”ï¸ forEach: 25134   // random order
    âœ”ï¸ forEachOrdered: 12345   // always maintains order

âš¡ forEach() vs forEachOrdered()
| Feature              | `forEach()`                                      | `forEachOrdered()`                                  |
| -------------------- | ------------------------------------------------ | --------------------------------------------------- |
| Ordering Guaranteed? | âŒ No (esp. in parallel)                         | âœ… Yes                                              |
| Performance          | Faster (no ordering overhead)                    | Slower (preserves order)                            |
| Best Use Case        | When order doesnâ€™t matter (e.g., logging, stats) | When order is critical (e.g., printing in sequence) |

âš¡ Key Points
â¤ Use forEachOrdered() when order matters.
â¤ Use plain forEach() for better performance when order is irrelevant.
â¤ Both are terminal operations â†’ consume the stream.

ğŸ‘‰Note: After parallelism to make things sequential use sequential()
ğŸ‘‰Note: Stream cannot be reused after a terminal operation has been called, gives exception.


ğŸ”· Collectors
â¤ A utility class (java.util.stream.Collectors) providing implementations of the Collector interface.
â¤ Used in the terminal operation collect() to gather results of a stream into a collection, map, string, etc.
â¤ Enables mutable reduction (accumulating elements into a container).

1ï¸âƒ£ Basic Collectors (Collections)
âš¡ toList(), toSet(), toCollection()

List<String> list = Stream.of("A","B","C").collect(Collectors.toList());
Set<String> set = Stream.of("A","B","C").collect(Collectors.toSet());
LinkedList<String> linked = Stream.of("A","B").collect(Collectors.toCollection(LinkedList::new));

2ï¸âƒ£ String Collector
âš¡ joining()

List<String> names = Arrays.asList("Alice","Bob","Charlie");
String result = names.stream().collect(Collectors.joining(", ", "[", "]"));
// [Alice, Bob, Charlie]

3ï¸âƒ£ Counting & Aggregation
âš¡ counting()
long count = Stream.of(1,2,3).collect(Collectors.counting()); // 3

âš¡ summingInt / summingLong / summingDouble
âš¡ averagingInt / averagingLong / averagingDouble
int sum = Stream.of(1,2,3).collect(Collectors.summingInt(Integer::intValue)); // 6
double avg = Stream.of(1,2,3).collect(Collectors.averagingInt(Integer::intValue)); // 2.0

âš¡ summarizingInt / summarizingLong / summarizingDouble
IntSummaryStatistics stats = Stream.of(5,10,20)
    .collect(Collectors.summarizingInt(Integer::intValue));
// count=3, sum=35, min=5, avg=11.6, max=20

âš¡ minBy(), maxBy()
Optional<Integer> min = Stream.of(5,10,1).collect(Collectors.minBy(Integer::compare)); // 1

4ï¸âƒ£ Grouping
âš¡ groupingBy(classifier)
List<String> words = Arrays.asList("apple","banana","apricot","blueberry");
Map<Character, List<String>> grouped = words.stream()
    .collect(Collectors.groupingBy(w -> w.charAt(0)));
// {a=[apple, apricot], b=[banana, blueberry]}


âš¡ groupingBy(classifier, downstreamCollector)
Map<Character, Long> groupedCount = words.stream()
    .collect(Collectors.groupingBy(w -> w.charAt(0), Collectors.counting()));
// {a=2, b=2}

5ï¸âƒ£ Partitioning
âš¡ partitioningBy(predicate)
List<Integer> nums = Arrays.asList(1,2,3,4,5);
Map<Boolean, List<Integer>> partitioned = nums.stream()
    .collect(Collectors.partitioningBy(n -> n % 2 == 0));
// {false=[1,3,5], true=[2,4]}

6ï¸âƒ£ Map Collectors
âš¡ toMap(keyMapper, valueMapper)
List<String> fruits = Arrays.asList("apple","banana","cherry");
Map<String, Integer> map = fruits.stream()
    .collect(Collectors.toMap(f -> f, String::length));
// {apple=5, banana=6, cherry=6}

âš¡ toMap(keyMapper, valueMapper, mergeFunction)
Map<Integer, String> map2 = fruits.stream()
    .collect(Collectors.toMap(String::length, f->f, (a,b)->a+","+b));
// {5=apple, 6=banana,cherry}

7ï¸âƒ£ Advanced Collectors
âš¡ collectingAndThen(downstream, finisher)
List<String> list = Arrays.asList("a","b","c");
List<String> unmodifiable = list.stream()
    .collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList));

âš¡ reducing(identity, accumulator)
int sum = Stream.of(1,2,3,4).collect(Collectors.reducing(0, Integer::sum)); // 10


âœ… Examples:
1ï¸âƒ£ Collecting names by length
import java.util.*;
import java.util.stream.*;

public class Example1 {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");

        Map<Integer, List<String>> namesByLength = names.stream()
                .collect(Collectors.groupingBy(String::length));

        System.out.println(namesByLength);
        // {3=[Bob], 5=[Alice, David], 7=[Charlie]}
    }
}

2ï¸âƒ£ Counting word occurrences
import java.util.*;
import java.util.stream.*;

public class Example2 {
    public static void main(String[] args) {
        List<String> words = Arrays.asList("apple", "banana", "apple", "orange", "banana", "apple");

        Map<String, Long> wordCount = words.stream()
                .collect(Collectors.groupingBy(w -> w, Collectors.counting()));

        System.out.println(wordCount);
        // {orange=1, banana=2, apple=3}
    }
}

3ï¸âƒ£ Partitioning even and odd numbers
import java.util.*;
import java.util.stream.*;

public class Example3 {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1,2,3,4,5,6,7,8,9,10);

        Map<Boolean, List<Integer>> partitioned = numbers.stream()
                .collect(Collectors.partitioningBy(n -> n % 2 == 0));

        System.out.println(partitioned);
        // {false=[1, 3, 5, 7, 9], true=[2, 4, 6, 8, 10]}
    }
}

4ï¸âƒ£ Summing values in a map
import java.util.*;
import java.util.stream.*;

public class Example4 {
    public static void main(String[] args) {
        Map<String, Integer> items = new HashMap<>();
        items.put("A", 10);
        items.put("B", 20);
        items.put("C", 30);

        int total = items.values().stream()
                .collect(Collectors.summingInt(Integer::intValue));

        System.out.println("Total sum = " + total);
        // Total sum = 60
    }
}

5ï¸âƒ£ Creating a map from stream elements
import java.util.*;
import java.util.stream.*;

public class Example5 {
    public static void main(String[] args) {
        List<String> fruits = Arrays.asList("apple", "banana", "cherry");

        Map<String, Integer> fruitLengthMap = fruits.stream()
                .collect(Collectors.toMap(f -> f, String::length));

        System.out.println(fruitLengthMap);
        // {apple=5, banana=6, cherry=6}
    }
}

ğŸ”„ Collectors: Two Contexts
1ï¸âƒ£ Normal Collector
â¤ A normal collector is directly applied to a whole stream.

âœ… Example:
long count = list.stream().collect(Collectors.counting());
int sum = list.stream().collect(Collectors.summingInt(x -> x));

â¤ Here, the collector is applied to the entire stream as a single group.

2ï¸âƒ£ Downstream Collector
â¤ A downstream collector is applied inside another collector (like groupingBy or partitioningBy).
â¤ It decides what to do with each subgroup after grouping.

âœ… Example:
Map<String, Double> avgMarksBySubject = students.stream()
    .collect(Collectors.groupingBy(
        Student::getSubject,                  // key â†’ subject
        Collectors.averagingInt(Student::getMarks) // downstream collector
    ));
âœ”ï¸ groupingBy splits students into subgroups by subject.
âœ”ï¸ Then averagingInt is applied as the downstream collector to each subgroup.
âœ”ï¸ Without downstream collectors, groupingBy would just give you a Map<String, List<Student>>.
âœ”ï¸ With downstream collectors, you can transform that into counts, sums, averages, max/min, etc.


ğŸ”· Primitive Streams
1ï¸âƒ£ Why Primitive Streams?
â¤ Normal Stream<T> works with objects only â†’ leads to autoboxing/unboxing overhead when dealing with primitives.
â¤ To avoid performance cost, Java provides specialized streams for primitives:
    âœ”ï¸ IntStream â†’ for int
    âœ”ï¸ LongStream â†’ for long
    âœ”ï¸ DoubleStream â†’ for double

âœ… These provide:
â¤ Better performance (no boxing/unboxing).
â¤ Extra specialized methods (like sum(), average(), range(), etc.).

2ï¸âƒ£ Types of Primitive Streams
ğŸ”¹ IntStream: Used for int values.
âœ… Example:

import java.util.stream.*;

public class IntStreamExample {
    public static void main(String[] args) {
        IntStream.range(1, 5).forEach(System.out::println); // 1 2 3 4
        int sum = IntStream.of(1, 2, 3, 4, 5).sum();
        System.out.println("Sum = " + sum); // 15
    }
}

ğŸ”¹ LongStream: Used for long values.
âœ… Example:

import java.util.stream.*;

public class LongStreamExample {
    public static void main(String[] args) {
        long count = LongStream.rangeClosed(1, 5).count();
        System.out.println("Count = " + count); // 5
    }
}

ğŸ”¹ DoubleStream: Used for double values.
âœ… Example:

import java.util.stream.*;

public class DoubleStreamExample {
    public static void main(String[] args) {
        DoubleStream.of(2.5, 3.5, 4.5).average()
                    .ifPresent(avg -> System.out.println("Average = " + avg));
        // Average = 3.5
    }
}

3ï¸âƒ£ Creating Primitive Streams
âš¡ of()
IntStream.of(1, 2, 3);
DoubleStream.of(1.1, 2.2, 3.3);

âš¡ range() / rangeClosed()
IntStream.range(1, 5);       // 1,2,3,4
IntStream.rangeClosed(1, 5); // 1,2,3,4,5

âš¡ Arrays.stream()
int[] arr = {1,2,3,4};
IntStream stream = Arrays.stream(arr);

âš¡ Random numbers
new Random().ints(5).forEach(System.out::println); // 5 random ints

âš¡ builder()
IntStream stream = IntStream.builder().add(10).add(20).add(30).build();

4ï¸âƒ£ Common Methods in Primitive Streams
ğŸ”— sum()
ğŸ”— average()
ğŸ”— min() / max()
ğŸ”— count()
ğŸ”— summaryStatistics() â†’ gives count, sum, min, max, avg in one go

IntSummaryStatistics stats = IntStream.of(5, 10, 15).summaryStatistics();
System.out.println(stats);
// IntSummaryStatistics{count=3, sum=30, min=5, average=10.000000, max=15}

5ï¸âƒ£ Conversions
ğŸ‘‰ Primitive â†’ Object Stream

IntStream.range(1, 4).mapToObj(i -> "Num:" + i)
        .forEach(System.out::println);
// Num:1 Num:2 Num:3


ğŸ‘‰ Object â†’ Primitive Stream
List<String> list = Arrays.asList("1","2","3");
IntStream intStream = list.stream().mapToInt(Integer::parseInt);
intStream.forEach(System.out::println); // 1 2 3

6ï¸âƒ£ Parallel Processing
Primitive streams also support .parallel()


