🧠 Method Referencing in Java
➤ A shorthand syntax of lambda expressions when the lambda body only calls an existing method.
➤ Improves readability and makes code look cleaner.
➤ Introduced in Java 8 with functional programming features.

🔹 Syntax
ClassName::methodName
object::methodName
ClassName::new  (for constructors)

🔹 Types of Method References
✅Type 1: Reference to a static method

list.forEach(System.out::println);  
// equivalent to: list.forEach(x -> System.out.println(x));

✅Type 2: Reference to an instance method of a particular object
String str = "hello";
Supplier<Integer> s = str::length;
System.out.println(s.get());  // 5

✅Type 3: Reference to an instance method of an arbitrary object of a particular type
List<String> names = Arrays.asList("Ankur", "Ravi", "Megha");
names.sort(String::compareToIgnoreCase);
// equivalent to (a, b) -> a.compareToIgnoreCase(b)

✅Type 4: Reference to a constructor
Supplier<Student> s = Student::new;
Student st = s.get();

🔹 Why Method Reference?
➤ Makes lambda shorter and cleaner.
➤ Avoids boilerplate (param) -> obj.method(param).
➤ Improves readability in sorting, filtering, mapping, etc.

🔹 Example: Sorting with Method Reference
students.sort(Comparator.comparingInt(Student::getAge));

Equivalent lambda:
students.sort((s1, s2) -> Integer.compare(s1.getAge(), s2.getAge()));

⚡ Tips
➤ Method reference is just syntactic sugar for lambdas.
➤ Works only when the method signature matches the functional interface method.
➤ Commonly used in Streams API (map, filter, forEach) and Comparator.

✅ Example Code Snippet
package collections;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;

class Student {
	String name;
	double gpa;

	Student(String name, double gpa) {
		this.name = name;
		this.gpa = gpa;
	}

	String getName() {
		return this.name;
	}

	double getGpa() {
		return this.gpa;
	}

} 
public class ArrayListIntro {

	public static void main(String[] args) {
		List<Student> students = new ArrayList<>();
		students.add(new Student("Charlie", 3.5));
		students.add(new Student("Bob", 3.7));
		students.add(new Student("Alice", 3.5));
		students.add(new Student("Ankur", 3.9));

		Comparator<Student> comparator = Comparator.comparing(Student::getGpa).reversed()
				.thenComparing(Student::getName);

		students.sort(comparator);
		for (Student s : students) {
			System.out.println(s.getName() + " " + s.getGpa());
		}

	}
}


🔷 Java 8 Basics
➤ Introduced to write minimal code and improve developer productivity.
➤ Functional Programming. For Example: lambda expressions, method references, streams, etc.

🌟 Lambda expression
// Functional interface
@FunctionalInterface
interface MathOperation {
    int operate(int a, int b);
}

public class LambdaMathOperation {
    public static void main(String[] args) {

        // Addition
        MathOperation add = (a, b) -> a + b;

        // Subtraction
        MathOperation subtract = (a, b) -> a - b;

        // Multiplication
        MathOperation multiply = (a, b) -> a * b;

        // Division (with check for divide by zero)
        MathOperation divide = (a, b) -> b != 0 ? a / b : 0;

        // Testing
        System.out.println("10 + 5 = " + add.operate(10, 5));
        System.out.println("10 - 5 = " + subtract.operate(10, 5));
        System.out.println("10 * 5 = " + multiply.operate(10, 5));
        System.out.println("10 / 5 = " + divide.operate(10, 5));
    }
}
✅ Output:
10 + 5 = 15
10 - 5 = 5
10 * 5 = 50
10 / 5 = 2


🌟Predicate
➤ A functional interface in java.util.function.
➤ Represents a boolean-valued function of one argument.
➤ Contains one abstract method:
🔗 boolean test(T t);

🔄 Common Usage
➤ Filtering collections (Stream.filter()).
➤ Validation checks (like input checks, number checks, etc.).
➤ Combining multiple conditions.

✅Code Example:
import java.util.function.Predicate;

public class PredicateExample {
    public static void main(String[] args) {
        Predicate<Integer> isEven = x -> x % 2 == 0;
        Predicate<Integer> isPositive = x -> x > 0;

        System.out.println(isEven.test(4));   // true
        System.out.println(isPositive.test(-3)); // false
    }
}

🔄 Combining Predicates
Predicate provides default methods to combine multiple conditions:

👉 and() → Returns true if both predicates are true.
✅Code Example:
Predicate<Integer> isEven = x -> x % 2 == 0;
Predicate<Integer> isPositive = x -> x > 0;

Predicate<Integer> isEvenAndPositive = isEven.and(isPositive);
System.out.println(isEvenAndPositive.test(4));  // true
System.out.println(isEvenAndPositive.test(-2)); // false

👉 or() → Returns true if any one predicate is true.
✅Code Example:
Predicate<Integer> isEven = x -> x % 2 == 0;
Predicate<Integer> isNegative = x -> x < 0;

Predicate<Integer> isEvenOrNegative = isEven.or(isNegative);
System.out.println(isEvenOrNegative.test(3));   // false
System.out.println(isEvenOrNegative.test(-5));  // true

👉 negate() → Returns the opposite of the predicate.
✅Code Example:
Predicate<Integer> isEven = x -> x % 2 == 0;

Predicate<Integer> isOdd = isEven.negate();
System.out.println(isOdd.test(5));  // true

👉 isEqual() → Static method, checks if an object is equal to another.
✅Code Example:
Predicate<String> isHello = Predicate.isEqual("Hello");
System.out.println(isHello.test("Hello")); // true
System.out.println(isHello.test("Hi"));    // false

✅Real-Life Example: Filtering a List
import java.util.*;
import java.util.function.Predicate;
import java.util.stream.Collectors;

public class PredicateFilterExample {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(10, -3, 4, -7, 8, 15);

        Predicate<Integer> isPositive = x -> x > 0;
        Predicate<Integer> isEven = x -> x % 2 == 0;

        // Filter only positive even numbers
        List<Integer> result = numbers.stream()
                                      .filter(isPositive.and(isEven))
                                      .collect(Collectors.toList());

        System.out.println(result); // [10, 4, 8]
    }
}

🧠 Tips & Traps
✅ Predicate is mostly used in Streams API (e.g., filter() needs Predicate).
✅ Can be combined using .and(), .or(), .negate().
❌ Null values: Predicate can throw NullPointerException if not handled.
❓ Trick Q: How is Predicate<T> different from Function<T, Boolean>?
✔️ Predicate<T> is specialized for boolean-returning conditions, while Function<T, Boolean> is generic.


🌟 Function
➤ A functional interface from java.util.function.
➤ Represents a function that takes one argument and returns a result.
➤ Abstract method:
🔗 R apply(T t);

✅Code Example:
import java.util.function.Function;

public class FunctionExample {
    public static void main(String[] args) {
        Function<Integer, Integer> square = x -> x * x;

        System.out.println(square.apply(5)); // 25
    }
}

When both input and output types are the same, use UnaryOperator<T> instead of Function<T, T>.
✅ Example: 
import java.util.function.Function;

public class FunctionExample {
    public static void main(String[] args) {
        UnaryOperator<Integer> square = x -> x * x;

        System.out.println(square.apply(5)); // 25
    }
}

🔄 Default Methods (Combining Functions)
👉 andThen()
➤ Executes the current function first, then applies another function.
✅Code Example
Function<Integer, Integer> multiplyBy2 = x -> x * 2;
Function<Integer, Integer> square = x -> x * x;

// First multiply by 2, then square
Function<Integer, Integer> resultFunc = multiplyBy2.andThen(square);

System.out.println(resultFunc.apply(3)); // (3*2)^2 = 36

👉 compose()
➤ Opposite of andThen(). Executes the given function first, then applies the current one.
✅Code Example
Function<Integer, Integer> multiplyBy2 = x -> x * 2;
Function<Integer, Integer> square = x -> x * x;

// First square, then multiply by 2
Function<Integer, Integer> resultFunc = multiplyBy2.compose(square);

System.out.println(resultFunc.apply(3)); // (3^2)*2 = 18

👉 identity() (Static Method)
➤ Returns a function that always returns its input.
✅Code Example
Function<String, String> identityFunc = Function.identity();
System.out.println(identityFunc.apply("Hello")); // Hello

✅ Real-Life Example: Convert & Process Data
import java.util.function.Function;

public class FunctionChainExample {
    public static void main(String[] args) {
        // Step 1: Convert string to integer
        Function<String, Integer> strToInt = Integer::parseInt;

        // Step 2: Square the integer
        Function<Integer, Integer> square = x -> x * x;

        // Chain them
        Function<String, Integer> process = strToInt.andThen(square);

        System.out.println(process.apply("6")); // 36
    }
}

🧠 Notes
✅ andThen() vs compose() → Order of execution is key (common trick Q).
✅ Function.identity() → used in collectors (e.g., toMap() in Streams).
❌ Be careful with NumberFormatException when using Integer::parseInt.
🔥 Advanced: There’s also BiFunction<T,U,R> for functions with two arguments.


🌟 Consumer
➤ A functional interface from java.util.function.
➤ Represents an operation that takes one argument but returns no result.
➤ Abstract method:
🔗 void accept(T t);

✅ Example:
import java.util.function.Consumer;

public class ConsumerExample {
    public static void main(String[] args) {
        Consumer<Integer> printSquare = x -> System.out.println(x * x);
        printSquare.accept(5); // 25
    }
}

🔄 Chaining Consumers
Consumer provides andThen() to chain operations.
✅ Example:
import java.util.function.Consumer;

public class ConsumerChainExample {
    public static void main(String[] args) {
        Consumer<String> printUpper = s -> System.out.println(s.toUpperCase());
        Consumer<String> printLength = s -> System.out.println("Length: " + s.length());

        Consumer<String> combined = printUpper.andThen(printLength);

        combined.accept("hello");
    }
}
✅ Output
HELLO
Length: 5

✅ Real-Life Example
import java.util.*;
import java.util.function.Consumer;

public class ConsumerListExample {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

        Consumer<String> printName = name -> System.out.println("Hello, " + name);

        // forEach accepts a Consumer
        names.forEach(printName);
    }
}

⚡Notes
✅ Consumer is mostly used in forEach() (Streams + Collections).
✅ Can be chained with .andThen().
❌ Returns void, so can’t be used for transformations (that’s Function<T,R>).
🔥 Advanced variants:
➤ BiConsumer<T,U> → accepts two arguments.
➤ IntConsumer, LongConsumer, DoubleConsumer → primitive specializations (avoid boxing).


🌟Supplier
➤ A functional interface from java.util.function.
➤ Represents a supplier of results → takes no argument and returns a value.
➤ Abstract method:
🔗 T get();

✅ Example:
import java.util.function.Supplier;

public class SupplierExample {
    public static void main(String[] args) {
        Supplier<Double> randomValue = () -> Math.random();

        System.out.println(randomValue.get()); // e.g., 0.527896123
    }
}

Real-Life Examples
✅ Generate Current Time
import java.time.LocalDateTime;
import java.util.function.Supplier;

public class TimeSupplier {
    public static void main(String[] args) {
        Supplier<LocalDateTime> currentTime = () -> LocalDateTime.now();

        System.out.println("Current Time: " + currentTime.get());
    }
}

✅ Fallback Values (e.g., default config)
import java.util.function.Supplier;

public class ConfigSupplier {
    public static void main(String[] args) {
        Supplier<String> defaultConfig = () -> "DEFAULT-CONFIG";

        String config = null;
        String result = (config != null) ? config : defaultConfig.get();

        System.out.println(result); // DEFAULT-CONFIG
    }
}

⚡ Notes
✅ Supplier is useful for lazy initialization (create objects only when needed).
✅ Used in Streams API (e.g., Stream.generate(Supplier<T>)).
❌ No input → only returns.
🔥 Advanced variants:
BooleanSupplier, IntSupplier, LongSupplier, DoubleSupplier (primitive specializations).

🌟 BiPredicate
➤ Boolean-valued function of two arguments.
➤ Abstract method:
🔗 boolean test(T t, U u);

✅ Example
import java.util.function.BiPredicate;

public class BiPredicateExample {
    public static void main(String[] args) {
        BiPredicate<String, String> areEqual = (s1, s2) -> s1.equalsIgnoreCase(s2);

        System.out.println(areEqual.test("Java", "java")); // true
        System.out.println(areEqual.test("Java", "Python")); // false
    }
}
👉 Use Case: String comparisons, validation checks involving two values.

🌟 BiConsumer
➤ Represents an operation that takes two arguments and returns no result.
➤ Abstract method:
🔗 void accept(T t, U u);

✅ Example
import java.util.function.BiConsumer;

public class BiConsumerExample {
    public static void main(String[] args) {
        BiConsumer<String, Integer> printNameAge = 
            (name, age) -> System.out.println(name + " is " + age + " years old");

        printNameAge.accept("Alice", 25);
    }
}
👉 Use Case: Logging, printing, updating maps (Map.forEach(BiConsumer)).

🌟 BiFunction
➤ Represents a function that takes two arguments and returns a result.
➤ Abstract method:
🔗 R apply(T t, U u);

✅ Example
import java.util.function.BiFunction;

public class BiFunctionExample {
    public static void main(String[] args) {
        BiFunction<Integer, Integer, Integer> add = (a, b) -> a + b;

        System.out.println(add.apply(10, 20)); // 30
    }
}
👉 Use Case: Arithmetic operations, combining two inputs to produce an output.

⚡ Pro Tip:
If both the input type and return type is of same Wrapper class then use BinaryOperator<T>
✅ Example:
import java.util.function.BinaryOperator;

public class BinaryOperatorExample {
    public static void main(String[] args) {
        BinaryOperator<Integer> add = (a,b)-> a+b;

        System.out.println(add.apply(10, 20)); // 30
    }
}


🌟 Streams (Java 8)
➤ Process collections of data in a functional & declarative manner.
➤ Introduced in Java 8.
➤ Benefits:
    ✔️ Simplifies data processing & analysis.
    ✔️ Improves readability & maintainability.
    ✔️ Encourages functional programming style.
    ✔️ Enables easy parallelism (parallelStream()).
➤ A stream = sequence of elements supporting various operations.


Stream Workflow
Source → Intermediate Operations → Terminal Operation
✅ Example: Count even numbers in a list
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

// Traditional way
int count = 0;
for (int num : numbers) {
    if (num % 2 == 0) count++;
}
System.out.println("Count of even numbers: " + count);

// Stream way
long countStream = numbers.stream()
                          .filter(num -> num % 2 == 0)
                          .count();
System.out.println("Count of even numbers: " + countStream);


🔄 Creating Streams
⚡ From Collections
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
Stream<Integer> stream = numbers.stream();

⚡ From Arrays
int[] arr = {1, 2, 3, 4, 5};
IntStream stream = Arrays.stream(arr);

⚡ Stream.of()
Stream<Integer> stream = Stream.of(1, 2, 3, 4, 5);

⚡ Stream.empty()
Stream<Integer> emptyStream = Stream.empty();

⚡ Stream.generate() → Infinite Stream
Stream<Integer> infiniteStream = Stream.generate(() -> 1);
infiniteStream.limit(5).forEach(System.out::println);

⚡ Stream.iterate() → Infinite Stream
Stream<Integer> infiniteStream = Stream.iterate(1, n -> n + 1);
infiniteStream.limit(5).forEach(System.out::println); 
// Output: 1 2 3 4 5


🔄 Intermediate Operations
➤ This transforms a stream into another stream
➤ Lazy evaluation → they don’t run until a terminal operation is invoked.

List<String> list = Arrays.asList("Alice", "Bob", "Charlie");
⚡ Filter: Used to include only elements matching a condition.
long count = list.stream().filter(name -> name.st).count();
System.out.println("Count: " + count);

⚡ Map: Transforms each element into another form.
list.stream()
    .map(String::toUpperCase)
    .forEach(System.out::println);
✅ Output: ALICE, BOB, CHARLIE

⚡ sorted()
➤ Sorts stream elements.
➤ Default: natural ordering.
➤ Can pass custom comparator.

list.stream().sorted().forEach(System.out::println);
✅ Output: Alice, Bob, Charlie

list.stream()
    .sorted((a, b) -> b.compareTo(a))
    .forEach(System.out::println);
✅ Output: Charlie, Bob, Alice

⚡ distinct: Removes duplicate elements.
List<Integer> nums = Arrays.asList(1, 2, 2, 3, 3, 3);
long uniqueCount = nums.stream().distinct().count();
System.out.println(uniqueCount); // 3

⚡ limit -> to limit the number of output getting from the previous stream
Stream.iterate(1, n -> n + 1).limit(5).forEach(System.out::println);
✅ Output: 1 2 3 4 5

6. skip -> to skip the first n elements from the previous stream
Stream.iterate(1, n -> n + 1)
      .skip(5)
      .limit(5)
      .forEach(System.out::println);
✅ Output: 6 7 8 9 10

⚡ peek -> peek() is an intermediate operation in streams.
➤ Used mainly for debugging — lets you “peek” at elements as they flow through the stream pipeline.
➤ It does not modify the stream elements.

✅ Syntax: Stream<T> peek(Consumer<? super T> action)

✅ Example 1: Debugging Stream
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

names.stream()
     .filter(name -> name.length() > 3)
     .peek(n -> System.out.println("Filtered: " + n)) // debugging
     .map(String::toUpperCase)
     .peek(n -> System.out.println("Mapped: " + n))   // debugging
     .forEach(System.out::println);

✅ Output:
Filtered: Alice
Mapped: ALICE
ALICE
Filtered: Charlie
Mapped: CHARLIE
CHARLIE     

✅ Example 2: Difference between peek() and forEach()
List<Integer> numbers = Arrays.asList(1, 2, 3);

numbers.stream()
       .peek(n -> System.out.println("Peek: " + n))   // intermediate
       .map(n -> n * n)
       .forEach(n -> System.out.println("ForEach: " + n)); // terminal


✅ Output:
Peek: 1
ForEach: 1
Peek: 2
ForEach: 4
Peek: 3
ForEach: 9

⚠️ Important Notes
➤ peek() is lazy → it won’t run unless there’s a terminal operation (like forEach, collect, count).
➤ forEach() is a terminal operation, executes the stream pipeline and consumes it.
➤ Don’t misuse peek() for business logic — it’s intended for debugging/inspection.

🔄 Terminal Operations in Streams
➤ Produce a final result (non-stream value like List, int, Optional, etc.).
➤ Trigger execution of intermediate operations.
➤ Some are short-circuiting → terminate once the result is found (anyMatch, findFirst, etc.).

⚡ collect()
Collects elements into a collection (like List, Set, Map).
List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> result = list.stream()
                           .skip(1)
                           .collect(Collectors.toList());
// or Java 16+: .toList()

⚡ forEach()
Performs action for each element.
list.forEach(System.out::println);

⚡ reduce()
Reduces elements into a single value.
Optional<Integer> sum1 = list.stream().reduce(0, (a, b) -> a + b);
Optional<Integer> sum2 = list.stream().reduce(Integer::sum);
System.out.println(sum2.get()); // 15

⚡ count()
Counts elements in the stream.
long c = list.stream().count();
System.out.println(c); // 5

⚡ anyMatch() (✅ Short-circuit)
Returns true if any element matches.
boolean isEven = list.stream().anyMatch(num -> num % 2 == 0);
// true

⚡ allMatch() (✅ Short-circuit)
Returns true if all elements match.
boolean allEven = list.stream().allMatch(num -> num % 2 == 0);
// false

⚡ noneMatch() (✅ Short-circuit)
Returns true if no elements match.
boolean noNegative = list.stream().noneMatch(num -> num < 0);
// true

⚡ findFirst() (✅ Short-circuit)
Returns the first element that matches.
Optional<Integer> firstEven = list.stream()
                                  .filter(num -> num % 2 == 0)
                                  .findFirst();

⚡ findAny() (✅ Short-circuit, useful with parallel streams)
Returns any matching element.
Optional<Integer> anyEven = list.stream()
                                .filter(num -> num % 2 == 0)
                                .findAny();

⚡ min()
Returns minimum element using comparator.
Optional<Integer> min = list.stream().min(Integer::compare);

⚡ max()
Returns maximum element using comparator.
Optional<Integer> max = list.stream().max(Integer::compare);

⚡ toArray
➤ A terminal operation in Streams.
➤ Collects stream elements into an array.
➤ Two forms:
    ✔️ Object[] toArray() → returns elements as Object[].
    ✔️ <A> A[] toArray(IntFunction<A[]> generator) → returns elements in an array of a specific type.

✅ Example 1: Default toArray()
List<String> names = Arrays.asList("Alice", "Bob", "Charlie"); 
Object[] arr = names.stream().toArray(); 
System.out.println(Arrays.toString(arr)); 

✅ Output: [Alice, Bob, Charlie]


✅ Example 2: Typed Array with Generator
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
String[] arr = names.stream().toArray(String[]::new);
System.out.println(Arrays.toString(arr)); 

✅ Output: [Alice, Bob, Charlie]

✅ Example 3: Numbers
List<Integer> numbers = Arrays.asList(1, 2, 3, 4);
Integer[] arr = numbers.stream().map(n -> n * n)
                                  .toArray(Integer[]::new);
System.out.println(Arrays.toString(arr)); 
✅ Output: [1, 4, 9, 16]

👉 Notes:
➤ toArray() is terminal, ends the stream pipeline.
➤ Use toArray(String[]::new) (or similar) for type safety.
➤ Good when APIs require arrays instead of lists.

⚡flatMap()
➤ An intermediate operation that flattens a stream of collections into a single stream.
➤ Combines map() + flattening.
➤ Signature:
<R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper)

✅ Why Use flatMap()?
When each element maps to multiple elements (like a list inside a list).
Instead of having a Stream<Stream<T>>, you get a Stream<T>.

✅ Example 1: Flatten a List of Lists
List<List<String>> namesList = Arrays.asList(
        Arrays.asList("Alice", "Bob"),
        Arrays.asList("Charlie", "David"),
        Arrays.asList("Eve", "Frank")
);
List<String> flatList = namesList.stream()
                                 .flatMap(List::stream)
                                 .toList();
System.out.println(flatList); 
✅Output: [Alice, Bob, Charlie, David, Eve, Frank]

✅ Example 2: Split Strings into Words
List<String> sentences = Arrays.asList("Java is fun", "Streams are powerful");
List<String> words = sentences.stream()
                              .flatMap(s -> Arrays.stream(s.split(" ")))
                              .toList();
System.out.println(words); 
✅Output: [Java, is, fun, Streams, are, powerful]

✅ Example 3: Mapping with Transformation
List<String> names = Arrays.asList("Ankur", "Verma");
List<String> chars = names.stream()
                          .flatMap(name -> name.chars()
                                               .mapToObj(c -> String.valueOf((char) c)))
                          .toList();
System.out.println(chars);
✅Output: [A, n, k, u, r, V, e, r, m, a]

⚡ map() vs flatMap()
| Feature        | `map()`                                     | `flatMap()`                    |
| -------------- | ------------------------------------------- | ------------------------------ |
| Input → Output | One-to-One                                  | One-to-Many (flattens)         |
| Result Type    | `Stream<R>`                                 | `Stream<R>` (flattened)        |
| Common Pitfall | Leaves nested streams (`Stream<Stream<T>>`) | Removes nesting                |
| Example        | Split strings → Stream\<String\[]>          | Split strings → Stream<String> |


📝 Interview Notes
➤ Use map() for simple transformations.
➤ Use flatMap() when dealing with nested collections.
➤ Very common in database joins, JSON parsing, text processing.
➤ In parallel streams, flatMap() helps avoid deep nesting.

⚡ Short-Circuiting Terminal Operations
Stop early without processing all elements.
✅ Examples:
🔗 anyMatch()
🔗 allMatch()
🔗 noneMatch()
🔗 findFirst()
🔗 findAny()

✅ Stream Examples
❓ Filtering and Collecting Names
List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");
List<String> result = names.stream()
                           .filter(name -> name.startsWith("A"))
                           .collect(Collectors.toList());
System.out.println(result); // [Alice]

❓ Squaring and Sorting Numbers
List<Integer> numbers = Arrays.asList(5, 2, 8, 3, 1);
List<Integer> squaredSorted = numbers.stream()
                                     .map(n -> n * n)
                                     .sorted()
                                     .collect(Collectors.toList());
System.out.println(squaredSorted); // [1, 4, 9, 25, 64]

❓ Summing Values
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
int sum = numbers.stream()
                 .reduce(0, Integer::sum);
System.out.println(sum); // 15

❓ Count the Occurrence of a Character
String input = "programming";
long count = input.chars()   // Stream of int (Unicode code points)
                  .filter(ch -> ch == 'm')
                  .count();
System.out.println(count); // 2


🔷 StateFull and Stateless Operations

🔄 Stateless Operations
➤ Each element is processed independently.
➤ Don’t need information about other elements.
➤ Can process in parallel efficiently.
➤ Faster and less resource intensive.

Examples:
🔗 filter()
🔗 map()
🔗 forEach()
🔗 peek()

✅ Code:
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
numbers.stream()
       .filter(n -> n % 2 == 0)   // stateless
       .map(n -> n * n)           // stateless
       .forEach(System.out::println); // stateless
✅ Output: 4, 16

🔄 Stateful Operations
➤ Need to know other elements in the stream to produce a result.
➤ May require buffering or extra computation.
➤ Can affect performance in parallel streams.

Examples:
🔗 sorted()
🔗 distinct()
🔗 limit()
🔗 skip()

🔧 Code:
List<Integer> numbers = Arrays.asList(5, 2, 8, 2, 1);
numbers.stream()
       .distinct()   // stateful (checks all seen elements)
       .sorted()     // stateful (needs to sort all elements)
       .forEach(System.out::println);
✅ Output: 1, 2, 5, 8

📝 Notes
Stateless ops → process items as they arrive.
Stateful ops → may need to look at the whole stream (sorting, uniqueness, skipping).
Performance Tip: Be careful with large streams when using stateful operations like sorted() or distinct().

🔷 ParallelStream
➤ A ParallelStream is a type of Stream that splits the workload into multiple threads for faster processing.
➤ Useful for large data sets and CPU-intensive tasks where tasks are independent.
➤ Internally uses the ForkJoinPool (common pool, by default uses available processors).
➤ They may add overhead for simple tasks or small datasets.

✅ How to Create Parallel Stream
list.parallelStream()      // from collection
Stream.of(1, 2, 3).parallel();  // from Stream

✅ Example: Factorials in Parallel
import java.util.List;
import java.util.stream.Stream;

public class ParallelStreamExample {
    public static void main(String[] args) {
        List<Integer> list = Stream.iterate(1, x -> x + 1)
                                   .limit(20_000)
                                   .toList();

        // Parallel processing
        List<Long> results = list.parallelStream()
                                 .map(ParallelStreamExample::factorial)
                                 .toList();

        System.out.println("Computed " + results.size() + " factorials.");
    }

    private static long factorial(int n) {
        long result = 1;
        for (int i = 1; i <= n; i++) {
            result *= i;
        }
        return result;
    }
}

⚡ Notes
✅ parallelStream() splits the data into chunks and processes them concurrently.
✅ Improves performance for large collections but has overhead for small ones.
❌ Order of results may differ unless you use forEachOrdered().
❌ Be careful with shared mutable state → race conditions.
⚠️ Uses ForkJoinPool.commonPool() → can impact other parallel tasks.
➤ You can control pool size with:
System.setProperty("java.util.concurrent.ForkJoinPool.common.parallelism", "8");

🚫 Where NOT to use ParallelStream
❌ Shared Mutable State
➤ Parallel streams split work into multiple threads.
➤ If you use shared mutable state (like AtomicInteger, ArrayList, HashMap), results become unpredictable.
➤ Different threads update the shared variable in non-deterministic order → wrong results.

⚡ Example: Cumulative Sum (Wrong with ParallelStream)
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;

public class ParallelPitfall {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
        AtomicInteger sum = new AtomicInteger(0);

        // Parallel stream with shared mutable state
        List<Integer> cumulativeSum = numbers.parallelStream()
                                             .map(sum::addAndGet)
                                             .toList();

        System.out.println("Expected cumulativeSum: [1, 3, 6, 10, 15]");
        System.out.println("Actual cumulativeSum: " + cumulativeSum);
    }
}

✅ Possible Output (Non-deterministic):
Expected cumulativeSum: [1, 3, 6, 10, 15]
Actual cumulativeSum: [3, 1, 6, 15, 10]

✅ Correct Way (Sequential)
List<Integer> cumulativeSum = numbers.stream()
                                     .scan(0, Integer::sum)  // Java 9+
                                     .skip(1)
                                     .toList();
System.out.println(cumulativeSum); // [1, 3, 6, 10, 15]
Or manually with a loop if pre-Java 9.

🔷 forEachOrdered() in Streams
A terminal operation similar to forEach().
Guarantees to process elements in encounter order (the order defined by the source).
Especially important when using parallel streams, where forEach() may produce non-deterministic ordering.

✅ Syntax
void forEachOrdered(Consumer<? super T> action)

✅ Example 1: Sequential Stream
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
numbers.stream()
       .forEachOrdered(System.out::print); 
✅ Output: 12345

👉 Same as forEach() here, since stream is sequential.
✅ Example 2: Parallel Stream (Key Difference)
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
System.out.print("forEach: ");
numbers.parallelStream()
       .forEach(System.out::print);  
System.out.println();
System.out.print("forEachOrdered: ");
numbers.parallelStream()
       .forEachOrdered(System.out::print);
✅ Possible Output:
    ✔️ forEach: 25134   // random order
    ✔️ forEachOrdered: 12345   // always maintains order

⚡ forEach() vs forEachOrdered()
| Feature              | `forEach()`                                      | `forEachOrdered()`                                  |
| -------------------- | ------------------------------------------------ | --------------------------------------------------- |
| Ordering Guaranteed? | ❌ No (esp. in parallel)                         | ✅ Yes                                              |
| Performance          | Faster (no ordering overhead)                    | Slower (preserves order)                            |
| Best Use Case        | When order doesn’t matter (e.g., logging, stats) | When order is critical (e.g., printing in sequence) |

⚡ Key Points
➤ Use forEachOrdered() when order matters.
➤ Use plain forEach() for better performance when order is irrelevant.
➤ Both are terminal operations → consume the stream.

👉Note: After parallelism to make things sequential use sequential()
👉Note: Stream cannot be reused after a terminal operation has been called, gives exception.


🔷 Collectors
➤ A utility class (java.util.stream.Collectors) providing implementations of the Collector interface.
➤ Used in the terminal operation collect() to gather results of a stream into a collection, map, string, etc.
➤ Enables mutable reduction (accumulating elements into a container).

1️⃣ Basic Collectors (Collections)
⚡ toList(), toSet(), toCollection()

List<String> list = Stream.of("A","B","C").collect(Collectors.toList());
Set<String> set = Stream.of("A","B","C").collect(Collectors.toSet());
LinkedList<String> linked = Stream.of("A","B").collect(Collectors.toCollection(LinkedList::new));

2️⃣ String Collector
⚡ joining()

List<String> names = Arrays.asList("Alice","Bob","Charlie");
String result = names.stream().collect(Collectors.joining(", ", "[", "]"));
// [Alice, Bob, Charlie]

3️⃣ Counting & Aggregation
⚡ counting()
long count = Stream.of(1,2,3).collect(Collectors.counting()); // 3

⚡ summingInt / summingLong / summingDouble
⚡ averagingInt / averagingLong / averagingDouble
int sum = Stream.of(1,2,3).collect(Collectors.summingInt(Integer::intValue)); // 6
double avg = Stream.of(1,2,3).collect(Collectors.averagingInt(Integer::intValue)); // 2.0

⚡ summarizingInt / summarizingLong / summarizingDouble
IntSummaryStatistics stats = Stream.of(5,10,20)
    .collect(Collectors.summarizingInt(Integer::intValue));
// count=3, sum=35, min=5, avg=11.6, max=20

⚡ minBy(), maxBy()
Optional<Integer> min = Stream.of(5,10,1).collect(Collectors.minBy(Integer::compare)); // 1

4️⃣ Grouping
⚡ groupingBy(classifier)
List<String> words = Arrays.asList("apple","banana","apricot","blueberry");
Map<Character, List<String>> grouped = words.stream()
    .collect(Collectors.groupingBy(w -> w.charAt(0)));
// {a=[apple, apricot], b=[banana, blueberry]}


⚡ groupingBy(classifier, downstreamCollector)
Map<Character, Long> groupedCount = words.stream()
    .collect(Collectors.groupingBy(w -> w.charAt(0), Collectors.counting()));
// {a=2, b=2}

5️⃣ Partitioning
⚡ partitioningBy(predicate)
List<Integer> nums = Arrays.asList(1,2,3,4,5);
Map<Boolean, List<Integer>> partitioned = nums.stream()
    .collect(Collectors.partitioningBy(n -> n % 2 == 0));
// {false=[1,3,5], true=[2,4]}

6️⃣ Map Collectors
⚡ toMap(keyMapper, valueMapper)
List<String> fruits = Arrays.asList("apple","banana","cherry");
Map<String, Integer> map = fruits.stream()
    .collect(Collectors.toMap(f -> f, String::length));
// {apple=5, banana=6, cherry=6}

⚡ toMap(keyMapper, valueMapper, mergeFunction)
Map<Integer, String> map2 = fruits.stream()
    .collect(Collectors.toMap(String::length, f->f, (a,b)->a+","+b));
// {5=apple, 6=banana,cherry}

7️⃣ Advanced Collectors
⚡ collectingAndThen(downstream, finisher)
List<String> list = Arrays.asList("a","b","c");
List<String> unmodifiable = list.stream()
    .collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList));

⚡ reducing(identity, accumulator)
int sum = Stream.of(1,2,3,4).collect(Collectors.reducing(0, Integer::sum)); // 10


✅ Examples:
1️⃣ Collecting names by length
import java.util.*;
import java.util.stream.*;

public class Example1 {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");

        Map<Integer, List<String>> namesByLength = names.stream()
                .collect(Collectors.groupingBy(String::length));

        System.out.println(namesByLength);
        // {3=[Bob], 5=[Alice, David], 7=[Charlie]}
    }
}

2️⃣ Counting word occurrences
import java.util.*;
import java.util.stream.*;

public class Example2 {
    public static void main(String[] args) {
        List<String> words = Arrays.asList("apple", "banana", "apple", "orange", "banana", "apple");

        Map<String, Long> wordCount = words.stream()
                .collect(Collectors.groupingBy(w -> w, Collectors.counting()));

        System.out.println(wordCount);
        // {orange=1, banana=2, apple=3}
    }
}

3️⃣ Partitioning even and odd numbers
import java.util.*;
import java.util.stream.*;

public class Example3 {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1,2,3,4,5,6,7,8,9,10);

        Map<Boolean, List<Integer>> partitioned = numbers.stream()
                .collect(Collectors.partitioningBy(n -> n % 2 == 0));

        System.out.println(partitioned);
        // {false=[1, 3, 5, 7, 9], true=[2, 4, 6, 8, 10]}
    }
}

4️⃣ Summing values in a map
import java.util.*;
import java.util.stream.*;

public class Example4 {
    public static void main(String[] args) {
        Map<String, Integer> items = new HashMap<>();
        items.put("A", 10);
        items.put("B", 20);
        items.put("C", 30);

        int total = items.values().stream()
                .collect(Collectors.summingInt(Integer::intValue));

        System.out.println("Total sum = " + total);
        // Total sum = 60
    }
}

5️⃣ Creating a map from stream elements
import java.util.*;
import java.util.stream.*;

public class Example5 {
    public static void main(String[] args) {
        List<String> fruits = Arrays.asList("apple", "banana", "cherry");

        Map<String, Integer> fruitLengthMap = fruits.stream()
                .collect(Collectors.toMap(f -> f, String::length));

        System.out.println(fruitLengthMap);
        // {apple=5, banana=6, cherry=6}
    }
}

🔄 Collectors: Two Contexts
1️⃣ Normal Collector
➤ A normal collector is directly applied to a whole stream.

✅ Example:
long count = list.stream().collect(Collectors.counting());
int sum = list.stream().collect(Collectors.summingInt(x -> x));

➤ Here, the collector is applied to the entire stream as a single group.

2️⃣ Downstream Collector
➤ A downstream collector is applied inside another collector (like groupingBy or partitioningBy).
➤ It decides what to do with each subgroup after grouping.

✅ Example:
Map<String, Double> avgMarksBySubject = students.stream()
    .collect(Collectors.groupingBy(
        Student::getSubject,                  // key → subject
        Collectors.averagingInt(Student::getMarks) // downstream collector
    ));
✔️ groupingBy splits students into subgroups by subject.
✔️ Then averagingInt is applied as the downstream collector to each subgroup.
✔️ Without downstream collectors, groupingBy would just give you a Map<String, List<Student>>.
✔️ With downstream collectors, you can transform that into counts, sums, averages, max/min, etc.


🔷 Primitive Streams
1️⃣ Why Primitive Streams?
➤ Normal Stream<T> works with objects only → leads to autoboxing/unboxing overhead when dealing with primitives.
➤ To avoid performance cost, Java provides specialized streams for primitives:
    ✔️ IntStream → for int
    ✔️ LongStream → for long
    ✔️ DoubleStream → for double

✅ These provide:
➤ Better performance (no boxing/unboxing).
➤ Extra specialized methods (like sum(), average(), range(), etc.).

2️⃣ Types of Primitive Streams
🔹 IntStream: Used for int values.
✅ Example:

import java.util.stream.*;

public class IntStreamExample {
    public static void main(String[] args) {
        IntStream.range(1, 5).forEach(System.out::println); // 1 2 3 4
        int sum = IntStream.of(1, 2, 3, 4, 5).sum();
        System.out.println("Sum = " + sum); // 15
    }
}

🔹 LongStream: Used for long values.
✅ Example:

import java.util.stream.*;

public class LongStreamExample {
    public static void main(String[] args) {
        long count = LongStream.rangeClosed(1, 5).count();
        System.out.println("Count = " + count); // 5
    }
}

🔹 DoubleStream: Used for double values.
✅ Example:

import java.util.stream.*;

public class DoubleStreamExample {
    public static void main(String[] args) {
        DoubleStream.of(2.5, 3.5, 4.5).average()
                    .ifPresent(avg -> System.out.println("Average = " + avg));
        // Average = 3.5
    }
}

3️⃣ Creating Primitive Streams
⚡ of()
IntStream.of(1, 2, 3);
DoubleStream.of(1.1, 2.2, 3.3);

⚡ range() / rangeClosed()
IntStream.range(1, 5);       // 1,2,3,4
IntStream.rangeClosed(1, 5); // 1,2,3,4,5

⚡ Arrays.stream()
int[] arr = {1,2,3,4};
IntStream stream = Arrays.stream(arr);

⚡ Random numbers
new Random().ints(5).forEach(System.out::println); // 5 random ints

⚡ builder()
IntStream stream = IntStream.builder().add(10).add(20).add(30).build();

4️⃣ Common Methods in Primitive Streams
🔗 sum()
🔗 average()
🔗 min() / max()
🔗 count()
🔗 summaryStatistics() → gives count, sum, min, max, avg in one go

IntSummaryStatistics stats = IntStream.of(5, 10, 15).summaryStatistics();
System.out.println(stats);
// IntSummaryStatistics{count=3, sum=30, min=5, average=10.000000, max=15}

5️⃣ Conversions
👉 Primitive → Object Stream

IntStream.range(1, 4).mapToObj(i -> "Num:" + i)
        .forEach(System.out::println);
// Num:1 Num:2 Num:3


👉 Object → Primitive Stream
List<String> list = Arrays.asList("1","2","3");
IntStream intStream = list.stream().mapToInt(Integer::parseInt);
intStream.forEach(System.out::println); // 1 2 3

6️⃣ Parallel Processing
Primitive streams also support .parallel()


