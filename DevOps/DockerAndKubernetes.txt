
###############################
ğŸ”· Introduction to Containers
###############################
â¤ Containers are lightweight, isolated runtime environments that package an application along with its dependencies (libraries, configs, binaries).
â¤ They share the host OS kernel, unlike VMs which need a full guest OS.
â¤ They ensure â€œWorks on my machineâ€ issues disappear by providing a consistent environment across development, testing, and production.
â¤ Popular container runtime: Docker (most common), containerd, CRI-O, runc.


ğŸ”„ Problems With Virtual Machines
âŒ Problem 1ï¸âƒ£: Heavy Resource Usage
â¤ VMs include a full guest operating system â†’ large in size (GBs).
â¤ Heavy CPU/RAM consumption.

âŒ Problem 2ï¸âƒ£: Slow Boot Time
â¤ VMs take minutes to start because they boot a complete OS.

âŒ Problem 3ï¸âƒ£: Hard to Scale
â¤ Spinning up multiple VMs is costly and slow â†’ not ideal for microservices.

âŒ Problem 4ï¸âƒ£: Duplication of OS
â¤ Each VM has its own OS â†’ wastes disk space.

âŒ Problem 5ï¸âƒ£: Hard to Port
â¤ VM images are large â†’ difficult to move, copy, push/pull.

âŒ Problem 6ï¸âƒ£: Dev/Prod Inconsistency
â¤ Developers run different OS versions or dependencies â†’ deployment failures.


ğŸ”„ How Containers Solve Those Problems
1ï¸âƒ£ Lightweight (No Guest OS)
âœ”ï¸ Containers share the host OS kernel â†’ only app + its libraries are packaged.
âœ”ï¸ Much smaller than VMs (MBs instead of GBs).

2ï¸âƒ£ Fast Startup
âœ”ï¸ Containers start in seconds (no OS booting).

3ï¸âƒ£ Easy Scaling
âœ”ï¸ Spin up multiple containers instantly â†’ perfect for microservices + Kubernetes.

4ï¸âƒ£ Better Resource Utilization
More containers on same hardware vs VMs â†’ cheaper infrastructure.

5ï¸âƒ£ Portability
Same container image runs on:
  âœ”ï¸Dev laptop
  âœ”ï¸Test server
  âœ”ï¸Production
  âœ”ï¸Cloud

6ï¸âƒ£ Consistent Environments
âœ”ï¸ Application + dependencies packaged together â†’ no configuration drift.

 
ğŸ”„ Containers ğŸ†š VMs
| Feature      | Containers           | Virtual Machines              |
| ------------ | -------------------- | ----------------------------- |
| OS           | Share host OS kernel | Each has its own guest OS     |
| Startup time | Seconds              | Minutes                       |
| Size         | MBs                  | GBs                           |
| Isolation    | Process-level        | Full OS-level                 |
| Performance  | Near-native          | Some overhead                 |
| Scaling      | Very fast            | Slow                          |
| Use case     | Microservices, CI/CD | Strong isolation, legacy apps |


ğŸ”„ Drawbacks of Containers & How to Overcome Them
âŒ  Weaker Security (Shared Kernel)
â¤ If kernel is compromised â†’ all containers are at risk.

âœ… Solution:
â¤ Use VM isolation for untrusted workloads.
â¤ Use Kubernetes Pod Security Policies, AppArmor, SELinux.
â¤ Regular kernel patching.

âŒ Limited Isolation Compared to VMs
â¤ Containers share the same OS kernel.

âœ… Solution:
â¤ Use sandboxed containers (gVisor, Kata Containers).
â¤ Use hardened distros (Bottlerocket, Flatcar).

âŒ Complex Networking
â¤ Container networking (bridge, overlay, CNI plugins) is harder than VM networks.

âœ… Solution:
â¤ Use Kubernetes CNI (Calico, Flannel) for easier management.

âŒ Persistent Storage Challenges
â¤ Containers are ephemeral; data disappears on deletion.

âœ… Solution:
â¤ Use volumes: Docker volumes, Kubernetes PersistentVolumes.

âŒ Image Bloat
â¤ Large base images â†’ slow builds and pulls.

âœ… Solution:
â¤ Use slim images (alpine, debian-slim).
â¤ Multi-stage Docker builds.


ğŸ”„ Architecture of Containers
Container architecture consists of:

1ï¸âƒ£ User Layer
âœ”ï¸ Applications
âœ”ï¸ Libraries
âœ”ï¸ Dependencies
âœ”ï¸ Environment variables

2ï¸âƒ£ Container Image Layer
â¤ Immutable filesystem created by layering:
  âœ”ï¸ base image â†’ runtime â†’ dependencies â†’ source code
â¤ Stored in a registry (Docker Hub, ECR, GCR)

3ï¸âƒ£ Runtime Layer
Two main components:
1ï¸âƒ£ High-level runtime (Docker, containerd)
2ï¸âƒ£ Low-level runtime (runc) â€” responsible for creating the containerâ€™s namespaces & cgroups

4ï¸âƒ£ OS Layer
Kernel features used:
âœ”ï¸ Namespaces â†’ isolation
âœ”ï¸ cgroups â†’ resource limits
âœ”ï¸ UnionFS â†’ layered filesystem

5ï¸âƒ£ Host Layer
Host OS + hardware resources


ğŸ”„ Features of Containers
1ï¸âƒ£ Isolation
Each container runs independently.

2ï¸âƒ£ Portability
Runs anywhere (Linux, Windows, Cloud, Kubernetes).

3ï¸âƒ£ Lightweight
No OS included â†’ fast and small.

4ï¸âƒ£ Scalability
Scale up/down quickly.

5ï¸âƒ£ Immutability
Images are read-only; changes create new layers.

6ï¸âƒ£ Consistency
Same environment across all stages.

7ï¸âƒ£ Resource Efficiency
More apps per host vs VMs.

8ï¸âƒ£ Fast Deployment
Containers spin up in seconds.

9ï¸âƒ£ Loose Coupling
Perfect for microservices architecture.


ğŸ”„ Lifecycle of Containers
1ï¸âƒ£ Create
âœ”ï¸ Container is defined but not running.
ğŸ”— docker create image-name

2ï¸âƒ£ Start
âœ”ï¸ Container starts execution.
ğŸ”— docker start container-id

3ï¸âƒ£ Run
âœ”ï¸ Equivalent to create + start.
ğŸ”— docker run image-name

4ï¸âƒ£ Pause
âœ”ï¸ Temporarily pause execution.
ğŸ”— docker pause container-id

5ï¸âƒ£ Resume / Unpause
ğŸ”— docker unpause container-id

6ï¸âƒ£ Stop
âœ”ï¸ Gracefully stops the container (SIGTERM).
ğŸ”— docker stop container-id

7ï¸âƒ£ Kill
âœ”ï¸ Force stop (SIGKILL).
ğŸ”— docker kill container-id

8ï¸âƒ£ Restart
âœ”ï¸ Stop + start.
ğŸ”— docker restart container-id

9ï¸âƒ£ Remove
âœ”ï¸ Deletes the container.
ğŸ”— docker rm container-id


ğŸ”„ Files and Folders in containers base images
1ï¸âƒ£  /bin: contains binary executable files, such as the ls, cp, and ps commands.
2ï¸âƒ£ /sbin: contains system binary executable files, such as the init and shutdown commands.
3ï¸âƒ£ /etc: contains configuration files for various system services.
4ï¸âƒ£ /lib: contains library files that are used by the binary executables.
5ï¸âƒ£ /usr: contains user-related files and utilities, such as applications, libraries, and documentation.
6ï¸âƒ£ /var: contains variable data, such as log files, spool files, and temporary files.
7ï¸âƒ£ /root: is the home directory of the root user.

ğŸ”„ Files and Folders that containers use from host operating system
1ï¸âƒ£ The host's file system: Docker containers can access the host file system using bind mounts, which allow the container to read and write files in the host file system.

2ï¸âƒ£ The host's Networking stack: The host's networking stack is used to provide network connectivity to the container. Docker containers can be connected to the host's network directly or through a virtual network.

3ï¸âƒ£ The host's System calls: The host's kernel handles system calls from the container, which is how the container accesses the host's resources, such as CPU, memory, and I/O.

4ï¸âƒ£ Namespaces: Docker containers use Linux namespaces to create isolated environments for the container's processes. Namespaces provide isolation for resources such as the file system, process ID, and network.

5ï¸âƒ£ Control groups (cgroups): Docker containers use cgroups to limit and control the amount of resources, such as CPU, memory, and I/O, that a container can access.


###########
ğŸ”· Docker
###########
Docker is a containerization platform that provides easy way to containerize your applications, which means, using Docker you can build container images, run the images to create containers and also push these containers to container regestries such as DockerHub, Quay.io and so on.

In simple words, you can understand as containerization is a concept or technology and Docker Implements Containerization.

ğŸ”„ Docker LifeCycle
There are three important things,
1ï¸âƒ£ docker build -> builds docker images from Dockerfile
2ï¸âƒ£ docker run -> runs container from docker images
3ï¸âƒ£ docker push -> push the container image to public/private regestries to share the docker images.


ğŸ”„ Understanding the terminology
1ï¸âƒ£ Docker daemon
The Docker daemon (dockerd) listens for Docker API requests and manages Docker objects such as images, containers, networks, and volumes. A daemon can also communicate with other daemons to manage Docker services.

2ï¸âƒ£ Docker client
The Docker client (docker) is the primary way that many Docker users interact with Docker. When you use commands such as docker run, the client sends these commands to dockerd, which carries them out. The docker command uses the Docker API. The Docker client can communicate with more than one daemon.

3ï¸âƒ£ Docker Desktop
Docker Desktop is an easy-to-install application for your Mac, Windows or Linux environment that enables you to build and share containerized applications and microservices. Docker Desktop includes the Docker daemon (dockerd), the Docker client (docker), Docker Compose, Docker Content Trust, Kubernetes, and Credential Helper. For more information, see Docker Desktop.

4ï¸âƒ£ Docker registries
âœ”ï¸ A Docker registry stores Docker images. Docker Hub is a public registry that anyone can use, and Docker is configured to look for images on Docker Hub by default. You can even run your own private registry.

âœ”ï¸ When you use the docker pull or docker run commands, the required images are pulled from your configured registry. When you use the docker push command, your image is pushed to your configured registry. Docker objects

âœ”ï¸ When you use Docker, you are creating and using images, containers, networks, volumes, plugins, and other objects. This section is a brief overview of some of those objects.

5ï¸âƒ£ Dockerfile
Dockerfile is a file where you provide the steps to build your Docker Image.

6ï¸âƒ£ Images
An image is a read-only template with instructions for creating a Docker container. Often, an image is based on another image, with some additional customization. For example, you may build an image which is based on the ubuntu image, but installs the Apache web server and your application, as well as the configuration details needed to make your application run.

You might create your own images or you might only use those created by others and published in a registry. To build your own image, you create a Dockerfile with a simple syntax for defining the steps needed to create the image and run it. Each instruction in a Dockerfile creates a layer in the image. When you change the Dockerfile and rebuild the image, only those layers which have changed are rebuilt. This is part of what makes images so lightweight, small, and fast, when compared to other virtualization technologies.


ğŸ”„ INSTALL DOCKER
A very detailed instructions to install Docker are provide in the below link

https://docs.docker.com/get-docker/

For Demo,
1ï¸âƒ£ You can create an Ubuntu EC2 Instance on AWS and run the below commands to install docker.
ğŸ”— sudo apt update
ğŸ”— sudo apt install docker.io -y

2ï¸âƒ£ Start Docker and Grant Access
A very common mistake that many beginners do is, After they install docker using the sudo access, they miss the step to Start the Docker daemon and grant acess to the user they want to use to interact with docker and run docker commands.

3ï¸âƒ£ Always ensure the docker daemon is up and running.
A easy way to verify your Docker installation is by running the below command
ğŸ”— docker run hello-world

ğŸ‘‰ If the output says:
docker: Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Post "http://%2Fvar%2Frun%2Fdocker.sock/v1.24/containers/create": dial unix /var/run/docker.sock: connect: permission denied.
See 'docker run --help'.

This can mean two things,
1ï¸âƒ£ Docker deamon is not running.
2ï¸âƒ£ Your user does not have access to run docker commands.

4ï¸âƒ£ Start Docker daemon
You use the below command to verify if the docker daemon is actually started and Active
ğŸ”— sudo systemctl status docker

5ï¸âƒ£ If you notice that the docker daemon is not running, you can start the daemon using the below command
ğŸ”— sudo systemctl start docker

6ï¸âƒ£ Grant Access to your user to run docker commands
To grant access to your user to run the docker command, you should add the user to the Docker Linux group. Docker group is create by default when docker is installed.
ğŸ”— sudo usermod -aG docker ubuntu

ğŸ‘‰ In the above command ubuntu is the name of the user, you can change the username appropriately.

âš¡ NOTE: : You need to logout and login back for the changes to be reflected.

Docker is Installed, up and running ğŸ¥³ğŸ¥³
Use the same command again, to verify that docker is up and running.

ğŸ”— docker run hello-world
âœ… Output should look like:
....
....
Hello from Docker!
This message shows that your installation appears to be working correctly.
...
...

#############################
ğŸ”· Multi-Stage Docker Build 
#############################
Multi-stage Docker build allows you to use multiple temporary images during the build process and copy only the required final artifacts into a small, clean production image.

ğŸ“Œ In short:
â¤ Build in one image
â¤ Run in another image
â¤ Discard everything else


ğŸ”„ Why Multi-Stage Build Was Introduced (The Problem)
âŒ Old (Single-Stage Dockerfile) Problem

Earlier, Dockerfiles looked like this:
FROM node:18

WORKDIR /app
COPY . .
RUN npm install
RUN npm run build

CMD ["npm", "start"]

â— Issues with this approach:
â¤ Image contains:
  âœ”ï¸ Node.js
  âœ”ï¸ npm
  âœ”ï¸ source code
  âœ”ï¸ build tools
  âœ”ï¸ dev dependencies
â¤ Image size becomes very large (300â€“800MB)
â¤ Security risk (extra tools inside production container)
â¤ Slow deployment


ğŸ”„ Core Idea of Multi-Stage Build
Use different images for different stages of the build.

| Stage         | Purpose                   |
| ------------- | ------------------------- |
| Build stage   | Compile / build code      |
| Runtime stage | Only run the final output |
ğŸ‘‰ Only the final stage image is shipped ğŸš€


ğŸ”—  Basic Syntax of Multi-Stage Dockerfile
FROM image AS stage-name
ğŸ‘‰ You can have multiple FROM statements in one Dockerfile.


âœ… Example (Node.js App)
ğŸ“ Project Structure
.
â”œâ”€â”€ package.json
â”œâ”€â”€ src/
â””â”€â”€ Dockerfile

ğŸ”— Multi-Stage Dockerfile
# ---------- Stage 1: Build ----------
FROM node:18 AS builder

WORKDIR /app
COPY package*.json ./
RUN npm install

COPY . .
RUN npm run build


# ---------- Stage 2: Production ----------
FROM node:18-alpine

WORKDIR /app

COPY --from=builder /app/dist ./dist
COPY --from=builder /app/package.json ./

RUN npm install --only=production

CMD ["node", "dist/index.js"]


ğŸ”„ Internal Working
1ï¸âƒ£ Docker starts Stage 1 (builder)
2ï¸âƒ£ Installs dependencies
3ï¸âƒ£ Builds the project
4ï¸âƒ£ Output goes to /app/dist
5ï¸âƒ£ Docker starts Stage 2
6ï¸âƒ£ Copies only /app/dist from Stage 1
7ï¸âƒ£ Stage 1 image is discarded
8ï¸âƒ£ Final image contains:
  âœ”ï¸ compiled files
  âœ”ï¸ minimal runtime
ğŸ‘‰ Intermediate images are NOT shipped

ğŸ”„ COPY --from 
COPY --from=builder /app/dist ./dist

ğŸ‘‰ Means:
â¤ Copy files from another stage
â¤ Not from local filesystem
â¤ Stage name acts like a virtual image

âœ… Real-World Example: React App + Nginx
ğŸ¯ Goal
â¤ Build React app
â¤ Serve via Nginx
â¤ No Node.js in production

ğŸ”— Dockerfile
# ---------- Stage 1: Build ----------
FROM node:18 AS builder

WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build


# ---------- Stage 2: Nginx ----------
FROM nginx:alpine

COPY --from=builder /app/build /usr/share/nginx/html

EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]

ğŸ‘‰ Final image:
â¤ No Node.js
â¤ Only static files + Nginx
â¤ Very small (~25MB)

ğŸ”„Multi-Stage ğŸ†š Single-Stage 
| Feature            | Single Stage | Multi-Stage |
| ------------------ | ------------ | ----------- |
| Image size         | Large        | Very small  |
| Security           | Poor         | High        |
| Build tools inside | Yes          | No          |
| Production ready   | âŒ            | âœ…           |
| Best practice      | âŒ            | âœ…           |


ğŸ” Security Advantages
â¤ No compilers
â¤ No package managers
â¤ No source code
â¤ Reduced attack surface
â¤ Follows principle of least privilege

âš¡ â€œMulti-stage builds significantly reduce the attack surface of production containers.â€


ğŸ”„ Performance Benefits
â¤ Faster pull time
â¤ Faster container startup
â¤ Less disk usage
â¤ Faster CI/CD pipelines

âœ… Multi-Stage Build with Java
Spring Boot Example
# ---------- Stage 1: Build ----------
FROM maven:3.9-eclipse-temurin-17 AS builder

WORKDIR /app
COPY pom.xml .
COPY src ./src
RUN mvn clean package -DskipTests


# ---------- Stage 2: Runtime ----------
FROM eclipse-temurin:17-jre-alpine

WORKDIR /app
COPY --from=builder /app/target/app.jar app.jar

CMD ["java", "-jar", "app.jar"]

ğŸ‘‰ Maven is not included in final image.


â“ Can multiple stages use different base images?
âœ… Yes (Node, Nginx, JRE, Alpine, etc.)

â“ Are intermediate images stored?
âŒ No (unless you tag them manually)

â“ Does multi-stage increase build time?
âŒ Slightly during build
âœ… But saves time in runtime and deployment

â“ Can we copy between stages?
âœ… Yes using COPY --from=stage


ğŸ”„ Best Practices 
âœ”ï¸ Use small base images (alpine)
âœ”ï¸ Separate build and runtime
âœ”ï¸ Name stages clearly (builder, runtime)
âœ”ï¸ Copy only required artifacts
âœ”ï¸ Avoid copying .env or secrets


âŒ When NOT to Use Multi-Stage?
â¤ Very small scripts
â¤ One-file utilities
â¤ Quick local testing

ğŸ‘‰ In production â†’ Always use multi-stage

#################################
ğŸ”· Distroless Container Images
#################################
Distroless container images are Docker/container images that contain only the application and its runtime dependencies, and nothing else.
â¤ No OS package manager
â¤ No shell (bash/sh)
â¤ No utilities like ls, curl, ps
â¤ No unnecessary libraries

â¡ï¸ Distroless images remove everything except what is required to run the app.â€


â“ Why are they called â€œDistrolessâ€?

ğŸ”— Traditional images:
Ubuntu / Debian / Alpine
+ Shell
+ Coreutils
+ Package manager
+ Debug tools
+ App


ğŸ”— Distroless images:
Only App + Runtime (JRE / Node / Python / libc)
â¡ï¸ There is no Linux distribution inside, so the image is called â€œdistrolessâ€.

ğŸ‘‰ Distroless was Developed by Google
ğŸ‘‰ Used internally at Google Cloud
ğŸ‘‰ Open-sourced for production workloads


ğŸ”„ Goal of Distroless Images
ğŸ¯ Reduce attack surface + increase security + reduce image size


â—Problems with Traditional Container Images
âŒ 1ï¸âƒ£ Large Image Size
â¤ Ubuntu image ~70MB
â¤ Debian ~120MB
â¤ Includes tools not required in production

âŒ 2ï¸âƒ£ Security Vulnerabilities
â¤ Shells + utilities = more CVEs
â¤ Hackers can exploit bash, curl, apt, etc.

âŒ 3ï¸âƒ£ Containers Used as Mini VMs
â¤ Devs SSH into containers (bad practice)
â¤ Containers should be immutable

ğŸ”„ Distroless Solves These Problems
| Problem        | Distroless Solution             |
| -------------- | ------------------------------- |
| Large size     | Only runtime libraries included |
| Security risk  | No shell, no package manager    |
| Debug misuse   | Forces proper observability     |
| Faster startup | Less filesystem to scan         |


ğŸ”„ Distroless Images Contain
Depending on runtime:
1ï¸âƒ£ Java Distroless
  âœ”ï¸ JVM
  âœ”ï¸ Required libc
  âœ”ï¸ CA certificates
  âœ”ï¸ Your .jar

2ï¸âƒ£ Node.js Distroless
  âœ”ï¸ Node runtime
  âœ”ï¸ Required shared libraries
  âœ”ï¸ Your JS app

3ï¸âƒ£ Python Distroless
  âœ”ï¸ Python interpreter
  âœ”ï¸ Required libraries
  âœ”ï¸ Your app


ğŸ”„ Distroless Images DO NOT Contain
âŒ /bin/bash
âŒ /bin/sh
âŒ apt, apk, yum
âŒ curl, wget
âŒ ps, top, netstat
ğŸ‘‰ This is intentional.


ğŸ”„ Why No Shell is a BIG DEAL
1ï¸âƒ£ Security Impact:
â¤ Attacker cannot run commands inside container
â¤ Even if container is compromised â†’ limited damage

2ï¸âƒ£ Operational Impact:
â¤ Cannot docker exec -it bash
â¤ Must rely on:
  âœ”ï¸ Logs
  âœ”ï¸ Metrics
  âœ”ï¸ Tracing
ğŸ‘‰ Encourages cloud-native best practices


ğŸ”„ Distroless ğŸ†š Alpine ğŸ†š Ubuntu
| Feature          | Ubuntu | Alpine | Distroless    |
| ---------------- | ------ | ------ | ------------  |
| OS present       | Yes    | Yes    | âŒ No         |
| Shell            | Yes    | Yes    | âŒ No         |
| Package manager  | Yes    | Yes    | âŒ No         |
| Image size       | Large  | Small  | Smallest      |
| Security         | Medium | Better | Best          |
| Debugging        | Easy   | Easy   | Hard          |
| Production ready | âŒ     | âš ï¸    | âœ…            |


ğŸ”„ Distroless is for Production, not Development
âŒ Bad Use Case
â¤ Local debugging
â¤ Running scripts interactively
â¤ Installing packages dynamically

âœ… Good Use Case
â¤ Microservices
â¤ Kubernetes workloads
â¤ Cloud-native apps
â¤ CI/CD final stage images


ğŸ”„ Multi-Stage Docker Build 
Distroless is almost always used with multi-stage builds.

âœ… Example (Java-Based App) 
# Stage 1: Build
FROM maven:3.9-eclipse-temurin-17 AS build
WORKDIR /app
COPY . .
RUN mvn clean package -DskipTests

# Stage 2: Runtime (Distroless)
FROM gcr.io/distroless/java17-debian12
COPY --from=build /app/target/app.jar /app.jar
CMD ["app.jar"]


âœ”ï¸ Build tools not included
âœ”ï¸ Only final artifact copied
âœ”ï¸ No shell in runtime image


ğŸ”„ How Distroless Containers Run Without a Shell
âŒ Instead of:
ğŸ”— CMD java -jar app.jar

âœ… They use exec form:
ğŸ”— CMD ["java", "-jar", "app.jar"]

ğŸ‘‰ Shell form (CMD java -jar) requires /bin/sh â†’ not available

ğŸ”„ Logging in Distroless Containers
â¤ Logs go to stdout / stderr
â¤ Docker / Kubernetes captures logs
â¤ Use:
  âœ”ï¸ kubectl logs
  âœ”ï¸ ELK / Loki / Cloud Logging

ğŸ”¹ Debugging Distroless Containers (Interview Trap)
âŒ You cannot exec into them
âœ… Proper debugging methods:
âœ”ï¸ Application logs
âœ”ï¸ Metrics (Prometheus)
âœ”ï¸ Tracing (Jaeger)
âœ”ï¸ Sidecar containers
âœ”ï¸ Temporary debug image


ğŸ”„ Distroless & Kubernetes (Real World)
â¤ Preferred for:
  âœ”ï¸ Backend services
  âœ”ï¸ APIs
  âœ”ï¸ Event consumers

â¤ Used by:
  âœ”ï¸ Google
  âœ”ï¸ Large SaaS companies

â¤ Works best with:
  âœ”ï¸ Read-only root filesystem
  âœ”ï¸ Non-root users

âœ… Distroless Images Examples
| Runtime | Image                                 |
| ------- | ------------------------------------- |
| Java    | `gcr.io/distroless/java17-debian12`   |
| Node    | `gcr.io/distroless/nodejs20-debian12` |
| Python  | `gcr.io/distroless/python3-debian12`  |
| Base    | `gcr.io/distroless/base-debian12`     |


ğŸŒŸ Common Questions
â“ Why are distroless images more secure?
âœ… Answer: Because they remove shell, package managers, and unnecessary binaries, which significantly reduces the attack surface and vulnerability exposure.

â“ Can you SSH into a distroless container?
âœ… Answer: No. Distroless containers do not contain a shell or SSH server.

â“ How do you debug a distroless container?
âœ… Answer: By using logs, metrics, distributed tracing, or attaching a temporary debug container.

â“ Why not use Alpine instead?
âœ… Answer: Alpine still contains a shell and package manager, whereas distroless removes everything unnecessary, making it more secure for production.

â“ Is distroless suitable for development?
âœ… Answer: No. It is designed for production workloads only.