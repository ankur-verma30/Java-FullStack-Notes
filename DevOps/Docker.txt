###############################
ğŸ”· Introduction to Containers
###############################
â¤ Containers are lightweight, isolated runtime environments that package an application along with its dependencies (libraries, configs, binaries).
â¤ They share the host OS kernel, unlike VMs which need a full guest OS.
â¤ They ensure â€œWorks on my machineâ€ issues disappear by providing a consistent environment across development, testing, and production.
â¤ Popular container runtime: Docker (most common), containerd, CRI-O, runc.


ğŸ”„ Problems With Virtual Machines
âŒ Problem 1ï¸âƒ£: Heavy Resource Usage
â¤ VMs include a full guest operating system â†’ large in size (GBs).
â¤ Heavy CPU/RAM consumption.

âŒ Problem 2ï¸âƒ£: Slow Boot Time
â¤ VMs take minutes to start because they boot a complete OS.

âŒ Problem 3ï¸âƒ£: Hard to Scale
â¤ Spinning up multiple VMs is costly and slow â†’ not ideal for microservices.

âŒ Problem 4ï¸âƒ£: Duplication of OS
â¤ Each VM has its own OS â†’ wastes disk space.

âŒ Problem 5ï¸âƒ£: Hard to Port
â¤ VM images are large â†’ difficult to move, copy, push/pull.

âŒ Problem 6ï¸âƒ£: Dev/Prod Inconsistency
â¤ Developers run different OS versions or dependencies â†’ deployment failures.


ğŸ”„ How Containers Solve Those Problems
1ï¸âƒ£ Lightweight (No Guest OS)
âœ”ï¸ Containers share the host OS kernel â†’ only app + its libraries are packaged.
âœ”ï¸ Much smaller than VMs (MBs instead of GBs).

2ï¸âƒ£ Fast Startup
âœ”ï¸ Containers start in seconds (no OS booting).

3ï¸âƒ£ Easy Scaling
âœ”ï¸ Spin up multiple containers instantly â†’ perfect for microservices + Kubernetes.

4ï¸âƒ£ Better Resource Utilization
More containers on same hardware vs VMs â†’ cheaper infrastructure.

5ï¸âƒ£ Portability
Same container image runs on:
  âœ”ï¸Dev laptop
  âœ”ï¸Test server
  âœ”ï¸Production
  âœ”ï¸Cloud

6ï¸âƒ£ Consistent Environments
âœ”ï¸ Application + dependencies packaged together â†’ no configuration drift.

 
ğŸ”„ Containers ğŸ†š VMs
| Feature      | Containers           | Virtual Machines              |
| ------------ | -------------------- | ----------------------------- |
| OS           | Share host OS kernel | Each has its own guest OS     |
| Startup time | Seconds              | Minutes                       |
| Size         | MBs                  | GBs                           |
| Isolation    | Process-level        | Full OS-level                 |
| Performance  | Near-native          | Some overhead                 |
| Scaling      | Very fast            | Slow                          |
| Use case     | Microservices, CI/CD | Strong isolation, legacy apps |


ğŸ”„ Drawbacks of Containers & How to Overcome Them
âŒ  Weaker Security (Shared Kernel)
â¤ If kernel is compromised â†’ all containers are at risk.

âœ… Solution:
â¤ Use VM isolation for untrusted workloads.
â¤ Use Kubernetes Pod Security Policies, AppArmor, SELinux.
â¤ Regular kernel patching.

âŒ Limited Isolation Compared to VMs
â¤ Containers share the same OS kernel.

âœ… Solution:
â¤ Use sandboxed containers (gVisor, Kata Containers).
â¤ Use hardened distros (Bottlerocket, Flatcar).

âŒ Complex Networking
â¤ Container networking (bridge, overlay, CNI plugins) is harder than VM networks.

âœ… Solution:
â¤ Use Kubernetes CNI (Calico, Flannel) for easier management.

âŒ Persistent Storage Challenges
â¤ Containers are ephemeral; data disappears on deletion.

âœ… Solution:
â¤ Use volumes: Docker volumes, Kubernetes PersistentVolumes.

âŒ Image Bloat
â¤ Large base images â†’ slow builds and pulls.

âœ… Solution:
â¤ Use slim images (alpine, debian-slim).
â¤ Multi-stage Docker builds.


ğŸ”„ Architecture of Containers
Container architecture consists of:

1ï¸âƒ£ User Layer
âœ”ï¸ Applications
âœ”ï¸ Libraries
âœ”ï¸ Dependencies
âœ”ï¸ Environment variables

2ï¸âƒ£ Container Image Layer
â¤ Immutable filesystem created by layering:
  âœ”ï¸ base image â†’ runtime â†’ dependencies â†’ source code
â¤ Stored in a registry (Docker Hub, ECR, GCR)

3ï¸âƒ£ Runtime Layer
Two main components:
1ï¸âƒ£ High-level runtime (Docker, containerd)
2ï¸âƒ£ Low-level runtime (runc) â€” responsible for creating the containerâ€™s namespaces & cgroups

4ï¸âƒ£ OS Layer
Kernel features used:
âœ”ï¸ Namespaces â†’ isolation
âœ”ï¸ cgroups â†’ resource limits
âœ”ï¸ UnionFS â†’ layered filesystem

5ï¸âƒ£ Host Layer
Host OS + hardware resources


ğŸ”„ Features of Containers
1ï¸âƒ£ Isolation
Each container runs independently.

2ï¸âƒ£ Portability
Runs anywhere (Linux, Windows, Cloud, Kubernetes).

3ï¸âƒ£ Lightweight
No OS included â†’ fast and small.

4ï¸âƒ£ Scalability
Scale up/down quickly.

5ï¸âƒ£ Immutability
Images are read-only; changes create new layers.

6ï¸âƒ£ Consistency
Same environment across all stages.

7ï¸âƒ£ Resource Efficiency
More apps per host vs VMs.

8ï¸âƒ£ Fast Deployment
Containers spin up in seconds.

9ï¸âƒ£ Loose Coupling
Perfect for microservices architecture.


ğŸ”„ Lifecycle of Containers
1ï¸âƒ£ Create
âœ”ï¸ Container is defined but not running.
ğŸ”— docker create image-name

2ï¸âƒ£ Start
âœ”ï¸ Container starts execution.
ğŸ”— docker start container-id

3ï¸âƒ£ Run
âœ”ï¸ Equivalent to create + start.
ğŸ”— docker run image-name

4ï¸âƒ£ Pause
âœ”ï¸ Temporarily pause execution.
ğŸ”— docker pause container-id

5ï¸âƒ£ Resume / Unpause
ğŸ”— docker unpause container-id

6ï¸âƒ£ Stop
âœ”ï¸ Gracefully stops the container (SIGTERM).
ğŸ”— docker stop container-id

7ï¸âƒ£ Kill
âœ”ï¸ Force stop (SIGKILL).
ğŸ”— docker kill container-id

8ï¸âƒ£ Restart
âœ”ï¸ Stop + start.
ğŸ”— docker restart container-id

9ï¸âƒ£ Remove
âœ”ï¸ Deletes the container.
ğŸ”— docker rm container-id


ğŸ”„ Files and Folders in containers base images
1ï¸âƒ£  /bin: contains binary executable files, such as the ls, cp, and ps commands.
2ï¸âƒ£ /sbin: contains system binary executable files, such as the init and shutdown commands.
3ï¸âƒ£ /etc: contains configuration files for various system services.
4ï¸âƒ£ /lib: contains library files that are used by the binary executables.
5ï¸âƒ£ /usr: contains user-related files and utilities, such as applications, libraries, and documentation.
6ï¸âƒ£ /var: contains variable data, such as log files, spool files, and temporary files.
7ï¸âƒ£ /root: is the home directory of the root user.

ğŸ”„ Files and Folders that containers use from host operating system
1ï¸âƒ£ The host's file system: Docker containers can access the host file system using bind mounts, which allow the container to read and write files in the host file system.

2ï¸âƒ£ The host's Networking stack: The host's networking stack is used to provide network connectivity to the container. Docker containers can be connected to the host's network directly or through a virtual network.

3ï¸âƒ£ The host's System calls: The host's kernel handles system calls from the container, which is how the container accesses the host's resources, such as CPU, memory, and I/O.

4ï¸âƒ£ Namespaces: Docker containers use Linux namespaces to create isolated environments for the container's processes. Namespaces provide isolation for resources such as the file system, process ID, and network.

5ï¸âƒ£ Control groups (cgroups): Docker containers use cgroups to limit and control the amount of resources, such as CPU, memory, and I/O, that a container can access.


###########
ğŸ”· Docker
###########
Docker is a containerization platform that provides easy way to containerize your applications, which means, using Docker you can build container images, run the images to create containers and also push these containers to container regestries such as DockerHub, Quay.io and so on.

In simple words, you can understand as containerization is a concept or technology and Docker Implements Containerization.

ğŸ”„ Docker LifeCycle
There are three important things,
1ï¸âƒ£ docker build -> builds docker images from Dockerfile
2ï¸âƒ£ docker run -> runs container from docker images
3ï¸âƒ£ docker push -> push the container image to public/private regestries to share the docker images.


ğŸ”„ Understanding the terminology
1ï¸âƒ£ Docker daemon
The Docker daemon (dockerd) listens for Docker API requests and manages Docker objects such as images, containers, networks, and volumes. A daemon can also communicate with other daemons to manage Docker services.

2ï¸âƒ£ Docker client
The Docker client (docker) is the primary way that many Docker users interact with Docker. When you use commands such as docker run, the client sends these commands to dockerd, which carries them out. The docker command uses the Docker API. The Docker client can communicate with more than one daemon.

3ï¸âƒ£ Docker Desktop
Docker Desktop is an easy-to-install application for your Mac, Windows or Linux environment that enables you to build and share containerized applications and microservices. Docker Desktop includes the Docker daemon (dockerd), the Docker client (docker), Docker Compose, Docker Content Trust, Kubernetes, and Credential Helper. For more information, see Docker Desktop.

4ï¸âƒ£ Docker registries
âœ”ï¸ A Docker registry stores Docker images. Docker Hub is a public registry that anyone can use, and Docker is configured to look for images on Docker Hub by default. You can even run your own private registry.

âœ”ï¸ When you use the docker pull or docker run commands, the required images are pulled from your configured registry. When you use the docker push command, your image is pushed to your configured registry. Docker objects

âœ”ï¸ When you use Docker, you are creating and using images, containers, networks, volumes, plugins, and other objects. This section is a brief overview of some of those objects.

5ï¸âƒ£ Dockerfile
Dockerfile is a file where you provide the steps to build your Docker Image.

6ï¸âƒ£ Images
An image is a read-only template with instructions for creating a Docker container. Often, an image is based on another image, with some additional customization. For example, you may build an image which is based on the ubuntu image, but installs the Apache web server and your application, as well as the configuration details needed to make your application run.

You might create your own images or you might only use those created by others and published in a registry. To build your own image, you create a Dockerfile with a simple syntax for defining the steps needed to create the image and run it. Each instruction in a Dockerfile creates a layer in the image. When you change the Dockerfile and rebuild the image, only those layers which have changed are rebuilt. This is part of what makes images so lightweight, small, and fast, when compared to other virtualization technologies.


ğŸ”„ INSTALL DOCKER
A very detailed instructions to install Docker are provide in the below link

https://docs.docker.com/get-docker/

For Demo,
1ï¸âƒ£ You can create an Ubuntu EC2 Instance on AWS and run the below commands to install docker.
ğŸ”— sudo apt update
ğŸ”— sudo apt install docker.io -y

2ï¸âƒ£ Start Docker and Grant Access
A very common mistake that many beginners do is, After they install docker using the sudo access, they miss the step to Start the Docker daemon and grant acess to the user they want to use to interact with docker and run docker commands.

3ï¸âƒ£ Always ensure the docker daemon is up and running.
A easy way to verify your Docker installation is by running the below command
ğŸ”— docker run hello-world

ğŸ‘‰ If the output says:
docker: Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Post "http://%2Fvar%2Frun%2Fdocker.sock/v1.24/containers/create": dial unix /var/run/docker.sock: connect: permission denied.
See 'docker run --help'.

This can mean two things,
1ï¸âƒ£ Docker deamon is not running.
2ï¸âƒ£ Your user does not have access to run docker commands.

4ï¸âƒ£ Start Docker daemon
You use the below command to verify if the docker daemon is actually started and Active
ğŸ”— sudo systemctl status docker

5ï¸âƒ£ If you notice that the docker daemon is not running, you can start the daemon using the below command
ğŸ”— sudo systemctl start docker

6ï¸âƒ£ Grant Access to your user to run docker commands
To grant access to your user to run the docker command, you should add the user to the Docker Linux group. Docker group is create by default when docker is installed.
ğŸ”— sudo usermod -aG docker ubuntu

ğŸ‘‰ In the above command ubuntu is the name of the user, you can change the username appropriately.

âš¡ NOTE: : You need to logout and login back for the changes to be reflected.

Docker is Installed, up and running ğŸ¥³ğŸ¥³
Use the same command again, to verify that docker is up and running.

ğŸ”— docker run hello-world
âœ… Output should look like:
....
....
Hello from Docker!
This message shows that your installation appears to be working correctly.
...
...

#############################
ğŸ”· Multi-Stage Docker Build 
#############################
Multi-stage Docker build allows you to use multiple temporary images during the build process and copy only the required final artifacts into a small, clean production image.

ğŸ“Œ In short:
â¤ Build in one image
â¤ Run in another image
â¤ Discard everything else


ğŸ”„ Why Multi-Stage Build Was Introduced (The Problem)
âŒ Old (Single-Stage Dockerfile) Problem

Earlier, Dockerfiles looked like this:
FROM node:18

WORKDIR /app
COPY . .
RUN npm install
RUN npm run build

CMD ["npm", "start"]

â— Issues with this approach:
â¤ Image contains:
  âœ”ï¸ Node.js
  âœ”ï¸ npm
  âœ”ï¸ source code
  âœ”ï¸ build tools
  âœ”ï¸ dev dependencies
â¤ Image size becomes very large (300â€“800MB)
â¤ Security risk (extra tools inside production container)
â¤ Slow deployment


ğŸ”„ Core Idea of Multi-Stage Build
Use different images for different stages of the build.

| Stage         | Purpose                   |
| ------------- | ------------------------- |
| Build stage   | Compile / build code      |
| Runtime stage | Only run the final output |
ğŸ‘‰ Only the final stage image is shipped ğŸš€


ğŸ”—  Basic Syntax of Multi-Stage Dockerfile
FROM image AS stage-name
ğŸ‘‰ You can have multiple FROM statements in one Dockerfile.


âœ… Example (Node.js App)
ğŸ“ Project Structure
.
â”œâ”€â”€ package.json
â”œâ”€â”€ src/
â””â”€â”€ Dockerfile

ğŸ”— Multi-Stage Dockerfile
# ---------- Stage 1: Build ----------
FROM node:18 AS builder

WORKDIR /app
COPY package*.json ./
RUN npm install

COPY . .
RUN npm run build


# ---------- Stage 2: Production ----------
FROM node:18-alpine

WORKDIR /app

COPY --from=builder /app/dist ./dist
COPY --from=builder /app/package.json ./

RUN npm install --only=production

CMD ["node", "dist/index.js"]


ğŸ”„ Internal Working
1ï¸âƒ£ Docker starts Stage 1 (builder)
2ï¸âƒ£ Installs dependencies
3ï¸âƒ£ Builds the project
4ï¸âƒ£ Output goes to /app/dist
5ï¸âƒ£ Docker starts Stage 2
6ï¸âƒ£ Copies only /app/dist from Stage 1
7ï¸âƒ£ Stage 1 image is discarded
8ï¸âƒ£ Final image contains:
  âœ”ï¸ compiled files
  âœ”ï¸ minimal runtime
ğŸ‘‰ Intermediate images are NOT shipped

ğŸ”„ COPY --from 
COPY --from=builder /app/dist ./dist

ğŸ‘‰ Means:
â¤ Copy files from another stage
â¤ Not from local filesystem
â¤ Stage name acts like a virtual image

âœ… Real-World Example: React App + Nginx
ğŸ¯ Goal
â¤ Build React app
â¤ Serve via Nginx
â¤ No Node.js in production

ğŸ”— Dockerfile
# ---------- Stage 1: Build ----------
FROM node:18 AS builder

WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build


# ---------- Stage 2: Nginx ----------
FROM nginx:alpine

COPY --from=builder /app/build /usr/share/nginx/html

EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]

ğŸ‘‰ Final image:
â¤ No Node.js
â¤ Only static files + Nginx
â¤ Very small (~25MB)

ğŸ”„Multi-Stage ğŸ†š Single-Stage 
| Feature            | Single Stage | Multi-Stage |
| ------------------ | ------------ | ----------- |
| Image size         | Large        | Very small  |
| Security           | Poor         | High        |
| Build tools inside | Yes          | No          |
| Production ready   | âŒ            | âœ…           |
| Best practice      | âŒ            | âœ…           |


ğŸ” Security Advantages
â¤ No compilers
â¤ No package managers
â¤ No source code
â¤ Reduced attack surface
â¤ Follows principle of least privilege

âš¡ â€œMulti-stage builds significantly reduce the attack surface of production containers.â€


ğŸ”„ Performance Benefits
â¤ Faster pull time
â¤ Faster container startup
â¤ Less disk usage
â¤ Faster CI/CD pipelines

âœ… Multi-Stage Build with Java
Spring Boot Example
# ---------- Stage 1: Build ----------
FROM maven:3.9-eclipse-temurin-17 AS builder

WORKDIR /app
COPY pom.xml .
COPY src ./src
RUN mvn clean package -DskipTests


# ---------- Stage 2: Runtime ----------
FROM eclipse-temurin:17-jre-alpine

WORKDIR /app
COPY --from=builder /app/target/app.jar app.jar

CMD ["java", "-jar", "app.jar"]

ğŸ‘‰ Maven is not included in final image.


â“ Can multiple stages use different base images?
âœ… Yes (Node, Nginx, JRE, Alpine, etc.)

â“ Are intermediate images stored?
âŒ No (unless you tag them manually)

â“ Does multi-stage increase build time?
âŒ Slightly during build
âœ… But saves time in runtime and deployment

â“ Can we copy between stages?
âœ… Yes using COPY --from=stage


ğŸ”„ Best Practices 
âœ”ï¸ Use small base images (alpine)
âœ”ï¸ Separate build and runtime
âœ”ï¸ Name stages clearly (builder, runtime)
âœ”ï¸ Copy only required artifacts
âœ”ï¸ Avoid copying .env or secrets


âŒ When NOT to Use Multi-Stage?
â¤ Very small scripts
â¤ One-file utilities
â¤ Quick local testing

ğŸ‘‰ In production â†’ Always use multi-stage

#################################
ğŸ”· Distroless Container Images
#################################
Distroless container images are Docker/container images that contain only the application and its runtime dependencies, and nothing else.
â¤ No OS package manager
â¤ No shell (bash/sh)
â¤ No utilities like ls, curl, ps
â¤ No unnecessary libraries

â¡ï¸ Distroless images remove everything except what is required to run the app.â€


â“ Why are they called â€œDistrolessâ€?

ğŸ”— Traditional images:
Ubuntu / Debian / Alpine
+ Shell
+ Coreutils
+ Package manager
+ Debug tools
+ App


ğŸ”— Distroless images:
Only App + Runtime (JRE / Node / Python / libc)
â¡ï¸ There is no Linux distribution inside, so the image is called â€œdistrolessâ€.

ğŸ‘‰ Distroless was Developed by Google
ğŸ‘‰ Used internally at Google Cloud
ğŸ‘‰ Open-sourced for production workloads


ğŸ”„ Goal of Distroless Images
ğŸ¯ Reduce attack surface + increase security + reduce image size


â—Problems with Traditional Container Images
âŒ 1ï¸âƒ£ Large Image Size
â¤ Ubuntu image ~70MB
â¤ Debian ~120MB
â¤ Includes tools not required in production

âŒ 2ï¸âƒ£ Security Vulnerabilities
â¤ Shells + utilities = more CVEs
â¤ Hackers can exploit bash, curl, apt, etc.

âŒ 3ï¸âƒ£ Containers Used as Mini VMs
â¤ Devs SSH into containers (bad practice)
â¤ Containers should be immutable

ğŸ”„ Distroless Solves These Problems
| Problem        | Distroless Solution             |
| -------------- | ------------------------------- |
| Large size     | Only runtime libraries included |
| Security risk  | No shell, no package manager    |
| Debug misuse   | Forces proper observability     |
| Faster startup | Less filesystem to scan         |


ğŸ”„ Distroless Images Contain
Depending on runtime:
1ï¸âƒ£ Java Distroless
  âœ”ï¸ JVM
  âœ”ï¸ Required libc
  âœ”ï¸ CA certificates
  âœ”ï¸ Your .jar

2ï¸âƒ£ Node.js Distroless
  âœ”ï¸ Node runtime
  âœ”ï¸ Required shared libraries
  âœ”ï¸ Your JS app

3ï¸âƒ£ Python Distroless
  âœ”ï¸ Python interpreter
  âœ”ï¸ Required libraries
  âœ”ï¸ Your app


ğŸ”„ Distroless Images DO NOT Contain
âŒ /bin/bash
âŒ /bin/sh
âŒ apt, apk, yum
âŒ curl, wget
âŒ ps, top, netstat
ğŸ‘‰ This is intentional.


ğŸ”„ Why No Shell is a BIG DEAL
1ï¸âƒ£ Security Impact:
â¤ Attacker cannot run commands inside container
â¤ Even if container is compromised â†’ limited damage

2ï¸âƒ£ Operational Impact:
â¤ Cannot docker exec -it bash
â¤ Must rely on:
  âœ”ï¸ Logs
  âœ”ï¸ Metrics
  âœ”ï¸ Tracing
ğŸ‘‰ Encourages cloud-native best practices


ğŸ”„ Distroless ğŸ†š Alpine ğŸ†š Ubuntu
| Feature          | Ubuntu | Alpine | Distroless    |
| ---------------- | ------ | ------ | ------------  |
| OS present       | Yes    | Yes    | âŒ No         |
| Shell            | Yes    | Yes    | âŒ No         |
| Package manager  | Yes    | Yes    | âŒ No         |
| Image size       | Large  | Small  | Smallest      |
| Security         | Medium | Better | Best          |
| Debugging        | Easy   | Easy   | Hard          |
| Production ready | âŒ     | âš ï¸    | âœ…            |


ğŸ”„ Distroless is for Production, not Development
âŒ Bad Use Case
â¤ Local debugging
â¤ Running scripts interactively
â¤ Installing packages dynamically

âœ… Good Use Case
â¤ Microservices
â¤ Kubernetes workloads
â¤ Cloud-native apps
â¤ CI/CD final stage images


ğŸ”„ Multi-Stage Docker Build 
Distroless is almost always used with multi-stage builds.

âœ… Example (Java-Based App) 
# Stage 1: Build
FROM maven:3.9-eclipse-temurin-17 AS build
WORKDIR /app
COPY . .
RUN mvn clean package -DskipTests

# Stage 2: Runtime (Distroless)
FROM gcr.io/distroless/java17-debian12
COPY --from=build /app/target/app.jar /app.jar
CMD ["app.jar"]


âœ”ï¸ Build tools not included
âœ”ï¸ Only final artifact copied
âœ”ï¸ No shell in runtime image


ğŸ”„ How Distroless Containers Run Without a Shell
âŒ Instead of:
ğŸ”— CMD java -jar app.jar

âœ… They use exec form:
ğŸ”— CMD ["java", "-jar", "app.jar"]

ğŸ‘‰ Shell form (CMD java -jar) requires /bin/sh â†’ not available

ğŸ”„ Logging in Distroless Containers
â¤ Logs go to stdout / stderr
â¤ Docker / Kubernetes captures logs
â¤ Use:
  âœ”ï¸ kubectl logs
  âœ”ï¸ ELK / Loki / Cloud Logging

ğŸ”¹ Debugging Distroless Containers (Interview Trap)
âŒ You cannot exec into them
âœ… Proper debugging methods:
âœ”ï¸ Application logs
âœ”ï¸ Metrics (Prometheus)
âœ”ï¸ Tracing (Jaeger)
âœ”ï¸ Sidecar containers
âœ”ï¸ Temporary debug image


ğŸ”„ Distroless & Kubernetes (Real World)
â¤ Preferred for:
  âœ”ï¸ Backend services
  âœ”ï¸ APIs
  âœ”ï¸ Event consumers

â¤ Used by:
  âœ”ï¸ Google
  âœ”ï¸ Large SaaS companies

â¤ Works best with:
  âœ”ï¸ Read-only root filesystem
  âœ”ï¸ Non-root users

âœ… Distroless Images Examples
| Runtime | Image                                 |
| ------- | ------------------------------------- |
| Java    | `gcr.io/distroless/java17-debian12`   |
| Node    | `gcr.io/distroless/nodejs20-debian12` |
| Python  | `gcr.io/distroless/python3-debian12`  |
| Base    | `gcr.io/distroless/base-debian12`     |


ğŸŒŸ Common Questions
â“ Why are distroless images more secure?
âœ… Answer: Because they remove shell, package managers, and unnecessary binaries, which significantly reduces the attack surface and vulnerability exposure.

â“ Can you SSH into a distroless container?
âœ… Answer: No. Distroless containers do not contain a shell or SSH server.

â“ How do you debug a distroless container?
âœ… Answer: By using logs, metrics, distributed tracing, or attaching a temporary debug container.

â“ Why not use Alpine instead?
âœ… Answer: Alpine still contains a shell and package manager, whereas distroless removes everything unnecessary, making it more secure for production.

â“ Is distroless suitable for development?
âœ… Answer: No. It is designed for production workloads only.


#################################
ğŸ”· Persistent Storage in Docker
#################################
ğŸ”„ Why Do We Need Persistent Storage in Docker?
â— Problem:
â¤ Containers are ephemeral
â¤ When a container stops or is deleted:
    âœ”ï¸ All data inside it is lost

âœ… Example:
Container â†’ writes data â†’ container deleted â†’ data gone âŒ

ğŸ‘‰ But real applications need:
â¤ Database data
â¤ Logs
â¤ Uploaded files
â¤ Cache
ğŸ‘‰ This is where persistent storage comes in.

ğŸ”„ Persistent Storage in Docker
â¤ Data lives outside the container lifecycle

â¤ Docker provides two main mechanisms:
1ï¸âƒ£ Bind Mounts
2ï¸âƒ£ Volumes


#################
ğŸ”· Bind Mounts
#################
A bind mount maps a specific directory/file on the host machine directly into a container.
Host Path  â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶  Container Path

âœ… Example (Bind Mount)
ğŸ”— docker run -v /home/user/data:/app/data nginx
â¤ /home/user/data â†’ host directory
â¤ /app/data â†’ container directory

Any change in:
â¤ Host â†’ visible in container
â¤ Container â†’ visible on host

ğŸ”„ Characteristics of Bind Mounts
| Property          | Bind Mount  |
| ----------------- | ----------- |
| Host-dependent    | âœ… Yes      |
| Managed by Docker | âŒ No       |
| Performance       | High        |
| Portability       | âŒ Low      |
| Security          | Risky       |
| Use case          | Development |

ğŸ”„ When to Use Bind Mountsâ“ 
âœ… Local development
âœ… Live code reload
âœ… Debugging
âœ… Editing files from IDE

ğŸ”„ Bind Mount Internals
â¤ Docker does not manage the data
â¤ Docker just creates a filesystem link
â¤ If the host path is deleted â†’ data lost

ğŸ”„ Problems with Bind Mounts
âŒ Not portable (path differs per machine)
âŒ Host filesystem exposure
âŒ Permission issues
âŒ Harder to secure


####################
ğŸ”· Docker Volumes
####################
A Docker volume is a directory managed by Docker, stored in Dockerâ€™s own storage area.

ğŸ“ Location (Linux):
ğŸ”— /var/lib/docker/volumes/

âœ… Example (Volume)
ğŸ”— docker volume create myvolume
ğŸ”— docker run -v myvolume:/app/data nginx

ğŸ”— docker volume inspect myvolume â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ gives the detail about a particular volume
ğŸ”— docker volume ls â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ lists all the volumes created in docker
ğŸ”— docker volume rm myvolume1 myvolume2 â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ removes a particular/group of volumes
ğŸ”— docker run -d --mount source=myvolume, target = /app docker-volume
ğŸ”— docker ps â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ to check the running containers
ğŸ”—  docker inspect <container_id> â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ to check the volume attached to the particular container


Docker decides:
â¤ Where data is stored
â¤ How itâ€™s managed

ğŸ”„ Characteristics of Docker Volumes
| Property         | Volume     |
| ---------------- | ---------- |
| Docker-managed   | âœ… Yes     |
| Host-independent | âœ… Yes     |
| Portable         | âœ… Yes     |
| Secure           | âœ… Safer   |
| Backup           | Easy       |
| Use case         | Production |


ğŸ”„ Volume Internals
â¤ Stored outside container filesystem
â¤ Survive:
  âœ”ï¸ Container stop
  âœ”ï¸ Container delete
â¤ Can be shared across containers

ğŸ”„ Volume Lifecycle
Create â†’ Attach â†’ Use â†’ Detach â†’ Still Exists
ğŸ‘‰ Volume exists until explicitly deleted.

ğŸ”„ Volumes vs Bind Mounts 
| Feature           | Volumes    | Bind Mounts |
| ----------------- | ---------- | ----------- |
| Managed by Docker | âœ… Yes     | âŒ No      |
| Host path needed  | âŒ No      | âœ… Yes     |
| Portable          | âœ… Yes     | âŒ No      |
| Security          | High       | Medium      |
| Backup & restore  | Easy       | Manual      |
| Cross-platform    | âœ…         | âŒ         |
| Best for          | Production | Development |

ğŸ”„ Anonymous Volumes
ğŸ”— docker run -v /app/data nginx

â¤ Docker creates a volume automatically
â¤ No name
â¤ Hard to manage
â¤ Often causes disk leaks
ğŸ‘‰ Avoid in production

ğŸ”„ Real-World Examples
âœ… Database (MySQL)
ğŸ”— docker volume create mysql_data

ğŸ”— docker run -d \
  -v mysql_data:/var/lib/mysql \
  mysql

âœ”ï¸ Data survives container restart
âœ”ï¸ Easy backup

ğŸ”„ Development (Bind Mount)
ğŸ”— docker run -v $(pwd):/app node

âœ”ï¸ Code changes reflect instantly
âœ”ï¸ IDE friendly


âš¡ Best Practices
âœ… Use volumes for databases
âœ… Use bind mounts for dev code
âŒ Donâ€™t store state inside container
âŒ Avoid anonymous volumes
âœ… Backup volumes regularly

ğŸ”„ Common Traps
âŒ Saying bind mounts are better than volumes
âŒ Using volumes for live code editing
âŒ Forgetting volume cleanup
âŒ Mixing production & dev storage strategy


######################
ğŸ”· Docker Networking
######################
ğŸ”„ Why Networking Is Needed in Containers
â¤ Containers run in isolated environments

â¤ Each container has:
  âœ”ï¸ Its own network namespace
  âœ”ï¸ Its own IP address

â¤ Without Docker networking:
  âœ”ï¸ Containers cannot talk to host
  âœ”ï¸ Containers cannot talk to each other
ğŸ‘‰ Docker networking connects these isolated namespaces in a controlled way.


ğŸ”„ Containers Communicate with the Host
Case 1ï¸âƒ£: Using Port Mapping
âœ… Example:
ğŸ”— docker run -p 8080:80 nginx

ğŸ‘‰ What happens internally:
Browser â†’ Host:8080 â†’ Docker NAT â†’ Container:80
âš¡ 8080 â†’ Host port
âš¡ 80 â†’ Container port
âš¡ Docker uses iptables + NAT

â¤ Container cannot directly access host services
â¤ Host exposes services via ports


Case 2ï¸âƒ£: Using Host IP (172.x.x.x)
Docker bridge network creates a virtual gateway:

ğŸ”— docker0 â†’ 172.17.0.1 (host)
ğŸ”— Container â†’ Host via: 172.17.0.1


Case 3ï¸âƒ£: Host Network Mode
ğŸ”— docker run --network host nginx

â¤ Container uses hostâ€™s network stack
â¤ No isolation
â¤ Same IP as host
âŒ Not recommended for security


ğŸ”„ Containers Communicate With Each Other
ğŸŒŸ Default: Bridge Network
âœ… Example:
ğŸ”— docker network create mybridge

ğŸ”— docker run -d --name app1 --network mybridge nginx
ğŸ”— docker run -d --name app2 --network mybridge nginx

ğŸ‘‰ Communication: app1 â†’ app2 (via container name)

Docker provides:
âœ”ï¸ Internal DNS
âœ”ï¸ Automatic IP resolution


ğŸ”„ Why NOT Use IPs?
âŒ IP changes on restart
âŒ Breaks communication
âœ… Always use container name


ğŸ”„ Docker Networking Internals
Docker creates:
â¤ Network Namespace: Isolated network stack per container
â¤ Virtual Ethernet (veth pair): Container â†” veth â†” docker0 bridge â†” host
â¤ Docker Bridge (docker0): Acts like a virtual switch
â¤ iptables Rules Handle:
  âœ”ï¸ NAT
  âœ”ï¸ Port forwarding
  âœ”ï¸ Isolation

ğŸ”„ Types of Docker Networks
| Network Type | Purpose                      | Isolation |
| ------------ | ---------------------------- | --------- |
| bridge       | Default container networking | Medium    |
| host         | No isolation                 | None      |
| none         | No networking                | Full      |
| overlay      | Multi-host (Swarm/K8s)       | High      |
| macvlan      | Container gets real IP       | Medium    |


ğŸ”„ How Docker Networking Enables Communication
| Scenario              | Network Used    |
| --------------------- | --------------- |
| Container â†” Container | Bridge          |
| Container â†” Host      | NAT / Host mode |
| Multi-host containers | Overlay         |
| No communication      | None            |
 

ğŸ”„ How to PREVENT Containers from Communicating (Complete Isolation)
Method 1ï¸âƒ£: none Network (BEST)
ğŸ”— docker run --network none nginx

Result:
  âœ”ï¸ No IP
  âœ”ï¸ No internet
  âœ”ï¸ No container communication
âœ” FULL ISOLATION

 
Method 2ï¸âƒ£: Separate Bridge Networks
ğŸ”— docker network create net1
ğŸ”— docker network create net2

ğŸ”— docker run --network net1 app1
ğŸ”— docker run --network net2 app2
ğŸ‘‰ Result: app1 âŒ app2
âœ” Logical isolation


Method 3ï¸âƒ£: Disable Inter-Container Communication (ICC)
ğŸ”— dockerd --icc=false

â¤ Containers cannot talk by default
â¤ Legacy but interview-relevant


Method 4ï¸âƒ£: Firewall / iptables Rules
  âœ”ï¸ Block traffic between containers
  âœ”ï¸ Advanced security

â¤ Used in:
  âœ”ï¸ Production
  âœ”ï¸ Zero-trust architecture


Method 5ï¸âƒ£: Kubernetes Network Policies (Advanced)
â¤ Define: Who can talk to whom
â¤ Fine-grained isolation


âœ… Real-World Isolation Example
Scenario:
â¤ Frontend should talk to backend
â¤ Backend should talk to DB
â¤ Frontend âŒ DB

âœ… Solution:
frontend-net â†’ frontend + backend
backend-net â†’ backend + db
âš¡ Controlled communication

9ï¸âƒ£ Common Traps
âŒ Saying containers share host IP
âŒ Using IP instead of container name
âŒ Using host network in production
âŒ Assuming Docker networks are optional


#####################################
ğŸ”· Real Time Challenges with Docker
#####################################
1ï¸âƒ£ Docker is a single daemon process. Which can cause a single point of failure. If the docker daemon goes down for some reason all the applications running inside the docker containers will also go down. Tools like podman, Buildah can be used to overcome this issue.

2ï¸âƒ£ Docker Daemon runs as a root user. which is a security threat. Any process running as a root can have adverse effects. when it is compromised for security reasons, it can impact other applications or containers on the host.

3ï¸âƒ£ Rescource Contraints: If you are running too many containers on a single host, you may experience issues with resource constraints. This can result in slow performance crashes.


################################
ğŸ”· Steps to secure Containers
################################
1ï¸âƒ£ Use Distroless or images with not too many packages as your final image in multi-stage docker builds, so that there is less chance of CVE or security vulnerabilities.

2ï¸âƒ£ Ensure that the networking is configured properly. This is one of the most common reasons for security breaches in containers. If required configure custom bridge networks to isolate the containers.

3ï¸âƒ£ Use utilities like Sync to scan your container images for vulnerabilities before deploying them to production.


####################
ğŸ”· Docker Compose
####################
