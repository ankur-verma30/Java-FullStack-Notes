ğŸ”· Linux Commands 
1ï¸âƒ£ free â€” Check RAM (Memory) Usage
Displays information about system memory â€” total, used, and free RAM & swap.

ğŸ”„ Syntax:
ğŸ”— free
ğŸ”— free -m   # Show in MB
ğŸ”— free -g   # Show in GB

âœ… Example:
ğŸ”— free -g

âœ… Output Example:
              total        used        free      shared  buff/cache   available
Mem:              8           2           3           0           2           5
Swap:             2           0           2

ğŸ‘‰ Meaning:
âœ”ï¸ total â†’ Total RAM in the system
âœ”ï¸ used â†’ RAM currently used
âœ”ï¸ free â†’ RAM available
âœ”ï¸ buff/cache â†’ Memory used by kernel buffers & cache
âœ”ï¸ available â†’ Memory available for new processes

âš¡Use in scripts:
To check if a server has enough memory before deploying or running a heavy service.

2ï¸âƒ£ nproc â€” Get Number of CPU Cores
Displays the number of CPU cores available for processing.

âœ… Syntax: nproc
âœ… Example Output: 4

ğŸ‘‰ The system has 4 CPU cores (useful for tuning multi-threaded tasks or Docker containers).

ğŸ‘‰ Use in scripts:
Automatically detect CPU cores to parallelize builds or workloads.
âœ… Example: make -j$(nproc)
â†’ Compiles code using all available CPU cores.


3ï¸âƒ£ df -h â€” Check Disk Usage
Shows disk space usage on all mounted file systems.

âœ… Syntax: df -h

âœ… Example Output:
Filesystem      Size  Used Avail Use% Mounted on
/dev/xvda1       30G   10G   18G  36% /
tmpfs           1.9G     0  1.9G   0% /dev/shm

âœ”ï¸ Filesystem â†’ Name of the disk/partition
âœ”ï¸ Size â†’ Total disk size
âœ”ï¸ Used â†’ Space already used
âœ”ï¸ Avail â†’ Free space available
âœ”ï¸ Use% â†’ Percentage of disk used
âœ”ï¸ Mounted on â†’ Directory where the disk is attached

ğŸ‘‰ Check if thereâ€™s enough disk space before uploading files, running backups, or installing packages.

ğŸ”· top Command â€” Real-Time Process & Resource Monitor

ğŸ”„ Purpose:
Shows real-time information about:
1ï¸âƒ£ Running processes
2ï¸âƒ£ CPU & memory usage
3ï¸âƒ£ System load
4ï¸âƒ£ Uptime
5ï¸âƒ£ Process IDs (PIDs)
6ï¸âƒ£ Users running those processes
ğŸ‘‰ Itâ€™s like Task Manager in Windows â€” but for Linux CLI.

ğŸ‘‰ Syntax : top

ğŸ‘‰ can also use:
ğŸ”— top -u <username>     # Show processes of a specific user
ğŸ”— top -p <pid>          # Monitor a specific process ID
ğŸ”— top -n 1              # Show output only once and exit


âœ… Sample Output:
top - 10:12:36 up 3 days,  2:04,  1 user,  load average: 0.07, 0.03, 0.01
Tasks: 120 total,   1 running, 119 sleeping,   0 stopped,   0 zombie
%Cpu(s):  2.3 us,  1.2 sy,  0.0 ni, 96.2 id,  0.2 wa,  0.0 hi,  0.1 si,  0.0 st
MiB Mem :   7982.4 total,   2345.1 free,   1223.5 used,   4413.8 buff/cache
MiB Swap:   2048.0 total,   2048.0 free,      0.0 used.   6037.3 avail Mem 

PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
1234 ec2-user  20   0  123456  5678  1234 S   1.3  0.2   0:02.34 java
5678 root      20   0  87654  4321  3210 S   0.7  0.1   0:01.45 sshd


ğŸ”„ Output Breakdown:
| Field                | Description                                          |
| -------------------- | ---------------------------------------------------- |
| **PID**              | Process ID                                           |
| **USER**             | Owner of the process                                 |
| **PR / NI**          | Process priority & nice value                        |
| **VIRT / RES / SHR** | Virtual, Resident & Shared memory usage              |
| **S**                | Process status (`R` = running, `S` = sleeping, etc.) |
| **%CPU / %MEM**      | CPU and memory usage of the process                  |
| **TIME+**            | Total CPU time used                                  |
| **COMMAND**          | Command/program name                                 |


ğŸ”„ Top Section Details: 
1ï¸âƒ£ Uptime & Load Average
load average: 0.07, 0.03, 0.01
â¤ Indicates system load in the last 1, 5, and 15 minutes.
(Lower is better; if load > number of CPUs, system is overloaded.)

2ï¸âƒ£ Tasks
Tasks: 120 total, 1 running, 119 sleeping
â¤ Shows how many processes are running, sleeping, or stopped.

3ï¸âƒ£ CPU Usage
%Cpu(s): 2.3 us, 1.2 sy, 96.2 id
âœ”ï¸ us = user processes
âœ”ï¸ sy = system processes
âœ”ï¸ id = idle time
âœ”ï¸ wa = waiting for I/O

4ï¸âƒ£ Memory Usage
Mem: 7982 total, 1223 used, 4413 buff/cache
â¤ Monitors RAM and swap usage in real-time.

ğŸ”„ Top Command Shortcuts
| Key           | Function                                 |
| ------------- | ---------------------------------------- |
| **q**         | Quit `top`                               |
| **k**         | Kill a process (youâ€™ll be asked for PID) |
| **r**         | Renice (change process priority)         |
| **M**         | Sort by memory usage                     |
| **P**         | Sort by CPU usage                        |
| **1**         | Show CPU usage for each core             |
| **u**         | Filter processes by user                 |
| **Shift + E** | Change memory units (KB â†’ MB â†’ GB)       |


ğŸ”„ In Shell Scripts
You usually donâ€™t use top directly in scripts (since itâ€™s interactive),
but you can use:
ğŸ”— top -b -n 1

ğŸ‘‰ This runs top in batch mode (non-interactive) â†’ useful for automation or logging.

âœ… Example:
ğŸ”— top -b -n 1 | head -15 > system_report.txt
â†’ Saves top 15 lines of top output into a file.

ğŸ”· Shell Scripting
A shell script is a file containing a series of Linux commands that the shell (command-line interpreter) executes one after another automatically.

Think of it like:
ğŸ§© Instead of typing each command manually in the terminal, you write them in a file and let the system run them all at once.

ğŸ”· Why Use Shell Scripting?
â¤ Automation
â¤ Reusability
â¤ Security

Creating a Shell Script
ğŸ”— nano script.sh --> file should be of .sh extension 


ğŸ”„ Shebang (#! ) in Shell Scripting
A shebang (#!) is the first line in a shell script that tells the system which interpreter should be used to execute the script.

âœ… Syntax:
ğŸ”— #!/bin/

 âœ…Example 1 â€” Bash Script
#!/bin/bash
echo "Hello, World!"
â¡ï¸ This tells Linux:
"Use the bash shell (located at /bin/bash) to run this script."

ğŸ”„ Why Shebang is Important
â¤ Specifies interpreter explicitly â€” ensures script runs the same way everywhere.
â¤ Avoids confusion â€” even if a userâ€™s default shell is different (like zsh or fish).

âš¡ Used by system to know how to execute when you run:
./script.sh
âš¡ save the file in vim editor and exit by :wq

Running a Shell Script
1ï¸âƒ£ Can use sh prefix to run a script.
ğŸ”— sh script.sh

2ï¸âƒ£ Or make it executable and run directly:
ğŸ”— chmod +x script.sh   # Make it executable


ğŸ”„ Always write metadata information about the script before writing the script
##########################
# Author: Ankur
# Date: 12/11/2025
#
# This scripts outputs the node health
#
# Version:v1
#####################################


ğŸ”· Writing shell script to check the health of the VM Machines
ğŸ”„ Method 1: Using echo command to write the readabe scripts 
#!/bin/bash


echo "Print the disk space"
ğŸ”— df -h

echo "Print the memory"
ğŸ”— free -g


echo "Print the number of CPU"
ğŸ”— nproc
â¤ However for large and complex scripts writing echo is not a good idea and its a very cumbersome task

ğŸ”„ Method 2: use Debug mode to write the script

#!/bin/bash
ğŸ”— set -x   # Enable debug mode
ğŸ”— df -h
ğŸ”— free -g
ğŸ”— nproc

â¤ The set -x command enables debug mode, which prints each command and its arguments to the terminal as they are executed.
â¤ This makes it easier to write and troubleshoot the script since you can see exactly what commands are being run.

