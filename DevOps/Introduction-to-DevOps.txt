ğŸ”· DevOps
DevOps (Development + Operations) is a set of practices that combines software development (Dev) and IT operations (Ops) to:
â¤ Increase software delivery speed using Automation
â¤ Improve product quality
â¤ Enable continuous integration and deployment (CI/CD)
â¤ Continuous Monitoring and logging
â¤ Continuous Testing
DevOps is a culture and process that helps teams build, test, and release software faster and more reliably through automation and collaboration.

ğŸ”· Why Devops?
Because it solves the traditional gap between developers and operations teams.

ğŸ”‘ Key Reasons:
âœ”ï¸ Faster Delivery: Automates build, test, and deployment â†’ delivers updates quickly.
âœ”ï¸ Better Collaboration: Breaks silos between dev & ops â†’ teams work together efficiently.
âœ”ï¸ Higher Quality: Continuous testing & monitoring â†’ fewer bugs in production.
âœ”ï¸ Scalability: Easier to handle large, complex systems through automation tools.
âœ”ï¸ Reliability: Continuous integration and deployment ensure stable, consistent releases.
âœ”ï¸ Quick Recovery: Issues are detected and fixed faster with monitoring and rollback features.
âœ”ï¸ Customer Satisfaction: Frequent updates and faster fixes â†’ happier users.


ğŸ”· Software Development Lifecycle(SDLC) 
SDLC is the process used to design, develop, test, and deploy software systematically and efficiently.

ğŸ§© Phases of SDLC:
âœ”ï¸ Requirement Analysis(Planning and Defining)
â¤ Understand what the client/user needs.
â¤ Gather and docu ment functional & non-functional requirements.
â¤ Output: Software Requirement Specification (SRS)

âœ”ï¸ System Design
â¤ Plan architecture, database, UI, and technology stack.
â¤ Output: Design Documents, Wireframes

âš¡ DevOps Centric Phases
âœ”ï¸ Implementation (Coding)
â¤ Developers write code based on the design.
â¤ Follow coding standards and version control.

âœ”ï¸ Testing
â¤ Verify that the software works correctly and meets requirements.
â¤ Includes unit testing, integration testing, and system testing.

âœ”ï¸ Deployment
â¤ Release the software to production (end users).
â¤ Can be manual or automated (DevOps CI/CD).

âœ”ï¸ Maintenance
â¤ Fix bugs, update features, and ensure system reliability.

ğŸ” Popular SDLC Models:
â¤ Waterfall Model: Linear, phase-by-phase.
â¤ Agile Model: Iterative and flexible.
â¤ Spiral Model: Combines design + prototyping.
â¤ V-Model: Verification and validation in parallel.


ğŸ”· Roles in Company
âœ”ï¸ Business Analyst: Gathers and documents customer requierments.
âœ”ï¸ Product Manager: Defines the vision, goals, and priorities
âœ”ï¸ Product Owner: Manages baclong and converts vision into actionable stories
âœ”ï¸ UI/UX Designer: Designs user interface and user experience.
âœ”ï¸ Software Architect: Designs technical system structure and frameworks.
âœ”ï¸ Developers: Build the actual product(UI, APIs, databases).
âœ”ï¸ DBA: Designs and manages the database.
âœ”ï¸ Security Engineer: Ensures product and infrasturcture security.
âœ”ï¸ QA Engineer: Tests product quality and performance.
âœ”ï¸ DevOps Engineer: Builds CI/CD pipelines and manages environments.
âœ”ï¸ Release Manager: Plans and manages releases.
âœ”ï¸ SRE: Ensures uptime, performance, and reliability post-release.
âœ”ï¸ Technical Writer: Creates documentation for users and developers.

ğŸ”· Virtual Machines (VM)
â¤ A Virtual Machine is a software-based computer that runs inside another physical computer.
â¤ It behaves just like a real machine (has its own CPU, memory, disk, OS), but it's virtual â€” created using virtualization software.
â¤ A VM is like a computer inside a computer.

ğŸŒ What is a Server?
A server is a computer that provides resources or services (like websites, databases, or files) to other computers (called clients) over a network.

âœ… Example:
âœ”ï¸ A web server hosts websites.
âœ”ï¸ A database server stores and manages data.

âš™ï¸ Physical vs Virtual Servers
| Feature            | **Physical Server**                      | **Virtual Server (VM)**                                        |
| ------------------ | ---------------------------------------- | -------------------------------------------------------------- |
| **Definition**     | Actual hardware machine                  | Software-based machine running on a physical host              |
| **Resource Usage** | Dedicated (not shared)                   | Shared among multiple VMs                                      |
| **Scalability**    | Difficult (requires new hardware)        | Easy (create new VMs quickly)                                  |
| **Cost**           | Expensive                                | Cost-effective                                                 |
| **Isolation**      | One OS per server                        | Multiple OSs can run on one physical machine                   |
| **Example**        | A Dell PowerEdge server in a data center | Several Ubuntu/Windows VMs running inside VMware or VirtualBox |


ğŸ”„ Hypervisor
A Hypervisor is software that creates and manages virtual machines by sharing physical resources (CPU, RAM, disk) between them. 
ğŸ§© Types of Hypervisors:
ğŸ‘‰ Type 1 â€“ Bare Metal Hypervisor:
â¤ Runs directly on hardware (no host OS).
âœ… Examples: VMware ESXi, Microsoft Hyper-V, KVM

ğŸ‘‰ Type 2 â€“ Hosted Hypervisor:
â¤ Runs on top of a host OS (like an app).
âœ… Examples: Oracle VirtualBox, VMware Workstation

ğŸŒ Real-World Examples:
âœ”ï¸ Cloud Providers:
â¤  AWS EC2, Google Cloud Compute Engine, Azure VMs â€” all use virtualization to create VMs on demand.

âœ”ï¸ Development & Testing:
â¤  Developers use VMs to test software in multiple OS environments.

âœ”ï¸ Server Consolidation:
â¤  Companies run multiple VMs (web server, DB server, mail server) on a single physical server to save costs.


â“ How to Automate the creation of Virtual Machines on any Cloud Platform using API?
Automation means you donâ€™t manually click buttons to create a VM â€” instead, you use scripts or tools to create and manage VMs automatically.

1ï¸âƒ£ AWS CLI (Command Line Interface)
â¤ A command-line tool to interact directly with AWS services.
â¤ Executes imperative commands (step-by-step actions).

âœ… Example:
aws ec2 run-instances --image-id ami-0abcdef --instance-type t2.micro

ğŸ”„ Use case:
â¤ Quick manual automation or scripting.
â¤ Good for ad-hoc tasks, like creating or stopping instances.
âš™ï¸ Level: Low-level (manual commands)

2ï¸âƒ£ AWS SDK / API
â¤ Programmatic access to AWS services using code.
â¤ Available for languages like Python (Boto3), JavaScript, Java, etc.

âœ… Example (Python Boto3):
import boto3
ec2 = boto3.client('ec2')
ec2.run_instances(ImageId='ami-0abcdef', InstanceType='t2.micro', MinCount=1, MaxCount=1)

ğŸ”„ Use case:
â¤ When you want to integrate AWS operations inside an app or custom automation scripts.
âš™ï¸ Level: Low-level (programmatic control)

3ï¸âƒ£ AWS CloudFormation (CFT)
â¤ Infrastructure as Code (IaC) tool native to AWS.
â¤ Uses YAML/JSON templates to define and deploy AWS resources.

âœ… Example (YAML):
Resources:
  MyEC2Instance:
    Type: AWS::EC2::Instance
    Properties:
      ImageId: ami-0abcdef
      InstanceType: t2.micro

ğŸ”„ Use case:
â¤ Automate AWS infrastructure provisioning in a declarative way.
â¤ Used for repeatable deployments (same infra across environments).
âš™ï¸ Level: Declarative IaC (AWS-only)

4ï¸âƒ£ Terraform
â¤ Multi-cloud Infrastructure as Code tool by HashiCorp.
â¤ Works with AWS, Azure, GCP, etc.
â¤ Uses HCL (HashiCorp Configuration Language).

âœ… Example (HCL):
provider "aws" {
  region = "us-east-1"
}

resource "aws_instance" "example" {
  ami           = "ami-0abcdef"
  instance_type = "t2.micro"
}

ğŸ”„ Use case:
â¤ Cross-cloud automation
â¤ Version-controlled infrastructure
â¤ More flexible than CloudFormation (modular, reusable, portable).
âš™ï¸ Level: Declarative IaC (multi-cloud)

ğŸ’¡ 5ï¸âƒ£ AWS CDK (Cloud Development Kit)
â¤ High-level Infrastructure as Code using real programming languages (TypeScript, Python, Java, etc.)
â¤ Converts your code â†’ CloudFormation under the hood.

âœ… Example (TypeScript):
import * as ec2 from 'aws-cdk-lib/aws-ec2';
import { Stack } from 'aws-cdk-lib';

class MyStack extends Stack {
  constructor(scope, id, props) {
    super(scope, id, props);
    new ec2.Instance(this, 'MyInstance', {
      instanceType: new ec2.InstanceType('t2.micro'),
      machineImage: ec2.MachineImage.latestAmazonLinux(),
    });
  }
}

ğŸ”„ Use case:
â¤ Developers who prefer real code over YAML.
â¤ Allows loops, conditions, functions in infra definitions.
âš™ï¸ Level: High-level IaC (code-driven)

| Tool                     | Type            | Scope       | Language         | Style                    | Use Case                     |
| ------------------------ | --------------- | ----------- | ---------------- | ------------------------ | ---------------------------- |
| **AWS CLI**              | Command line    | AWS only    | Shell            | Imperative               | Quick manual automation      |
| **AWS SDK/API**          | Programming API | AWS only    | Python, JS, etc. | Imperative               | Embed AWS ops in code        |
| **CloudFormation (CFT)** | IaC             | AWS only    | YAML/JSON        | Declarative              | AWS-native infra automation  |
| **Terraform**            | IaC             | Multi-cloud | HCL              | Declarative              | Cross-cloud infra automation |
| **AWS CDK**              | IaC             | AWS only    | Python/TS/Java   | Declarative (code-based) | Code-native infra definition |


ğŸ”· Connecting to EC2 Instance
1ï¸âƒ£ From AWS Management Console (UI)
Go to EC2 Dashboard â†’ Instances.
Select your running instance.
Click Connect at the top.
Choose EC2 Instance Connect or Session Manager.
Click Connect to open a browser-based terminal session.

âœ… Advantage:
No local setup required.
Secure and easy for quick access.

ğŸ’» Method 2: From CLI (Git Bash / Terminal)
Used when you want to connect directly from your local machine.

1ï¸âƒ£ Set file permissions for keypair (.pem file):
ğŸ”— chmod 400 my-key-pair.pem

â¤ This ensures that only you (the file owner) can read the key file â€” a security requirement by SSH.

2ï¸âƒ£ Connect using SSH:
ğŸ”— ssh -i "my-key-pair.pem" ec2-user@ec2-3-109-59-6.ap-south-1.compute.amazonaws.com

âœ”ï¸ -i â†’ specifies the private key file
âœ”ï¸ ec2-user â†’ default username for Amazon Linux
âœ”ï¸ The public DNS name is unique for your instance

ğŸ”„ Advantage:
â¤ Direct access from terminal
â¤ Useful for automation, DevOps scripts, and deployments

ğŸ” Stopping and Terminating EC2 Instances
ğŸ“´ Stop Instance
â¤ Temporarily shuts down the instance.
â¤ Data on EBS volume is retained.
â¤ You can start it again later.

âŒ Terminate Instance
â¤ Permanently deletes the instance.
â¤ All data on instance store volumes is lost.
â¤ Cannot be restarted once terminated.

âš¡ Note:
Always stop first, then terminate only if not needed further.


ğŸ”· AWS CLI
AWS CLI is a command-line tool that allows you to interact with AWS services directly from your terminal instead of using the AWS Management Console (UI).

ğŸ”„ Key Features:
1ï¸âƒ£ Automate AWS tasks using commands or scripts
2ï¸âƒ£ Manage EC2 instances, S3 buckets, IAM users, etc.
3ï¸âƒ£ Integrates with Shell Scripting and CI/CD pipelines

ğŸ”„ Setup Steps:
1ï¸âƒ£ Install AWS CLI:
ğŸ”— Download from https://aws.amazon.com/cli/

2ï¸âƒ£ Configure credentials:
ğŸ”— aws configure

ğŸ‘‰ Enter:
  âœ”ï¸ AWS Access Key ID
  âœ”ï¸ AWS Secret Access Key
  âœ”ï¸ Default region name (e.g., ap-south-1)
  âœ”ï¸ Default output format (json, text, or table)

3ï¸âƒ£  Verify installation:
ğŸ”— aws --version

âœ… Example Commands:
ğŸ”— aws ec2 describe-instances
ğŸ”— aws s3 ls
ğŸ”— aws ec2 stop-instances --instance-ids i-0abcd1234ef5678gh

ğŸ“ AWS CLI Command Reference: https://docs.aws.amazon.com/cli/latest/userguide/cli-services-ec2-instances.html
ğŸ“ AWS Cloud Formation Template Example: https://github.com/aws-cloudformation/aws-cloudformation-templates
ğŸ“ AWS Python Boto3 Example: https://gist.github.com/mda590/679aba60ca03699d5b12a32314debdc0


ğŸ”· Version Control System (VCS)
A Version Control System tracks changes in code/files, enables collaboration, and keeps history of all modifications.

Two major types:
1ï¸âƒ£ Centralized VCS (CVCS)
2ï¸âƒ£ Decentralized / Distributed VCS (DVCS)

ğŸ”µ Centralized Version Control System (CVCS)
A centralized VCS has a single central server that stores the entire codebase and its history.
Developers connect to this server to commit, update, and retrieve code.

âœ… Examples
â¤ SVN (Subversion)
â¤ CVS
â¤ Perforce

ğŸ”„ How it works
â¤ One central repository lives on a server.
â¤ Developers only keep a working copy, not full history.
â¤ If the server is down â†’ no commits, no history access.

ğŸ”„ Advantages
â¤ Simple to understand
â¤ Centralized control (good for enterprises)
â¤ Easy to maintain permissions

ğŸ”„ Disadvantages
â¤ Single point of failure (Server crash = work stops)
â¤ Slow operations (network-dependent)
â¤ Limited offline work
â¤ Server load is high

ğŸŸ¢  Decentralized / Distributed Version Control System (DVCS)
A distributed VCS gives every developer a complete copy of the entire repository, including full history.

âœ… Examples
âœ”ï¸ Git (Most widely used today)
âœ”ï¸ Mercurial
âœ”ï¸ Bazaar

ğŸ”„ How it works
â¤ Every developer has a local repo (local copy of full history).
â¤ Commits, branching, merging happen locally.
â¤ Pushing/pulling happens with a remote like GitHub/GitLab.

ğŸ”„ Advantages
â¤ No single point of failure
â¤ Almost everything can be done offline
â¤ Fast operations (local)
â¤ Easier branching & merging
â¤ Highly scalable for large teams

ğŸ”„ Disadvantages
â¤ Slightly more complex to understand
â¤ Requires more local storage (full history stored locally)


ğŸ”· Git Branching Strategy
A Git branching strategy defines how teams create, use, and merge branches in a project.
It ensures:
â¤ Clean and predictable workflow
â¤ Easy collaboration
â¤ Safe deployment
â¤ Reduced merge conflicts
â¤ Stable production releases

ğŸ”¥ Why Do We Need a Branching Strategy?
â¤ Because without a strategy:
â¤ Developers overwrite each otherâ€™s work
â¤ Releases become unstable
â¤ Hard to review code
â¤ Hotfixes break existing code
â¤ Production gets messy

Branching strategies bring discipline and structure to teamwork.

ğŸ§± Popular Git Branching Strategies
1ï¸âƒ£ Git Flow (Most Traditional & Full-featured)
Used in large, release-focused projects.

ğŸ”— Main Branches
  âœ”ï¸ main â†’ always production-ready
  âœ”ï¸ develop â†’ integration branch for features

ğŸ”— Supporting Branches
  âœ”ï¸ feature/* â†’ new features
  âœ”ï¸ release/* â†’ preparing new release
  âœ”ï¸ hotfix/* â†’ emergency fixes in production

ğŸ”„ Flow Summary
feature â†’ develop â†’ release â†’ main â†’ tag version
                      â†‘
                 hotfix â†’ main

âš¡ Pros
â¤ Great for large teams
â¤ Very structured
â¤ Supports multiple releases

âŒ Cons
â¤ Too heavy for small/fast-moving teams

2ï¸âƒ£ GitHub Flow (Simple & Best for Continuous Deployment)
Used in modern web companies (GitHub, Facebook, etc.)

ğŸ”„ Structure
â¤ Only one main branch: main
â¤ New work â†’ feature-branch
â¤ After work is done â†’ Open Pull Request â†’ Review â†’ Merge to main
â¤ Deployment happens after merge

âš¡ Pros
â¤ Very simple
â¤ Works great with CI/CD
â¤ Fast iterations

âŒCons
â¤ No separate develop or release branches
â¤ Not suitable for complex release cycles

3ï¸âƒ£ GitLab Flow (Hybrid of Git Flow + GitHub Flow)
Mixes environment branches (like staging, production).

ğŸ”„ Common Flow
feature â†’ main â†’ staging â†’ production

âš¡Pro
â¤ Supports environments (QA, staging).
â¤ Balanced between complexity and simplicity

âŒ Cons
â¤ Slightly more complex than GitHub Flow

4ï¸âƒ£ Trunk-Based Development (Used by Google, Netflix)
Very fast and extreme Agile.

ğŸ”„ Rules
  âœ”ï¸ Only one main branch â†’ main
  âœ”ï¸ Developers create short-lived feature branches
  âœ”ï¸ Merge into main daily or several times a day
  âœ”ï¸ Requires feature flags to hide incomplete features

âš¡ Pros
â¤ Very fast releases
â¤ Minimal merge conflicts
â¤ Perfect for DevOps

âŒ Cons
â¤ Requires high discipline
â¤ Needs strong automation & CI/CD

â­ Which Branching Strategy Should You Use? (Interview Answer)
â¤ Small teams / startups: GitHub Flow
â¤ Large enterprise projects: Git Flow
â¤ CI/CD-heavy teams (DevOps): Trunk-Based Development
â¤ Teams with environments (QA, staging): GitLab Flow


ğŸ”· AWS services For DevOps
1ï¸âƒ£ EC2 (Elastic Compute Cloud)
2ï¸âƒ£ VPC (Virtual Private Cloud)
3ï¸âƒ£ EBS (Elastic Block Store)
4ï¸âƒ£ S3 (Simple Storage Service)
5ï¸âƒ£ IAM (Identity and Access Management)
6ï¸âƒ£ CloudWatch (Monitoring and Logging)
7ï¸âƒ£ Lambda (Serverless Computing) 
8ï¸âƒ£ CodeBuild (Build Service)
  1ï¸âƒ£ AWS CodePipeline (CI/CD Service)
  2ï¸âƒ£ AWS CodeBuild (Build Service)
  3ï¸âƒ£ AWS CodeDeploy (Deployment Service)
9ï¸âƒ£ AWS Configuration Manager (AWS Config)
1ï¸âƒ£0ï¸âƒ£ Billing and Cost Management
1ï¸âƒ£1ï¸âƒ£ AWS KMS (Key Management Service)
1ï¸âƒ£2ï¸âƒ£ AWS CloudTrail (Audit and Compliance)
1ï¸âƒ£3ï¸âƒ£ AWS EKS (Elastic Kubernetes Service)
1ï¸âƒ£4ï¸âƒ£ Fargate, ECS 
1ï¸âƒ£5ï¸âƒ£ ELK Stack (Elasticsearch, Logstash, Kibana)


ğŸ”·Configuration Management With Ansible
Configuration Management (CM) is the process of automating the setup, configuration, and management of servers so they remain consistent across environments.

ğŸ”„ Why do we need CM?
âœ”ï¸ Avoid manual configuration
âœ”ï¸ Ensure consistency across Dev, QA, Prod
âœ”ï¸ Reduce human errors
âœ”ï¸ Automate deployments & scaling
âœ”ï¸ Improve reliability for infrastructure

ğŸŒŸ Configuration Management with Ansible
Ansible is a simple, agentless, open-source configuration management and automation tool.

ğŸ”„ It automates:
â¤  Server configuration
â¤  Application deployment
â¤  Orchestration
â¤  Cloud provisioning

ğŸ” Key Features
â¤ Agentless (No software installation on client machines)
â¤ Uses SSH for communication
â¤ YAML-based Playbooks (simple to read and write)
â¤ Idempotent (same script can run multiple times without breaking anything)


ğŸ”„ Components of Ansible
1ï¸âƒ£ Control Node
  âœ”ï¸ Where Ansible is installed
  âœ”ï¸ Executes Playbooks
2ï¸âƒ£ Managed Nodes
  âœ”ï¸ Target servers
  âœ”ï¸ No agent required
3ï¸âƒ£ Inventory File
  âœ”ï¸ List of hosts (IP or domain)
4ï¸âƒ£ Playbooks (YAML)
  âœ”ï¸ Written instructions for tasks

âœ… Example Inventory:
[webservers]
192.168.1.10
192.168.1.11

âœ… Example Playbook:
- hosts: webservers
  tasks:
    - name: install nginx
      apt:
        name: nginx
        state: present


ğŸ†š Puppet vs Ansible
| Feature              | **Puppet**                     | **Ansible**                                     |
| -------------------- | ------------------------------ | ----------------------------------------------- |
| **Type**             | Configuration Management       | Configuration Management + Orchestration        |
| **Language**         | DSL (Domain Specific Language) | YAML (Easy)                                     |
| **Agent**            | **Agent-based**                | **Agentless**                                   |
| **Communication**    | Client-Agent Architecture      | SSH / WinRM                                     |
| **Setup Complexity** | High                           | Very Easy                                       |
| **Learning Curve**   | Steep                          | Beginner-friendly                               |
| **Ease of Use**      | Medium                         | Very High                                       |
| **Speed**            | Slower initial setup           | Faster setup + execution                        |
| **Push/Pull Model**  | Pull (Clients pull configs)    | Push (Control pushes configs)                   |
| **Best For**         | Large enterprise environments  | Small to medium teams; also used in enterprises |
| **Scaling**          | Very powerful                  | Scales decently                                 |

ğŸ” Puppet
â¤ Follows a clientâ€“server model
â¤ Each node runs a Puppet Agent
â¤ Agents connect to Puppet Master to fetch configuration
â¤ Uses its own scripting language (Puppet DSL)
â¤ Suitable for large enterprises with complex infrastructures

ğŸ” Ansible
â¤ No agent required on target machines
â¤ Uses SSH, which is built in everywhere
â¤ Easier to start & maintain
â¤ Playbooks written in YAML (very readable)
â¤ Very popular in DevOps & Cloud automation
â¤ Faster to adopt and integrate with CI/CD


ğŸ”· How to Setup Ansible in EC2 instance
ğŸŸ¦ Step 1: Launch EC2 Instances
You need at least 2 EC2 instances:

1ï¸âƒ£ Control Node
Ansible will be installed here
OS: Ubuntu is recommended

2ï¸âƒ£ Managed Node(s)
Ansible will configure these
Can be Ubuntu / Amazon Linux / CentOS
You can have 1 or more managed nodes.

ğŸŸ¦ Step 2: Connect to the Control Node
ğŸ‘‰ SSH into the control node:
ğŸ”— ssh -i your-key.pem ubuntu@public-ip

ğŸ‘‰ Update system:
ğŸ”— sudo apt update -y

ğŸŸ¢ Step 3: Install Ansible on Control Node
ğŸ‘‰ For Ubuntu:
ğŸ”— sudo apt install ansible -y

ğŸ‘‰ Check version:
ğŸ”— ansible --version

use command:
ssh-keygen
generates public key in path /home/ubuntu/.ssh/id_ed25519.pub and private key in path /home/ubuntu/.ssh/id_ed25519

ğŸŸ¦ Step 4: Create an Inventory File
Ansible uses an inventory to know which servers to manage.

ğŸ‘‰ Create a directory:
ğŸ”— mkdir ansible-setup
ğŸ”— cd ansible-setup

ğŸ‘‰ Create inventory file:
ğŸ”— nano inventory

Add your managed node IPs:
[webservers]
âœ”ï¸ ec2-user@<managed-node-1-public-ip>
âœ”ï¸ ec2-user@<managed-node-2-public-ip>
â€» If using Ubuntu as managed nodes, replace ec2-user with ubuntu.

ğŸŸ¢ Step 5: Copy SSH Key to Control Node
You must move your .pem key to the control node:

ğŸ‘‰ On your laptop:
ğŸ”— scp -i your-key.pem your-key.pem ubuntu@control-node-ip:/home/ubuntu/

ğŸ‘‰ Inside control node:
ğŸ”— chmod 400 your-key.pem

ğŸŸ¦ Step 6: Test Connection from Ansible to Managed Node

ğŸ‘‰ Run:
ğŸ”— ansible -i inventory webservers -m ping --private-key your-key.pem

ğŸ‘‰ Expected output if successful:
managed-node-ip | SUCCESS => {
    "changed": false,
    "ping": "pong"
}

ğŸŸ¢ Step 7: Create a Playbook (Optional but Recommended)
Example: Install NGINX on nodes.

ğŸ‘‰ Create a playbook:
ğŸ”— nano install-nginx.yml


ğŸ‘‰ Add:
ğŸ”— - hosts: webservers
  become: yes
  tasks:
    - name: Install Nginx
      apt:
        name: nginx
        state: present

ğŸ‘‰ Run playbook:
ğŸ”— ansible-playbook -i inventory install-nginx.yml --private-key your-key.pem

ğŸŸ¦ Step 8: Verify on Managed Nodes
ğŸ‘‰ SSH into managed node:
ğŸ”— ssh -i your-key.pem ubuntu@managed-node-ip

ğŸ‘‰ Check Nginx:
ğŸ”— systemctl status nginx
