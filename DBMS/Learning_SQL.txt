🧠 Why SQL?
We need a language to interact with databases—whether it's to store, retrieve, update, or delete data.
SQL (Structured Query Language) is the standard language used for interacting with Relational Databases.

With SQL, we can perform:

➤ Create – Create new records or database structures
➤ Read – Retrieve data from tables
➤ Update – Modify existing records
➤ Delete – Remove data
These operations are known as CRUD operations and are essential for any database-driven application.

Key Features and Advantages of Using SQL
✔️ Simplicity: SQL is easy to learn English-like syntax and use, making it accessible to a wide range of developers.
✔️ Ubiquity: SQL is a widely used language, making it easy to learn and use.
✔️ Flexibility: SQL supports a wide range of database operations, including data definition, data manipulation, and data control.
✔️ Performance: SQL provides efficient and optimized database operations, making it suitable for high-performance applications.
✔️ Data Integrity: SQL ensures data integrity and security, making it suitable for enterprise-level applications.

🧠 What is MySQL?
MySQL is a Relational Database Management System (RDBMS) that uses SQL as its querying language.
It is:
➤ Open-source and widely used in web and enterprise applications
➤ Known for its speed, reliability, and ease of use
➤ Maintained by Oracle Corporation

MySQL allows you to:
➤ Store data in tables
➤ Establish relationships using primary and foreign keys
➤ Enforce data integrity and security
➤ Handle large volumes of structured data efficiently

✅ In short:
SQL is the language, while MySQL is a software (RDBMS) that understands and executes SQL queries.

🧠 How SQL Helps Us
SQL (Structured Query Language) enables users to interact with relational databases effectively. It supports a wide range of operations, grouped into the following categories:

✅ 1. Retrieving Data
➤ SQL allows users to fetch specific and meaningful data from large datasets.
➤ Users can apply filters, conditions, sorting, and grouping to extract exactly what is needed.
➤ This is essential for generating reports, dashboards, and data analysis.

✅ 2. Manipulating Data
➤ SQL provides commands to add, update, and delete records in the database.
➤ These operations help maintain up-to-date and accurate information.
➤ It supports bulk updates and conditional changes as well.

✅ 3. Defining Data
➤ SQL allows the creation and modification of the database structure.
➤ This includes creating or altering tables, views, indexes, and constraints.
➤ It ensures the data is stored in an organized and consistent format.

✅ 4. Controlling Data
➤ SQL supports user access control by allowing database administrators to grant or revoke permissions.
➤ It ensures that sensitive data is only accessible to authorized users.
➤ Helps enforce security, privacy, and role-based access.

🧠 Types of SQL Commands
SQL commands are categorized based on the type of operation they perform on the database:

✅ 1. Data Query Language (DQL)
➤ Purpose: To retrieve data from the database.

Command: SELECT
Note: Although it has only one command, it's one of the most frequently used.

✅ 2. Data Manipulation Language (DML)
➤ Purpose: To manipulate data stored in existing tables.
Common Operations:
1. Insert new records
2. Update existing records
3. Delete records

Commands: INSERT, UPDATE, DELETE
Affects: Only the data, not the structure.

✅ 3. Data Definition Language (DDL)
➤ Purpose: To define or modify the structure of database objects.

Used for:
Creating tables, indexes, and views
Modifying table structure
Deleting database objects

Commands: CREATE, ALTER, DROP, TRUNCATE, RENAME
Note: DDL commands are usually auto-committed (changes are permanent).

✅ 4. Data Control Language (DCL)
➤ Purpose: To control access to data and database operations.

Used for:
Granting permissions to users
Revoking access when needed

Commands: GRANT, REVOKE
Helps enforce: Data security and role-based access control.

✅ 5. Transaction Control Language (TCL)
➤ Purpose: To manage transactions in a database.

Used to:
Commit changes
Roll back changes in case of errors
Ensure consistency of operations

Commands: COMMIT, ROLLBACK, SAVEPOINT

🧠 Understanding Rows and Columns in a Table
Columns = Attributes / Fields / Characteristics
Each column in a table represents a specific attribute of the entity.
Example: In a Student table, columns could be RollNo, Name, Age, Department.

Rows = Records / Tuples
Each row stores a complete set of data for one instance of the entity.
In other words, a row contains all the attribute values for a single entity.

🧠 Hierarchy in a Relational Database System

✅ 1. Server
➤ A database server hosts and manages one or more databases.
➤ It handles connections, storage, and access control.

✅ 2. Database
➤ A database is a logical collection of related data.
➤ You can create multiple databases on a single server.
➤ Each database is independent and contains its own tables, users, permissions, etc.

✅ 3. Tables
➤ A database is made up of multiple tables.
➤ Each table stores data related to a specific entity (e.g., students, employees).
➤ Tables are structured in rows and columns.

✅ 4. Records (Rows)
➤ A record (also called a tuple) represents one entry in the table.
➤ Each row holds data for one instance of the entity.

✅ 5. Attributes (Columns)
➤ Each record is made up of attributes (columns).
➤ Attributes represent the properties or characteristics of the entity.
Example: For a Student record, attributes could be Name, Roll No, Marks, etc.

🔁Server → Databases → Tables → Records → Attributes

🧠 Creation of Database
➤ We use the CREATE DATABASE statement to create a new database.
➤ SQL commands are not case-sensitive, but it's good practice to use uppercase for keywords.

✅ Basic Command: 
CREATE DATABASE database_name;

✅ To Avoid Errors (If Database Already Exists):
CREATE DATABASE IF NOT EXISTS database_name;
The IF NOT EXISTS clause is used to prevent errors if the database already exists.

This clause is commonly used with CREATE TABLE as well.

🧠 Deletion of Database
➤ We use the DROP DATABASE statement to permanently delete a database.
➤ This removes the entire database, including all:
1. Tables
2. Data
3. Views
4. Stored procedures
5. Other objects

It is a DDL (Data Definition Language) command.

✅ Basic Command:
DROP DATABASE database_name;

✅ To Avoid Errors (If Database Doesn’t Exist):
DROP DATABASE IF EXISTS database_name;

The IF EXISTS clause helps avoid runtime errors by checking if the database exists before trying to delete it.

🧠 Using a Database
➤ To work with a specific database, we use the USE statement.
➤ This command sets the active database for your current session.
➤ After executing it, all subsequent operations (like creating tables or inserting data) will apply to the selected database.

✅ Command:
USE database_name;

📝 Note:
➤ You must use this command before performing any operations on tables if multiple databases exist on the server.
➤ This helps the DBMS understand which database you’re referring to.

🧠 Showing All Databases
➤ To view all databases available on the current database server, we use the SHOW DATABASES command.
➤ It displays a list of all existing databases, whether created by the user or system-defined.

✅ Command:
SHOW DATABASES;

📝 Note:
➤ You can only see databases for which you have access privileges.
➤ This is helpful when working on a shared server or verifying successful creation of a new database.

🧠 Select Database
✅ Command:
SELECT DATABASE();

➤ This command displays the currently active database for the current session.

🔷 Working with Tables

🧠 Creating a Table
➤ We use the CREATE TABLE statement to define a new table within a database.
➤ It is a DDL command.
➤ A table consists of columns, each with a data type and optional constraints to enforce rules on the data.

✅ Syntax:
CREATE TABLE table_name (
    column1 data_type1 constraint1,
    column2 data_type2 constraint2,
    column3 data_type3 constraint3,
    ...
    table_constraints
);

✅Example:
CREATE TABLE employees(
employee_id int primary key auto_increment,
first_name varchar(50) not null,
last_name varchar(50) not null,
email varchar(50) unique,
hire_date date default (current_date()),
phone_number varchar(20) unique,
salary decimal(10,2) check (salary> 0.0),
employment_status enum('active', 'on leave', 'terminated') default 'active',
created_at timestamp default current_timestamp,
updated_at timestamp default current_timestamp on update current_timestamp

);

📝 Explanation:
➤ table_name: Name of the table you want to create.
➤ column1, column2, ...: Names of the columns (attributes).
➤ data_type: Defines the type of data (e.g., INT, VARCHAR, DATE).
➤ constraint (optional): Rules like PRIMARY KEY, NOT NULL, UNIQUE, etc.

🧠 Inserting Values into a Table
➤ INSERT is a DML (Data Manipulation Language) command.
➤ It is used to add new records (rows) into an existing table.

✅ Syntax:
INSERT INTO table_name (column1, column2, ..., columnN)
VALUES (value1, value2, ..., valueN);
📝 Key Points:
➤ Column names should match the order of values provided.
➤ You must ensure the values follow the data type and constraint rules defined during table creation.

➤ If you want to insert into all columns, you can skip the column list:
INSERT INTO table_name VALUES (value1, value2, ..., valueN);

✅Example:
insert into employees (first_name,last_name,email,phone_number,salary,employment_status) values ('John','Doe','2aLX0@example.com','1234567890',10000.00,'active');

🧠 Viewing Data from a Table
➤ We use the SELECT command to retrieve data from one or more columns in a table.
➤ It is a DQL (Data Query Language) command.

🔄Use Cases:
1️⃣ To view specific columns:
SELECT column_name1, column_name2 FROM table_name;

✅ Example:
🔗 SELECT cid FROM course;
(This displays only the cid column from the course table.)

2️⃣ To view all columns and all records:
🔗 SELECT * FROM table_name;

✅ Example:
🔗 SELECT * FROM course;
(This displays the entire table, including all columns and all rows.)

3️⃣ To change the name of the columns in output for better readability
🔗 SELECT column_name1 AS column_name1_alias, column_name2 AS column_name2_alias FROM table_name;

✅ Example:
🔗 SELECT cid AS course_id, cname AS course_name FROM course;

4️⃣ To filter data based on conditions:
🔗 Select * from employees where department="IT" order by salary desc  → Displays all employees in the IT department sorted by salary in descending order

5️⃣ To limit the number of rows returned:
🔗 Select * from employees where department="IT" order by salary desc limit 2  → Displays the top 2 employees in the IT department sorted by salary in descending order

6️⃣ To display unique values:
🔗 Select distinct department from employees;  → Displays unique departments from the employees table.

7️⃣ To display calculated values:
🔗 Select first_name, last_name, salary*1.1 as 'Salary After Raise' from employees;  → Displays first name, last name, and salary after a 10% raise.

8️⃣ Working with built-in function:
🔗 Select concat(first_name," ",last_name) as 'Full Name', YEAR(hire_date) as 'Year of Joining', Round(salary,1) from employees; 

9️⃣ Working with subquery(Nested queries):
🔗 Select * from employees where salary>(select avg(salary) from employees);

1️⃣0️⃣ Working with union:
🔗 Select first_name, last_name from employees where department="IT" union select first_name, last_name from employees where department="HR";

1️⃣1️⃣ Working with group by:
select count(*), department from employees group by department;

1️⃣2️⃣ Evaluating expressions using select(used for debugging):
🔗 select now() as 'time';
🔗 select 5*2;
🔗 select length('hello');
🔗 select 5<3;

📝 Note:
➤ * is a wildcard that means "all columns".
➤ The result set may be filtered or sorted further using clauses like WHERE, ORDER BY, etc.

🧠 Viewing All Tables in a Database
➤ We use the SHOW TABLES command to list all tables present in the currently selected database.
➤ It helps verify if a table was created successfully or to explore existing tables.

✅ Command:
SHOW TABLES;

📝 Note:
➤ You must first select a database using the USE database_name; command before running SHOW TABLES.
➤ Only tables within the currently active database will be shown.
➤ Useful for database exploration and management.

🧠 Alter Table Command
➤ We use the ALTER TABLE command to modify the structure of an existing table.
➤ It is a DDL (Data Definition Language) command.

✅ Use Cases:
🔹 To add a new column:
ALTER TABLE table_name ADD COLUMN new_column_name data_type;

🔹 To modify an existing column:
ALTER TABLE table_name MODIFY COLUMN column_name data_type;

🔹 To delete a column:
ALTER TABLE table_name DROP COLUMN column_name;

🔹 To rename a table/column_name:
ALTER TABLE table_name RENAME TO new_table_name;

🔹 To add constraints:
ALTER TABLE table_name ADD CONSTRAINT constraint_name CHECK (condition);

✅Example:
1️⃣ Alter table employees add column description text;

2️⃣ ALTER TABLE employees 
ADD COLUMN emergency_contact VARCHAR(100) 
NOT NULL DEFAULT 'Name:0000000000'
CHECK (emergency_contact REGEXP '^[A-Za-z]+:[0-9+-]+$');

🧠 Drop table table_name
➤ We use the DROP TABLE command to remove an existing table from the database.
➤ It is a DDL (Data Definition Language) command.

✅ Use Cases:
🔹 To delete a table:
DROP TABLE table_name if exists;

🧠 Data Types in SQL
SQL provides various data types to define the type of data that can be stored in each column of a table.

✅ 1. Numeric Data Types
Used to store numbers (integers or decimals).

➤ INT / INTEGER – Whole numbers (INT_MIN to INT_MAX)- 4 Bytes
➤ SMALLINT – Smaller range of integers 2 Bytes
➤ TINYINT – Smallest range of integers 1 Byte
➤ MEDIUMINT – Medium range of integers 3 Bytes
➤ BIGINT – Larger range of integers 8 Bytes

➤ DECIMAL(p,s) – Fixed-point number with precision p and scale s (e.g., DECIMAL(5,2) → 123.45)- Variable Size limit of (p,s) is (65,30).
➤ DOUBLE – Double-precision floating-point numbers (8-byte) (10,0) as precision and scale
➤ FLOAT – Approximate floating-point numbers (4-byte) (not always precise)

By default all the numeric dataypes can have negative as well as positive values. This restrict the range so if we know there is only +ve values which is stored we use UNSIGNED attribute (0-255).
 
✅ 2. Character/String Data Types
Used to store text.

➤ CHAR(n) – Fixed-length string range(0-255) (e.g., CHAR(10) stores exactly 10 characters)
➤ VARCHAR(n) – Variable-length string range(65535 bytes) (up to n characters)
➤ TEXT – Large text blocks (no fixed limit like VARCHAR)

✅ 3. Date and Time Data Types
Used to store date/time values.

➤ DATE – Stores a date (YYYY-MM-DD)
➤ TIME – Stores a time (HH:MM:SS)
➤ DATETIME – Stores both date and time
➤ TIMESTAMP – Similar to DATETIME, often used for auto-recording date/time of entry
➤ YEAR - Stores a year (2-digit or 4-digit format)

✅ 4. Boolean Data Type
Used for true/false values.
BOOLEAN / BOOL – Stores TRUE or FALSE (internally stored as 1 or 0)

✅ 5. Binary Data Types
Used to store binary data (e.g., images, files).
➤ BINARY(n) – Fixed-length binary data 255 bytes
➤ VARBINARY(n) – Variable-length binary data 64KB
➤ BLOB – Binary Large Object, used to store large binary files like images or documents
Categories of BLOB data types:
    ➤ TINYBLOB (255 bytes)
    ➤ BLOB (64KB)
    ➤ MEDIUMBLOB (16MB)
    ➤ LONGBLOB (4GB)

✅ Enum Data Type
➤ Used to store a set of predefined values.
➤ Size is limited to 65535 members.
➤ Single Seleection from a fixed list.
✅Example: ENUM('active', 'inactive', 'deleted');

✅ Set Data Type
➤ Used to store a set of values.
➤ Size is limited to 64 members.
➤ Multiple Selection from a fixed list.
✅Example: SET('A', 'B', 'C');

📝 Tips for Interviews:
➤ Use VARCHAR over CHAR for variable-length strings to save space.
➤ Prefer DECIMAL/NUMERIC over FLOAT for money-related values to maintain precision.
➤ TIMESTAMP is auto-updated on row modification (useful for tracking updates).

🧠 Keys in SQL
Keys are crucial in SQL to uniquely identify records and establish relationships between tables.

✅ 1. Primary Key
➤ A Primary Key uniquely identifies each record in a table.
➤ It ensures that no two rows have the same value for this key.

A primary key column must be:
1. Unique
2. Not Null

A table can have only one primary key, which can consist of one or more columns (composite key).

📌 Purpose: Uniquely identify each row.

✅ 2. Foreign Key
➤ A Foreign Key is a column (or set of columns) in one table that refers to the Primary Key in another table.
➤ It is used to establish a relationship between two tables (called referential integrity).
➤ A foreign key can have duplicate and null values, unlike primary keys.

📌 Terms:
➤ Referenced Table: The table containing the primary key.
➤ Referencing Table: The table containing the foreign key.

📝 Example Use Case:
Students table has student_id as primary key.
Enrollments table has student_id as foreign key, referencing the Students table.

📊 Sample Data:
🔹 Students Table:
| student\_id | name  | department |
| ----------- | ----- | ---------- |
| 101         | Ankur | CS         |
| 102         | Riya  | IT         |

🔹 Enrollments Table:
| enrollment\_id | student\_id | course\_name |
| -------------- | ----------- | ------------ |
| 1              | 101         | DBMS         |
| 2              | 102         | SQL          |
| 3              | 101         | Data Science |

The Enrollments.student_id refers to Students.student_id, ensuring relational integrity.

🧠 Constraints in SQL
Constraints are rules applied to columns or tables to maintain the accuracy, validity, and integrity of data in a database.

✅ Common SQL Constraints:
🧠 SQL Constraints with Examples
Each of the following examples uses a new table to demonstrate a specific constraint.

✅ 1. UNIQUE Constraint
Ensures that all values in a column are distinct (no duplicates).

CREATE TABLE student (
    phonenbr INT UNIQUE
);
-- Inserts unique phone numbers
INSERT INTO student VALUES (123), (456);

✅ 2. NOT NULL Constraint
Ensures a column cannot be left empty (NULL values not allowed).

CREATE TABLE student1 (
    age INT,
    rollno INT NOT NULL
);
-- Valid: rollno is NOT NULL
INSERT INTO student1 VALUES (23, 123);

✅ 3. CHECK Constraint
Applies a condition that each value in the column must satisfy.

CREATE TABLE student2 (
    age INT CHECK(age > 18)
);
-- Valid: 19 > 18
INSERT INTO student2 VALUES (19);

✅ 4. DEFAULT Constraint
Automatically assigns a default value to a column if no value is specified.

CREATE TABLE student3 (
    schoolName VARCHAR(50) DEFAULT 'RLB',
    age INT
);
-- Only age is given, schoolName will be set to default 'RLB'
INSERT INTO student3 (age) VALUES (23);

-- View inserted data
SELECT * FROM student3;

✅ 5. PRIMARY KEY Constraint
Uniquely identifies each row. It combines UNIQUE + NOT NULL. Only one per table.

CREATE TABLE student4 (
    age INT,
    rollNo INT PRIMARY KEY
);
-- All rollNo values must be unique and not null
INSERT INTO student4 VALUES (12,1), (13,2), (14,3), (15,5), (16,6);

-- View data
SELECT * FROM student4;

✅ 6. FOREIGN KEY Constraint
Establishes a relationship between two tables by referencing the primary key of another table.

CREATE TABLE course (
    courseName VARCHAR(50),
    rollNo INT,
    FOREIGN KEY (rollNo) REFERENCES student4(rollNo)
);
-- Inserting data with rollNo values that exist in student4
INSERT INTO course VALUES ('DBMS', 1), ('OS', 2);

-- View data
SELECT * FROM course;

🧠 Foreign Key in SQL
➤ A foreign key creates a relationship between two tables.
➤ It ensures that the value in the child table exists in the parent (referenced) table.

✅ Syntax:
CREATE TABLE childTableName (
    childId INT PRIMARY KEY,
    baseId INT,
    FOREIGN KEY (baseId) REFERENCES baseTableName(baseId)
);
🔍 Purpose:
➤ Enforces referential integrity
➤ Helps in JOIN operations between tables

🌊 Cascading in Foreign Keys
Cascading options define how changes in the parent table affect the child table.

✅ 1. CASCADE
If a row in the parent is updated/deleted → same action is done on the child.
Syntax:
FOREIGN KEY (baseId) REFERENCES baseTable(baseId)
    ON DELETE CASCADE
    ON UPDATE CASCADE

✅ 2. SET NULL
If parent row is updated/deleted → sets foreign key in child table to NULL.
Syntax:
FOREIGN KEY (baseId) REFERENCES baseTable(baseId)
    ON DELETE SET NULL
    ON UPDATE SET NULL

✅ 3. RESTRICT / NO ACTION
Prevents parent row from being deleted/updated if it has referencing rows in the child.
Syntax:
FOREIGN KEY (baseId) REFERENCES baseTable(baseId)
    ON DELETE RESTRICT
    ON UPDATE RESTRICT

🧪 Example:
🔹 Parent Table
CREATE TABLE baseTable (
    baseId INT PRIMARY KEY,
    baseName VARCHAR(50)
);

INSERT INTO baseTable VALUES (1, 'Alpha'), (2, 'Beta');

🔹 Child Table with CASCADE
CREATE TABLE childTable (
    childId INT PRIMARY KEY,
    baseId INT,
    FOREIGN KEY (baseId) REFERENCES baseTable(baseId)
        ON DELETE CASCADE
        ON UPDATE CASCADE
);

INSERT INTO childTable VALUES (101, 1), (102, 2);

🔹 Deleting a row in baseTable:
DELETE FROM baseTable WHERE baseId = 1;

⚠️ This will also delete the row in childTable where baseId = 1 because of ON DELETE CASCADE.


🧠 Understanding Where clause in SQL
✅Example: Creating bookstore database and books table
🔗 CREATE DATABASE bookstore;

USE bookstore;
🔗 CREATE TABLE books (
    book_id INT PRIMARY KEY,
    title VARCHAR(100),
    author VARCHAR(50),
    price DECIMAL(10,2),
    publication_date DATE,
    category VARCHAR(30),
    in_stock INT
);

🔗 INSERT INTO books VALUES
(1, 'The MySQL Guide', 'John Smith', 29.99, '2023-01-15', 'Technology', 50),
(2, 'Data Science Basics', 'Sarah Johnson', 34.99, '2023-03-20', 'Technology', 30),
(3, 'Mystery at Midnight', 'Michael Brown', 19.99, '2023-02-10', 'Mystery', 100),
(4, 'Cooking Essentials', 'Lisa Anderson', 24.99, '2023-04-05', 'Cooking', 75);


🔗 select * from books where category='Technology' ;
🔗 SELECT title, price FROM books WHERE price < 30.00;
🔗 SELECT title, publication_date FROM books WHERE publication_date >= '2023-03-01';

🔄 Logical Operators
And Operator (AND)  → Return records where both conditions are true
Or Operator (OR)  → Return records where either condition is true
Not Operator (NOT) → Negates a condition (return the opposite result)

🔗 select * from books where category = 'Technology' and price < 30;
🔗 select * from books where category = 'Technology' or price < 30;
🔗 select * from books where (category = 'Technology' or category = 'Mystery') and price < 25; 
🔗 select * from books where not category = 'Technology';

🔄 Finding NULL values
🔗 INSERT INTO books VALUES
(5, 'Cook Book', null, 24.99, '2023-04-05', 'Cooking', 75);

🔗 select * from books where author is null;(= null will not work here gives unknown so where will not satify any condition)
🔗 select * from books where author is not null;

🔄 Pattern matching uses like keyword with where 
🔗 select * from books where title like '%SqL%'; → these are case in-sensitive
🔗 select * from books where title like 'the%';  → books starting with the
🔗 select * from books where title like binary '%SQL%'; → for case sensitive search use like binary, i.e compares the binary values of characters(strict checking)

🔗 INSERT INTO books VALUES
(6, 'Mini Cook Book', 'Gohn Smith', 24.99, '2023-04-05', 'Cooking', 75);
🔗 select * from books where author like '_ohn%';  → enforcing that only one character should be present before ohn, so we use underscore wildcard for checking

🔄 RANGE OPERATORS 
🔗 select * from books where price between 20 and 30;  → includes 20 and 30 as well.
🔗 select * from books where category in (
'Technology', 'MysterY', 'Science'); →  for multiple values use in operator and they are case insensitive
🔗 SELECT * FROM books 
WHERE price BETWEEN 20.00 AND 40.00 
    AND publication_date >= '2023-01-01';
    
🔄 SUBQUERIES
🔗 select * from books where price > ( select avg(price) from books );
🔗 select * from books where category in (
select category from books where in_stock > 20
);

✅ Example Queries:
⚡ Find all books published in 2023 that cost less than the average book price
🔗 SELECT title, price, publication_date
FROM books
WHERE YEAR(publication_date) = 2023
AND price < (SELECT AVG(price) FROM books);

⚡ List all technology books with "data" in the title that have more than 50 copies in stock
🔗 SELECT title, category, in_stock
FROM books
WHERE category = 'Technology'
AND title LIKE '%data%'
AND in_stock > 50;

⚡ Find books that are either in the Technology category with price > $30 or in the Mystery category with price < $20
🔗 SELECT title, category, price
FROM books
WHERE (category = 'Technology' AND price > 30.00)
OR (category = 'Mystery' AND price < 20.00);

⚡ List all books where the author's name contains either 'son' or 'th' and were published after March 2023
🔗 SELECT title, author, publication_date
FROM books
WHERE (author LIKE '%son%' OR author LIKE '%th%')
AND publication_date > '2023-03-31';


🧠 Comparision Operators
= → equal to
!= → not equal to
< → less than
> → greater than
<= → less than or equal to
>= → greater than or equal to

👉 Create products table
🔗 CREATE TABLE products (
    product_id INT AUTO_INCREMENT PRIMARY KEY,
    product_name VARCHAR(50),
    category VARCHAR(50),
    price DECIMAL(10,2),
    stock INT
);

👉 Insert sample data into products table
🔗 INSERT INTO products (product_name, category, price, stock) VALUES
('Laptop', 'Electronics', 1200.00, 10),
('Phone', 'Electronics', 800.00, 15),
('Tablet', 'Electronics', 600.00, 20),
('Headphones', 'Accessories', 150.00, 50),
('Mouse', 'Accessories', 30.00, 100),
('Keyboard', 'Accessories', 45.00, 80);

👉 Create orders table
🔗 CREATE TABLE orders (
    order_id INT AUTO_INCREMENT PRIMARY KEY,
    order_date DATE,
    customer_name VARCHAR(50)
);


✅Example:
⚡  Get all products with a price of exactly 600
🔗 SELECT * FROM products WHERE price = 600;

⚡  Get all products that are NOT priced at 800
🔗 SELECT * FROM products WHERE price <> 800; //---> something new
🔗 SELECT * FROM products WHERE price != 800;

⚡  Get all products priced below 500
🔗 SELECT * FROM products WHERE price < 500;

⚡  Get all products priced above 700
🔗 SELECT * FROM products WHERE price > 700;

⚡  Get all products priced at or below 150
🔗 SELECT * FROM products WHERE price <= 150;

⚡  Get all products priced at or above 800
🔗 SELECT * FROM products WHERE price >= 800;

⚡  Get all products where the category is exactly "Electronics"
🔗 SELECT * FROM products WHERE category = 'Electronics';

👉 Insert sample data into orders table
🔗 INSERT INTO orders (order_date, customer_name) VALUES
('2024-02-01', 'Alice'),
('2024-02-05', 'Bob'),
('2024-02-10', 'Charlie'),
('2024-02-15', 'David');

⚡  Retrieve Orders Placed Before February 10, 2024
🔗 SELECT * FROM orders WHERE order_date < '2024-02-10';

⚡  String comparison example (alphabetical ordering)
🔗 SELECT * FROM products WHERE product_name > 'Mouse';

⚡  Numeric comparison with strings (lexicographic comparison)
🔗 SELECT '100' < '2';

⚡  Another string comparison example (lexicographic ordering)
🔗 SELECT 100 < '211fcfc';


🧠 Understanding OrderBy clause
OrderBy clause is used to sort the results of a query in ascending or descending order based on one or more columns.
🔗 CREATE TABLE products (
    product_id INT PRIMARY KEY,
    product_name VARCHAR(100),
    category VARCHAR(50),
    price DECIMAL(10,2),
    stock_quantity INT,
    last_updated TIMESTAMP
);

🔗 INSERT INTO products VALUES
(1, 'Laptop Pro', 'Electronics', 1299.99, 50, '2024-01-15 10:00:00'),
(2, 'Desk Chair', 'Furniture', 199.99, 30, '2024-01-16 11:30:00'),
(3, 'Coffee Maker', 'Appliances', 79.99, 100, '2024-01-14 09:15:00'),
(4, 'Gaming Mouse', 'Electronics', 59.99, 200, '2024-01-17 14:20:00'),
(5, 'Bookshelf', 'Furniture', 149.99, 25, '2024-01-13 16:45:00');


🔄  Basic Sorting Operations
🔗 SELECT * FROM products;  # Display all records (unsorted)

🔗 SELECT * FROM products ORDER BY price ASC;        #Sort by price in ascending order (ASC is optional as it's the default)

🔗 SELECT * FROM products ORDER BY price DESC;       #Sort by price in descending order

🔗 SELECT * FROM products ORDER BY last_updated;   #Sort by last updated timestamp


🔄 Advanced Sorting Techniques
🔗 SELECT * FROM products ORDER BY category DESC, price DESC;      #Multiple column sorting (sort by category descending, then price descending)

🔗 SELECT * FROM products ORDER BY 4;      #Sort using column position (4 represents the price column)  ❌Not preferred 

🔗 SELECT * FROM products 
WHERE category = 'Electronics' 
ORDER BY price;     #Combining WHERE clause with ORDER BY

🔗 SELECT * FROM products ORDER BY BINARY category;        #Case-sensitive sorting using BINARY


🔄 Function-Based Sorting
🔗 SELECT * FROM products ORDER BY LENGTH(product_name);       #Sort by product name length

🔗 SELECT * FROM products ORDER BY DAY(last_updated);      #Sort by day of the month from timestamp

🔗 SELECT * FROM products 
ORDER BY stock_quantity DESC 
LIMIT 1;        #Using LIMIT with ORDER BY to find highest stock quantity


🔄 Custom Sorting Orders
🔗 SELECT * FROM products ORDER BY category;       #Default category sorting

🔗 SELECT * FROM products 
ORDER BY FIELD(category, 'Electronics','Appliances','Furniture'), price DESC;       #Custom category order using FIELD function


🔄 Complex Sorting with Conditions
🔗 SELECT *, 
    stock_quantity <= 50 AND price >= 200 AS priority_flag
FROM products 
ORDER BY (stock_quantity <= 50 AND price >= 200) DESC;      #Simple conditional sorting for low stock and high price items

🔗 SELECT *,
    CASE
        WHEN stock_quantity <= 50 AND price >= 200 THEN 1
        WHEN stock_quantity <= 50 THEN 2
        ELSE 3
    END AS priority 
FROM products 
ORDER BY priority;      #Advanced priority-based sorting using CASE


🔄 Handling NULL Values
🔗 INSERT INTO products VALUES
(6, 'Desk Lamp', 'Furniture', NULL, 45, '2024-01-18 13:25:00'),
(7, 'Keyboard', 'Electronics', 89.99, NULL, '2024-01-19 15:10:00');

🔗 SELECT * FROM products ORDER BY price;      #Basic NULL handling in ORDER BY gives null value products at the top in ascending order sorting

🔗 SELECT *, 
    price IS NULL
FROM products 
ORDER BY price IS NULL;     #Explicit NULL handling


🔄 Working with Calculated Columns
🔗 SELECT *, 
    price * stock_quantity AS total_value 
FROM products 
ORDER BY total_value DESC;      #Sort by total value (price * quantity)


🔄 Query Performance Analysis
🔗 EXPLAIN SELECT * FROM products
ORDER BY category, price;       #Examine query execution plan for multi-column sort

🔗 EXPLAIN SELECT * FROM products 
ORDER BY product_id;    #Compare with primary key sort performance


🧠 Understanding LIMIT & OFFSET 

🔗 CREATE TABLE products (
id INT AUTO_INCREMENT PRIMARY KEY,
name VARCHAR(100),
price DECIMAL(10,2),
category VARCHAR(50),
created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);


🔗 INSERT INTO products (name, price, category) VALUES
('Laptop', 999.99, 'Electronics'),
('Smartphone', 499.99, 'Electronics'),
('Coffee Maker', 79.99, 'Appliances'),
('Headphones', 149.99, 'Electronics'),
('Blender', 59.99, 'Appliances'),
('Tablet', 299.99, 'Electronics'),
('Microwave', 199.99, 'Appliances'),
('Smart Watch', 249.99, 'Electronics'),
('Toaster', 39.99, 'Appliances'),
('Speaker', 89.99, 'Electronics');


🔄 Basic LIMIT Usage
🔗 SELECT * FROM products ORDER BY id LIMIT 2; # Return first 2 products

🔄 LIMIT with OFFSET
✅Syntax 1: LIMIT [row_count] OFFSET [offset]
🔗 SELECT * FROM products ORDER BY id LIMIT 2 OFFSET 2; # return 3rd and 4th product skips first 2

✅ Syntax 2: LIMIT [offset], [row_count]
🔗 SELECT * FROM products ORDER BY id LIMIT 2, 2;


🔄 Pagination Implementation
✔️ Page size: 3 items per page
✔️ For page 1 (Using OFFSET syntax):
🔗 SELECT * FROM products LIMIT 3 OFFSET 0;
✔️ For page 2:
🔗 SELECT * FROM products LIMIT 3 OFFSET 3;
✔️ For page 3:
🔗 SELECT * FROM products LIMIT 3 OFFSET 6;

⚡ Alternative syntax using LIMIT offset, count
✔️ For page 1:
🔗 SELECT * FROM products LIMIT 0, 3;
✔️ For page 2:
🔗 SELECT * FROM products LIMIT 3, 3;
✔️ For page 3:
🔗 SELECT * FROM products LIMIT 6, 3;

🟢  Generic formula for pagination: LIMIT (page_number - 1) * items_per_page, items_per_page

🔄 Common Use Cases
✅ Top 3 most expensive products
🔗 SELECT * FROM products
ORDER BY price DESC
LIMIT 3;

✅ Get 5 random products
🔗 SELECT * FROM products
ORDER BY RAND()
LIMIT 5;

🔄 Performance Considerations
✅ Example of potentially slow query with large offset
🔗 SELECT *
FROM products  ⚡ Note: In real scenario, this would be a much larger table
ORDER BY created_at
LIMIT 1000000, 10;

👉 Better alternative using WHERE clause
🔗 SELECT *
FROM products
WHERE created_at > '2025-01-01 00:00:00'
ORDER BY created_at
LIMIT 10;

🔄 Key Takeaways
✅ LIMIT helps in retrieving a specific number of rows
✅ LIMIT offset, count is used for pagination
✅ Combining ORDER BY with LIMIT is essential for meaningful result sets
✅ Be cautious about performance impacts when using high offset values


🧠 MySQL aliases
Alias are temporary names assigned to database tables, column, or expressions to simplify their use in SQL queries.

🔗 CREATE TABLE employees (
    emp_id INT PRIMARY KEY,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    salary DECIMAL(10,2),
    hire_date DATE
);

🔗 INSERT INTO employees VALUES
    (1, 'John', 'Doe', 60000.00, '2020-01-15'),
    (2, 'Jane', 'Smith', 65000.00, '2019-11-20'),
    (3, 'Mike', 'Johnson', 55000.00, '2021-03-10');


🔗 SELECT * FROM employees;

🔄 Basic column aliases: Creating full name using concatenation
🔗 SELECT 
    CONCAT(first_name, " ", last_name) AS full_name 
FROM employees;

🔗 CREATE TABLE departments (
    dept_id INT PRIMARY KEY,
    dept_name VARCHAR(50),
    location VARCHAR(50)
);

🔗 INSERT INTO departments VALUES
    (1, 'Engineering', 'New York'),
    (2, 'Marketing', 'Los Angeles'),
    (3, 'Finance', 'Chicago');

🔗 ALTER TABLE employees ADD COLUMN department_id INT;     # Add department reference to employees table


🔄 Using table aliases in JOIN operations
🔗 SELECT 
    e.first_name,
    e.last_name,
    d.dept_name 
FROM employees AS e 
JOIN departments AS d 
    ON e.department_id = d.dept_id;

Can be written without as also:
🔗 SELECT 
    e.first_name,
    e.last_name,
    d.dept_name 
FROM employees e 
JOIN departments d 
    ON e.department_id = d.dept_id;

🔄 Using aliases in subqueries
🔗 SELECT avg_salary.average_salary
FROM (
    SELECT AVG(salary) AS average_salary 
    FROM employees
) AS avg_salary;
👉 From this subquery a derived table is created named avg(salary) which is aliased with a name average_salary 
👉 then we are refering as another alias avg_salary derived table average_salary.

🔄 Storing case as alias
🔗 Select first_name,
case
when age<18 then 'Minor'
else 'Adult'
end as age_group
from students;


🧠 Understanding distinct
🔗 CREATE TABLE employees (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50),
    department VARCHAR(50),
    salary DECIMAL(10,2)
);

🔗 INSERT INTO employees (name, department, salary) VALUES
    ('Alice', 'HR', 50000),
    ('Bob', 'Finance', 60000),
    ('Charlie', 'IT', 70000),
    ('Alice', 'HR', 50000),      -- Duplicate record
    ('David', 'Finance', 55000),
    ('Eve', 'IT', 70000),        -- Duplicate salary
    ('Frank', 'HR', 50000);      -- Duplicate department & salary

🔗 SELECT * FROM employees;

✅ Example Using DISTINCT on a single column
🔗 SELECT DISTINCT department FROM employees;      # Get unique departments

✅ Example 2: Using DISTINCT on multiple columns
🔗 SELECT DISTINCT department, salary FROM employees;      #Get unique department-salary combinations

✅ Example 3: Using DISTINCT with aggregate functions
🔗 SELECT COUNT(DISTINCT department) AS unique_departments 
FROM employees;         #Count number of unique departments

✅ Example 4: Using DISTINCT with string functions
🔗 SELECT DISTINCT CONCAT(name, '-', department) 
FROM employees;     #Get unique name-department combinations

✅ Example 5: Using DISTINCT with ORDER BY
🔗 SELECT DISTINCT salary 
FROM employees 
ORDER BY salary DESC;       # Get unique salaries in descending order

✅ Example 6: Using DISTINCT with WHERE clause
🔗 SELECT DISTINCT department 
FROM employees 
WHERE salary > 50000;       #Get unique departments where salary is greater than 50000

🔗 SELECT * FROM employees;

✅Example 7: Handling NULL values with DISTINCT
INSERT INTO employees (name, department, salary) VALUES 
    ('Grace', NULL, 48000),
    ('Bobby', NULL, 48000);     #Insert records with NULL departments

🔗 SELECT DISTINCT department 
FROM employees;     #Show how DISTINCT handles NULL values


🧠 SQL Functions: String, Date, Math & Aggregate
🔄String Functions
🔗 CREATE TABLE employees (
    emp_id INT AUTO_INCREMENT PRIMARY KEY,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    email VARCHAR(100),
    department VARCHAR(50)
);

🔗 INSERT INTO employees (first_name, last_name, email, department) VALUES
('John', 'Doe', 'john.doe@example.com', 'Marketing'),
('Jane', 'Smith', 'jane.smith@example.com', 'Sales'),
('Michael', 'Johnson', 'michael.johnson@example.com', 'IT'),
('Emily', 'Davis', 'emily.davis@example.com', 'HR'),
('Chris', 'Brown', 'chris.brown@example.com', 'Finance');

🔗 SELECT CONCAT(first_name, ' ', last_name) AS full_name FROM employees;      #CONCAT: Combine first and last names into full name


LENGTH: Get the length of the first name
🔗 SELECT first_name, LENGTH(first_name) AS name_length FROM employees;

✔️ UPPER and LOWER: Convert first names to uppercase and lowercase
🔗 SELECT first_name, UPPER(first_name) AS uppercase, LOWER(first_name) AS lowercase FROM employees;

✔️ TRIM: Remove leading and trailing spaces
🔗 SELECT TRIM(UPPER('      ok.   ')) AS trimmed_sample;

✔️ SUBSTRING: Extract the first three characters of first names, 
⚡ substring takes (column_name, start_position, number_of_characters)
🔗 SELECT first_name, SUBSTRING(first_name, 1, 3) AS first_three_chars FROM employees;

✔️ LOCATE: Find the position of first occurance of character 'a' in first names, follows 1-based indexing if not present returns 0
🔗 SELECT first_name, LOCATE('a', first_name) AS position_of_a FROM employees;

✔️ LOCATE: Find the position of characters 'ch' in first names, can pass a substring also gives the starting position of the matching substring
🔗 SELECT first_name, LOCATE('ch', first_name) AS position_of_ch FROM employees;

✔️ REPLACE: Replace domain in email addresses, replace takes (column_name, old_string, new_string)
🔗 SELECT first_name, REPLACE(email, 'example.com', 'amazon.com') AS new_email FROM employees;

✔️ REVERSE: Reverse the characters in first names
🔗 SELECT first_name, REVERSE(first_name) AS reversed_name FROM employees;

✔️ LEFT and RIGHT: Get the first two and last two characters of first names left and right takes two arguments(column_name, number_of_characters) for the extraction
🔗 SELECT first_name, 
       LEFT(first_name, 2) AS first_two, 
       RIGHT(first_name, 2) AS last_two 
FROM employees;

✔️ ASCII: Get ASCII value of the first character in first names (regular and lowercase)
🔗 SELECT first_name, 
       ASCII(first_name) AS ascii_value, 
       ASCII(LOWER(first_name)) AS ascii_lowercase_value 
FROM employees;

🔗 CREATE TABLE products (
    product_id INT PRIMARY KEY,
    product_name VARCHAR(100),
    category VARCHAR(50),
    price DECIMAL(10,2),
    stock_quantity INT,
    last_updated TIMESTAMP
);

🔗 INSERT INTO products VALUES
(1, 'Laptop Pro', 'Electronics', 1299.99, 50, '2024-01-15 10:00:00'),
(2, 'Desk Chair', 'Furniture', 199.99, 30, '2024-01-16 11:30:00'),
(3, 'Coffee Maker', 'Appliances', 79.99, 100, '2024-01-14 09:15:00'),
(4, 'Gaming Mouse', 'Electronics', 59.99, 200, '2024-01-17 14:20:00'),
(5, 'Bookshelf', 'Furniture', 149.99, 25, '2024-01-13 16:45:00');

✔️ FIELD: Order products by category in custom order
🔗 SELECT *, 
       FIELD(category, 'Electronics', 'Appliances', 'Furniture') AS category_order 
FROM products 
ORDER BY FIELD(category, 'Electronics', 'Appliances', 'Furniture') DESC;

✔️ LENGTH vs CHAR_LENGTH: difference with ASCII and multibyte characters
🔗 SELECT LENGTH('hello') AS length_in_bytes;          -- Returns 5 (bytes)
🔗 SELECT LENGTH('こんにちは') AS multibyte_length;      -- Returns 15 because each character is multiple bytes
🔗 SELECT CHAR_LENGTH('hello') AS char_count;          -- Returns 5 (characters)
🔗 SELECT CHAR_LENGTH('こんにちは') AS multibyte_char_count; -- Returns 5 (characters)

✔️ SOUNDEX: Compare phonetically similar strings
🔗 SELECT SOUNDEX('Smith') AS smith_soundex;  -- Returns 'S530'
🔗 SELECT SOUNDEX('Smyth') AS smyth_soundex;  -- Also returns 'S530'
🔗 SELECT SOUNDEX('Robert') AS robert_soundex; -- Returns 'R163'
🔗 SELECT SOUNDEX('Rupert') AS rupert_soundex; -- Also returns 'R163'

✔️ Find employees with names that sound like "Jane"
🔗 SELECT * FROM employees WHERE SOUNDEX('jane') = SOUNDEX(first_name);

🔄 Numeric Functions
🔗 CREATE TABLE numbers (
    id INT AUTO_INCREMENT PRIMARY KEY,
    num_value DECIMAL(10,5)
);

🔗 INSERT INTO numbers (num_value) VALUES
(25.6789),
(-17.5432),
(100.999),
(-0.4567),
(9.5),
(1234.56789),
(0);

✔️ Basic display of all values
🔗 SELECT * FROM numbers;

✔️ Absolute value function
🔗 SELECT num_value, ABS(num_value) AS absolute_value FROM numbers;

✅ Rounding functions
🔗 SELECT num_value, 
       CEIL(num_value) AS rounded_up, 
       FLOOR(num_value) AS rounded_down 
FROM numbers;

🔗 SELECT num_value, ROUND(num_value, 2) AS rounded_2_decimals FROM numbers;
🔗 SELECT num_value, TRUNCATE(num_value, 2) AS truncated_2_decimals FROM numbers;

✅ Mathematical operations
🔗 SELECT num_value, POWER(num_value, 2) AS squared FROM numbers;
🔗 SELECT num_value, MOD(num_value, 3) AS remainder FROM numbers;
🔗 SELECT num_value, SQRT(ABS(num_value)) AS sqrt_value FROM numbers;

✔️ Exponential functions with handling for out-of-range values
🔗 SELECT 
    num_value, 
    CASE 
        WHEN num_value > 709 THEN 'Value too large for EXP()' 
        ELSE EXP(num_value) 
    END AS exp_value 
FROM numbers;

✔️ Logarithmic functions
🔗 SELECT num_value, 
       LOG(2, ABS(num_value) + 1) AS log_base2, 
       LOG10(ABS(num_value) + 1) AS log_base10 
FROM numbers;

✔️ Trigonometric functions
🔗 SELECT num_value, 
       SIN(num_value) AS sin_value, 
       COS(num_value) AS cos_value, 
       TAN(num_value) AS tan_value 
FROM numbers;

✔️ Pi constant and angle conversions
🔗 SELECT PI() AS pi_value;
🔗 SELECT num_value, 
       RADIANS(num_value) AS radians_value, 
       DEGREES(num_value) AS degrees_value 
FROM numbers;

✅ Bitwise operations
🔗 SELECT BIT_AND(num_value) FROM numbers;
🔗 SELECT BIT_OR(num_value) FROM numbers;
🔗 SELECT BIT_XOR(num_value) FROM numbers;

🔄 Date Functions
➤ Date and time data types:
➤ DATE	        YYYY-MM-DD           Stores only date without time
➤ DATETIME     YYYY-MM-DD HH:MI:SS  Stores date and time
➤ TIMESTAMP    YYYY-MM-DD HH:MI:SS  Stores date/time with automatic UTC conversion
➤ TIME         HH:MI:SS             Stores only time
➤ YEAR         YYYY                 Stores only a four-digit year

✅ Current date and time functions
🔗 SELECT NOW() AS current_datetime;
🔗 SELECT CURDATE() AS current_date_value;
🔗 SELECT CURTIME() AS current_time_value;

✅ Date part extraction
🔗 SELECT YEAR(NOW()) AS current_year;
🔗 SELECT MONTH(NOW()) AS current_month;
🔗 SELECT DAY(NOW()) AS current_day;
🔗 SELECT HOUR(NOW()) AS current_hour;
🔗 SELECT MINUTE(NOW()) AS current_minute;
🔗 SELECT SECOND(NOW()) AS current_second;

✅ Date formatting
🔗 SELECT DATE_FORMAT('2025-03-13', '%W, %M %e, %Y') AS formatted_date_long; -- "Thursday, March 13, 2025"
🔗 SELECT DATE_FORMAT('2025-03-13', '%e/%m/%Y') AS formatted_date_short; -- "13/03/2025"

✅ Date arithmetic
🔗 SELECT DATE_ADD('2025-03-13', INTERVAL 7 MONTH) AS date_plus_7_months;
🔗 SELECT DATE_SUB('2025-03-13', INTERVAL 7 MONTH) AS date_minus_7_months;

✅ Date difference
🔗 SELECT DATEDIFF('2025-03-10', '2024-03-03') AS days_between;

✅ Unix timestamp functions (seconds since January 1, 1970, at 00:00:00 UTC)
🔗 SELECT UNIX_TIMESTAMP('2025-03-03') AS unix_time;
🔗 SELECT FROM_UNIXTIME(1741392000) AS readable_date;

✅ Date function examples with a database
CREATE DATABASE DateExamplesDB;
USE DateExamplesDB;

🔗 CREATE TABLE orders (
    order_id INT AUTO_INCREMENT PRIMARY KEY,
    customer_name VARCHAR(100),
    order_date DATETIME
);

🔗 INSERT INTO orders (customer_name, order_date) VALUES
('Alice', '2025-03-01 10:15:00'),
('Bob', '2025-03-02 14:45:30'),
('Charlie', '2025-03-03 09:30:15'),
('Akshay', '2024-03-01 10:15:00');

✔️ Querying orders in the last 7 days
🔗 SELECT * FROM orders WHERE order_date >= DATE_SUB(NOW(), INTERVAL 7 DAY);

🔄 Aggregate Functions
➤ Used to perform calculations on multiple rows of data and return a single summarized value
➤ COUNT() – Returns the number of rows
➤ SUM() – Returns the sum of a numeric column
➤ AVG() – Returns the average value of a numeric column
➤ MIN() – Returns the minimum value
➤ MAX() – Returns the maximum value

🔗 CREATE TABLE employees (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50),
    department VARCHAR(50),
    salary DECIMAL(10,2),
    hire_date DATE
);

🔗 INSERT INTO employees (name, department, salary, hire_date) VALUES
('Alice', 'HR', 50000, '2018-06-23'),
('Bob', 'IT', 70000, '2019-08-01'),
('Charlie', 'Finance', 80000, '2017-04-15'),
('David', 'HR', 55000, '2020-11-30'),
('Eve', 'IT', 75000, '2021-01-25'),
('Frank', 'Finance', 72000, '2019-07-10'),
('Grace', 'IT', 68000, '2018-09-22'),
('Hank', 'Finance', 90000, '2016-12-05'),
('Ivy', 'HR', 53000, '2022-03-19'),
('Jack', 'IT', 72000, '2017-05-12');

✔️ Count employees in HR department
🔗 SELECT COUNT(*) AS hr_employee_count FROM employees WHERE department='HR';

✔️ Sum of salaries in HR department
🔗 SELECT SUM(salary) AS total_hr_salary FROM employees WHERE department='HR';

✔️ Average salary in HR department
🔗 SELECT AVG(salary) AS avg_hr_salary FROM employees WHERE department='HR';

✔️ Minimum salary in HR department
🔗 SELECT MIN(salary) AS min_hr_salary FROM employees WHERE department='HR';

✔️ Maximum salary in HR department
🔗 SELECT MAX(salary) AS max_hr_salary FROM employees WHERE department='HR';

✔️ Comprehensive statistics for all employees
🔗 SELECT 
    COUNT(*) AS num_employees,
    SUM(salary) AS total_salary,
    AVG(salary) AS average_salary,
    MIN(salary) AS lowest_salary,
    MAX(salary) AS highest_salary
FROM employees;

✔️ Group by department to get statistics per department
🔗 SELECT 
    department,
    COUNT(*) AS employee_count,
    SUM(salary) AS department_total_salary,
    ROUND(AVG(salary), 2) AS department_avg_salary,
    MIN(salary) AS department_min_salary,
    MAX(salary) AS department_max_salary
FROM employees
GROUP BY department
ORDER BY department_avg_salary DESC;


🧠 Understanding groupBy Clause
GroupBy clause is used to arrange identical data into groups. It is often used with aggregate functions (like COUNT, SUM, AVG, MAX, MIN) to perform operations on each group of data.

🔗 CREATE TABLE employees (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50),
    department VARCHAR(50),
    salary DECIMAL(10,2),
    joining_date DATE
);

🔗 INSERT INTO employees (name, department, salary, joining_date) VALUES
('Alice', 'HR', 50000, '2020-06-15'),
('Bob', 'HR', 55000, '2019-08-20'),
('Charlie', 'IT', 70000, '2018-03-25'),
('David', 'IT', 72000, '2017-07-10'),
('Eve', 'IT', 73000, '2021-02-15'),
('Frank', 'Finance', 60000, '2020-11-05'),
('Grace', 'Finance', 65000, '2019-05-30'),
('Hannah', 'Finance', 62000, '2021-01-12');

🔗 INSERT INTO employees (name, department, salary, joining_date) VALUES
('Tim', 'HR', 65000, '2019-05-30'),
('Tom', 'IT', 62000, '2021-01-12');

🔗 SELECT * FROM employees;

✅ Example 1: Count Employees in Each Department
🔗 SELECT department, COUNT(*) AS employee_count 
FROM employees 
GROUP BY department;

 ✅ Example 2: Get the Average Sal🔗 ary Per Department
🔗 SELECT department, AVG(salary) AS average_salary 
FROM employees 
GROUP BY department;

 ✅ Example 3: Get the Highest and Lowest Salary Per Department
🔗 SELECT department, MIN(salary) AS lowest_salary, MAX(salary) AS highest_salary 
FROM employees 
GROUP BY department;

 ✅ Example 4: Count Employees Per Department and Joining Year
🔗 SELECT department, YEAR(joining_date) AS joining_year, COUNT(*) AS employee_count 
FROM employees 
GROUP BY joining_year, department;

 ✅ Example 5: Order Departments by the Highest Average Salary
🔗 SELECT department, AVG(salary) AS avg_salary
FROM employees
GROUP BY department
ORDER BY avg_salary DESC;

 ✅ Example 6: Group by Calculated Salary Range
🔗 SELECT 
    CASE 
        WHEN salary < 60000 THEN 'Low Salary'
        WHEN salary BETWEEN 60000 AND 70000 THEN 'Medium Salary'
        ELSE 'High Salary'
    END AS salary_range,
    COUNT(*) AS employee_count
FROM employees 
GROUP BY salary_range;

 ✅ Example 7: Find Department with the Maximum Number of Employees
🔗 SELECT department, COUNT(*) AS total_employees 
FROM employees 
GROUP BY department 
ORDER BY total_employees DESC 
LIMIT 1;

 ✅ Example 8: Find Departments With More Than 2 Employees (With Conditions)
🔗 SELECT 
    department, 
    AVG(salary) AS average_salary, 
    COUNT(*) AS total_employees 
FROM employees 
WHERE joining_date > '2017-07-10' 
GROUP BY department HAVING total_employees > 2 AND average_salary > 55000;


🧠 Understanding Primary Key

🔄 Primary Keys - Key Benefits:
➤ They uniquely identify each record in a table
➤ They ensure no duplicate records exist
➤ They provide a reference point for relationships between tables
➤ They optimize database performance for record retrieval

🔗 CREATE TABLE students (
    student_id INT PRIMARY KEY,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    email VARCHAR(100)
);

🔗 INSERT INTO students (student_id, first_name, last_name, email)
VALUES 
(1, 'John', 'Smith', 'john.smith@example.com'),
(2, 'Maria', 'Garcia', 'maria.garcia@example.com'),
(3, 'Ahmed', 'Khan', 'ahmed.khan@example.com');

✔️ Demonstrating primary key constraint - This will fail
🔗 INSERT INTO students (student_id, first_name, last_name, email)
VALUES (1, 'Jane', 'Doe', 'jane.doe@example.com');
❌ Error Code: 1062. Duplicate entry '1' for key 'PRIMARY'

🔄 Auto-increment Primary Keys
-- Creating a table with an auto-increment primary key
CREATE TABLE products (
    product_id INT AUTO_INCREMENT PRIMARY KEY,
    product_name VARCHAR(100) NOT NULL,
    price DECIMAL(10, 2) NOT NULL,
    description TEXT
);

✔️ With auto-increment, we don't need to specify the primary key value
🔗 INSERT INTO products (product_name, price, description)
VALUES 
('Laptop', 1299.99, 'High-performance laptop'),
('Smartphone', 799.99, 'Latest model smartphone'),
('Headphones', 199.99, 'Noise-cancelling headphones');

🔗 SELECT * FROM products;     # View the auto-generated IDs

🔄 Adding Primary Keys to Existing Tables
✔️ Creating a table with a primary key defined separately
🔗 CREATE TABLE orders (
    order_id INT,
    customer_id INT,
    order_date DATE NOT NULL,
    total_amount DECIMAL(10, 2) NOT NULL,
    PRIMARY KEY (order_id)
);

✔️ Create table without primary key
🔗 CREATE TABLE suppliers (
    supplier_id INT,
    supplier_name VARCHAR(100) NOT NULL,
    contact_person VARCHAR(100)
);

✔️ Adding a primary key to an existing table
🔗 ALTER TABLE suppliers
ADD PRIMARY KEY (supplier_id);

🔄 Composite Primary Keys
✔️Creating a table with a composite primary key (multiple columns)
🔗 CREATE TABLE enrollments (
    student_id INT,
    course_id INT,
    enrollment_date DATE NOT NULL,
    grade VARCHAR(2),
    PRIMARY KEY (student_id, course_id)
);

✔️ Insert records with unique combinations of the composite key
🔗 INSERT INTO enrollments (student_id, course_id, enrollment_date, grade)
VALUES 
(1, 101, '2023-01-15', 'A'),
(1, 102, '2023-01-15', 'B+'),  -- Same student, different course - OK
(2, 101, '2023-01-16', 'A-'),  -- Different student, same course - OK
(3, 103, '2023-01-17', 'B');

✔️ This will fail - duplicate composite key (student_id + course_id)
🔗 INSERT INTO enrollments (student_id, course_id, enrollment_date, grade)
VALUES (1, 101, '2023-02-01', 'C');
-- Error: Duplicate entry '1-101' for key 'PRIMARY'

🔄 Primary Key Best Practices:
➤ Always include a primary key in every table
➤ Use auto-increment unless you have a specific reason not to
➤ Keep primary keys simple - use INT or BIGINT for numeric IDs

When we create a primary key in MySQL, the database engine implements it as a special type of index called a clustered index. 
This means that the data rows in the table are physically organized on disk based on the order of the primary key values. 
This organization allows for efficient retrieval of records based on the primary key, as the database can quickly locate the data without needing to search through all rows.