üî∑ Database and Table Navigation
‚û§ SHOW DATABASES;                 -- Show all databases
‚û§ USE database_name;               -- Use a specific database
‚û§ SHOW TABLES;                     -- Show all tables in the selected database

üî∑ Reading Data from Tables
üåü  Select All Columns
‚û§ SELECT * FROM emplyoee;

Example Output:
| EID | EName | Salary | Cities |
| --- | ----- | ------ | ------ |
| 1   | Ankur | 10000  | BGLR   |
| 2   | Ram   | 20000  | BGLR   |
| 3   | Smith | 5000   | MBI    |
| 4   | Carlo | 2000   | MBI    |
| 5   | Manas | 1000   | LKO    |
| 6   | Ramu  | 15000  | LKO    |

üî∑ Reading Specific Columns
üåü Sometimes you may only need to retrieve certain columns instead of all the data. For example, if you only want to see the EID and EName columns for every employee, you can write:
‚û§ SELECT EID, EName FROM emplyoee;

üî∑ Filtering Records Using WHERE
üåü If you want to fetch the name of the employee whose salary is exactly 10000, you can apply a filter using the WHERE clause as follows:
‚û§ SELECT EName FROM emplyoee WHERE Salary = 10000;

üåü If you wish to retrieve the names of employees whose salary is greater than or equal to 10000, the query will be:
‚û§ SELECT EName FROM emplyoee WHERE Salary >= 10000;

üåü If you want to get the names of employees whose salary is either 5000 or 2000, you can use the IN operator:
‚û§ SELECT EName FROM emplyoee WHERE Salary IN (5000, 2000);

üåü If your goal is to get the employee IDs for those whose names are either Smith or Carlo, you can write:
‚û§ SELECT EID FROM emplyoee WHERE EName IN ('Smith', 'Carlo');

üî∑ Using HAVING for Filtering
üåü The HAVING clause is generally used to filter aggregated data after a GROUP BY operation, but it can also be applied without grouping. For example, if you want to display all employees whose salary is exactly 10000 using HAVING, you can write:
‚û§ SELECT * FROM emplyoee HAVING Salary = 10000;

üåü Similarly, if you need the employee ID for the employee named "Vikram" using HAVING, the query will be:
‚û§ SELECT EID FROM emplyoee HAVING EName = 'Vikram';

üî∑ Sorting Data Using ORDER BY
üåü If you want to see employee IDs sorted in descending order, you can use:
‚û§ SELECT EID FROM emplyoee ORDER BY EID DESC;

üåü To get employee names sorted in descending order alphabetically:
‚û§ SELECT EName FROM emplyoee ORDER BY EName DESC;

üåü And if you need employee IDs sorted in ascending order:
‚û§ SELECT EID FROM emplyoee ORDER BY EID ASC;

üî∑ Using Aggregate Functions
üåü If you want to find the maximum salary among all employees, you can use the MAX() function:
‚û§ SELECT MAX(Salary) FROM emplyoee;

üåü To find the second-highest salary, you can write:
‚û§ SELECT MAX(Salary) 
FROM emplyoee 
WHERE Salary < (SELECT MAX(Salary) FROM emplyoee);

üåü To calculate the average salary of all employees:
‚û§ SELECT AVG(Salary) FROM emplyoee;

üåü If you want to find the total sum of all salaries:
‚û§ SELECT SUM(Salary) FROM emplyoee;

üåü To count the total number of employees:
‚û§ SELECT COUNT(EID) FROM emplyoee;

üî∑ Grouping Records with GROUP BY
üåü If you want to count the number of employees in each city, you can group by the Cities column:
‚û§ SELECT Cities, COUNT(EID) 
FROM emplyoee 
GROUP BY Cities;

üåü If you want to count employees city-wise and then sort them in ascending order of count:
‚û§ SELECT Cities, COUNT(EID) AS EmpCount
FROM emplyoee
GROUP BY Cities
ORDER BY EmpCount ASC;

üåü If you want to count the number of cities and sort them alphabetically:
‚û§ SELECT Cities, COUNT(Cities) 
FROM emplyoee
GROUP BY Cities
ORDER BY Cities ASC;

üåü If you want to group employees by city but only for those in Bangalore (BGLR), you can filter with WHERE first:
‚û§ SELECT COUNT(Cities) 
FROM emplyoee
WHERE Cities = 'BGLR'
GROUP BY Cities;

üî∑ Changing Case of Text
üåü To display all employee names in uppercase, you can use the UCASE() function:
‚û§ SELECT UCASE(EName) FROM emplyoee;

üåü To display them in lowercase, use:
‚û§ SELECT LCASE(EName) FROM emplyoee;

üî∑ Limiting Records with LIMIT()
If you want to get only the top 2 records of the employee table, the correct approach is to first sort the records in ascending order based on the primary key (EID) and then limit the number of rows displayed.
‚û§ SELECT * FROM employee ORDER BY EID ASC LIMIT 2;

üåü If you want to fetch only the first record from the table, you can simply sort in ascending order and limit the output to 1 row.
‚û§ SELECT * FROM employee ORDER BY EID ASC LIMIT 1;

üåü To get the last two records, sort the table in descending order of EID and then limit it to 2 rows.
‚û§ SELECT * FROM employee ORDER BY EID DESC LIMIT 2;

üî∑ Extracting Substrings with MID()
üåü If you want the city column to display only the first three letters of each city name, you can use the MID() function.
‚û§ SELECT MID(Cities, 1, 3) FROM employee;

üî∑ Displaying Current System Time
üåü If you want to print the current system date and time in SQL, you can use the NOW() function.
‚û§ SELECT NOW();

üåü You can also give an alias to the column name so that the output displays as timestamp.
‚û§ SELECT NOW() AS timestamp;

üî∑ Using Column Aliases
üåü If you want to change the column name EName to Name in the output, you can use the AS keyword.
‚û§ SELECT EName AS Name FROM employee;

üî∑ Pattern Matching with Wildcards (LIKE)
üåü If you want to find the employees whose names end with the letter m, you can use the LIKE operator with %.
‚û§ SELECT EName FROM employee WHERE EName LIKE "%m";

üåü If you want employees whose names contain the letter m anywhere in them:
‚û§ SELECT EName FROM employee WHERE EName LIKE "%m%";

üåü If you want to fetch employees whose names start with the letter s:
‚û§ SELECT EName FROM employee WHERE EName LIKE "s%";

üåü If you want to find employee names that have exactly three letters, you can use underscores (_) as wildcards.
‚û§ SELECT EName FROM employee WHERE EName LIKE "___";

üåü If you want names that have exactly three letters and end with m, you can combine conditions.
‚û§ SELECT EName FROM employee WHERE EName LIKE "___" AND EName LIKE "%m";

üî∑ Deleting Records
üåü If you want to delete a record where the employee ID is 101:
‚û§ DELETE FROM employee WHERE EID = 101;

üåü If you want to delete multiple records with IDs 101 and 102:
‚û§ DELETE FROM employee WHERE EID IN (101, 102);

üåü If you want to delete records where the employee name is "Smith":
‚û§ DELETE FROM employee WHERE EName = "Smith";

üåü If you want to remove the entire table structure and data, you can drop the table.
‚û§ DROP TABLE employee;

üî∑ Removing Duplicate Records with DISTINCT
üåü If you want to get all unique city names from the employee table, you can apply the DISTINCT keyword.
‚û§ SELECT DISTINCT Cities FROM employee;

üî∑ Concatenating Columns with CONCAT()
üåü If you want to join employee names and their salaries into one output column:
‚û§ SELECT CONCAT(EName, Salary) FROM employee;

üåü If you want to concatenate the name and salary with an underscore in between:
‚û§ SELECT CONCAT(EName, "_", Salary) FROM employee;
You can also concatenate multiple columns or strings together in one query.

üî∑ Trimming Whitespace with LTRIM(), RTRIM(), and TRIM()
üåü If you want to remove whitespace from the left side of employee names:
‚û§ SELECT LTRIM(EName) FROM employee;

üåü If you want to remove whitespace from both sides of the employee name and salary and then concatenate them with an underscore:
‚û§ SELECT CONCAT(TRIM(EName), "_", TRIM(Salary)) FROM employee;

üåü If you want to concatenate employee name and salary and then display the results in descending order:
‚û§ SELECT CONCAT(EName, Salary) 
FROM employee 
ORDER BY CONCAT(EName, Salary) DESC;

üî∑ Updating Records with UPDATE
üåü If you want to change the name of an employee from "Smith" to "abc":
‚û§ UPDATE employee SET EName = "abc" WHERE EName = "Smith";

üåü If you want to update the employee name where ID is 101:
‚û§ UPDATE employee SET EName = "abc" WHERE EID = 101;

üåü If you want to update the employee ID from 101 to 110:
‚û§ UPDATE employee SET EID = 110 WHERE EID = 101;

üåü If you want to delete all records of employees whose salary is 10000:
‚û§ DELETE FROM employee WHERE Salary = 10000;

üåü If you want to increase everyone‚Äôs salary by 200:
‚û§ UPDATE employee SET Salary = Salary + 200;

üî∑ Altering Table Structure with ALTER TABLE
üåü If you want to add a new column email at the end of the table:
‚û§ ALTER TABLE employee ADD email VARCHAR(50);

üåü If you want to add the email column at the beginning of the table:
‚û§ ALTER TABLE employee ADD email VARCHAR(50) FIRST;

üåü If you want to add the column after the EName column:
‚û§ ALTER TABLE employee ADD email VARCHAR(50) AFTER EName;

üåü If you want to delete the email column from the table:
‚û§ ALTER TABLE employee DROP email;

üî∑ Measuring String Length with LENGTH()
üåü If you want to find the length of each employee‚Äôs name:
‚û§ SELECT LENGTH(EName) FROM employee;


üî∑ MySQL Data Types
MySQL supports 3 major categories of data types:

1. Numeric Data Types
‚û§ INT / INTEGER ‚Üí Stores whole numbers (range: -2,147,483,648 to 2,147,483,647).
‚û§ SMALLINT ‚Üí Smaller range than INT (-32,768 to 32,767).
‚û§ TINYINT ‚Üí Very small numbers (-128 to 127). Commonly used for Boolean flags (0/1).
‚û§ BIGINT ‚Üí Large integers (up to ¬±9.22e18).
‚û§ DECIMAL / NUMERIC (p, s) ‚Üí Fixed-point numbers (p = precision, s = scale). Best for financial data (e.g., DECIMAL(10,2) = 8 digits before decimal + 2 digits after).
‚û§ FLOAT ‚Üí Approximate single-precision floating-point (7 digits).
‚û§ DOUBLE / REAL ‚Üí Approximate double-precision floating-point (15 digits).
‚û§ BIT(M) ‚Üí Stores binary values (M = number of bits, default = 1).

2. Date & Time Data Types
‚û§ DATE ‚Üí Stores date only (YYYY-MM-DD).
‚û§ DATETIME ‚Üí Stores both date & time (YYYY-MM-DD HH:MM:SS).
‚û§ TIMESTAMP ‚Üí Similar to DATETIME but stored in UTC. Auto-updates with current time.
‚û§ TIME ‚Üí Stores only time (HH:MM:SS).
‚û§ YEAR(2 | 4) ‚Üí Stores year (2-digit or 4-digit format).

3. String (Character/Text) Data Types
‚û§ CHAR(n) ‚Üí Fixed-length string (padded with spaces if shorter). Faster but wastes space.
‚û§ VARCHAR(n) ‚Üí Variable-length string (up to 65535 characters depending on row size). Efficient for dynamic text.
‚û§ TEXT ‚Üí Large text (up to 65,535 characters). Types:
      ‚û§ TINYTEXT (255 chars)
      ‚û§ TEXT (65,535 chars)
      ‚û§ MEDIUMTEXT (16 million chars)
      ‚û§ LONGTEXT (4 billion chars)

‚û§ ENUM ‚Üí Stores one value from a predefined list (ENUM('M','F')). Good for fixed categories.‚û§ 
‚û§ SET ‚Üí Stores multiple values from a predefined list.‚û§ 
‚û§ BLOB (Binary Large Object) ‚Üí Used for images, videos, or raw binary data. Types:
      ‚û§ TINYBLOB, BLOB, MEDIUMBLOB, LONGBLOB

üß† Constraints in SQL
Constraints are rules applied to columns or tables to maintain the accuracy, validity, and integrity of data in a database.

‚úÖ Common SQL Constraints:
üß† SQL Constraints with Examples
Each of the following examples uses a new table to demonstrate a specific constraint.

‚úÖ 1. UNIQUE Constraint
Ensures that all values in a column are distinct (no duplicates).
can be NULL also as two null values are considered distinct.
CREATE TABLE student (
    phonenbr INT UNIQUE
);
-- Inserts unique phone numbers
INSERT INTO student VALUES (123), (456);

‚úÖ 2. NOT NULL Constraint
Ensures a column cannot be left empty (NULL values not allowed) but can be duplicates.

CREATE TABLE student1 (
    age INT,
    rollno INT NOT NULL
);
-- Valid: rollno is NOT NULL
INSERT INTO student1 VALUES (23, 123);

‚úÖ 3. CHECK Constraint
Applies a condition that each value in the column must satisfy.

CREATE TABLE student2 (
    age INT CHECK(age > 18)
);
-- Valid: 19 > 18
INSERT INTO student2 VALUES (19);

‚úÖ 4. DEFAULT Constraint
Automatically assigns a default value to a column if no value is specified.

CREATE TABLE student3 (
    schoolName VARCHAR(50) DEFAULT 'RLB',
    age INT
);
-- Only age is given, schoolName will be set to default 'RLB'
INSERT INTO student3 (age) VALUES (23);

-- View inserted data
SELECT * FROM student3;

‚úÖ 5. PRIMARY KEY Constraint
Uniquely identifies each row. It combines UNIQUE + NOT NULL. Only one per table.

CREATE TABLE student4 (
    age INT,
    rollNo INT PRIMARY KEY
);
-- All rollNo values must be unique and not null
INSERT INTO student4 VALUES (12,1), (13,2), (14,3), (15,5), (16,6);

-- View data
SELECT * FROM student4;

‚úÖ 6. FOREIGN KEY Constraint
Establishes a relationship between two tables by referencing the primary key of another table.
Can have multiple foreign keys in a table.

CREATE TABLE course (
    courseName VARCHAR(50),
    rollNo INT,
    FOREIGN KEY (rollNo) REFERENCES student4(rollNo)
);
-- Inserting data with rollNo values that exist in student4
INSERT INTO course VALUES ('DBMS', 1), ('OS', 2);

‚úÖ 7. AUTO_INCREMENT Constraint
‚û§ Automatically generates a unique number for each new row.
‚û§ Works only with integer types and typically on PRIMARY KEY.
Example:

CREATE TABLE students (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50)
);
üîë Use when you need a surrogate key instead of natural key.

‚úÖ 8. ENUM as a Constraint‚û§ 
‚û§ ENUM lets you restrict a column to one value from a predefined list.‚û§ 
‚û§ Acts like a check constraint.

Example:
CREATE TABLE employee (
    emp_id INT PRIMARY KEY,
    gender ENUM('Male', 'Female', 'Other') NOT NULL
);
‚û§ Here, gender can only take one of the listed values.
‚û§ If you try to insert something outside the list ‚Üí MySQL throws an error.

üîë Use case: Limited categorical choices (gender, status, priority).

‚úÖ 9. SET as a Constraint
‚û§ SET lets you store multiple values from a predefined list.

Example:
CREATE TABLE student (
    id INT PRIMARY KEY,
    subjects SET('Math', 'Science', 'English', 'History')
);
‚û§ Here, subjects can be 'Math', 'Science', 'Math,Science', etc.
‚û§ Useful for multi-choice constraints (skills, hobbies, languages).

‚ö†Ô∏è Important Points
‚û§ ENUM & SET behave like constraints because they restrict data, but technically they are data types with built-in validation, not separate constraints.
‚û§ ENUM ‚Üí only one value allowed.
‚û§ SET ‚Üí allows multiple values, stored as a comma-separated string internally.
‚û§ They are not portable (other DBs like PostgreSQL/Oracle don‚Äôt support them directly).
‚û§ Best practice in enterprise apps ‚Üí prefer CHECK constraint or lookup/reference table instead of ENUM/SET (for flexibility).

üëâ So the answer is:
‚úîÔ∏è Yes, ENUM and SET can be used like constraints in MySQL.
‚ùå But they are data types, not formal constraints.

üéØ Problem Definition: Subtracting Two Tables
Suppose we have two tables with the same structure:

TableA
id | name
-----------
1  | Ram
2  | Shyam
3  | Mohan

TableB
id | name
-----------
2  | Shyam
3  | Mohan

We want TableA ‚Äì TableB = records present in A but not in B.
Expected Output:
id | name
-----------
1  | Ram

‚úÖ Methods to Subtract Tables in MySQL
üß† Method 1. Using LEFT JOIN + IS NULL
SELECT a.id, a.name
FROM TableA a
LEFT JOIN TableB b ON a.id = b.id
WHERE b.id IS NULL

üëâ Gives only rows present in TableA and not in TableB.
This is the most common approach in MySQL.

üß† Method 2. Using NOT IN
SELECT id, name
FROM TableA
WHERE id NOT IN (SELECT id FROM TableB);

‚ö†Ô∏è Caveat ‚Üí If TableB.id contains NULL, the whole query may return nothing.
So safer to use NOT EXISTS.

üß† Method 3. Using NOT EXISTS (Preferred)
SELECT id, name
FROM TableA a
WHERE NOT EXISTS (
    SELECT 1 
    FROM TableB b 
    WHERE a.id = b.id
);
‚úîÔ∏è More reliable than NOT IN.
‚úîÔ∏è Works even if NULLs exist.

üß† Method 4. Using UNION and EXCEPT Logic
MySQL doesn‚Äôt support EXCEPT, but we can simulate it:

SELECT id, name FROM TableA
UNION
SELECT id, name FROM TableB
EXCEPT
SELECT id, name FROM TableB;
‚ö†Ô∏è Only works in MySQL 8.0+ with CTE simulation (otherwise not directly).

‚ö°Tip
If asked in MySQL:
Say: "MySQL does not have a direct MINUS operator like Oracle, but we can achieve subtraction using LEFT JOIN ... IS NULL or NOT EXISTS."

Then write the LEFT JOIN query ‚Äî it's the cleanest.

üî∑ JOINS in MySQL
JOINS are used to combine rows from two or more tables based on a related column between them. MySQL supports several types of JOINS:
1. INNER JOIN
2. LEFT JOIN (or LEFT OUTER JOIN)
3. RIGHT JOIN (or RIGHT OUTER JOIN)
4. FULL JOIN (or FULL OUTER JOIN)
5. CROSS JOIN
6. SELF JOIN
7. NATURAL JOIN
