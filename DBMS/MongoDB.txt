ğŸ”· MongoDB
â¤ MongoDB is a NoSQL (non-relational) database
â¤ It stores data in documents instead of tables.
â¤ Each document is a JSON-like object (BSON) â€” flexible, schema-less, and easy to scale.


ğŸ†šDifference Between MySQL and MongoDB
| Feature                | **MySQL (Relational DB)**                      | **MongoDB (Non-relational DB)**                    |
| ---------------------- | ---------------------------------------------- | -------------------------------------------------- |
| **Data Format**        | Tables with rows and columns                   | Collections with JSON-like documents               |
| **Schema**             | Fixed schema (predefined columns)              | Schema-less (fields can vary per document)         |
| **Joins**              | Supports JOIN operations                       | No JOINs (uses embedding or referencing instead)   |
| **Scalability**        | Vertical (add more CPU/RAM to one machine)     | Horizontal (add more servers easily)               |
| **Transactions**       | Strong ACID compliance                         | Supports multi-document transactions (since v4.0)  |
| **Query Language**     | SQL (Structured Query Language)                | MongoDB Query Language (MQL) â€“ JSON-style queries  |
| **Data Relationships** | Uses foreign keys                              | Embeds related data within documents               |
| **Best Use Cases**     | Financial, structured data, strong consistency | Real-time apps, IoT, social media, flexible schema |

ğŸ”· Basic Structural Difference
ğŸ”„ MySQL
Database â†’ Tables â†’ Rows â†’ Columns

âœ… Example:

CREATE TABLE users (
  id INT PRIMARY KEY,
  name VARCHAR(50),
  email VARCHAR(100)
);

Data:
| id | name  | email                                     |
| -- | ----- | ----------------------------------------- |
| 1  | Ankur | [ankur@gmail.com](mailto:ankur@gmail.com) |

ğŸ”„ MongoDB
Database â†’ Collections â†’ Documents â†’ Fields

âœ… Example: JSON format
{
  "_id": 1,
  "name": "Ankur",
  "email": "ankur@gmail.com"
}

ğŸ”„Structure of MongoDB Database
MongoDB structure hierarchy:
MongoDB Server
    â””â”€â”€ Database
          â””â”€â”€ Collection
                â””â”€â”€ Documents
                      â””â”€â”€ Fields (Key-Value pairs)

ğŸ”„ JSON to BSON Conversion
â¤ MongoDB internally stores documents in BSON (Binary JSON) â€” a binary-encoded version of JSON.
â¤ BSON allows:
    âœ”ï¸ More data types (e.g., Date, ObjectId, Decimal128)
    âœ”ï¸ Faster traversal and storage
    âœ”ï¸ Efficient indexing

âš¡ To start sevice on MongoDB shell: mongodb://localhost:27017/


ğŸ”·  Create Database in MongoDB
ğŸ”— show dbs  â†’  Display all databases
ğŸ”— use <database_name> â†’ Switch to a specific database if does not exist it will create one
ğŸ”— db.collection_name â†’ Create a collection in the current database if does not exist

âœ…Example db.students.insertOne({
    "name": "Ankur",
    "email": "ankur@gmail.com"
});

ğŸ”— db.collecction_name.find() â†’ Return all documents in a collection

ğŸ”„ Update Database
db.students.updateOne({ "name": "Ankur" }, { $set: {idCards:{hasPanCard:false, hasAadharCard:true}} });

âœ… Output: 
acknowleged: true,
insertedId: null,
matchedCount: 1, 
modifiedCount: 1, 
upsertedCount: 0

âš¡ Max size of a document in MongoDB is 16MB.

ğŸ”„ updating many documents at once
âœ… Example:
db.students.updateMany({},{$set:{hobbies:["Anime","Coding","Cooking"]}});
âœ… Output:
acknowleged: true,
insertedId: null,
matchedCount: 3,
modifiedCount: 3,
upsertedCount: 0

ğŸ”„ Searching in db
âœ…Example: db.students.find({hobbies:"Anime"});  â†’  Even though hobbies is list of hobbies it will return all the documents having Anime as one of their hobbies

ğŸ‘‰ can count also:
âœ…Example: db.students.find({hobbies:"Anime"}).count();

ğŸ”„ Searching Nested documents
âœ…Example: db.students.find({'idCards.hasPanCard':true});
âœ… Output: will give the documents having hasPanCard as true
 
ğŸ”· CRUD Operations in MongoDB
1ï¸âƒ£ Create
    âœ”ï¸ insertOne(data, options)
    âœ”ï¸ insertMany(data, options)  â†’ we have to provide an array of documents

âœ… Example :
ğŸ”— db.collection_name.insertOne({
    "name": "Ankur",
    "email": "ankur@gmail.com"
});

ğŸ”— db.collection_name.insertMany([
    {
        "name": "Ankur",
        "email": "ankur@gmail.com"
    },
    {
        "name": "Ankur",
        "email": "ankur@gmail.com"
    }
]);

2ï¸âƒ£ Read
    âœ”ï¸ find(filter, options)
    âœ”ï¸ findOne(filter, options)
    âœ”ï¸ count(filter, options)

âœ…Example:
ğŸ”— db.collection.find({name:"Ankur"}); return a list or pointer  on which/ through which  we can iterate on the result, if not found does not return anything
So we can do something like db.students.find().forEach((x)=>{}) --> similar to JavaScript
ğŸ”— db.collection.findOne({name:"Ankur"}); return single document if not found return null 
ğŸ”— db.collection.find({name:"Ankur"}).count();

ğŸ”„ Conditional Searching:
âœ…Example:
ğŸ”— db.collection.find({age:{$lte:12}});
ğŸ”— db.collection.find({age:{$gte:12}});
ğŸ”— db.collection.find({age:{$lt:12}});
ğŸ”— db.collection.find({age:{$gt:12}});


3ï¸âƒ£ Update
    âœ”ï¸ updateOne(filter, updateData, options)
    âœ”ï¸ updateMany(filter, updateData, options)
    âœ”ï¸ replaceOne(filter, updateData, options)
âœ…Example:
ğŸ”— db.students.updateOne({ "name": "Ankur" }, { $set: {idCards:{hasPanCard:false, hasAadharCard:true}} });

ğŸ”— db.students.updateMany({},{$set:{hobbies:["Anime","Coding","Cooking"]}});

4ï¸âƒ£ Delete
    âœ”ï¸ deleteOne(filter, options)
    âœ”ï¸ deleteMany(filter, options)

âœ…Example:
ğŸ”— db.collection.deleteOne({name:"Ankur"});
ğŸ”— db.collection.deleteMany({name:"Ankur"});

ğŸ”— db.collecti on.deleteMany({}); â†’ delete all the documents in a collection

ğŸ”· Select Column query (Projection in MongoDB)
âœ…Example:
ğŸ”— db.collection.find({},{name:1,email:1}); â†’ will return only name and email columns
ğŸ”— db.collection.find({},{name:1}); â†’ will return only name column 
Returns only the required field along with the id as id is a default field and always inclusive

ğŸ”· Is MongoDB Schemaless â“
âœ… MongoDB is Schema-less by Nature
But âš ï¸ not schema-free in practice.

â¤ MongoDB does not require you to define a fixed schema (like MySQL tables do).
â¤ You can insert documents with different fields into the same collection.

âœ… Example:
ğŸ”— db.students.insertOne({ name: "Ankur", age: 22 });
ğŸ”— db.students.insertOne({ name: "Riya", branch: "IT", city: "Delhi" });

âœ… Both documents are valid â€” even though their fields are different.
Thatâ€™s why MongoDB is often called schema-less.

ğŸ§© However â€” It Can Have a Schema
MongoDB allows optional schema validation using JSON Schema Validators.
You can enforce structure if your application needs it.

âœ… Example:
ğŸ”— db.createCollection("students", {
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["name", "age"],
      properties: {
        name: { bsonType: "string" },
        age: { bsonType: "int" }
      }
    }
  }
});

Now MongoDB will reject documents that donâ€™t follow this schema.

ğŸ”„ Schema-less vs Schema-enforced
| Aspect                | Description                                              |
| --------------------- | -------------------------------------------------------- |
| **Default behavior**  | Schema-less (no enforced structure)                      |
| **Possible behavior** | Schema-enforced (using validators or ORMs like Mongoose) |
| **Developer control** | You decide whether to enforce or keep it flexible        |

ğŸ”· Common MongoDB Data Types
| **Data Type**                  | **Description**                                    | **Example**                                       |
| ------------------------------ | -------------------------------------------------- | ------------------------------------------------- |
| **String**                     | Stores text data                                   | `{ name: "Ankur" }`                               |
| **Number / Int32**             | 32-bit integer                                     | `{ age: 22 }`                                     |
| **Long / Int64**               | 64-bit integer (for large values)                  | `{ phone: NumberLong(9876543210) }`               |
| **Double**                     | 64-bit floating point                              | `{ marks: 88.5 }`                                 |
| **Decimal128**                 | High-precision decimal (for financial data)        | `{ amount: NumberDecimal("1234.5678") }`          |
| **Boolean**                    | True/False values                                  | `{ isActive: true }`                              |
| **Date**                       | Stores date and time (in UTC)                      | `{ joinedAt: new Date() }`                        |
| **Timestamp**                  | Internal timestamp for operations                  | `{ createdAt: new Timestamp() }`                      |
| **ObjectId**                   | Unique 12-byte ID automatically created by MongoDB | `{ _id: ObjectId("64a0b2f4c2...") }`              |
| **Array**                      | Stores list of values                              | `{ skills: ["JavaScript", "Node.js"] }`           |
| **Object / Embedded Document** | Nested document inside another                     | `{ address: { city: "Delhi", pincode: 110001 } }` |
| **Binary Data**                | Stores binary (e.g., image, file)                  | `{ file: BinData(0, "base64string") }`            |
| **Null**                       | Represents null or missing value                   | `{ middleName: null }`                            |
| **Regular Expression**         | For pattern matching                               | `{ name: /Ank/i }`                                |
| **JavaScript (Code)**          | Stores JavaScript code snippets                    | `{ calc: function() { return 5 + 2 } }`           |
| **MinKey / MaxKey**            | Used for comparison operations                     | `{ value: MinKey }`                               |

ğŸ”„ Numeric Type Details
| Type             | Size     | Range              | Usage                      |
| ---------------- | -------- | ------------------ | -------------------------- |
| **Int32**        | 4 bytes  | âˆ’2Â³Â¹ to 2Â³Â¹âˆ’1      | Regular integers           |
| **Int64 (Long)** | 8 bytes  | Very large numbers | Timestamps, large counters |
| **Double**       | 8 bytes  | IEEE 754 standard  | Decimal values             |
| **Decimal128**   | 16 bytes | High precision     | Finance, currency          |

âš¡ can use typeof to check the datatype of a field
ğŸ”— typeof db.companyData.findOne().name


ğŸ”· Delete Database in MongoDB
ğŸ”— db.dropDatabase(); delete the whole database along with all the collections present inside it
ğŸ”— dp.products.drop(); delete only the products collection


ğŸ”· Ordered Options in insert Commmand
When you insert multiple documents at once in MongoDB (using insertMany() or insert()),
you can control whether MongoDB stops on the first error or continues inserting the rest.

ğŸ”„ ğŸ”„ Syntax:
db.collection.insertMany(
  [ <document1>, <document2>, ... ],
  { ordered: <boolean> }
)

ğŸ”„ Option Explanation
| Option                        | Behavior                                                                 |
| ----------------------------- | ------------------------------------------------------------------------ |
| **`ordered: true` (default)** | Stops inserting when the **first error** occurs (e.g., duplicate `_id`). |
| **`ordered: false`**          | Continues inserting the remaining documents even if one fails.           |

âœ… Example 1: Ordered = true (Default)
ğŸ”— db.students.insertMany(
  [
    { _id: 1, name: "Ankur" },
    { _id: 2, name: "Riya" },
    { _id: 1, name: "Sohan" }  // duplicate _id
  ],
  { ordered: true }
);

ğŸ”„ Result:
â¤ MongoDB inserts {_id:1} and {_id:2} successfully.
â¤ When it reaches the duplicate _id:1, it throws an error and stops.
â¤ The third document is not inserted.

âœ… Example 2: Ordered = false
ğŸ”— db.students.insertMany(
  [
    { _id: 1, name: "Ankur" },
    { _id: 2, name: "Riya" },
    { _id: 1, name: "Sohan" }  // duplicate _id
  ],
  { ordered: false }
);

ğŸ”„ Result:
â¤ MongoDB inserts documents with _id:1 and _id:2.
â¤ Encounters an error at the duplicate _id:1, but continues.
â¤ Other valid documents after the error are still inserted successfully.

ğŸ”„ Why It Matters
â¤ ordered: true â†’ ensures data integrity (good for critical transactions).
â¤ ordered: false â†’ ensures performance and partial success (useful for bulk inserts where some failures are acceptable).


ğŸ”· Schema Validation in MongoDB 
â¤ By default, MongoDB is schema-less â€” it allows documents with any structure in a collection.
â¤ However, Schema Validation lets you enforce rules or structure on documents using JSON Schema.
âœ… This ensures data consistency and prevents invalid data from being inserted or updated.

ğŸ”„ How It Works
â¤ MongoDB uses the $jsonSchema operator inside a validator when creating or modifying a collection.
â¤ You define:
    âœ”ï¸ required fields
    âœ”ï¸ data types (bsonType)
    âœ”ï¸ nested objects and arrays
    âœ”ï¸ constraints like minimum, maximum, pattern, etc.

ğŸ”„ Basic Syntax
ğŸ”— db.createCollection("students", {
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["name", "age"],
      properties: {
        name: { bsonType: "string", description: "must be a string" },
        age: { bsonType: "int", minimum: 18, description: "must be at least 18" },
        branch: { bsonType: "string" }
      }
    }
  },
  validationLevel: "strict",
  validationAction: "error" or "warn" error is by Default
});

ğŸ”„ Important Options
| Option                 | Description
| `validationLevel       | Controls how strictly MongoDB applies validation.
                           `"strict"` â†’ all inserts and updates are validated. 
                           `"moderate"` â†’ only newly inserted or modified documents are validated.|
| `validationAction      | Determines what happens when validation fails.
                           `"error"` â†’ rejects invalid documents.
                           `"warn"` â†’ logs a warning but allows insertion.|

Example: Valid vs Invalid Inserts
âœ… Valid Document:
ğŸ”— db.students.insertOne({ name: "Ankur", age: 22, branch: "IT" });

âŒ Invalid Document:
ğŸ”— db.students.insertOne({ name: "Riya", age: "twenty-two" });
ğŸ‘‰ Error: Document failed validation (because age must be an integer).

ğŸ”„ Updating Schema for Existing Collection
You can add validation to an existing collection using:
ğŸ”— db.runCommand({
  collMod: "students", tells which collection you want to modify
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["name", "age"],
      properties: {
        name: { bsonType: "string" },
        age: { bsonType: "int", minimum: 18 }
      }
    }
  },
  validationLevel: "strict",
  validationAction: "error"
});

âœ… Example with Nested Object Validation
ğŸ”— db.createCollection("employees", {
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["name", "price", "authors],
      properties: {
        name: { bsonType: "string" 
                description: "must be a string" },
        },
        price:{
            bsonType: "int",
            minimum: 110,
            description: "must be a positive number"
        }
        authors:{
            bsonType: "array",
            minItems: 1,
            items: {
            bsonType: "object",
            required: ["firstName", "lastName"],
            properties: {
                firstName: { bsonType: "string" },
                lastName: { bsonType: "string" }
            }
        }
        }
      }
    }
  },
  validationLevel: "strict",
  validationAction: "error"
);


ğŸ”· Write Concern in MongoDB
Write Concern defines how strictly MongoDB acknowledges write operations (insert, update, delete) â€”
i.e., how many replicas/nodes must confirm the write before the client considers it successful.

It controls data durability and acknowledgment level of a write.

ğŸ”„ Why It Matters
â¤ Different write concerns let you trade off between:
    âœ”ï¸ Performance (speed)
    âœ”ï¸ Reliability (data safety)
â¤ If you want fast writes â†’ lower write concern
â¤ If you want guaranteed persistence â†’ higher write concern

ğŸ”„ Syntax
You can set write concern at:
    âœ”ï¸ Collection level
    âœ”ï¸ Database level
    âœ”ï¸ Per operation

âœ… Example:
ğŸ”— db.students.insertOne(
  { name: "Ankur", age: 22 },
  { writeConcern: { w: 1 } }
);

ğŸ”„ Write Concern Parameters
| Option         | Description                                                       |
| -------------- | ----------------------------------------------------------------- |
| **`w`**        | The number of nodes that must acknowledge the write.              |
| **`j`**        | If `true`, the write must be committed to the **journal** (disk). |
| **`wtimeout`** | Maximum time (ms) to wait for acknowledgment before timing out.   |

ğŸ”„ Values for w Parameter
| Value          | Meaning                                             | Durability             |
| -------------- | --------------------------------------------------- | ---------------------- |
| **0**          | Fire-and-forget (no acknowledgment)                 | âš¡ Fastest, âŒ Unsafe    |
| **1**          | Acknowledged by **primary** only                    | âœ… Safe enough for most |
| **majority**   | Acknowledged by **majority of replica set members** | ğŸ”’ Most reliable       |
| **n** (number) | Acknowledged by **n nodes**                         | Depends on setup       |

âœ… Examples:
ğŸ”„ Fire-and-forget (w:0)
db.logs.insertOne(
  { msg: "test log" },
  { writeConcern: { w: 0 } }
);
ğŸ‘‰MongoDB does not wait for acknowledgment. Fast, but risky.

ğŸ”„ Acknowledged by Primary (w:1)
db.users.insertOne(
  { name: "Ankur" },
  { writeConcern: { w: 1 } }
);
ğŸ‘‰MongoDB waits for the primary to confirm the write.

ğŸ”„ Majority Acknowledgment
db.orders.insertOne(
  { item: "Laptop", qty: 2 },
  { writeConcern: { w: "majority", j: true, wtimeout: 5000 } }
);
ğŸ‘‰MongoDB waits until the write is:
    âœ”ï¸ replicated to the majority of nodes
    âœ”ï¸ written to the journal
    âœ”ï¸ within 5 seconds timeout

âš¡ Default Write Concern
â¤ Default is usually { w: 1 } (acknowledged by primary).
â¤ Can be configured at the replica set or database level.

âš¡ Atomicity is achieved at document level in mongodb


ğŸ”· MongoImport in MongoDB
â¤ mongoimport is a command-line tool used to import data into a MongoDB collection from files like JSON, CSV, or TSV.
â¤ It helps you load bulk data into MongoDB â€” for example, from external systems, backups, or exported datasets.

ğŸ”„ Syntax
mongoimport --db <database> --collection <collection> --file <path-to-file> [options]

âœ… Example Commands
1ï¸âƒ£ Import a JSON file
mongoimport --db school --collection students --file students.json --jsonArray

    âœ”ï¸ --db school â†’ Database name
    âœ”ï¸ --collection students â†’ Collection name
    âœ”ï¸ --file students.json â†’ Input file path
    âœ”ï¸ --jsonArray â†’ Indicates that the JSON file contains an array of documents

2ï¸âƒ£ Import a CSV file
mongoimport --db school --collection students --type csv --headerline --file students.csv
    âœ”ï¸ --type csv â†’ File type is CSV
    âœ”ï¸ --headerline â†’ Uses first line of file as field names
    âœ”ï¸ --file students.csv â†’ Input file path

ğŸ”„ Useful Options
| Option         | Description                                               |
| -------------- | --------------------------------------------------------- |
| `--db`         | Specifies the database name                               |
| `--collection` | Target collection name                                    |
| `--file`       | Input data file path                                      |
| `--jsonArray`  | Treats JSON as an array of documents                      |
| `--type`       | Type of file (`json`, `csv`, `tsv`)                       |
| `--drop`       | Drops the collection before importing new data            |
| `--upsert`     | Updates existing docs if `_id` matches, else inserts      |
| `--uri`        | Allows importing to a remote MongoDB using connection URI |
   
âœ… Example: Using URI and Drop
mongoimport --uri "mongodb+srv://ankur:password@cluster.mongodb.net/school" \
--collection students --drop --file students.json --jsonArray
ğŸ‘‰ Drops the existing students collection and imports fresh data from students.json.

ğŸ”· Comparison Operator 
| Operator | Description                | Example                            |
| -------- | -------------------------- | ---------------------------------- |
| `$eq`    | Equal to                   | `{ age: { $eq: 25 } }` â†’ age = 25  |
| `$ne`    | Not equal to               | `{ age: { $ne: 25 } }` â†’ age â‰  25  |
| `$gt`    | Greater than               | `{ age: { $gt: 25 } }` â†’ age > 25  |
| `$gte`   | Greater than or equal to   | `{ age: { $gte: 25 } }` â†’ age â‰¥ 25 |
| `$lt`    | Less than                  | `{ age: { $lt: 25 } }` â†’ age < 25  |
| `$lte`   | Less than or equal to      | `{ age: { $lte: 25 } }` â†’ age â‰¤ 25 |
| `$in`    | Matches any value in array | `{ age: { $in: [20, 25, 30] } }`   |
| `$nin`   | Not in array               | `{ age: { $nin: [20, 25, 30] } }`  |

âœ… Example Query
1ï¸âƒ£ Find all students with marks greater than 80:
ğŸ”— db.students.find({ marks: { $gt: 80 } })

2ï¸âƒ£ Find students whose city is either "Delhi" or "Mumbai":
ğŸ”— db.students.find({ city: { $in: ["Delhi", "Mumbai"] } })

3ï¸âƒ£ Find students whose age is not equal to 18:
ğŸ”— db.students.find({ age: { $ne: 18 } })

ğŸ”· Logical Operator
| Operator | Description                    | Example                                      |
| -------- | ------------------------------ | -------------------------------------------- |
| `$and`   | Matches all conditions         | `{ $and: [{ age: 20 }, { city: "Delhi" }] }` |
| `$or`    | Matches any condition          | `{ $or: [{ age: 20 }, { city: "Delhi" }] }`  |
| `$not`   | Negates a condition            | `{ marks: { $not: { $gt: 80 } } }`           |
| `$nor`   | Matches none of the conditions | `{ $nor: [{ age: 20 }, { city: "Delhi" }] }` |


ğŸ”· Element Query Operators
1ï¸âƒ£ $exists â†’ Checks if a Field Exists
Returns documents where a specified field exists or not.

ğŸ”„ ğŸ”„ Syntax:
{ field: { $exists: <boolean> } }

âœ… Example 1:
Find students who have the field marks:
db.students.find({ marks: { $exists: true } })

âœ… Example 2:
Find students who donâ€™t have the field email:
db.students.find({ email: { $exists: false } })


2ï¸âƒ£ $type â†’ Checks the Data Type of a Field
Returns documents where the field is of the specified BSON type.

ğŸ”„ ğŸ”„ Syntax:
{ field: { $type: <BSON type number or alias> } }

âœ… Example 1:
Find documents where age is a number:
db.students.find({ age: { $type: "number" } })

âœ… Example 2:
Find documents where name is a string:
db.students.find({ name: { $type: "string" } })

âœ… Example 3 (using type code):
db.students.find({ marks: { $type: 16 } }) // 16 = int

ğŸ”„ Common BSON Type Aliases
| Alias     | Type Code | Description       |
| --------- | --------- | ----------------- |
| `double`  | 1         | Floating-point    |
| `string`  | 2         | String            |
| `object`  | 3         | Embedded document |
| `array`   | 4         | Array             |
| `binData` | 5         | Binary data       |
| `bool`    | 8         | Boolean           |
| `date`    | 9         | Date              |
| `null`    | 10        | Null              |
| `int`     | 16        | 32-bit integer    |
| `long`    | 18        | 64-bit integer    |
| `decimal` | 19        | Decimal128        |

ğŸ”· Evaluation Query Operators
Evaluation operators are used to perform custom evaluations â€” such as regular expressions, text search, JavaScript expressions, or mathematical checks â€” inside queries.

1ï¸âƒ£ $regex â†’ Pattern Matching (Regular Expression)
Used to search for a pattern in string fields (similar to LIKE in SQL).
ğŸ”„ Syntax:
{ field: { $regex: /pattern/, $options: 'i' } }

âœ… Examples:
ğŸ”— db.students.find({ name: { $regex: /^A/ } })       // Starts with A
ğŸ”— db.students.find({ name: { $regex: /verma/i } })   // Case-insensitive match
âœ”ï¸ $options: 'i' â†’ Case insensitive
âœ”ï¸ $options: 'm' â†’ Multiline match


2ï¸âƒ£ $expr â†’ Use Aggregation Expressions in Queries
Allows using aggregation expressions (like $add, $gt, $eq, etc.) directly in the find() query.

âœ… Example:
ğŸ”— db.students.find({
  $expr: { $gt: ["$marks", "$attendance"] }
})
â¡ï¸ Finds documents where marks > attendance.


3ï¸âƒ£ $mod â†’ Modulus (Remainder) Condition
Selects documents where the field value divided by a divisor has a specific remainder.
ğŸ”„ Syntax:
{ field: { $mod: [divisor, remainder] } }

âœ… Example:
ğŸ”— db.students.find({ rollNo: { $mod: [2, 0] } })
â¡ï¸ Finds students with even roll numbers.


4ï¸âƒ£ $text â†’ Full-Text Search
Searches text content in fields that have a text index.

âœ”ï¸ Create a text index first:
ğŸ”— db.articles.createIndex({ content: "text" })

âœ”ï¸ Search for documents:
ğŸ”— db.articles.find({ $text: { $search: "mongodb" } })

âœ”ï¸ Advanced options:
ğŸ”— db.articles.find({ $text: { $search: "mongodb database" } })
ğŸ”— db.articles.find({ $text: { $search: "\"exact phrase\"" } })


5ï¸âƒ£ $where â†’ JavaScript Expression Evaluation (âš ï¸ Slow)
Allows using a custom JavaScript condition for complex logic.

âœ… Example:
ğŸ”— db.students.find({
  $where: "this.marks + this.attendance > 150"
})
âš ï¸ Not recommended for production â€” slower and less secure.


ğŸ”· Querying Arrays in MongoDB
In MongoDB, arrays are first-class data types â€” you can store, query, and update them directly.

1ï¸âƒ£ Match Array Exactly
Matches a document where the array field exactly equals the specified array (order & elements both must match).

ğŸ”— db.students.find({ subjects: ["Math", "Science"] })
ğŸ‘‰ Matches documents with subjects exactly equal to ["Math", "Science"].


2ï¸âƒ£ Match If Array Contains a Specific Value
Matches if the array contains at least one specified element.

ğŸ”— db.students.find({ subjects: "Math" })
ğŸ‘‰ Finds all students having "Math" in the subjects array.

âœ… Example document:
{ name: "Ankur", subjects: ["Math", "Science", "English"] }
ğŸ‘‰ This will match because "Math" exists inside the array.


3ï¸âƒ£ Using Comparison Operators Inside Arrays
You can use $gt, $lt, $eq, etc. to match array elements.

ğŸ”— db.students.find({ marks: { $gt: 80 } })
ğŸ‘‰ Matches documents where any element in the marks array is greater than 80.

4ï¸âƒ£ $all â†’ Match All Values in Array
Checks if the array contains all specified elements (order doesnâ€™t matter).

ğŸ”— db.students.find({ subjects: { $all: ["Math", "Science"] } })
ğŸ‘‰ Finds students having both "Math" and "Science" in their subjects array.

5ï¸âƒ£ $elemMatch â†’ Match Based on Multiple Conditions in a Single Element
Used when an array of objects is present and you want to match conditions on the same element.

âœ… Example document:
{
  name: "Ankur",
  scores: [
    { subject: "Math", marks: 90 },
    { subject: "Science", marks: 80 }
  ]
}

âœ… Query:
ğŸ”— db.students.find({
  scores: { $elemMatch: { subject: "Math", marks: { $gt: 85 } } }
})
ğŸ‘‰ Matches if there is at least one element with subject = "Math" and marks > 85.

6ï¸âƒ£ $size â†’ Match Array Length
Matches documents based on number of elements in the array.

ğŸ”— db.students.find({ subjects: { $size: 3 } })
Finds documents where the subjects array has exactly 3 elements.


7ï¸âƒ£ Access Elements by Index
Use dot notation with index to query a specific element.

ğŸ”— db.students.find({ "marks.0": 100 })
ğŸ‘‰ Finds documents where the first element of marks array is 100.


ğŸ”· Sorting in MongoDB
Sorting in MongoDB is done using the .sort() method, which arranges documents in ascending or descending order based on one or more fields â€” similar to ORDER BY in SQL.

ğŸ”„ Syntax
ğŸ”— db.collection.find().sort({ field: <order> })
<order> â†’ 1 for ascending, -1 for descending.

1ï¸âƒ£ Sort by One Field
ğŸ”— db.students.find().sort({ age: 1 })
ğŸ‘‰ Sorts students by age in ascending order (smallest â†’ largest).

ğŸ”— db.students.find().sort({ age: -1 })
ğŸ‘‰ Sorts by age in descending order (largest â†’ smallest).

2ï¸âƒ£ Sort by Multiple Fields
If two documents have the same value for the first field, MongoDB uses the second field to break the tie.

ğŸ”— db.students.find().sort({ age: 1, name: -1 })
ğŸ‘‰ Sorts first by age ascending, and within the same age, by name descending.

3ï¸âƒ£ Sort with Limit
You can combine .sort() with .limit() to get top results.

ğŸ”— db.students.find().sort({ marks: -1 }).limit(5)
ğŸ‘‰ Returns top 5 students with the highest marks.

4ï¸âƒ£ Sorting in Aggregation
You can also sort inside an aggregation pipeline using $sort.

ğŸ”— db.students.aggregate([
  { $sort: { marks: -1, name: 1 } }
])

5ï¸âƒ£ Sorting on Embedded Fields
Use dot notation to sort by a field inside an embedded document.

âœ… Example document:
{ name: "Ankur", address: { city: "Delhi", pincode: 110001 } }

Query:
ğŸ”— db.students.find().sort({ "address.city": 1 })


ğŸ”· Advanced Update Operators in MongoDB
MongoDB provides several update operators to modify document fields dynamically â€” without replacing the entire document.

1ï¸âƒ£ $inc â†’ Increment / Decrement a Field
Used to increase or decrease numeric values.

ğŸ”— db.students.updateOne(
  { name: "Ankur" },
  { $inc: { marks: 10, attendance: -2 } }
)
ğŸ‘‰ Increases marks by 10 and decreases attendance by 2.

2ï¸âƒ£ $mul â†’ Multiply a Field
Used to multiply numeric values.

ğŸ”— db.students.updateOne(
  { name: "Ankur" },
  { $mul: { marks: 2, attendance: 2 } }
)
ğŸ‘‰ Multiplies marks by 2 and attendance by 2.

3ï¸âƒ£ $min â†’ Update Only if New Value is Smaller
Replaces the field only if the new value is less than the current one.

ğŸ”— db.students.updateOne(
  { name: "Ankur" },
  { $min: { marks: 80 } }
)
ğŸ‘‰ Updates marks to 80 only if the current marks are greater than 80.

4ï¸âƒ£ $max â†’ Update Only if New Value is Greater
Replaces the field only if the new value is greater than the current one.

ğŸ”— db.students.updateOne(
  { name: "Ankur" },
  { $max: { marks: 90 } }
)
ğŸ‘‰ Updates marks to 90 only if the current marks are less than 90.

8ï¸âƒ£ $unset â†’ Remove a Field
Deletes a field from the document.

ğŸ”— db.students.updateOne(
  { name: "Ankur" },
  { $unset: { address: "" } }
)
ğŸ‘‰ Removes the address field from the document.

6ï¸âƒ£ $rename â†’ Rename a Field
Changes the name of a field.

ğŸ”— db.students.updateOne(
  { name: "Ankur" },
  { $rename: { "fullname": "name" } }
)
ğŸ‘‰ Renames field fullname to name.

7ï¸âƒ£ Upsert â†’ Insert if Document Doesnâ€™t Exist
If no matching document is found, MongoDB creates a new one instead of skipping the update.

ğŸ”„ Syntax:
ğŸ”— db.students.updateOne(
  { name: "Rohit" },
  { $set: { marks: 80, city: "Delhi" } },
  { upsert: true }
)
ğŸ‘‰ If Rohit exists â†’ updates it.
ğŸ‘‰ If not â†’ inserts a new document with those fields.

ğŸ”· Update Nested Arrays
ğŸ”„ Sample document
{
  _id: 1,
  name: "Ankur",
  comments: [
    { id: 1, text: "great", likes: 2 },
    { id: 2, text: "nice", likes: 5 }
  ],
  tags: ["mongodb", "db"],
  scores: [10, 20, 30]
}

1ï¸âƒ£ $push â€” add an element (or many) to an array
Basic:
ğŸ”— db.posts.updateOne(
  { _id: 1 },
  { $push: { tags: "database" } }
);

Add multiple elements with ordering/slicing:
ğŸ”— db.posts.updateOne(
  { _id: 1 },
  {
    $push: {
      tags: {
        $each: ["ops", "nosql"],
        $position: 0,     // insert at start
        $slice: -5,       // keep last 5 elements
        $sort: 1          // sort elements after insertion (1 asc, -1 desc)
      }
    }
  }
);

2ï¸âƒ£ $addToSet â€” add only if not already present (no duplicates)
ğŸ”— db.posts.updateOne(
  { _id: 1 },
  { $addToSet: { tags: "mongodb" } }  // won't add if "mongodb" exists
);

Add multiple unique values:
ğŸ”— db.posts.updateOne(
  { _id: 1 },
  { $addToSet: { tags: { $each: ["scaling", "sharding"] } } }
);

3ï¸âƒ£ $pull â€” remove elements that match a condition
Remove scalar value:

ğŸ”— db.posts.updateOne(
  { _id: 1 },
  { $pull: { tags: "db" } }
);

Remove objects matching criteria (nested):
ğŸ”— db.posts.updateOne(
  { _id: 1 },
  { $pull: { comments: { id: 2 } } }
);

Remove by more complex condition:
ğŸ”— db.posts.updateMany(
  {},
  { $pull: { comments: { likes: { $lt: 3 } } } } // remove comments with likes < 3
);

$pullAll removes specific listed values (scalars only):
ğŸ”— db.posts.updateOne({ _id: 1 }, { $pullAll: { scores: [10, 30] } });

4ï¸âƒ£ $pop â€” remove first or last element
Remove last element:
ğŸ”— db.posts.updateOne({ _id: 1 }, { $pop: { tags: 1 } });

Remove first element:
ğŸ”— db.posts.updateOne({ _id: 1 }, { $pop: { tags: -1 } });


5ï¸âƒ£ Update multiple matching elements â€” arrayFilters
When multiple array elements in the same document should be updated, use arrayFilters:

âœ… Example: set approved: true for all comments with likes > 3
ğŸ”— db.posts.updateOne(
  { _id: 1 },
  { $set: { "comments.$[c].approved": true } },
  { arrayFilters: [{ "c.likes": { $gt: 3 } }] }
);

Multiple arrayFilters identifiers:
ğŸ”— db.orders.updateMany(
  {},
  { $set: { "items.$[it].status": "shipped", "items.$[it].shippedAt": new Date() } },
  { arrayFilters: [{ "it.status": "packed" }] }
);

ğŸ”· Indexing in MongoDB
â¤ An index in MongoDB is a data structure (usually a B-Tree) that improves the speed of data retrieval.
â¤ Without an index, MongoDB performs a collection scan â€” checking every document to find matches (very slow for large collections).
â¤ With an index, MongoDB can jump directly to the required data (like an index in a book ğŸ“–).

ğŸ”„ Default Index
Every collection automatically creates an index on the _id field.

{ "_id": 1 } // ascending order
ğŸ‘‰ It ensures uniqueness and allows fast lookup by _id.

1ï¸âƒ£ Create an Index
Syntax:
ğŸ”— db.collection.createIndex({ fieldName: 1 })

âœ”ï¸ 1 â†’ Ascending order
âœ”ï¸ -1 â†’ Descending order

Example:
ğŸ”— db.students.createIndex({ name: 1 })
ğŸ‘‰ Creates an ascending index on the name field.


2ï¸âƒ£ Compound Index
Index on multiple fields.

ğŸ”— db.students.createIndex({ name: 1, age: -1 })
ğŸ‘‰ Sorts primarily by name, and then by age within the same name.

âš ï¸ Order matters!
A compound index { name: 1, age: -1 } can support queries on:
    { name: "Ankur" }
    { name: "Ankur", age: 22 }
âŒ But not { age: 22 } alone (unless name is also in query).


3ï¸âƒ£ Unique Index
Prevents duplicate values.
ğŸ”— db.students.createIndex({ email: 1 }, { unique: true })


4ï¸âƒ£ Sparse Index
Only indexes documents that contain the field.

ğŸ”— db.students.createIndex({ phone: 1 }, { sparse: true })
ğŸ‘‰ Documents without phone will be ignored by the index.


5ï¸âƒ£ TTL (Time-To-Live) Index
Automatically removes documents after a given time.

ğŸ”— db.sessions.createIndex({ createdAt: 1 }, { expireAfterSeconds: 3600 })
ğŸ‘‰ Documents expire 1 hour (3600 seconds) after createdAt.

6ï¸âƒ£ Text Index
For full-text search on string fields.
Only one per collection

ğŸ”— db.articles.createIndex({ content: "text" })

âœ… Query example:
ğŸ”— db.articles.find({ $text: { $search: "mongodb indexing" } })

7ï¸âƒ£ Geospatial Index
Used for location-based queries (2d or 2dsphere).

ğŸ”— db.places.createIndex({ location: "2dsphere" })

Query nearby points:
ğŸ”— db.places.find({
  location: {
    $near: {
      $geometry: { type: "Point", coordinates: [77.5946, 12.9716] },
      $maxDistance: 1000 // in meters
    }
  }
})


8ï¸âƒ£  Covered Query
If all fields used in query and projection are part of the index â†’
MongoDB can answer query without touching actual documents.

âœ… Example:
ğŸ”— db.students.createIndex({ name: 1, age: 1 })
ğŸ”— db.students.find({ name: "Ankur" }, { name: 1, age: 1, _id: 0 })

ğŸ‘‰ This is a covered query â€” faster, uses only index.

9ï¸âƒ£ Partial Covered Query
If only some fields used in query and projection are part of the index â†’
MongoDB can answer query without touching actual documents.

db.teachers.createIndex({name: 1}, {partialFilterExpression: {name: {$exists: true}}})
db.teachers.find({name: "Ankur"}, {name: 1, _id: 0})

âš¡ In case of multiple indexes
MongoDB checks the performance of index on a sample of documents once the queries are run and set it as winning plan.
Then the second query of similary type id doesn't race them again.
It stores that winning plan in cache.

ğŸ”„ Cache is reset after:
1ï¸âƒ£ After 1000 writes
2ï¸âƒ£ Index is reset
3ï¸âƒ£ Mongo server is restarted
4ï¸âƒ£ Other indexes are manipulated

db.teachers.find({name:"Ankur"}).explain("allPlansExecution") -> gives the winning and losing plan based on some sample data


ğŸ”„ View Existing Indexes
ğŸ”— db.students.getIndexes()

ğŸ”„ Drop an Index
ğŸ”— db.students.dropIndex("name_1")

ğŸ”„ Performance Notes
â¤ Indexing improves read/query performance âœ…
â¤ But slows down write operations (insert/update/delete) âŒ
â¤ More indexes = more memory & disk usage
â¤ Always create indexes based on query patterns (use explain())


ğŸ”· Aggregation in MongoDB

ğŸ”·
ğŸ”·