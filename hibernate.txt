ğŸ”· Hibernate
â¤ Hibernate is an Object Relational Mapping (ORM) framework in Java.
â¤ It maps Java classes to database tables and Java objects to table rows.
â¤ It removes the need to write raw SQL queries by providing an abstraction layer.
â¤ CRUD operations are automated and handled internally by Hibernate.
â¤ It is an implementation of JPA (Java Persistence API) specification.

ğŸ”·  Features of Hibernate
ğŸ‘‰ ORM support â†’ Direct mapping between Java objects and database tables.
ğŸ‘‰ Database Independent â†’ Code works with multiple RDBMS without changes.
ğŸ‘‰ HQL (Hibernate Query Language) â†’ Object-oriented query language.
ğŸ‘‰ Caching support â†’ Improves performance using first-level and second-level cache.
ğŸ‘‰ Lazy Loading â†’ Data fetched only when required.
ğŸ‘‰ Automatic Table Creation â†’ Schema generation can be managed.
ğŸ‘‰ Transaction Management â†’ Integrated with Java Transaction API(JTA) and Java Database connectivity(JDBC) transactions.

ğŸ”· Advantages of Hibernate
â¤ Eliminates boilerplate JDBC code.
â¤ Portable across different databases.
â¤ Improved productivity â†’ Less code, more functionality.
â¤ HQL provides flexibility compared to SQL.
â¤ Performance optimization using caching and batch fetching.
â¤ Easy relationship management between entities (@OneToOne, @OneToMany, etc.).

ğŸ”· Hibernate Architecture
ğŸŒŸ Application Starts â†’ Configuration Loaded
â¤ Hibernate first loads its configuration (usually hibernate.cfg.xml or application.properties in Spring Boot).
â¤ This file contains:
    ğŸ”— DB connection info (URL, username, password).
    ğŸ”— Hibernate dialect (e.g., MySQLDialect).
    ğŸ”— Entity class mappings (Employee.class, etc.).
â¤ Hibernate builds a Configuration object in memory.

ğŸŒŸ SessionFactory Creation
â¤ From the configuration, Hibernate creates a SessionFactory.
â¤ SessionFactory is a heavyweight, thread-safe object, created once per application.
â¤ It:
    ğŸ”— Reads all mappings (e.g., @Entity annotations).
    ğŸ”— Prepares SQL templates for CRUD operations.
    ğŸ”— Maintains a connection pool.
ğŸ‘‰ Think of SessionFactory as a blueprint for working with the database.

ğŸŒŸ Session Opening
â¤ When you need to interact with DB, you call:
â¤ Session session = sessionFactory.openSession();
Session is a lightweight, short-lived object (not thread-safe).
â¤ It represents a unit of work with the database.

ğŸŒŸ Transaction Begins
â¤ Hibernate uses Transaction API (backed by JDBC or JTA).
â¤ When you call:
    Transaction tx = session.beginTransaction();
â¤ Hibernate ensures ACID properties:
    All queries either succeed (commit) or fail together (rollback).

ğŸŒŸ Object State Management
Hibernate tracks objects in three states:
âœ”ï¸ Transient â†’ new Java object (not linked to DB/session).
âœ”ï¸ Persistent â†’ after calling session.save(obj), Hibernate tracks it. Any changes are auto-synced to DB.
âœ”ï¸ Detached â†’ once the session is closed, objects are no longer tracked.

ğŸŒŸ Hibernate Converts Objects â†’ SQL
Example:
Employee emp = new Employee();
emp.setId(1);
emp.setName("John");
emp.setSalary(50000);
session.save(emp);

Behind the scenes, Hibernate generates SQL:
insert into Employee (id, name, salary) values (1, 'John', 50000);

â¤ Hibernate uses Dialect (e.g., MySQLDialect, OracleDialect) to generate SQL that matches the DB vendor.
â¤ It then executes the query via JDBC internally.

ğŸŒŸ Caching & Optimization
â¤ Hibernate uses First-Level Cache (Session scope) automatically â†’ if you call session.get(Employee.class, 1) multiple times in the same session, Hibernate only queries the DB once.
â¤ It can also use Second-Level Cache (SessionFactory scope) to cache data across sessions.

ğŸŒŸ Transaction Commit or Rollback
â¤ On tx.commit():
    ğŸ”— Hibernate flushes all pending changes (dirty checking).
    ğŸ”— Executes SQL statements.
    ğŸ”— Commits the JDBC/JTA transaction.
â¤ On tx.rollback():
    ğŸ”— All operations are discarded.

ğŸŒŸ Session Close
â¤ After commit/rollback, the session is closed:
session.close();
â¤ Persistent objects become detached.
â¤ Sessionâ€™s first-level cache is cleared.

âœ…Flow:
Application â†’ SessionFactory â†’ Session â†’ Transaction â†’ Database

ğŸ”·Difference between Hibernate and JDBC
| Aspect                     | JDBC (Java Database Connectivity)                                                                   | Hibernate                                                                             |
| -------------------------- | ------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------- |
| Definition             | A Java API to connect and execute SQL statements directly with relational databases.                | An ORM framework that maps Java objects to database tables and automates persistence. |
| Level of Work          | Low-level â†’ You write SQL manually and handle DB logic.                                                 | High-level â†’ Works with Java objects, Hibernate generates SQL.                            |
| Boilerplate Code       | Requires a lot of code (`Connection`, `Statement`, `ResultSet`, exception handling, closing resources). | Minimal code â†’ Hibernate manages connection, query execution, mapping automatically.      |
| Query Language         | Uses SQL (Structured Query Language).                                                               | Uses HQL (Hibernate Query Language) and Criteria API (object-oriented queries).       |
| Database Independence  | SQL is database-specific â†’ migration to another DB requires changes.                                | Database-independent â†’ Hibernate dialects handle DB differences.                          |
| Mapping                | Manual â†’ you map ResultSet columns to Java objects.                                                     | Automatic ORM mapping between Java class and DB table.                                    |
| Transaction Management | Manual â†’ developer must call `commit()` / `rollback()`.                                                 | Built-in â†’ integrates with JDBC or JTA for transaction handling.                  |
| Caching                | No caching â†’ always hits the database.                                                                  | Built-in First-level & Second-level caching for performance.                          |
| **Relationships          | Developer must handle foreign keys manually with SQL joins.                                             | Relationships (`@OneToOne`, `@OneToMany`, `@ManyToMany`) handled automatically.           |
| Productivity           | Lower â†’ more boilerplate, repetitive work.                                                              | Higher â†’ less code, faster development.                                                   |


âœ…Example Code Snippet: Entity Class Employee

@Entity
public class Employee {	
	@Id
	private int id;
	private String name;
	private float salary;
	
	//setters
	public void setId(int id) {
		this.id = id;
	}
	
	public void setName(String name) {
		this.name = name;
	}
	
	public void setSalary(float salary) {
		this.salary = salary;
	}

	//Getters
	public int getId() {
		return id;
	}

	public String getName() {
		return name;
	}

	public float getSalary() {
		return salary;
	}	
}

âš¡ Explanation:
â¤ @Entity â†’ tells Hibernate: â€œThis class should be mapped to a database table.â€
â¤ By default, table name = class name (Employee).
â¤ @Id â†’ tells Hibernate which field is the primary key column in the table.
â¤ Other fields (name, salary) will be mapped as columns in the table.

âœ…Flow Diagram:
Employee class  <-->  Employee table
id              <-->  primary key column
name            <-->  column name
salary          <-->  column salary

ğŸ”· Hibernate Annotations
âœ”ï¸ @Entity â†’ Marks a class as an entity.
âœ”ï¸ @Table(name="...") â†’ Maps class to table.
âœ”ï¸ @Id â†’ Marks primary key field.
âœ”ï¸ @GeneratedValue â†’ Defines primary key generation strategy.
âœ”ï¸ @Column(name="...") â†’ Maps property to a column.

Relationships:
âœ”ï¸ @OneToOne
âœ”ï¸ @OneToMany
âœ”ï¸ @ManyToOne
âœ”ï¸ @ManyToMany

ğŸ”· JPA
ğŸ‘‰JPA (Java Persistence API) is a specification, not an implementation.
ğŸ‘‰It defines a standard set of interfaces, annotations, and rules for persisting Java objects into relational databases.
ğŸ‘‰JPA itself does not provide the actual code â€” itâ€™s like a contract that ORM tools must follow.

Example JPA annotations:
@Entity, @Id, @Table, @Column

Example JPA interface:
EntityManager (similar to Hibernateâ€™s Session)

ğŸ‘‰ Think of JPA as a blueprint: It only says â€œthis is how persistence should be doneâ€, but does not do the work itself.

ğŸ”· Relation between Hibernate and JPA
â¤ Hibernate is an implementation of JPA.
â¤ It provides the actual code that fulfills JPA specifications.
â¤ It extends JPA and adds extra features not covered by JPA, like:
    ğŸ”— Hibernate Query Language (HQL)
    ğŸ”— Advanced caching
    ğŸ”— Better performance tuning options

â¤ Other JPA implementations besides Hibernate:
    ğŸ”— EclipseLink
    ğŸ”— OpenJPA
    ğŸ”— DataNucleus

ğŸ‘‰ Think of Hibernate as a real car built from JPAâ€™s design:
JPA = design/specification
Hibernate = actual car (with even more features)

âœ… Tip:
What is the difference between JPA and Hibernate?
âœ”ï¸ JPA is a specification (interfaces + annotations, no implementation).
âœ”ï¸ Hibernate is an implementation of JPA, plus it offers additional features.
âœ”ï¸ So, when you write JPA code, youâ€™re usually running it on Hibernate underneath.

ğŸ”· Hibernate Mappings

ğŸŒŸ OneToMany Mapping
â¤ One record in Table A is related to multiple records in Table B.
â¤ Annotation: @OneToMany
âœ… Example:
    1. In an E-commerce application, one Customer can have multiple Delivery Addresses saved in their profile.
    2. In a Banking system, one Bank Branch can have multiple Accounts.
    3. In a Healthcare system, one Doctor can have multiple Patients assigned.

ğŸŒŸ ManyToOne Mapping
â¤ Multiple records in Table A map to one record in Table B.
â¤ Annotation: @ManyToOne
âœ… Example:
    1. In an E-commerce system, many Orders belong to one Customer.
    2. In a Corporate HR system, many Employees report to one Department.
    3. In a Travel Booking platform, many Flight Bookings are associated with one User.    

ğŸŒŸ ManyToMany Mapping
â¤ Records in one table are associated with multiple records in another table and vice versa.
â¤ Annotation: @ManyToMany
âœ… Example:
    1. In a Learning Management System (LMS), many Students can enroll in many Courses.
    2. In a Job Portal, many Candidates can apply to many Job Postings.
    3. In a Music Streaming App, many Artists can be part of many Playlists, and playlists can include multiple artists.    

ğŸŒŸ OneToOne Mapping
One record in Table A maps exactly to one record in Table B.
Annotation: @OneToOne
âœ… Example:
    1. In a Banking application, one Customer has exactly one PAN Card or KYC record.
    2. In an HR system, one Employee has exactly one EmployeeProfile record (with DOB, address, etc.).
    3. In a Car Rental app, one Car has exactly one Insurance Policy.    


ğŸ”· Normalization
A database design technique to organize data efficiently.

Goals:
âœ”ï¸ Reduce redundancy (no unnecessary repetition of data).
âœ”ï¸ Improve data consistency and integrity.
âœ”ï¸ Break a large unstructured table into smaller, related tables.  

Forms of Normalization:
ğŸŒŸ First Normal Form (1NF)

Rules:
ğŸ‘‰ Each column must have atomic values (no multiple values in a single cell, e.g., "CS, IT").
ğŸ‘‰ Values in a column must be of the same data type (no mixing, e.g., phone number + email in one column).
ğŸ‘‰ Each row must be unique â†’ requires a primary key.
ğŸ‘‰ No repeating groups or arrays allowed.

âœ… Example (Before 1NF):
| StudentID | Name | Subjects | Phone Numbers |
| --------- | ---- | -------- | ------------- |
| 1         | Alex | CS, IT   | 1234, 5678    |

âœ… After 1NF:
| StudentID | Name | Subject | PhoneNumber |
| --------- | ---- | ------- | ----------- |
| 1         | Alex | CS      | 1234        |
| 1         | Alex | IT      | 5678        |

ğŸŒŸ Second Normal Form (2NF)
Precondition: Must already satisfy 1NF.

Rules:
ğŸ‘‰ No partial dependency â†’ every non-key attribute should depend on the whole primary key, not just a part of it.
ğŸ‘‰ Applies only when the table has a composite primary key (more than one column as PK).

âœ… Example (Before 2NF):
| StudentID | CourseID | StudentName | CourseName | Instructor |
â¤ Composite key = (StudentID, CourseID)
â¤ Problem: StudentName depends only on StudentID, not on CourseID.

âœ… After 2NF:
â¤ Students Table: (StudentID â†’ StudentName)
â¤ Courses Table: (CourseID â†’ CourseName, Instructor)
â¤ Enrollment Table: (StudentID, CourseID)

ğŸŒŸ Third Normal Form (3NF)
Precondition: Must already satisfy 2NF.

Rules:
ğŸ‘‰ No transitive dependency â†’ non-key attributes should not depend on other non-key attributes.
ğŸ‘‰ Every non-key column must depend only on the primary key.

âœ… Example (Before 3NF):
| StudentID | Name | DeptID | DeptName | DeptHead |
â¤ Problem: DeptName and DeptHead depend on DeptID, not directly on StudentID.

âœ… After 3NF:
â¤ Students Table: (StudentID â†’ Name, DeptID)
â¤ Departments Table: (DeptID â†’ DeptName, DeptHead)

âš¡ Tips:
Emphasize:
âœ”ï¸ 1NF â†’ Atomic values, no repeating groups.
âœ”ï¸ 2NF â†’ Remove partial dependency.
âœ”ï¸ 3NF â†’ Remove transitive dependency.

ğŸ§  Common trap: Interviewers may ask if 2NF applies when there is no 
 composite key.
ğŸ”„ Answer: No, because partial dependency exists only with composite keys.

ğŸ§  Working through normalization step-by-step helps ensure a well-structured database design.

âœ… For Example:
(0) Unnormalized table (UNF)

OrderSheet (single table)
OrderID | OrderDate|CustomerName|CustomerEmail|CustomerAddress|BookISBN| BookTitle | BookAuthor  |UnitPrice  |Quantity|LineTotal|  PhoneNumbers (comma-separated)
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
101     |2025-08-01| John Smith | john@x.com | 221B Baker St| 999-1    | SQL Basics| Ada Lovelace| 500       | 1      | 500     | Phones: "98765, 91234"
101     |2025-08-01| John Smith | john@x.com | 221B Baker St| 999-2    | DB Design | E. Codd     | 700       | 2      | 1400    | Phones: "98765, 91234"
102     |2025-08-02| Robert Ray | rob@y.com  | 42 Galaxy Way| 999-2    | DB Design | E. Codd     | 700       | 1      | 700     | Phones: "99887"

Whatâ€™s wrong here:
â¤ Multi-valued attribute: PhoneNumbers = "98765, 91234" (not atomic).
â¤ Redundancy: customer & book details repeat across rows.
â¤ Update anomalies: change Johnâ€™s address â†’ must update many rows.
â¤ Insert/delete anomalies: canâ€™t insert a new book without an order; deleting Johnâ€™s order may â€œloseâ€ the bookâ€™s master data.

ğŸŒŸ First Normal Form (1NF)
Goal:
â¤ Make every cell atomic, consistent types, define a key, and eliminate repeating groups.

Fixes weâ€™ll do
â¤ Remove comma-separated phones into a separate table.
â¤ Keep a composite primary key (OrderID, BookISBN) in the order-lines so two books in one order are allowed.
â¤ Keep other columns as-is for now.

1NF schema
OrderLines_1NF(
  OrderID,        -- part of PK
  BookISBN,       -- part of PK
  OrderDate,
  CustomerName,
  CustomerEmail,
  CustomerAddress,
  BookTitle,
  BookAuthor,
  UnitPrice,
  Quantity,
  LineTotal
  PRIMARY KEY (OrderID, BookISBN)
)

CustomerPhones_1NF(
  CustomerEmail,  -- weâ€™ll temporarily use email to link phones
  PhoneNumber,
  PRIMARY KEY (CustomerEmail, PhoneNumber)
)

âš¡Why this is 1NF now
â¤ No multi-valued fields; phones are atomic and stored as separate rows.
â¤ A row is uniquely identified by (OrderID, BookISBN).
â¤ Column types are consistent.

Still redundant: Customer info depends only on OrderID; book info depends only on BookISBN. Thatâ€™s the 2NF problem.

ğŸŒŸ Second Normal Form (2NF):
âœ… Precondition: Table(s) are in 1NF.

â—Rule: No partial dependencyâ€”every non-key attribute must depend on the entire composite key (when a composite key exists).

In OrderLines_1NF, the PK is (OrderID, BookISBN):
â¤ OrderDate, CustomerName, CustomerEmail, CustomerAddress depend only on OrderID (part of the key) â†’ partial dependency.
â¤ BookTitle, BookAuthor, UnitPrice depend only on BookISBN (part of the key) â†’ partial dependency.
â¤ Quantity, LineTotal depend on both â†’ fine.

Decompose to remove partial dependencies

2NF schema
Orders_2NF(
  OrderID PK,
  OrderDate,
  CustomerName,
  CustomerEmail,
  CustomerAddress
)

Books_2NF(
  BookISBN K,
  BookTitle,
  BookAuthor,
  UnitPrice
)

OrderItems_2NF(
  OrderID        -- part of PK, FK -> Orders_2NF(OrderID)
  BookISBN       -- part of PK, FK -> Books_2NF(BookISBN)
  Quantity,
  LineTotal,
  PRIMARY KEY (OrderID, BookISBN)
)

CustomerPhones_2NF(
  CustomerEmail,
  PhoneNumber,
  PRIMARY KEY (CustomerEmail, PhoneNumber)
)

ğŸ”— What we gained
â¤ No attribute in OrderItems_2NF depends only on part of its composite key.
â¤ Book and customer order headers are stored onceâ€”redundancy drops.

Still an issue for 3NF: In Orders_2NF, CustomerName/Email/Address are really properties of a Customer, not of an Order. We also still keep LineTotal, which is derivable (Quantity Ã— UnitPrice). That creates a transitive/derived dependency risk.

ğŸŒŸ Third Normal Form (3NF)
âœ… Precondition: In 2NF.
â— Rule: No transitive dependencyâ€”non-key attributes must not depend on other non-key attributes.

Whatâ€™s transitive here?

If we introduce a stable CustomerID, then:
â¤ Orders would have CustomerID (FK) and non-key attributes like CustomerName/Email/Address would depend on CustomerID, not directly on OrderID â†’ transitive dependency in Orders_2NF.
â¤ LineTotal depends on Quantity and UnitPrice (the latter is in Books). Itâ€™s derivable, and storing it risks inconsistency.

ğŸ”„ Decompose & clean

Final 3NF schema
Customers(
  CustomerID     PK,
  CustomerName,
  CustomerEmail  UNIQUE,
  CustomerAddress
)

CustomerPhones(
  CustomerID     FK -> Customers(CustomerID),
  PhoneNumber,
  PRIMARY KEY (CustomerID, PhoneNumber)
)

Orders(
  OrderID        PK,
  OrderDate,
  CustomerID     FK -> Customers(CustomerID)
)

Books(
  BookISBN       PK,
  BookTitle,
  BookAuthor,
  UnitPrice
)

OrderItems(
  OrderID        FK -> Orders(OrderID),
  BookISBN       FK -> Books(BookISBN),
  Quantity,
  -- no LineTotal here (computed when needed)
  PRIMARY KEY (OrderID, BookISBN)
)
ğŸ”— Why this is 3NF:
â¤ In Orders, every non-key attribute (OrderDate, CustomerID) depends only on the key (OrderID), and nothing depends on another non-key attribute.
â¤ Customer details live in Customers; phones in CustomerPhones with a clean 1-to-many.
â¤ Book master data is in Books.
â¤ OrderItems only has attributes that depend on the whole composite key (OrderID, BookISBN).
â¤ Derived value LineTotal removed â†’ no transitive/derived dependency.

Sample data (3NF)

ğŸ“ Customers
CustomerID | CustomerName | CustomerEmail | CustomerAddress
-----------------------------------------------------------
C001       | John Smith   | john@x.com    | 221B Baker St
C002       | Robert Ray   | rob@y.com     | 42 Galaxy Way

ğŸ“ CustomerPhones
CustomerID | PhoneNumber
------------------------
C001       | 98765
C001       | 91234
C002       | 99887

ğŸ“ Books
BookISBN | BookTitle     | BookAuthor   | UnitPrice
---------------------------------------------------
999-1    | SQL Basics    | Ada Lovelace | 500
999-2    | DB Design     | E. Codd      | 700

ğŸ“ Orders
OrderID | OrderDate   | CustomerID
-----------------------------------
101     | 2025-08-01  | C001
102     | 2025-08-02  | C002

ğŸ“ OrderItems
OrderID | BookISBN | Quantity
-----------------------------
101     | 999-1    | 1
101     | 999-2    | 2
102     | 999-2    | 1

ğŸ”„ Practical SQL (3NF):
Create tables
-- Master tables

CREATE TABLE Customers (
  CustomerID      VARCHAR(10) PRIMARY KEY,
  CustomerName    VARCHAR(100) NOT NULL,
  CustomerEmail   VARCHAR(150) UNIQUE NOT NULL,
  CustomerAddress VARCHAR(200) NOT NULL
);

CREATE TABLE CustomerPhones (
  CustomerID   VARCHAR(10) NOT NULL,
  PhoneNumber  VARCHAR(20) NOT NULL,
  PRIMARY KEY (CustomerID, PhoneNumber),
  FOREIGN KEY (CustomerID) REFERENCES Customers(CustomerID)
);

CREATE TABLE Books (
  BookISBN    VARCHAR(20) PRIMARY KEY,
  BookTitle   VARCHAR(150) NOT NULL,
  BookAuthor  VARCHAR(100) NOT NULL,
  UnitPrice   DECIMAL(10,2) NOT NULL
);

-- Transaction tables
CREATE TABLE Orders (
  OrderID     INT PRIMARY KEY,
  OrderDate   DATE NOT NULL,
  CustomerID  VARCHAR(10) NOT NULL,
  FOREIGN KEY (CustomerID) REFERENCES Customers(CustomerID)
);

CREATE TABLE OrderItems (
  OrderID    INT NOT NULL,
  BookISBN   VARCHAR(20) NOT NULL,
  Quantity   INT NOT NULL CHECK (Quantity > 0),
  PRIMARY KEY (OrderID, BookISBN),
  FOREIGN KEY (OrderID)  REFERENCES Orders(OrderID),
  FOREIGN KEY (BookISBN) REFERENCES Books(BookISBN)
);


âš¡ Compute an orderâ€™s total (derived at query-time, no redundancy):
â¤ SELECT
  oi.OrderID,
  SUM(oi.Quantity * b.UnitPrice) AS OrderTotal
FROM OrderItems oi
JOIN Books b ON b.BookISBN = oi.BookISBN
WHERE oi.OrderID = 101
GROUP BY oi.OrderID;

âš¡ List line items with computed line totals:
â¤ SELECT
  o.OrderID,
  o.OrderDate,
  c.CustomerName,
  b.BookTitle,
  oi.Quantity,
  (oi.Quantity * b.UnitPrice) AS LineTotal
FROM Orders o
JOIN Customers c   ON c.CustomerID = o.CustomerID
JOIN OrderItems oi ON oi.OrderID = o.OrderID
JOIN Books b       ON b.BookISBN = oi.BookISBN
WHERE o.OrderID = 101;

âœ… Key takeaways (interview-friendly)
âš¡ 1NF: Atomic values, no repeating groups; define a key.
âš¡ 2NF: Remove partial dependencies from tables with composite keys (separate order header vs. book master vs. order items).
âš¡ 3NF: Remove transitive dependencies (move customer details to Customers; drop derived LineTotal).

Result: minimal redundancy, better integrity; queries use joins to rebuild the full picture.

ğŸ”· Spring Data JPA
Spring Data JPA is a Spring framework project built on top of JPA (Java Persistence API) that makes database access and persistence operations easier.

ğŸ‘‰ In short:
â¤ JPA = Specification (interfaces & annotations, no implementation).
â¤ Hibernate = Implementation of JPA.
â¤ Spring Data JPA = Abstraction layer that makes working with JPA implementations (like Hibernate) much easier.

ğŸ”¹ Why Spring Data JPA?
Without it, youâ€™d need to write a lot of boilerplate DAO code like this:

public class EmployeeRepository {
    @PersistenceContext
    private EntityManager em;

    public void save(Employee emp) {
        em.persist(emp);
    }

    public Employee findById(Long id) {
        return em.find(Employee.class, id);
    }
}

With Spring Data JPA, this becomes:
public interface EmployeeRepository extends JpaRepository<Employee, Long> {
}
âœ… Done. Spring auto-generates the implementation at runtime.

ğŸŒŸ Key Features
ğŸ”„ Repository Abstractions
â¤ Provides ready-made repository interfaces:
  ğŸ”— CrudRepository<T, ID> â†’ basic CRUD.
  ğŸ”— JpaRepository<T, ID> â†’ CRUD + pagination + sorting.
â¤ No need to implement DAO manually.

ğŸ”„ Derived Query Methods
Spring parses method names and generates SQL automatically.

Example:
List<Employee> findByDepartment(String department);
List<Employee> findBySalaryGreaterThan(double salary);
ğŸ‘‰ These automatically generate SELECT queries.

ğŸ”„ Custom Queries with JPQL / Native SQL
â¤ Use @Query annotation for custom queries:
@Query("SELECT e FROM Employee e WHERE e.salary > :salary")
List<Employee> findHighEarners(@Param("salary") double salary);

â¤ Native SQL also supported:
@Query(value = "SELECT * FROM employee WHERE department = :dept", nativeQuery = true)
List<Employee> findByDept(@Param("dept") String dept);

ğŸ”„ Pagination and Sorting
â¤ Built-in support:
Page<Employee> findAll(Pageable pageable);
List<Employee> findAll(Sort sort);

ğŸ”„ Transaction Management
â¤ Integrated with Springâ€™s @Transactional.
â¤ Spring handles opening, committing, rolling back transactions automatically.

ğŸ”„ Auditing
â¤ Track createdBy, createdDate, lastModifiedBy, lastModifiedDate with annotations:
@CreatedDate
private LocalDateTime createdAt;

âš¡ How it Works Behind the Scenes
â¤ You declare a repository interface (e.g., EmployeeRepository extends JpaRepository<Employee, Long>).
â¤ At runtime, Spring Data JPA creates a proxy implementation of this interface.
â¤ The proxy internally uses EntityManager (from JPA) â†’ which is backed by Hibernate (default in Spring Boot).
â¤ SQL queries are generated based on:
  ğŸ”— Method name conventions (e.g., findByName).
  ğŸ”— @Query annotations.
  ğŸ”— Default CRUD methods from JpaRepository.

ğŸ“Œ Repository Layer in Spring Boot
â¤ The Repository Layer in Spring Boot is the layer that interacts with the database.
â¤ It provides predefined methods to perform CRUD (Create, Read, Update, Delete) operations without writing SQL queries.
â¤ It is built on Spring Data JPA, which internally uses Hibernate (by default) for ORM.

âš¡ How It Works
â¤ Instead of writing your own DAO (Data Access Object) classes with JDBC/Hibernate queries,
you just create an interface that extends one of Spring Data JPAâ€™s repository interfaces.
â¤ Spring Boot automatically creates the implementation at runtime.

Example:
public interface EmployeeRepository extends JpaRepository<Employee, Integer> {
}
Here:
Employee â†’ Entity class
Integer â†’ Primary Key type

ğŸ”„ Common Utility Methods
Repository interfaces provide many ready-made methods, such as:

ğŸ”§ save(entity) â†’ Insert or update entity in DB
ğŸ”§ findById(id) â†’ Retrieve entity by primary key
ğŸ”§ findAll() â†’ Get all records
ğŸ”§ delete(entity) â†’ Delete a record
ğŸ”§ deleteById(id) â†’ Delete by primary key
ğŸ”§ count() â†’ Count total records

ğŸ”„ Custom Query Methods
You can also define custom finder methods just by following naming conventions.

Example:
List<Employee> findByName(String name);
List<Employee> findBySalaryGreaterThan(float salary);
ğŸ‘‰ Spring Data JPA automatically generates queries for these methods.

ğŸ”„ Industry-level Use
â¤ In enterprise applications, Repository Layer is where all database interaction is isolated.
â¤ The Service Layer calls the Repository Layer, and repository handles DB operations.
â¤ This ensures separation of concerns and clean architecture.  

ğŸ“Œ Dependency Injection (DI) in Spring Bootâ¤ 
â¤ Dependency Injection (DI) is a design pattern where an objectâ€™s dependencies (other objects it needs to work) are provided (injected) by the Spring Framework instead of the class creating them manually.
â¤ Spring Boot manages the creation, configuration, and lifecycle of these dependencies at runtime.

ğŸ”„ Analogy
ğŸ‘‰ Think of building a house:
You need bricks, cement, wood.
Instead of making these materials yourself, you ask suppliers to provide them.

Similarly, your class does not create its required objects itself; Spring provides them automatically.

ğŸ”„ Why Use DI?
âœ… Loose Coupling
â¤ Classes do not depend on how objects are created, only on what they can do.
â¤ Easier to swap implementations (e.g., change from MySQL DB to MongoDB without modifying business logic).

âœ… Automatic Lifecycle Management
â¤ Spring controls the object creation, initialization, and destruction.
â¤ You donâ€™t need to manually manage memory or cleanup.

ğŸ”„ Improved Testability
Since dependencies are injected, you can easily mock objects for unit testing.

ğŸ”„ Types of Dependency Injection in Spring Boot
ğŸ“ Constructor Injection âœ… (Most recommended in modern Spring Boot)

@Service
public class EmployeeService {
    private final EmployeeRepository employeeRepository;

    // Constructor Injection
    public EmployeeService(EmployeeRepository employeeRepository) {
        this.employeeRepository = employeeRepository;
    }
}

ğŸ“ Setter Injection
@Service
public class EmployeeService {
    private EmployeeRepository employeeRepository;

    @Autowired
    public void setEmployeeRepository(EmployeeRepository employeeRepository) {
        this.employeeRepository = employeeRepository;
    }
}

ğŸ“ Field Injection âŒ (Not recommended for large apps, but commonly seen in small projects)
@Service
public class EmployeeService {
    @Autowired
    private EmployeeRepository employeeRepository;
}

ğŸ”„ How DI Works in Spring Boot
â¤ Spring Boot scans the project for classes annotated with @Component, @Service, @Repository, @Controller, etc.
â¤ It creates objects (called Spring Beans) of these classes.
â¤ Whenever another class requires these objects, Spring injects them automatically (instead of you writing new).

Example:
@RestController
public class EmployeeController {

    private final EmployeeService employeeService;

    // Constructor Injection
    public EmployeeController(EmployeeService employeeService) {
        this.employeeService = employeeService;
    }

    @GetMapping("/employees")
    public List<Employee> getAllEmployees() {
        return employeeService.getEmployees();
    }
}

ğŸ‘‰ Here:
â¤ EmployeeController depends on EmployeeService.
â¤ Spring Boot automatically injects an instance of EmployeeService.

ğŸŒ± Spring IoC (Inversion of Control)
â¤ IoC (Inversion of Control) is the principle where the control of object creation and management is transferred from the developer to the Spring IoC Container.
â¤ In simple words: You donâ€™t control the objects, Spring does.

ğŸ”„ Spring IoC Container
â¤ Core of the Spring Framework.
â¤ Responsible for:
  ğŸ”— Creating objects (beans)
  ğŸ”— Configuring them
  ğŸ”— Injecting dependencies (DI)
  ğŸ”— Managing their lifecycle

ğŸ”„ How It Works
â¤ You annotate/configure classes with @Component, @Service, @Repository, @Controller etc.
â¤ Spring IoC Container scans the project, finds these beans, and creates objects automatically.
â¤ Dependencies between beans are resolved using Dependency Injection (DI).

ğŸ”„ Advantages
â¤ Promotes loose coupling (objects donâ€™t create their dependencies).
â¤ Makes applications modular and testable.
â¤ Simplifies configuration and lifecycle management.

ğŸ”„ Analogy
ğŸ‘‰ Think of a restaurant:
â¤ You donâ€™t cook yourself; you just order.
â¤ The kitchen (IoC Container) manages all cooking, preparation, and delivery.
â¤ Similarly, you just define what you need, and Spring IoC takes care of how itâ€™s created and managed.

ğŸŒ€ Spring Bean Lifecycle
ğŸ“ Lifecycle Stages
â¤ Bean Creation
  ğŸ”— Spring IoC creates the bean object.
  ğŸ”— Example: using @Component or configuration class.

â¤ Dependency Injection
Dependencies are injected (e.g., using @Autowired or constructor injection).

â¤ Initialization (Optional Hooks)
If the bean implements InitializingBean or has @PostConstruct method â†’ executed here.

â¤ Execution (In Use)
The bean is ready to be used by the application.

â¤ Destruction
  ğŸ”— When the application context shuts down, Spring destroys the bean.
  ğŸ”— Example: @PreDestroy method or DisposableBean interface.

âœ”ï¸ Diagram (Flow)
Bean Instantiation 
       â†“
Dependencies Injection (@Autowired)
       â†“
Initialization (@PostConstruct, afterPropertiesSet)
       â†“
Bean is Ready (used by app)
       â†“
Destruction (@PreDestroy, destroy())

Example
@Component
public class MyBean implements InitializingBean, DisposableBean {

    @Override
    public void afterPropertiesSet() {
        System.out.println("Bean is initialized");
    }

    @Override
    public void destroy() {
        System.out.println("Bean is destroyed");
    }
}

âœ… JUnit in Spring Boot (Unit Testing)
â¤ JUnit is a testing framework used in Java to perform unit testing.
â¤ In unit testing (white-box testing), we test individual pieces of code (methods, classes) rather than the whole application.
â¤ Spring Boot projects by default include the JUnit library, so you donâ€™t need to add it manually.

âš¡ Important Annotations in JUnit
ğŸ”„ @Test
â¤ Marks a method as a test case.
â¤ JUnit will execute this method and report PASS / FAIL based on output or assertions.
â¤ Multiple @Test methods can exist in one class, each runs independently.

ğŸ”„ @BeforeEach
â¤ Runs before every @Test method.
â¤ Usually used for setting up resources or initialization.

ğŸ”„ @AfterEach
â¤ Runs after every @Test method.
â¤ Used for cleanup activities (e.g., closing DB connections).

ğŸ”„ @BeforeAll
â¤ Runs once before all tests in the class.
â¤ Must be static.
â¤ Used for global setup (e.g., starting an in-memory database).

ğŸ”„ @AfterAll
â¤ Runs once after all tests in the class.
â¤ Must be static.
â¤ Used for global cleanup (e.g., stopping server, closing shared resources).

ğŸ–¥ï¸ Example Code
package com.demo1;

import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class Demo1ApplicationTests {

    // This runs ONCE before any test method
    @BeforeAll
    public static void beforeAll() {
        System.out.println(">>> Before All - Runs only once before all tests");
    }

    // This runs BEFORE EACH test method
    @BeforeEach
    public void beforeTest() {
        System.out.println(">>> Before Each - Runs before every test case");
    }

    // Test case 1
    @Test
    void test1() {
        System.out.println(">>> Executing Test 1");
    }

    // Test case 2
    @Test
    void test2() {
        System.out.println(">>> Executing Test 2");
    }

    // This runs AFTER EACH test method
    @AfterEach
    public void afterTest() {
        System.out.println(">>> After Each - Runs after every test case");
    }

    // This runs ONCE after all test methods have executed
    @AfterAll
    public static void afterAll() {
        System.out.println(">>> After All - Runs only once after all tests");
    }
}

ğŸ“Œ Expected Execution Flow
When you run the test class, JUnit will call methods in the following order:

>>> Before All - Runs only once before all tests

>>> Before Each - Runs before every test case
>>> Executing Test 1
>>> After Each - Runs after every test case

>>> Before Each - Runs before every test case
>>> Executing Test 2
>>> After Each - Runs after every test case

>>> After All - Runs only once after all tests