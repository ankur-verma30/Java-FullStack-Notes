🔷 Hibernate
➤ Hibernate is an Object Relational Mapping (ORM) framework in Java.
➤ It maps Java classes to database tables and Java objects to table rows.
➤ It removes the need to write raw SQL queries by providing an abstraction layer.
➤ CRUD operations are automated and handled internally by Hibernate.
➤ It is an implementation of JPA (Java Persistence API) specification.

🔷  Features of Hibernate
👉 ORM support → Direct mapping between Java objects and database tables.
👉 Database Independent → Code works with multiple RDBMS without changes.
👉 HQL (Hibernate Query Language) → Object-oriented query language.
👉 Caching support → Improves performance using first-level and second-level cache.
👉 Lazy Loading → Data fetched only when required.
👉 Automatic Table Creation → Schema generation can be managed.
👉 Transaction Management → Integrated with Java Transaction API(JTA) and Java Database connectivity(JDBC) transactions.

🔷 Advantages of Hibernate
➤ Eliminates boilerplate JDBC code.
➤ Portable across different databases.
➤ Improved productivity → Less code, more functionality.
➤ HQL provides flexibility compared to SQL.
➤ Performance optimization using caching and batch fetching.
➤ Easy relationship management between entities (@OneToOne, @OneToMany, etc.).

🔷 Hibernate Architecture
🌟 Application Starts → Configuration Loaded
➤ Hibernate first loads its configuration (usually hibernate.cfg.xml or application.properties in Spring Boot).
➤ This file contains:
    🔗 DB connection info (URL, username, password).
    🔗 Hibernate dialect (e.g., MySQLDialect).
    🔗 Entity class mappings (Employee.class, etc.).
➤ Hibernate builds a Configuration object in memory.

🌟 SessionFactory Creation
➤ From the configuration, Hibernate creates a SessionFactory.
➤ SessionFactory is a heavyweight, thread-safe object, created once per application.
➤ It:
    🔗 Reads all mappings (e.g., @Entity annotations).
    🔗 Prepares SQL templates for CRUD operations.
    🔗 Maintains a connection pool.
👉 Think of SessionFactory as a blueprint for working with the database.

🌟 Session Opening
➤ When you need to interact with DB, you call:
➤ Session session = sessionFactory.openSession();
Session is a lightweight, short-lived object (not thread-safe).
➤ It represents a unit of work with the database.

🌟 Transaction Begins
➤ Hibernate uses Transaction API (backed by JDBC or JTA).
➤ When you call:
    Transaction tx = session.beginTransaction();
➤ Hibernate ensures ACID properties:
    All queries either succeed (commit) or fail together (rollback).

🌟 Object State Management
Hibernate tracks objects in three states:
✔️ Transient → new Java object (not linked to DB/session).
✔️ Persistent → after calling session.save(obj), Hibernate tracks it. Any changes are auto-synced to DB.
✔️ Detached → once the session is closed, objects are no longer tracked.

🌟 Hibernate Converts Objects → SQL
Example:
Employee emp = new Employee();
emp.setId(1);
emp.setName("John");
emp.setSalary(50000);
session.save(emp);

Behind the scenes, Hibernate generates SQL:
insert into Employee (id, name, salary) values (1, 'John', 50000);

➤ Hibernate uses Dialect (e.g., MySQLDialect, OracleDialect) to generate SQL that matches the DB vendor.
➤ It then executes the query via JDBC internally.

🌟 Caching & Optimization
➤ Hibernate uses First-Level Cache (Session scope) automatically → if you call session.get(Employee.class, 1) multiple times in the same session, Hibernate only queries the DB once.
➤ It can also use Second-Level Cache (SessionFactory scope) to cache data across sessions.

🌟 Transaction Commit or Rollback
➤ On tx.commit():
    🔗 Hibernate flushes all pending changes (dirty checking).
    🔗 Executes SQL statements.
    🔗 Commits the JDBC/JTA transaction.
➤ On tx.rollback():
    🔗 All operations are discarded.

🌟 Session Close
➤ After commit/rollback, the session is closed:
session.close();
➤ Persistent objects become detached.
➤ Session’s first-level cache is cleared.

✅Flow:
Application → SessionFactory → Session → Transaction → Database

🔷Difference between Hibernate and JDBC
| Aspect                     | JDBC (Java Database Connectivity)                                                                   | Hibernate                                                                             |
| -------------------------- | ------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------- |
| Definition             | A Java API to connect and execute SQL statements directly with relational databases.                | An ORM framework that maps Java objects to database tables and automates persistence. |
| Level of Work          | Low-level → You write SQL manually and handle DB logic.                                                 | High-level → Works with Java objects, Hibernate generates SQL.                            |
| Boilerplate Code       | Requires a lot of code (`Connection`, `Statement`, `ResultSet`, exception handling, closing resources). | Minimal code → Hibernate manages connection, query execution, mapping automatically.      |
| Query Language         | Uses SQL (Structured Query Language).                                                               | Uses HQL (Hibernate Query Language) and Criteria API (object-oriented queries).       |
| Database Independence  | SQL is database-specific → migration to another DB requires changes.                                | Database-independent → Hibernate dialects handle DB differences.                          |
| Mapping                | Manual → you map ResultSet columns to Java objects.                                                     | Automatic ORM mapping between Java class and DB table.                                    |
| Transaction Management | Manual → developer must call `commit()` / `rollback()`.                                                 | Built-in → integrates with JDBC or JTA for transaction handling.                  |
| Caching                | No caching → always hits the database.                                                                  | Built-in First-level & Second-level caching for performance.                          |
| **Relationships          | Developer must handle foreign keys manually with SQL joins.                                             | Relationships (`@OneToOne`, `@OneToMany`, `@ManyToMany`) handled automatically.           |
| Productivity           | Lower → more boilerplate, repetitive work.                                                              | Higher → less code, faster development.                                                   |


✅Example Code Snippet: Entity Class Employee

@Entity
public class Employee {	
	@Id
	private int id;
	private String name;
	private float salary;
	
	//setters
	public void setId(int id) {
		this.id = id;
	}
	
	public void setName(String name) {
		this.name = name;
	}
	
	public void setSalary(float salary) {
		this.salary = salary;
	}

	//Getters
	public int getId() {
		return id;
	}

	public String getName() {
		return name;
	}

	public float getSalary() {
		return salary;
	}	
}

⚡ Explanation:
➤ @Entity → tells Hibernate: “This class should be mapped to a database table.”
➤ By default, table name = class name (Employee).
➤ @Id → tells Hibernate which field is the primary key column in the table.
➤ Other fields (name, salary) will be mapped as columns in the table.

✅Flow Diagram:
Employee class  <-->  Employee table
id              <-->  primary key column
name            <-->  column name
salary          <-->  column salary

🔷 Hibernate Annotations
✔️ @Entity → Marks a class as an entity.
✔️ @Table(name="...") → Maps class to table.
✔️ @Id → Marks primary key field.
✔️ @GeneratedValue → Defines primary key generation strategy.
✔️ @Column(name="...") → Maps property to a column.

Relationships:
✔️ @OneToOne
✔️ @OneToMany
✔️ @ManyToOne
✔️ @ManyToMany

🔷 JPA
👉JPA (Java Persistence API) is a specification, not an implementation.
👉It defines a standard set of interfaces, annotations, and rules for persisting Java objects into relational databases.
👉JPA itself does not provide the actual code — it’s like a contract that ORM tools must follow.

Example JPA annotations:
@Entity, @Id, @Table, @Column

Example JPA interface:
EntityManager (similar to Hibernate’s Session)

👉 Think of JPA as a blueprint: It only says “this is how persistence should be done”, but does not do the work itself.

🔷 Relation between Hibernate and JPA
➤ Hibernate is an implementation of JPA.
➤ It provides the actual code that fulfills JPA specifications.
➤ It extends JPA and adds extra features not covered by JPA, like:
    🔗 Hibernate Query Language (HQL)
    🔗 Advanced caching
    🔗 Better performance tuning options

➤ Other JPA implementations besides Hibernate:
    🔗 EclipseLink
    🔗 OpenJPA
    🔗 DataNucleus

👉 Think of Hibernate as a real car built from JPA’s design:
JPA = design/specification
Hibernate = actual car (with even more features)

✅ Tip:
What is the difference between JPA and Hibernate?
✔️ JPA is a specification (interfaces + annotations, no implementation).
✔️ Hibernate is an implementation of JPA, plus it offers additional features.
✔️ So, when you write JPA code, you’re usually running it on Hibernate underneath.

🔷 Hibernate Mappings

🌟 OneToMany Mapping
➤ One record in Table A is related to multiple records in Table B.
➤ Annotation: @OneToMany
✅ Example:
    1. In an E-commerce application, one Customer can have multiple Delivery Addresses saved in their profile.
    2. In a Banking system, one Bank Branch can have multiple Accounts.
    3. In a Healthcare system, one Doctor can have multiple Patients assigned.

🌟 ManyToOne Mapping
➤ Multiple records in Table A map to one record in Table B.
➤ Annotation: @ManyToOne
✅ Example:
    1. In an E-commerce system, many Orders belong to one Customer.
    2. In a Corporate HR system, many Employees report to one Department.
    3. In a Travel Booking platform, many Flight Bookings are associated with one User.    

🌟 ManyToMany Mapping
➤ Records in one table are associated with multiple records in another table and vice versa.
➤ Annotation: @ManyToMany
✅ Example:
    1. In a Learning Management System (LMS), many Students can enroll in many Courses.
    2. In a Job Portal, many Candidates can apply to many Job Postings.
    3. In a Music Streaming App, many Artists can be part of many Playlists, and playlists can include multiple artists.    

🌟 OneToOne Mapping
One record in Table A maps exactly to one record in Table B.
Annotation: @OneToOne
✅ Example:
    1. In a Banking application, one Customer has exactly one PAN Card or KYC record.
    2. In an HR system, one Employee has exactly one EmployeeProfile record (with DOB, address, etc.).
    3. In a Car Rental app, one Car has exactly one Insurance Policy.    


🔷 Normalization
A database design technique to organize data efficiently.

Goals:
✔️ Reduce redundancy (no unnecessary repetition of data).
✔️ Improve data consistency and integrity.
✔️ Break a large unstructured table into smaller, related tables.  

Forms of Normalization:
🌟 First Normal Form (1NF)

Rules:
👉 Each column must have atomic values (no multiple values in a single cell, e.g., "CS, IT").
👉 Values in a column must be of the same data type (no mixing, e.g., phone number + email in one column).
👉 Each row must be unique → requires a primary key.
👉 No repeating groups or arrays allowed.

✅ Example (Before 1NF):
| StudentID | Name | Subjects | Phone Numbers |
| --------- | ---- | -------- | ------------- |
| 1         | Alex | CS, IT   | 1234, 5678    |

✅ After 1NF:
| StudentID | Name | Subject | PhoneNumber |
| --------- | ---- | ------- | ----------- |
| 1         | Alex | CS      | 1234        |
| 1         | Alex | IT      | 5678        |

🌟 Second Normal Form (2NF)
Precondition: Must already satisfy 1NF.

Rules:
👉 No partial dependency → every non-key attribute should depend on the whole primary key, not just a part of it.
👉 Applies only when the table has a composite primary key (more than one column as PK).

✅ Example (Before 2NF):
| StudentID | CourseID | StudentName | CourseName | Instructor |
➤ Composite key = (StudentID, CourseID)
➤ Problem: StudentName depends only on StudentID, not on CourseID.

✅ After 2NF:
➤ Students Table: (StudentID → StudentName)
➤ Courses Table: (CourseID → CourseName, Instructor)
➤ Enrollment Table: (StudentID, CourseID)

🌟 Third Normal Form (3NF)
Precondition: Must already satisfy 2NF.

Rules:
👉 No transitive dependency → non-key attributes should not depend on other non-key attributes.
👉 Every non-key column must depend only on the primary key.

✅ Example (Before 3NF):
| StudentID | Name | DeptID | DeptName | DeptHead |
➤ Problem: DeptName and DeptHead depend on DeptID, not directly on StudentID.

✅ After 3NF:
➤ Students Table: (StudentID → Name, DeptID)
➤ Departments Table: (DeptID → DeptName, DeptHead)

⚡ Tips:
Emphasize:
✔️ 1NF → Atomic values, no repeating groups.
✔️ 2NF → Remove partial dependency.
✔️ 3NF → Remove transitive dependency.

🧠 Common trap: Interviewers may ask if 2NF applies when there is no 
 composite key.
🔄 Answer: No, because partial dependency exists only with composite keys.

🧠 Working through normalization step-by-step helps ensure a well-structured database design.

✅ For Example:
(0) Unnormalized table (UNF)

OrderSheet (single table)
OrderID | OrderDate|CustomerName|CustomerEmail|CustomerAddress|BookISBN| BookTitle | BookAuthor  |UnitPrice  |Quantity|LineTotal|  PhoneNumbers (comma-separated)
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
101     |2025-08-01| John Smith | john@x.com | 221B Baker St| 999-1    | SQL Basics| Ada Lovelace| 500       | 1      | 500     | Phones: "98765, 91234"
101     |2025-08-01| John Smith | john@x.com | 221B Baker St| 999-2    | DB Design | E. Codd     | 700       | 2      | 1400    | Phones: "98765, 91234"
102     |2025-08-02| Robert Ray | rob@y.com  | 42 Galaxy Way| 999-2    | DB Design | E. Codd     | 700       | 1      | 700     | Phones: "99887"

What’s wrong here:
➤ Multi-valued attribute: PhoneNumbers = "98765, 91234" (not atomic).
➤ Redundancy: customer & book details repeat across rows.
➤ Update anomalies: change John’s address → must update many rows.
➤ Insert/delete anomalies: can’t insert a new book without an order; deleting John’s order may “lose” the book’s master data.

🌟 First Normal Form (1NF)
Goal:
➤ Make every cell atomic, consistent types, define a key, and eliminate repeating groups.

Fixes we’ll do
➤ Remove comma-separated phones into a separate table.
➤ Keep a composite primary key (OrderID, BookISBN) in the order-lines so two books in one order are allowed.
➤ Keep other columns as-is for now.

1NF schema
OrderLines_1NF(
  OrderID,        -- part of PK
  BookISBN,       -- part of PK
  OrderDate,
  CustomerName,
  CustomerEmail,
  CustomerAddress,
  BookTitle,
  BookAuthor,
  UnitPrice,
  Quantity,
  LineTotal
  PRIMARY KEY (OrderID, BookISBN)
)

CustomerPhones_1NF(
  CustomerEmail,  -- we’ll temporarily use email to link phones
  PhoneNumber,
  PRIMARY KEY (CustomerEmail, PhoneNumber)
)

⚡Why this is 1NF now
➤ No multi-valued fields; phones are atomic and stored as separate rows.
➤ A row is uniquely identified by (OrderID, BookISBN).
➤ Column types are consistent.

Still redundant: Customer info depends only on OrderID; book info depends only on BookISBN. That’s the 2NF problem.

🌟 Second Normal Form (2NF):
✅ Precondition: Table(s) are in 1NF.

❗Rule: No partial dependency—every non-key attribute must depend on the entire composite key (when a composite key exists).

In OrderLines_1NF, the PK is (OrderID, BookISBN):
➤ OrderDate, CustomerName, CustomerEmail, CustomerAddress depend only on OrderID (part of the key) → partial dependency.
➤ BookTitle, BookAuthor, UnitPrice depend only on BookISBN (part of the key) → partial dependency.
➤ Quantity, LineTotal depend on both → fine.

Decompose to remove partial dependencies

2NF schema
Orders_2NF(
  OrderID PK,
  OrderDate,
  CustomerName,
  CustomerEmail,
  CustomerAddress
)

Books_2NF(
  BookISBN K,
  BookTitle,
  BookAuthor,
  UnitPrice
)

OrderItems_2NF(
  OrderID        -- part of PK, FK -> Orders_2NF(OrderID)
  BookISBN       -- part of PK, FK -> Books_2NF(BookISBN)
  Quantity,
  LineTotal,
  PRIMARY KEY (OrderID, BookISBN)
)

CustomerPhones_2NF(
  CustomerEmail,
  PhoneNumber,
  PRIMARY KEY (CustomerEmail, PhoneNumber)
)

🔗 What we gained
➤ No attribute in OrderItems_2NF depends only on part of its composite key.
➤ Book and customer order headers are stored once—redundancy drops.

Still an issue for 3NF: In Orders_2NF, CustomerName/Email/Address are really properties of a Customer, not of an Order. We also still keep LineTotal, which is derivable (Quantity × UnitPrice). That creates a transitive/derived dependency risk.

🌟 Third Normal Form (3NF)
✅ Precondition: In 2NF.
❗ Rule: No transitive dependency—non-key attributes must not depend on other non-key attributes.

What’s transitive here?

If we introduce a stable CustomerID, then:
➤ Orders would have CustomerID (FK) and non-key attributes like CustomerName/Email/Address would depend on CustomerID, not directly on OrderID → transitive dependency in Orders_2NF.
➤ LineTotal depends on Quantity and UnitPrice (the latter is in Books). It’s derivable, and storing it risks inconsistency.

🔄 Decompose & clean

Final 3NF schema
Customers(
  CustomerID     PK,
  CustomerName,
  CustomerEmail  UNIQUE,
  CustomerAddress
)

CustomerPhones(
  CustomerID     FK -> Customers(CustomerID),
  PhoneNumber,
  PRIMARY KEY (CustomerID, PhoneNumber)
)

Orders(
  OrderID        PK,
  OrderDate,
  CustomerID     FK -> Customers(CustomerID)
)

Books(
  BookISBN       PK,
  BookTitle,
  BookAuthor,
  UnitPrice
)

OrderItems(
  OrderID        FK -> Orders(OrderID),
  BookISBN       FK -> Books(BookISBN),
  Quantity,
  -- no LineTotal here (computed when needed)
  PRIMARY KEY (OrderID, BookISBN)
)
🔗 Why this is 3NF:
➤ In Orders, every non-key attribute (OrderDate, CustomerID) depends only on the key (OrderID), and nothing depends on another non-key attribute.
➤ Customer details live in Customers; phones in CustomerPhones with a clean 1-to-many.
➤ Book master data is in Books.
➤ OrderItems only has attributes that depend on the whole composite key (OrderID, BookISBN).
➤ Derived value LineTotal removed → no transitive/derived dependency.

Sample data (3NF)

📝 Customers
CustomerID | CustomerName | CustomerEmail | CustomerAddress
-----------------------------------------------------------
C001       | John Smith   | john@x.com    | 221B Baker St
C002       | Robert Ray   | rob@y.com     | 42 Galaxy Way

📝 CustomerPhones
CustomerID | PhoneNumber
------------------------
C001       | 98765
C001       | 91234
C002       | 99887

📝 Books
BookISBN | BookTitle     | BookAuthor   | UnitPrice
---------------------------------------------------
999-1    | SQL Basics    | Ada Lovelace | 500
999-2    | DB Design     | E. Codd      | 700

📝 Orders
OrderID | OrderDate   | CustomerID
-----------------------------------
101     | 2025-08-01  | C001
102     | 2025-08-02  | C002

📝 OrderItems
OrderID | BookISBN | Quantity
-----------------------------
101     | 999-1    | 1
101     | 999-2    | 2
102     | 999-2    | 1

🔄 Practical SQL (3NF):
Create tables
-- Master tables

CREATE TABLE Customers (
  CustomerID      VARCHAR(10) PRIMARY KEY,
  CustomerName    VARCHAR(100) NOT NULL,
  CustomerEmail   VARCHAR(150) UNIQUE NOT NULL,
  CustomerAddress VARCHAR(200) NOT NULL
);

CREATE TABLE CustomerPhones (
  CustomerID   VARCHAR(10) NOT NULL,
  PhoneNumber  VARCHAR(20) NOT NULL,
  PRIMARY KEY (CustomerID, PhoneNumber),
  FOREIGN KEY (CustomerID) REFERENCES Customers(CustomerID)
);

CREATE TABLE Books (
  BookISBN    VARCHAR(20) PRIMARY KEY,
  BookTitle   VARCHAR(150) NOT NULL,
  BookAuthor  VARCHAR(100) NOT NULL,
  UnitPrice   DECIMAL(10,2) NOT NULL
);

-- Transaction tables
CREATE TABLE Orders (
  OrderID     INT PRIMARY KEY,
  OrderDate   DATE NOT NULL,
  CustomerID  VARCHAR(10) NOT NULL,
  FOREIGN KEY (CustomerID) REFERENCES Customers(CustomerID)
);

CREATE TABLE OrderItems (
  OrderID    INT NOT NULL,
  BookISBN   VARCHAR(20) NOT NULL,
  Quantity   INT NOT NULL CHECK (Quantity > 0),
  PRIMARY KEY (OrderID, BookISBN),
  FOREIGN KEY (OrderID)  REFERENCES Orders(OrderID),
  FOREIGN KEY (BookISBN) REFERENCES Books(BookISBN)
);


⚡ Compute an order’s total (derived at query-time, no redundancy):
➤ SELECT
  oi.OrderID,
  SUM(oi.Quantity * b.UnitPrice) AS OrderTotal
FROM OrderItems oi
JOIN Books b ON b.BookISBN = oi.BookISBN
WHERE oi.OrderID = 101
GROUP BY oi.OrderID;

⚡ List line items with computed line totals:
➤ SELECT
  o.OrderID,
  o.OrderDate,
  c.CustomerName,
  b.BookTitle,
  oi.Quantity,
  (oi.Quantity * b.UnitPrice) AS LineTotal
FROM Orders o
JOIN Customers c   ON c.CustomerID = o.CustomerID
JOIN OrderItems oi ON oi.OrderID = o.OrderID
JOIN Books b       ON b.BookISBN = oi.BookISBN
WHERE o.OrderID = 101;

✅ Key takeaways (interview-friendly)
⚡ 1NF: Atomic values, no repeating groups; define a key.
⚡ 2NF: Remove partial dependencies from tables with composite keys (separate order header vs. book master vs. order items).
⚡ 3NF: Remove transitive dependencies (move customer details to Customers; drop derived LineTotal).

Result: minimal redundancy, better integrity; queries use joins to rebuild the full picture.

🔷 Spring Data JPA
Spring Data JPA is a Spring framework project built on top of JPA (Java Persistence API) that makes database access and persistence operations easier.

👉 In short:
➤ JPA = Specification (interfaces & annotations, no implementation).
➤ Hibernate = Implementation of JPA.
➤ Spring Data JPA = Abstraction layer that makes working with JPA implementations (like Hibernate) much easier.

🔹 Why Spring Data JPA?
Without it, you’d need to write a lot of boilerplate DAO code like this:

public class EmployeeRepository {
    @PersistenceContext
    private EntityManager em;

    public void save(Employee emp) {
        em.persist(emp);
    }

    public Employee findById(Long id) {
        return em.find(Employee.class, id);
    }
}

With Spring Data JPA, this becomes:
public interface EmployeeRepository extends JpaRepository<Employee, Long> {
}
✅ Done. Spring auto-generates the implementation at runtime.

🌟 Key Features
🔄 Repository Abstractions
➤ Provides ready-made repository interfaces:
  🔗 CrudRepository<T, ID> → basic CRUD.
  🔗 JpaRepository<T, ID> → CRUD + pagination + sorting.
➤ No need to implement DAO manually.

🔄 Derived Query Methods
Spring parses method names and generates SQL automatically.

Example:
List<Employee> findByDepartment(String department);
List<Employee> findBySalaryGreaterThan(double salary);
👉 These automatically generate SELECT queries.

🔄 Custom Queries with JPQL / Native SQL
➤ Use @Query annotation for custom queries:
@Query("SELECT e FROM Employee e WHERE e.salary > :salary")
List<Employee> findHighEarners(@Param("salary") double salary);

➤ Native SQL also supported:
@Query(value = "SELECT * FROM employee WHERE department = :dept", nativeQuery = true)
List<Employee> findByDept(@Param("dept") String dept);

🔄 Pagination and Sorting
➤ Built-in support:
Page<Employee> findAll(Pageable pageable);
List<Employee> findAll(Sort sort);

🔄 Transaction Management
➤ Integrated with Spring’s @Transactional.
➤ Spring handles opening, committing, rolling back transactions automatically.

🔄 Auditing
➤ Track createdBy, createdDate, lastModifiedBy, lastModifiedDate with annotations:
@CreatedDate
private LocalDateTime createdAt;

⚡ How it Works Behind the Scenes
➤ You declare a repository interface (e.g., EmployeeRepository extends JpaRepository<Employee, Long>).
➤ At runtime, Spring Data JPA creates a proxy implementation of this interface.
➤ The proxy internally uses EntityManager (from JPA) → which is backed by Hibernate (default in Spring Boot).
➤ SQL queries are generated based on:
  🔗 Method name conventions (e.g., findByName).
  🔗 @Query annotations.
  🔗 Default CRUD methods from JpaRepository.

📌 Repository Layer in Spring Boot
➤ The Repository Layer in Spring Boot is the layer that interacts with the database.
➤ It provides predefined methods to perform CRUD (Create, Read, Update, Delete) operations without writing SQL queries.
➤ It is built on Spring Data JPA, which internally uses Hibernate (by default) for ORM.

⚡ How It Works
➤ Instead of writing your own DAO (Data Access Object) classes with JDBC/Hibernate queries,
you just create an interface that extends one of Spring Data JPA’s repository interfaces.
➤ Spring Boot automatically creates the implementation at runtime.

Example:
public interface EmployeeRepository extends JpaRepository<Employee, Integer> {
}
Here:
Employee → Entity class
Integer → Primary Key type

🔄 Common Utility Methods
Repository interfaces provide many ready-made methods, such as:

🔧 save(entity) → Insert or update entity in DB
🔧 findById(id) → Retrieve entity by primary key
🔧 findAll() → Get all records
🔧 delete(entity) → Delete a record
🔧 deleteById(id) → Delete by primary key
🔧 count() → Count total records

🔄 Custom Query Methods
You can also define custom finder methods just by following naming conventions.

Example:
List<Employee> findByName(String name);
List<Employee> findBySalaryGreaterThan(float salary);
👉 Spring Data JPA automatically generates queries for these methods.

🔄 Industry-level Use
➤ In enterprise applications, Repository Layer is where all database interaction is isolated.
➤ The Service Layer calls the Repository Layer, and repository handles DB operations.
➤ This ensures separation of concerns and clean architecture.  

📌 Dependency Injection (DI) in Spring Boot➤ 
➤ Dependency Injection (DI) is a design pattern where an object’s dependencies (other objects it needs to work) are provided (injected) by the Spring Framework instead of the class creating them manually.
➤ Spring Boot manages the creation, configuration, and lifecycle of these dependencies at runtime.

🔄 Analogy
👉 Think of building a house:
You need bricks, cement, wood.
Instead of making these materials yourself, you ask suppliers to provide them.

Similarly, your class does not create its required objects itself; Spring provides them automatically.

🔄 Why Use DI?
✅ Loose Coupling
➤ Classes do not depend on how objects are created, only on what they can do.
➤ Easier to swap implementations (e.g., change from MySQL DB to MongoDB without modifying business logic).

✅ Automatic Lifecycle Management
➤ Spring controls the object creation, initialization, and destruction.
➤ You don’t need to manually manage memory or cleanup.

🔄 Improved Testability
Since dependencies are injected, you can easily mock objects for unit testing.

🔄 Types of Dependency Injection in Spring Boot
📝 Constructor Injection ✅ (Most recommended in modern Spring Boot)

@Service
public class EmployeeService {
    private final EmployeeRepository employeeRepository;

    // Constructor Injection
    public EmployeeService(EmployeeRepository employeeRepository) {
        this.employeeRepository = employeeRepository;
    }
}

📝 Setter Injection
@Service
public class EmployeeService {
    private EmployeeRepository employeeRepository;

    @Autowired
    public void setEmployeeRepository(EmployeeRepository employeeRepository) {
        this.employeeRepository = employeeRepository;
    }
}

📝 Field Injection ❌ (Not recommended for large apps, but commonly seen in small projects)
@Service
public class EmployeeService {
    @Autowired
    private EmployeeRepository employeeRepository;
}

🔄 How DI Works in Spring Boot
➤ Spring Boot scans the project for classes annotated with @Component, @Service, @Repository, @Controller, etc.
➤ It creates objects (called Spring Beans) of these classes.
➤ Whenever another class requires these objects, Spring injects them automatically (instead of you writing new).

Example:
@RestController
public class EmployeeController {

    private final EmployeeService employeeService;

    // Constructor Injection
    public EmployeeController(EmployeeService employeeService) {
        this.employeeService = employeeService;
    }

    @GetMapping("/employees")
    public List<Employee> getAllEmployees() {
        return employeeService.getEmployees();
    }
}

👉 Here:
➤ EmployeeController depends on EmployeeService.
➤ Spring Boot automatically injects an instance of EmployeeService.

🌱 Spring IoC (Inversion of Control)
➤ IoC (Inversion of Control) is the principle where the control of object creation and management is transferred from the developer to the Spring IoC Container.
➤ In simple words: You don’t control the objects, Spring does.

🔄 Spring IoC Container
➤ Core of the Spring Framework.
➤ Responsible for:
  🔗 Creating objects (beans)
  🔗 Configuring them
  🔗 Injecting dependencies (DI)
  🔗 Managing their lifecycle

🔄 How It Works
➤ You annotate/configure classes with @Component, @Service, @Repository, @Controller etc.
➤ Spring IoC Container scans the project, finds these beans, and creates objects automatically.
➤ Dependencies between beans are resolved using Dependency Injection (DI).

🔄 Advantages
➤ Promotes loose coupling (objects don’t create their dependencies).
➤ Makes applications modular and testable.
➤ Simplifies configuration and lifecycle management.

🔄 Analogy
👉 Think of a restaurant:
➤ You don’t cook yourself; you just order.
➤ The kitchen (IoC Container) manages all cooking, preparation, and delivery.
➤ Similarly, you just define what you need, and Spring IoC takes care of how it’s created and managed.

🌀 Spring Bean Lifecycle
📝 Lifecycle Stages
➤ Bean Creation
  🔗 Spring IoC creates the bean object.
  🔗 Example: using @Component or configuration class.

➤ Dependency Injection
Dependencies are injected (e.g., using @Autowired or constructor injection).

➤ Initialization (Optional Hooks)
If the bean implements InitializingBean or has @PostConstruct method → executed here.

➤ Execution (In Use)
The bean is ready to be used by the application.

➤ Destruction
  🔗 When the application context shuts down, Spring destroys the bean.
  🔗 Example: @PreDestroy method or DisposableBean interface.

✔️ Diagram (Flow)
Bean Instantiation 
       ↓
Dependencies Injection (@Autowired)
       ↓
Initialization (@PostConstruct, afterPropertiesSet)
       ↓
Bean is Ready (used by app)
       ↓
Destruction (@PreDestroy, destroy())

Example
@Component
public class MyBean implements InitializingBean, DisposableBean {

    @Override
    public void afterPropertiesSet() {
        System.out.println("Bean is initialized");
    }

    @Override
    public void destroy() {
        System.out.println("Bean is destroyed");
    }
}

✅ JUnit in Spring Boot (Unit Testing)
➤ JUnit is a testing framework used in Java to perform unit testing.
➤ In unit testing (white-box testing), we test individual pieces of code (methods, classes) rather than the whole application.
➤ Spring Boot projects by default include the JUnit library, so you don’t need to add it manually.

⚡ Important Annotations in JUnit
🔄 @Test
➤ Marks a method as a test case.
➤ JUnit will execute this method and report PASS / FAIL based on output or assertions.
➤ Multiple @Test methods can exist in one class, each runs independently.

🔄 @BeforeEach
➤ Runs before every @Test method.
➤ Usually used for setting up resources or initialization.

🔄 @AfterEach
➤ Runs after every @Test method.
➤ Used for cleanup activities (e.g., closing DB connections).

🔄 @BeforeAll
➤ Runs once before all tests in the class.
➤ Must be static.
➤ Used for global setup (e.g., starting an in-memory database).

🔄 @AfterAll
➤ Runs once after all tests in the class.
➤ Must be static.
➤ Used for global cleanup (e.g., stopping server, closing shared resources).

🖥️ Example Code
package com.demo1;

import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class Demo1ApplicationTests {

    // This runs ONCE before any test method
    @BeforeAll
    public static void beforeAll() {
        System.out.println(">>> Before All - Runs only once before all tests");
    }

    // This runs BEFORE EACH test method
    @BeforeEach
    public void beforeTest() {
        System.out.println(">>> Before Each - Runs before every test case");
    }

    // Test case 1
    @Test
    void test1() {
        System.out.println(">>> Executing Test 1");
    }

    // Test case 2
    @Test
    void test2() {
        System.out.println(">>> Executing Test 2");
    }

    // This runs AFTER EACH test method
    @AfterEach
    public void afterTest() {
        System.out.println(">>> After Each - Runs after every test case");
    }

    // This runs ONCE after all test methods have executed
    @AfterAll
    public static void afterAll() {
        System.out.println(">>> After All - Runs only once after all tests");
    }
}

📌 Expected Execution Flow
When you run the test class, JUnit will call methods in the following order:

>>> Before All - Runs only once before all tests
>>> Before Each - Runs before every test case
>>> Executing Test 1
>>> After Each - Runs after every test case
>>> Before Each - Runs before every test case
>>> Executing Test 2
>>> After Each - Runs after every test case
>>> After All - Runs only once after all tests


✅ What is SessionFactory in Hibernate?
➤ SessionFactory is a core interface in Hibernate.
➤ It is responsible for establishing database connections and creating Session objects.
➤ It is thread-safe (can be shared across threads) and is usually created once per application.

🔑 Key Responsibilities of SessionFactory
➤ Database Connection Management
✔️ Reads the configuration (hibernate.cfg.xml or persistence.xml).
✔️ Creates a connection pool internally.

➤ Session Creation
Creates Session objects, which are lightweight, non-thread-safe objects used for CRUD operations.

➤ Caching
Provides first-level cache (Session) and optional second-level cache (SessionFactory scope).

➤ Metadata Storage
Stores mapping metadata of entities (@Entity classes ↔ DB tables).

🔷Difference between Session and SessionFactory
| Feature       | SessionFactory                         | Session                       |
| ------------- | -------------------------------------- | ----------------------------- |
| Creation Cost | Heavyweight (expensive to create)      | Lightweight                   |
| Thread-Safe   | ✅ Yes                                  | ❌ No                          |
| Lifetime      | Application-level (one per DB)         | Request/transaction level     |
| Purpose       | Manages connections + creates sessions | Performs CRUD operations      |
| Caching Scope | 2nd level cache (shared)               | 1st level cache (per session) |

🧠 If asked "How many SessionFactory objects should an application have?" Answer: Only one per database (singleton).
Because it is a heavyweight object and creating multiple instances can slow down performance.


🔷 Optional Class
➤ Optional<T> is a container object introduced in Java 8.
➤ It may or may not contain a non-null value.
➤ It is an alternative to null checks and helps avoid NullPointerException (NPE).

🔑 Why Optional?
➤ Traditionally, developers used null values to represent "no result".
➤ This often caused NullPointerExceptions if we forgot to check null.
➤ Optional provides a safe, expressive, and functional way to represent an absent value.


🛠 Common Methods in Optional
👉 Creating Optional Objects
✅Code Example: 
Optional<String> emptyOpt = Optional.empty();              // Empty Optional
Optional<String> valueOpt = Optional.of("Hello");          // Must not be null
Optional<String> nullableOpt = Optional.ofNullable(null);  // Can be null

👉 Checking Value
✅Code Example: 
if (valueOpt.isPresent()) {
    System.out.println(valueOpt.get()); // Safe to call get()
}

👉 Default Value Handling
✅Code Example: 
String result = nullableOpt.orElse("Default Value");
System.out.println(result);

👉 Lazy Default Value
✅Code Example: 
String result = nullableOpt.orElseGet(() -> "Generated Default");

👉 Throw Exception if Empty
✅Code Example: 
String result = nullableOpt.orElseThrow(() -> new RuntimeException("Value not present"));

👉 Functional Style (map, filter, ifPresent)
✅Code Example: 
Optional<String> nameOpt = Optional.of("Ankur");

nameOpt
    .filter(name -> name.startsWith("A"))
    .map(String::toUpperCase)
    .ifPresent(System.out::println); // Output: ANKUR

⚡ Example Use Case in Repository Layer (Spring Boot)
❌ Instead of:
User user = userRepository.findById(1);
if (user != null) {
    System.out.println(user.getName());
}

✅ We use:
Optional<User> userOpt = userRepository.findById(1);
userOpt.ifPresent(user -> System.out.println(user.getName()));
➤ This avoids NullPointerException if the user is not found.   

🆚 Key Difference: null vs Optional
| Feature     | null                                  | Optional                            |
| ----------- | ------------------------------------- | ----------------------------------- |
| Meaning     | Absence of value                      | Explicit container for absent value |
| Safety      | Prone to NPE                          | Safe API methods                    |
| Readability | Requires many `if (x != null)` checks | Cleaner, expressive                 |
| Usage       | Legacy style                          | Modern (Java 8+)                    |


💡 Tip:
If asked "Is Optional a replacement for null?"
Say:
👉 No, it’s not a complete replacement. It is a wrapper to handle null values safely in functional style, especially useful in APIs and return types.



🔷 Perform CRUD Operation using Hibernate in Spring Boot

🟢 Step 1: Database Configuration (application.properties)
spring.datasource.url=jdbc:mysql://localhost:3306/database_name (use snake casing for the DB name)
spring.datasource.username=root (username)
spring.datasource.password=test (password)

➤ Hibernate DDL (Data Definition Language) options:
  ✔️ create  → Drops table if exists, creates a new one every time project restarts
  ✔️ update  → Creates table if not exists, else updates schema without dropping data
spring.jpa.hibernate.ddl-auto=update

🟢 Step 2: Entity Class Explanation (Hibernate + Spring Boot)
package com.democrud.entity;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;

@Entity
@Table(name="employees")
public class Employee {
	
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY) 
	private long id;
	
	@Column(name = "first_name", nullable = false, length = 45)
	private String firstName;
	
	@Column(name = "last_name", nullable = false, length = 45)
	private String lastName;
	
	@Column(name = "email_id", nullable = false, length = 256, unique = true)
	private String emailId;
	
	@Column(name="mobile", nullable = false, unique = true)
	private String mobile;

    // Getters & Setters ...
}

🔄 Annotations
🔗 @Entity
➤ Marks this class as an Entity → Hibernate will map it to a database table.
➤ Without this, Hibernate will ignore the class.

🔗 @Table(name="employees")
➤ Specifies the table name in the database.
➤ If you don’t use it → Hibernate will create a table with default name = class name (Employee).
➤ Here, it will create/use a table called employees.

🔗 @Id
➤ Defines the Primary Key of the entity.
➤ Every entity must have one @Id field.

🔗 @GeneratedValue(strategy = GenerationType.IDENTITY)
➤ Tells Hibernate how to generate the primary key values.
➤ IDENTITY → Database will auto-generate the ID using auto-increment (common in MySQL, PostgreSQL).

Alternative strategies:
➤ AUTO → Hibernate chooses best strategy automatically.
➤ SEQUENCE → Uses DB sequence (common in Oracle).
➤ TABLE → Uses a special table to generate IDs.

🔗 @Column
➤ Maps a class field to a specific column in the DB.
➤ Attributes:
  ✔️ name → Column name in DB (different from field name).
  ✔️ nullable = false → Cannot be NULL in DB.
  ✔️ length → Defines max length of VARCHAR.
  ✔️ unique = true → Makes column values unique.

✅ Examples here:
➤ firstName → first_name VARCHAR(45) NOT NULL
➤ lastName → last_name VARCHAR(45) NOT NULL
➤ emailId → email_id VARCHAR(256) UNIQUE NOT NULL
➤ mobile → mobile VARCHAR(?) UNIQUE NOT NULL


🟢 Step 3: Repository Layer Explanation
package com.democrud.repository;

import org.springframework.data.repository.CrudRepository;
import com.democrud.entity.Employee;

public interface EmployeeRepository extends CrudRepository<Employee, Long> {
}

🔎 Breakdown:
⚡ EmployeeRepository
➤ An interface, not a class.
➤ Extends CrudRepository<Employee, Long>

⚡ CrudRepository<T, ID>
➤ A Spring Data JPA interface that provides ready-made CRUD methods.
➤ Here:
  ✔️ T = Employee → Entity type
  ✔️ ID = Long → Primary key type

⚡ No need to implement methods
➤ Spring Data JPA automatically generates implementations for you at runtime.
➤ So you don’t have to write SQL/JPQL manually for basic operations.


🟢 Step 4: Service Layer Explanation (Performing Unit Test)
package com.democrud;

import java.util.Optional;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import com.democrud.entity.Employee;
import com.democrud.repository.EmployeeRepository;

@SpringBootTest
class DemocrudApplicationTests {
	
	
	@Autowired
	private EmployeeRepository employeeRepository;

	@Test
	void saveRecord() {
		Employee emp = new Employee();
		emp.setFirstName("adam");
		emp.setLastName("a");
		emp.setEmailId("adam@gmail.com");
		emp.setMobile("9632629455");
		employeeRepository.save(emp);
	}

➤ Creates a new Employee object.
➤ Calls save().
📌 Hibernate generates:
🔗 INSERT INTO employees (first_name, last_name, email_id, mobile) 
VALUES ('adam', 'a', 'adam@gmail.com', '9632629455');

	@Test
	void deleteRecord() {
		employeeRepository.deleteById(3L);
	}

➤ Deletes row with ID = 3.
📌 Hibernate generates:
🔗 DELETE FROM employees WHERE id = 3;

	@Test
	void getRecordById() {
		Optional<Employee> opEmp = employeeRepository.findById(1L);
		if(opEmp.isPresent()) {
			Employee employee = opEmp.get();
			System.out.println(employee.getId());
			System.out.println(employee.getFirstName());
			System.out.println(employee.getLastName());
			System.out.println(employee.getEmailId());
		}else {
			System.out.println("No record Found");
		}
	}

➤ Fetches record with ID = 1.
➤ Uses Optional to avoid NullPointerException.
📌 Hibernate generates:
🔗 SELECT * FROM employees WHERE id = 1;
	
	@Test
	void getRecords() {
		Iterable<Employee> itrEmp = employeeRepository.findAll();
		for (Employee employee: itrEmp) {
			System.out.println(employee.getId());
			System.out.println(employee.getFirstName());
			System.out.println(employee.getLastName());
			System.out.println(employee.getEmailId());
		}
	}

➤ Fetches all employees.
📌 Hibernate generates:
🔗 SELECT * FROM employees;
	
	
	@Test
	void countRecords() {
		long count = employeeRepository.count();
		System.out.println(count);
	}
}

➤ Counts total rows in table.
📌 Hibernate generates:
🔗 SELECT COUNT(*) FROM employees;

✅ What This Unit Test Class Does
➤ This class (DemocrudApplicationTests) is testing your repository layer using Spring Boot + JUnit.
➤ @SpringBootTest → Boots the entire Spring context, loads beans (EmployeeRepository) so you can use dependency injection.
➤ @Autowired EmployeeRepository → Injects repository so tests can directly call CRUD methods.

👉 Pro tip: If you want to actually see SQL queries in the console, add this to your application.properties:
✔️ spring.jpa.show-sql=true
✔️ spring.jpa.properties.hibernate.format_sql=true


🔷 Finder Methods in Hibernate (Spring Data JPA)
➤ Finder methods are custom query methods that you define inside your repository interface.
➤ They allow you to fetch data based on specific conditions without writing SQL or JPQL manually.
➤ Spring Data JPA derives the query automatically by analyzing the method name.

✅ How Hibernate Works Behind the Scenes
➤ For each finder method:
  ✔️ Spring Data JPA parses the method name.
  ✔️ Converts it into a JPQL query.
  ✔️ Hibernate translates JPQL → SQL and executes it.

✅ Why Finder Methods are Useful
➤ No need to write SQL / JPQL queries manually.
➤ Easy to read and maintain.
➤ Spring Data JPA + Hibernate auto-generates queries → saves development time.
➤ Makes your repository layer clean and declarative.  

📌 Rules & Keywords for Writing Finder Methods in Spring Data JPA
⚡ Start with a Recognized Prefix
➤ Every finder method must start with one of these prefixes:
🔗 findBy... → fetch data
🔗 readBy... → alias of findBy
🔗 queryBy... → alias of findBy
🔗 getBy... → alias of findBy
🔗 countBy... → count records matching condition
🔗 existsBy... → check if record exists
🔗 deleteBy... / removeBy... → delete records

✅Example:
Optional<Employee> findByEmailId(String email);
long countByLastName(String lastName);
boolean existsByMobile(String mobile);

⚡ Use Property Names Exactly
➤ After the prefix, write your entity field name (case-sensitive with camelCase).
➤ Must match the Java property in the Entity, not the column name in DB.

✅ Example (Entity field = firstName)
List<Employee> findByFirstName(String firstName);
❌ Wrong: findByfirst_name (uses DB column name).

⚡ Combine Multiple Conditions with Keywords
You can combine fields with:
  ✔️  And
  ✔️  Or

✅ Examples:
List<Employee> findByFirstNameAndLastName(String first, String last);
List<Employee> findByFirstNameOrLastName(String first, String last);

👉 Generated JPQL:
SELECT e FROM Employee e WHERE e.firstName = ? AND e.lastName = ?;

⚡ Use Comparison Keywords
➤ Spring Data JPA supports many keywords after field names:
🔗 Is, Equals → exact match
🔗 Not → not equal
🔗 LessThan, GreaterThan, Between → comparisons
🔗 Like, Containing, StartingWith, EndingWith → pattern matching
🔗 In → matches in a list
🔗 True, False → for boolean fields

✅Example:
List<Employee> findBySalaryGreaterThan(double salary);
List<Employee> findByFirstNameContaining(String keyword);
List<Employee> findByFirstNameStartingWith(String prefix);
List<Employee> findByFirstNameEndingWith(String suffix);
List<Employee> findByIdIn(List<Long> ids);
List<Employee> findByActiveTrue();   // only active employees

⚡ Order the Results
➤ Add OrderBy keyword followed by field name + direction (Asc / Desc).

✅ Example:
List<Employee> findByLastNameOrderByFirstNameAsc(String lastName);

👉 SQL:
SELECT * FROM employees WHERE last_name=? ORDER BY first_name ASC;

🔄 Return Types
➤ Finder methods can return:
  ✔️ Single entity (Employee)
  ✔️ Optional<Employee> (preferred for safety)
  ✔️ List/Collection (List<Employee>)
  ✔️ Page<Employee> or Slice<Employee> (for pagination)
  ✔️ Stream<Employee>

✅ Repository (Updated)  
package com.democrud.repository;

import java.util.List;
import java.util.Optional;

import org.springframework.data.repository.CrudRepository;

import com.democrud.entity.Employee;

public interface EmployeeRepository extends CrudRepository<Employee, Long> {

    // Exact matches
    Optional<Employee> findByEmailId(String email);
    Optional<Employee> findByMobile(String mobile);

    // Existence checks
    boolean existsByEmailId(String email);
    boolean existsByMobile(String mobile);

    // Count records
    long countByEmailId(String email);

    // Pattern matching
    List<Employee> findByFirstNameContaining(String keyword);   // anywhere
    List<Employee> findByFirstNameStartingWith(String prefix);  // starts with
    List<Employee> findByFirstNameEndingWith(String suffix);    // ends with

    // You can add more if needed:
    List<Employee> findByFirstNameAndLastName(String firstName, String lastName);
    List<Employee> findByEmailIdIn(List<String> emails);
    List<Employee> findByFirstNameOrderByLastNameAsc(String firstName);
}

✅ Test Class
package com.democrud;

import java.util.List;
import java.util.Optional;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import com.democrud.entity.Employee;
import com.democrud.repository.EmployeeRepository;

@SpringBootTest
class DemocrudApplicationTests {

    @Autowired
    private EmployeeRepository employeeRepository;

    @Test
    void findByEmail() {
        employeeRepository.findByEmailId("adam@gmail.com").ifPresentOrElse(
            emp -> System.out.println("Found: " + emp.getFirstName()),
            () -> System.out.println("No record Found")
        );
    }

    @Test
    void findByMobile() {
        employeeRepository.findByMobile("9632629455").ifPresentOrElse(
            emp -> System.out.println("Found: " + emp.getFirstName()),
            () -> System.out.println("No record Found")
        );
    }

    @Test
    void existsByEmail() {
        System.out.println(employeeRepository.existsByEmailId("adam1@gmail.com")
            ? "Record exists" : "No record Found");
    }

    @Test
    void existsByMobile() {
        System.out.println(employeeRepository.existsByMobile("9632629455")
            ? "Record exists" : "No record Found");
    }

    @Test
    void countByEmail() {
        System.out.println("Count: " + employeeRepository.countByEmailId("adam@gmail.com"));
    }

    @Test
    void containingLetter() {
        List<Employee> employees = employeeRepository.findByFirstNameContaining("m");
        employees.forEach(e -> System.out.println(e.getFirstName()));
    }

    @Test
    void startingLetter() {
        List<Employee> employees = employeeRepository.findByFirstNameStartingWith("A");
        employees.forEach(e -> System.out.println(e.getFirstName()));
    }

    @Test
    void endingLetter() {
        List<Employee> employees = employeeRepository.findByFirstNameEndingWith("m");
        employees.forEach(e -> System.out.println(e.getFirstName()));
    }
}


⚡ Key Improvements made:
✅ Used ifPresentOrElse() (Java 9+) for cleaner Optional handling.
✅ Added System.out.println("...") confirmations after save/delete for clarity.
✅ Consistent method naming (startingLetter, not StaringLetter).
✅ Used lambda expressions for cleaner iteration.
✅ Added extra useful finder methods (And, In, OrderBy).