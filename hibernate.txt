ğŸ”· Hibernate
â¤ Hibernate is an Object Relational Mapping (ORM) framework in Java.
â¤ It maps Java classes to database tables and Java objects to table rows.
â¤ It removes the need to write raw SQL queries by providing an abstraction layer.
â¤ CRUD operations are automated and handled internally by Hibernate.
â¤ It is an implementation of JPA (Java Persistence API) specification.

ğŸ”·  Features of Hibernate
ğŸ‘‰ ORM support â†’ Direct mapping between Java objects and database tables.
ğŸ‘‰ Database Independent â†’ Code works with multiple RDBMS without changes.
ğŸ‘‰ HQL (Hibernate Query Language) â†’ Object-oriented query language.
ğŸ‘‰ Caching support â†’ Improves performance using first-level and second-level cache.
ğŸ‘‰ Lazy Loading â†’ Data fetched only when required.
ğŸ‘‰ Automatic Table Creation â†’ Schema generation can be managed.
ğŸ‘‰ Transaction Management â†’ Integrated with Java Transaction API(JTA) and Java Database connectivity(JDBC) transactions.

ğŸ”· Advantages of Hibernate
â¤ Eliminates boilerplate JDBC code.
â¤ Portable across different databases.
â¤ Improved productivity â†’ Less code, more functionality.
â¤ HQL provides flexibility compared to SQL.
â¤ Performance optimization using caching and batch fetching.
â¤ Easy relationship management between entities (@OneToOne, @OneToMany, etc.).

ğŸ”· Hibernate Architecture
ğŸŒŸ Application Starts â†’ Configuration Loaded
â¤ Hibernate first loads its configuration (usually hibernate.cfg.xml or application.properties in Spring Boot).
â¤ This file contains:
    ğŸ”— DB connection info (URL, username, password).
    ğŸ”— Hibernate dialect (e.g., MySQLDialect).
    ğŸ”— Entity class mappings (Employee.class, etc.).
â¤ Hibernate builds a Configuration object in memory.

ğŸŒŸ SessionFactory Creation
â¤ From the configuration, Hibernate creates a SessionFactory.
â¤ SessionFactory is a heavyweight, thread-safe object, created once per application.
â¤ It:
    ğŸ”— Reads all mappings (e.g., @Entity annotations).
    ğŸ”— Prepares SQL templates for CRUD operations.
    ğŸ”— Maintains a connection pool.
ğŸ‘‰ Think of SessionFactory as a blueprint for working with the database.

ğŸŒŸ Session Opening
â¤ When you need to interact with DB, you call:
â¤ Session session = sessionFactory.openSession();
Session is a lightweight, short-lived object (not thread-safe).
â¤ It represents a unit of work with the database.

ğŸŒŸ Transaction Begins
â¤ Hibernate uses Transaction API (backed by JDBC or JTA).
â¤ When you call:
    Transaction tx = session.beginTransaction();
â¤ Hibernate ensures ACID properties:
    All queries either succeed (commit) or fail together (rollback).

ğŸŒŸ Object State Management
Hibernate tracks objects in three states:
âœ”ï¸ Transient â†’ new Java object (not linked to DB/session).
âœ”ï¸ Persistent â†’ after calling session.save(obj), Hibernate tracks it. Any changes are auto-synced to DB.
âœ”ï¸ Detached â†’ once the session is closed, objects are no longer tracked.

ğŸŒŸ Hibernate Converts Objects â†’ SQL
Example:
Employee emp = new Employee();
emp.setId(1);
emp.setName("John");
emp.setSalary(50000);
session.save(emp);

Behind the scenes, Hibernate generates SQL:
insert into Employee (id, name, salary) values (1, 'John', 50000);

â¤ Hibernate uses Dialect (e.g., MySQLDialect, OracleDialect) to generate SQL that matches the DB vendor.
â¤ It then executes the query via JDBC internally.

ğŸŒŸ Caching & Optimization
â¤ Hibernate uses First-Level Cache (Session scope) automatically â†’ if you call session.get(Employee.class, 1) multiple times in the same session, Hibernate only queries the DB once.
â¤ It can also use Second-Level Cache (SessionFactory scope) to cache data across sessions.

ğŸŒŸ Transaction Commit or Rollback
â¤ On tx.commit():
    ğŸ”— Hibernate flushes all pending changes (dirty checking).
    ğŸ”— Executes SQL statements.
    ğŸ”— Commits the JDBC/JTA transaction.
â¤ On tx.rollback():
    ğŸ”— All operations are discarded.

ğŸŒŸ Session Close
â¤ After commit/rollback, the session is closed:
session.close();
â¤ Persistent objects become detached.
â¤ Sessionâ€™s first-level cache is cleared.

âœ…Flow:
Application â†’ SessionFactory â†’ Session â†’ Transaction â†’ Database

ğŸ”·Difference between Hibernate and JDBC
| Aspect                     | JDBC (Java Database Connectivity)                                                                   | Hibernate                                                                             |
| -------------------------- | ------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------- |
| Definition             | A Java API to connect and execute SQL statements directly with relational databases.                | An ORM framework that maps Java objects to database tables and automates persistence. |
| Level of Work          | Low-level â†’ You write SQL manually and handle DB logic.                                                 | High-level â†’ Works with Java objects, Hibernate generates SQL.                            |
| Boilerplate Code       | Requires a lot of code (`Connection`, `Statement`, `ResultSet`, exception handling, closing resources). | Minimal code â†’ Hibernate manages connection, query execution, mapping automatically.      |
| Query Language         | Uses SQL (Structured Query Language).                                                               | Uses HQL (Hibernate Query Language) and Criteria API (object-oriented queries).       |
| Database Independence  | SQL is database-specific â†’ migration to another DB requires changes.                                | Database-independent â†’ Hibernate dialects handle DB differences.                          |
| Mapping                | Manual â†’ you map ResultSet columns to Java objects.                                                     | Automatic ORM mapping between Java class and DB table.                                    |
| Transaction Management | Manual â†’ developer must call `commit()` / `rollback()`.                                                 | Built-in â†’ integrates with JDBC or JTA for transaction handling.                  |
| Caching                | No caching â†’ always hits the database.                                                                  | Built-in First-level & Second-level caching for performance.                          |
| **Relationships          | Developer must handle foreign keys manually with SQL joins.                                             | Relationships (`@OneToOne`, `@OneToMany`, `@ManyToMany`) handled automatically.           |
| Productivity           | Lower â†’ more boilerplate, repetitive work.                                                              | Higher â†’ less code, faster development.                                                   |


âœ…Example Code Snippet: Entity Class Employee

@Entity
public class Employee {	
	@Id
	private int id;
	private String name;
	private float salary;
	
	//setters
	public void setId(int id) {
		this.id = id;
	}
	
	public void setName(String name) {
		this.name = name;
	}
	
	public void setSalary(float salary) {
		this.salary = salary;
	}

	//Getters
	public int getId() {
		return id;
	}

	public String getName() {
		return name;
	}

	public float getSalary() {
		return salary;
	}	
}

âš¡ Explanation:
â¤ @Entity â†’ tells Hibernate: â€œThis class should be mapped to a database table.â€
â¤ By default, table name = class name (Employee).
â¤ @Id â†’ tells Hibernate which field is the primary key column in the table.
â¤ Other fields (name, salary) will be mapped as columns in the table.

âœ…Flow Diagram:
Employee class  <-->  Employee table
id              <-->  primary key column
name            <-->  column name
salary          <-->  column salary

ğŸ”· Hibernate Annotations
âœ”ï¸ @Entity â†’ Marks a class as an entity.
âœ”ï¸ @Table(name="...") â†’ Maps class to table.
âœ”ï¸ @Id â†’ Marks primary key field.
âœ”ï¸ @GeneratedValue â†’ Defines primary key generation strategy.
âœ”ï¸ @Column(name="...") â†’ Maps property to a column.

Relationships:
âœ”ï¸ @OneToOne
âœ”ï¸ @OneToMany
âœ”ï¸ @ManyToOne
âœ”ï¸ @ManyToMany

ğŸ”· JPA
ğŸ‘‰JPA (Java Persistence API) is a specification, not an implementation.
ğŸ‘‰It defines a standard set of interfaces, annotations, and rules for persisting Java objects into relational databases.
ğŸ‘‰JPA itself does not provide the actual code â€” itâ€™s like a contract that ORM tools must follow.

Example JPA annotations:
@Entity, @Id, @Table, @Column

Example JPA interface:
EntityManager (similar to Hibernateâ€™s Session)

ğŸ‘‰ Think of JPA as a blueprint: It only says â€œthis is how persistence should be doneâ€, but does not do the work itself.

ğŸ”· Relation between Hibernate and JPA
â¤ Hibernate is an implementation of JPA.
â¤ It provides the actual code that fulfills JPA specifications.
â¤ It extends JPA and adds extra features not covered by JPA, like:
    ğŸ”— Hibernate Query Language (HQL)
    ğŸ”— Advanced caching
    ğŸ”— Better performance tuning options

â¤ Other JPA implementations besides Hibernate:
    ğŸ”— EclipseLink
    ğŸ”— OpenJPA
    ğŸ”— DataNucleus

ğŸ‘‰ Think of Hibernate as a real car built from JPAâ€™s design:
JPA = design/specification
Hibernate = actual car (with even more features)

âœ… Tip:
What is the difference between JPA and Hibernate?
âœ”ï¸ JPA is a specification (interfaces + annotations, no implementation).
âœ”ï¸ Hibernate is an implementation of JPA, plus it offers additional features.
âœ”ï¸ So, when you write JPA code, youâ€™re usually running it on Hibernate underneath.

ğŸ”· Hibernate Mappings

ğŸŒŸ OneToMany Mapping
â¤ One record in Table A is related to multiple records in Table B.
â¤ Annotation: @OneToMany
âœ… Example:
    1. In an E-commerce application, one Customer can have multiple Delivery Addresses saved in their profile.
    2. In a Banking system, one Bank Branch can have multiple Accounts.
    3. In a Healthcare system, one Doctor can have multiple Patients assigned.

ğŸŒŸ ManyToOne Mapping
â¤ Multiple records in Table A map to one record in Table B.
â¤ Annotation: @ManyToOne
âœ… Example:
    1. In an E-commerce system, many Orders belong to one Customer.
    2. In a Corporate HR system, many Employees report to one Department.
    3. In a Travel Booking platform, many Flight Bookings are associated with one User.    

ğŸŒŸ ManyToMany Mapping
â¤ Records in one table are associated with multiple records in another table and vice versa.
â¤ Annotation: @ManyToMany
âœ… Example:
    1. In a Learning Management System (LMS), many Students can enroll in many Courses.
    2. In a Job Portal, many Candidates can apply to many Job Postings.
    3. In a Music Streaming App, many Artists can be part of many Playlists, and playlists can include multiple artists.    

ğŸŒŸ OneToOne Mapping
One record in Table A maps exactly to one record in Table B.
Annotation: @OneToOne
âœ… Example:
    1. In a Banking application, one Customer has exactly one PAN Card or KYC record.
    2. In an HR system, one Employee has exactly one EmployeeProfile record (with DOB, address, etc.).
    3. In a Car Rental app, one Car has exactly one Insurance Policy.    


ğŸ”· Normalization
A database design technique to organize data efficiently.

Goals:
âœ”ï¸ Reduce redundancy (no unnecessary repetition of data).
âœ”ï¸ Improve data consistency and integrity.
âœ”ï¸ Break a large unstructured table into smaller, related tables.  

Forms of Normalization:
ğŸŒŸ First Normal Form (1NF)

Rules:
ğŸ‘‰ Each column must have atomic values (no multiple values in a single cell, e.g., "CS, IT").
ğŸ‘‰ Values in a column must be of the same data type (no mixing, e.g., phone number + email in one column).
ğŸ‘‰ Each row must be unique â†’ requires a primary key.
ğŸ‘‰ No repeating groups or arrays allowed.

âœ… Example (Before 1NF):
| StudentID | Name | Subjects | Phone Numbers |
| --------- | ---- | -------- | ------------- |
| 1         | Alex | CS, IT   | 1234, 5678    |

âœ… After 1NF:
| StudentID | Name | Subject | PhoneNumber |
| --------- | ---- | ------- | ----------- |
| 1         | Alex | CS      | 1234        |
| 1         | Alex | IT      | 5678        |

ğŸŒŸ Second Normal Form (2NF)
Precondition: Must already satisfy 1NF.

Rules:
ğŸ‘‰ No partial dependency â†’ every non-key attribute should depend on the whole primary key, not just a part of it.
ğŸ‘‰ Applies only when the table has a composite primary key (more than one column as PK).

âœ… Example (Before 2NF):
| StudentID | CourseID | StudentName | CourseName | Instructor |
â¤ Composite key = (StudentID, CourseID)
â¤ Problem: StudentName depends only on StudentID, not on CourseID.

âœ… After 2NF:
â¤ Students Table: (StudentID â†’ StudentName)
â¤ Courses Table: (CourseID â†’ CourseName, Instructor)
â¤ Enrollment Table: (StudentID, CourseID)

ğŸŒŸ Third Normal Form (3NF)
Precondition: Must already satisfy 2NF.

Rules:
ğŸ‘‰ No transitive dependency â†’ non-key attributes should not depend on other non-key attributes.
ğŸ‘‰ Every non-key column must depend only on the primary key.

âœ… Example (Before 3NF):
| StudentID | Name | DeptID | DeptName | DeptHead |
â¤ Problem: DeptName and DeptHead depend on DeptID, not directly on StudentID.

âœ… After 3NF:
â¤ Students Table: (StudentID â†’ Name, DeptID)
â¤ Departments Table: (DeptID â†’ DeptName, DeptHead)

âš¡ Tips:
Emphasize:
âœ”ï¸ 1NF â†’ Atomic values, no repeating groups.
âœ”ï¸ 2NF â†’ Remove partial dependency.
âœ”ï¸ 3NF â†’ Remove transitive dependency.

ğŸ§  Common trap: Interviewers may ask if 2NF applies when there is no 
 composite key.
ğŸ”„ Answer: No, because partial dependency exists only with composite keys.

ğŸ§  Working through normalization step-by-step helps ensure a well-structured database design.

âœ… For Example:
(0) Unnormalized table (UNF)

OrderSheet (single table)
OrderID | OrderDate|CustomerName|CustomerEmail|CustomerAddress|BookISBN| BookTitle | BookAuthor  |UnitPrice  |Quantity|LineTotal|  PhoneNumbers (comma-separated)
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
101     |2025-08-01| John Smith | john@x.com | 221B Baker St| 999-1    | SQL Basics| Ada Lovelace| 500       | 1      | 500     | Phones: "98765, 91234"
101     |2025-08-01| John Smith | john@x.com | 221B Baker St| 999-2    | DB Design | E. Codd     | 700       | 2      | 1400    | Phones: "98765, 91234"
102     |2025-08-02| Robert Ray | rob@y.com  | 42 Galaxy Way| 999-2    | DB Design | E. Codd     | 700       | 1      | 700     | Phones: "99887"

Whatâ€™s wrong here:
â¤ Multi-valued attribute: PhoneNumbers = "98765, 91234" (not atomic).
â¤ Redundancy: customer & book details repeat across rows.
â¤ Update anomalies: change Johnâ€™s address â†’ must update many rows.
â¤ Insert/delete anomalies: canâ€™t insert a new book without an order; deleting Johnâ€™s order may â€œloseâ€ the bookâ€™s master data.

ğŸŒŸ First Normal Form (1NF)
Goal:
â¤ Make every cell atomic, consistent types, define a key, and eliminate repeating groups.

Fixes weâ€™ll do
â¤ Remove comma-separated phones into a separate table.
â¤ Keep a composite primary key (OrderID, BookISBN) in the order-lines so two books in one order are allowed.
â¤ Keep other columns as-is for now.

1NF schema
OrderLines_1NF(
  OrderID,        -- part of PK
  BookISBN,       -- part of PK
  OrderDate,
  CustomerName,
  CustomerEmail,
  CustomerAddress,
  BookTitle,
  BookAuthor,
  UnitPrice,
  Quantity,
  LineTotal
  PRIMARY KEY (OrderID, BookISBN)
)

CustomerPhones_1NF(
  CustomerEmail,  -- weâ€™ll temporarily use email to link phones
  PhoneNumber,
  PRIMARY KEY (CustomerEmail, PhoneNumber)
)

âš¡Why this is 1NF now
â¤ No multi-valued fields; phones are atomic and stored as separate rows.
â¤ A row is uniquely identified by (OrderID, BookISBN).
â¤ Column types are consistent.

Still redundant: Customer info depends only on OrderID; book info depends only on BookISBN. Thatâ€™s the 2NF problem.

ğŸŒŸ Second Normal Form (2NF):
âœ… Precondition: Table(s) are in 1NF.

â—Rule: No partial dependencyâ€”every non-key attribute must depend on the entire composite key (when a composite key exists).

In OrderLines_1NF, the PK is (OrderID, BookISBN):
â¤ OrderDate, CustomerName, CustomerEmail, CustomerAddress depend only on OrderID (part of the key) â†’ partial dependency.
â¤ BookTitle, BookAuthor, UnitPrice depend only on BookISBN (part of the key) â†’ partial dependency.
â¤ Quantity, LineTotal depend on both â†’ fine.

Decompose to remove partial dependencies

2NF schema
Orders_2NF(
  OrderID PK,
  OrderDate,
  CustomerName,
  CustomerEmail,
  CustomerAddress
)

Books_2NF(
  BookISBN K,
  BookTitle,
  BookAuthor,
  UnitPrice
)

OrderItems_2NF(
  OrderID        -- part of PK, FK -> Orders_2NF(OrderID)
  BookISBN       -- part of PK, FK -> Books_2NF(BookISBN)
  Quantity,
  LineTotal,
  PRIMARY KEY (OrderID, BookISBN)
)

CustomerPhones_2NF(
  CustomerEmail,
  PhoneNumber,
  PRIMARY KEY (CustomerEmail, PhoneNumber)
)

ğŸ”— What we gained
â¤ No attribute in OrderItems_2NF depends only on part of its composite key.
â¤ Book and customer order headers are stored onceâ€”redundancy drops.

Still an issue for 3NF: In Orders_2NF, CustomerName/Email/Address are really properties of a Customer, not of an Order. We also still keep LineTotal, which is derivable (Quantity Ã— UnitPrice). That creates a transitive/derived dependency risk.

ğŸŒŸ Third Normal Form (3NF)
âœ… Precondition: In 2NF.
â— Rule: No transitive dependencyâ€”non-key attributes must not depend on other non-key attributes.

Whatâ€™s transitive here?

If we introduce a stable CustomerID, then:
â¤ Orders would have CustomerID (FK) and non-key attributes like CustomerName/Email/Address would depend on CustomerID, not directly on OrderID â†’ transitive dependency in Orders_2NF.
â¤ LineTotal depends on Quantity and UnitPrice (the latter is in Books). Itâ€™s derivable, and storing it risks inconsistency.

ğŸ”„ Decompose & clean

Final 3NF schema
Customers(
  CustomerID     PK,
  CustomerName,
  CustomerEmail  UNIQUE,
  CustomerAddress
)

CustomerPhones(
  CustomerID     FK -> Customers(CustomerID),
  PhoneNumber,
  PRIMARY KEY (CustomerID, PhoneNumber)
)

Orders(
  OrderID        PK,
  OrderDate,
  CustomerID     FK -> Customers(CustomerID)
)

Books(
  BookISBN       PK,
  BookTitle,
  BookAuthor,
  UnitPrice
)

OrderItems(
  OrderID        FK -> Orders(OrderID),
  BookISBN       FK -> Books(BookISBN),
  Quantity,
  -- no LineTotal here (computed when needed)
  PRIMARY KEY (OrderID, BookISBN)
)
ğŸ”— Why this is 3NF:
â¤ In Orders, every non-key attribute (OrderDate, CustomerID) depends only on the key (OrderID), and nothing depends on another non-key attribute.
â¤ Customer details live in Customers; phones in CustomerPhones with a clean 1-to-many.
â¤ Book master data is in Books.
â¤ OrderItems only has attributes that depend on the whole composite key (OrderID, BookISBN).
â¤ Derived value LineTotal removed â†’ no transitive/derived dependency.

Sample data (3NF)

ğŸ“ Customers
CustomerID | CustomerName | CustomerEmail | CustomerAddress
-----------------------------------------------------------
C001       | John Smith   | john@x.com    | 221B Baker St
C002       | Robert Ray   | rob@y.com     | 42 Galaxy Way

ğŸ“ CustomerPhones
CustomerID | PhoneNumber
------------------------
C001       | 98765
C001       | 91234
C002       | 99887

ğŸ“ Books
BookISBN | BookTitle     | BookAuthor   | UnitPrice
---------------------------------------------------
999-1    | SQL Basics    | Ada Lovelace | 500
999-2    | DB Design     | E. Codd      | 700

ğŸ“ Orders
OrderID | OrderDate   | CustomerID
-----------------------------------
101     | 2025-08-01  | C001
102     | 2025-08-02  | C002

ğŸ“ OrderItems
OrderID | BookISBN | Quantity
-----------------------------
101     | 999-1    | 1
101     | 999-2    | 2
102     | 999-2    | 1

ğŸ”„ Practical SQL (3NF):
Create tables
-- Master tables

CREATE TABLE Customers (
  CustomerID      VARCHAR(10) PRIMARY KEY,
  CustomerName    VARCHAR(100) NOT NULL,
  CustomerEmail   VARCHAR(150) UNIQUE NOT NULL,
  CustomerAddress VARCHAR(200) NOT NULL
);

CREATE TABLE CustomerPhones (
  CustomerID   VARCHAR(10) NOT NULL,
  PhoneNumber  VARCHAR(20) NOT NULL,
  PRIMARY KEY (CustomerID, PhoneNumber),
  FOREIGN KEY (CustomerID) REFERENCES Customers(CustomerID)
);

CREATE TABLE Books (
  BookISBN    VARCHAR(20) PRIMARY KEY,
  BookTitle   VARCHAR(150) NOT NULL,
  BookAuthor  VARCHAR(100) NOT NULL,
  UnitPrice   DECIMAL(10,2) NOT NULL
);

-- Transaction tables
CREATE TABLE Orders (
  OrderID     INT PRIMARY KEY,
  OrderDate   DATE NOT NULL,
  CustomerID  VARCHAR(10) NOT NULL,
  FOREIGN KEY (CustomerID) REFERENCES Customers(CustomerID)
);

CREATE TABLE OrderItems (
  OrderID    INT NOT NULL,
  BookISBN   VARCHAR(20) NOT NULL,
  Quantity   INT NOT NULL CHECK (Quantity > 0),
  PRIMARY KEY (OrderID, BookISBN),
  FOREIGN KEY (OrderID)  REFERENCES Orders(OrderID),
  FOREIGN KEY (BookISBN) REFERENCES Books(BookISBN)
);


âš¡ Compute an orderâ€™s total (derived at query-time, no redundancy):
â¤ SELECT
  oi.OrderID,
  SUM(oi.Quantity * b.UnitPrice) AS OrderTotal
FROM OrderItems oi
JOIN Books b ON b.BookISBN = oi.BookISBN
WHERE oi.OrderID = 101
GROUP BY oi.OrderID;

âš¡ List line items with computed line totals:
â¤ SELECT
  o.OrderID,
  o.OrderDate,
  c.CustomerName,
  b.BookTitle,
  oi.Quantity,
  (oi.Quantity * b.UnitPrice) AS LineTotal
FROM Orders o
JOIN Customers c   ON c.CustomerID = o.CustomerID
JOIN OrderItems oi ON oi.OrderID = o.OrderID
JOIN Books b       ON b.BookISBN = oi.BookISBN
WHERE o.OrderID = 101;

âœ… Key takeaways (interview-friendly)
âš¡ 1NF: Atomic values, no repeating groups; define a key.
âš¡ 2NF: Remove partial dependencies from tables with composite keys (separate order header vs. book master vs. order items).
âš¡ 3NF: Remove transitive dependencies (move customer details to Customers; drop derived LineTotal).

Result: minimal redundancy, better integrity; queries use joins to rebuild the full picture.