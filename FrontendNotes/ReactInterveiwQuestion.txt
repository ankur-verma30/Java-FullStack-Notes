Q1. Why React?
─────────▶React simplifies building complex UIs by making the UI declarative, component-based, and state-driven, allowing predictable rendering and efficient updates using a virtual DOM.


Q2. Why is React a library, not a framework?
─────────▶React focuses only on the view layer and leaves routing, state management, and networking to external libraries, giving developers flexibility.


Q3. What problem does React solve?
─────────▶React solves the problem of managing complex UI state and keeping the UI in sync with data efficiently.


O4. “Why React is mostly SPA?”
─────────▶ React is optimized for long-lived UI sessions where state changes frequently. SPA allows React to manage state and UI efficiently without full page reloads.


O5. “Is React only SPA?”
─────────▶ No. React can be used with SSR and hybrid models using frameworks like Next.js.


Q6: How does React update UI?
─────────▶ React recalculates the UI using a virtual DOM, diffs it with the previous version during reconciliation, and applies minimal changes to the real DOM in the commit phase.


Q7: Why Fiber architecture?
─────────▶ Fiber allows React to pause, prioritize, and resume rendering work, improving responsiveness for complex UIs.


Q8: Why hooks must be called in same order?
─────────▶ Hooks are stored sequentially in Fiber nodes, so consistent order ensures correct state mapping.


Q9: Why does React use Virtual DOM?
─────────▶ React uses a virtual DOM to calculate UI changes efficiently in memory and apply only the minimal required updates to the real DOM.


Q10: Is Virtual DOM faster than direct DOM manipulation?
─────────▶ Not inherently. Virtual DOM helps React batch and optimize updates, which often results in better performance for complex UIs.


Q11: How does React decide what to re-render?
─────────▶ React re-executes components to create a new virtual DOM and uses reconciliation to diff it with the previous tree, applying only the minimal required DOM changes.


Q12: Why are keys important?
─────────▶ Keys help React uniquely identify elements across renders, ensuring correct state preservation and efficient reconciliation.


Q13: What happens if keys change?
─────────▶ React treats the component as new, unmounts the old one, and mounts a new one, losing state.


Q14: What is React Fiber?
─────────▶ React Fiber is React’s internal reconciliation architecture that allows rendering work to be split into small units, paused, resumed, and prioritized to improve UI responsiveness.


Q15: Why Fiber was introduced?
─────────▶ To solve UI blocking caused by synchronous rendering in large component trees.


Q16: How does Fiber help UX?
─────────▶ By prioritizing user interactions and avoiding long blocking renders.


Q17: Why JSX?
─────────▶ JSX makes UI code more readable and declarative by allowing developers to write component structure similar to HTML while still being JavaScript.


Q18: Why only one root element?
─────────▶ JSX expressions must return a single JavaScript expression, which maps to one root element.