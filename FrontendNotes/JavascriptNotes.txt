XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX‚úÖ Core Concepts Of JavaScript ‚úÖXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
###########################################
üåä Variables and Scoping (var, let, const)
###########################################
üî∑ Scopes in JavaScript
| Scope              | Applies to            | Stored in                              |
| ------------------ | --------------------- | -------------------------------------- |
| **Global Scope**   | `window` / `global`   | Global Object                          |
| **Function Scope** | `var` inside function | Execution Context Variable Environment |
| **Block Scope**    | `{ }`, loops, if      | Lexical Environment                    |


üî∑ var vs let vs const
| Feature                            | `var`                            | `let`            | `const`          |
| ---------------------------------- | -------------------------------- | ---------------- | ---------------- |
| Scope                              | Function                         | Block            | Block            |
| Hoisted?                           | Yes (initialized as `undefined`) | Yes (but in TDZ) | Yes (but in TDZ) |
| Re-declaration                     | Allowed                          | ‚ùå Not allowed   | ‚ùå Not allowed  |
| Re-assignment                      | Allowed                          | Allowed          | ‚ùå Not allowed   |
| Attached to Global Object?         | Yes                              | ‚ùå               | ‚ùå              |
| Can be declared without assignment | Yes                              | Yes              | ‚ùå No            |
üëâ TDZ- Temporal Dead Zone
A zone between the start of the scope and declaration where let/const exist but cannot be accessed.


üî∑ Hoisting Behavior
console.log(a); // undefined
var a = 10;

console.log(b); // ReferenceError (TDZ)
let b = 20;

console.log(c); // ReferenceError (TDZ)
const c = 30;

üî∑ const != Immutable ‚ùå Misconception
const obj = {name: "A"};
obj.name = "B"; // ‚ùå Allowed! (mutation)
obj = {}; // ‚ùå Error (reassignment)
‚û§ To freeze an object, use Object.freeze(obj)


üî∑ Closure + Loop Traps
‚ùì Why does var fail inside the loops?
for(var i = 1; i <= 3; i++){
  setTimeout(() => console.log(i), 1000);
}
// Output: 4 4 4
üëâ All callbacks share one i variable, from the function scope and not from the loop scope. This is called a closure.


‚ùì How to fix? Modern Solution
for(let i = 1; i <= 3; i++){
  setTimeout(() => console.log(i), 1000);
}
// Output: 1 2 3
üëâ Each iteration has its own i variable, from the loop scope.


üî∑ Global Leaks(Real-world Bug)
function test() {
  x = 100; // ‚ùå creates global variable
}
test();
console.log(x); // 100 (bad!)


‚úÖ Use "use strict" to prevent this:
"use strict";
x=100; // ‚ùå ReferenceError


#############
üåä Hoisting
#############
JavaScript moves declarations to the top of the current scope (compile phase) before code execution.

Only declarations are hoisted ‚Äî not initializations.

| Type                 | Hoisted?           | Value Before Declaration         | Notes                        |
| -------------------- | ------------------ | -------------------------------- | ---------------------------- |
| `var`                | Yes                | `undefined`                      | Function-scoped              |
| `let`                | Yes                | TDZ (ReferenceError if accessed) | Block-scoped                 |
| `const`              | Yes                | TDZ + must be initialized        | Block-scoped                 |
| Function Declaration | Yes                | Actual function                  | Can be called before defined |
| Function Expression  | Only variable name | `undefined` if accessed early    | Depends on var/let/const     |


‚úÖ Examples
1Ô∏è‚É£ var Hoisting
console.log(a); // undefined
var a = 10;

2Ô∏è‚É£ let/const Hoisting+ TDZ
console.log(b); //‚ùå ReferenceError (TDZ)
let b = 20;

3Ô∏è‚É£ Function Declaration Hoisting
greet(); //"Hello"
function greet(){
  console.log("Hello");
}

4Ô∏è‚É£ Function Expression Hoisting
greet(); // ‚ùå TypeError greet is not a function
var greet = function(){
  console.log("Hello");
}
‚úÖ greet becomes undefined during hoisting

4Ô∏è‚É£.1Ô∏è‚É£ Using const/let
greet(); // ‚ùå Cannot access 'greet' before initialization
const greet = function(){
  console.log("Hello");
}

üî∑ Tricky Questions
‚ùìQ1: foo();
function foo(){
    console.log("Called");
}
‚úÖ Output: Called

‚ùìQ2: var a=1;
function foo(){
    console.log(a);
    var a=2;
}
test();
‚úÖ Output: undefined (inner a shadowed + hoisted)

‚ùìQ3: console.log(a);
let a=10;
‚úÖ Output: Uncaught ReferenceError: a is not defined because typeof also fails in TDZ

‚ùìQ4: hello();
function hello() {
  console.log("A");
}
var hello = function() {
  console.log("B");
};
‚úÖ Output: "A" Function declaration hoisted first ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂ overwrites var declaration.


#################################
üåä Primitive vs Reference Types
#################################
üî∑ Primitive Types
‚úîÔ∏è Stored directly in stack.
‚úîÔ∏è Copied by value.
‚úîÔ∏è Immutable (value cannot be changed in memory).
üëâ Types: string, number, boolean, null, undefined, symbol, bigint.

let a = 10;
let b = a;
b = 20;

console.log(a); // 10 (unchanged)
console.log(b); // 20

üî∑ Reference Types
‚úîÔ∏è Stored in heap.
‚úîÔ∏è Variables stores reference(pointer) to memory.
‚úîÔ∏è Copied by reference.
üëâ Types: object, array, function, date, etc.

let obj1 = { x: 1 };
let obj2 = obj1;
obj2.x = 99;
console.log(obj1.x); // 99 (same reference)

üî∑ Comparing Values (===)
10 === 10           // true (value check)
{a:1} === {a:1}     // false (different references)

üî∑ Cloning Reference Types 
üëâ Shallow Copy
const obj1 = {a:1, b:{c:2}};
const obj2 = {...obj1};
obj2.b.c = 5;

console.log(obj1.b.c); // 5 (nested ref shared)

üëâ Deep Copy
const obj1 = {a:1, b:{c:2}};
const obj2 = JSON.parse(JSON.stringify(obj1));
obj2.b.c = 5;

console.log(obj1.b.c); // 2 (nested ref not shared)
‚ùó Loses functions, Date, undefined, Infinity

üî∑ Primitive Wrappers
JS auto-boxes primitives into temporary objects:
"abc".toUpperCase(); // "ABC" (temporary object)

üî∑ Tricky Questions
‚ùìQ1: let a="hi";
a.name="test";
console.log(a.name); 
‚úÖ Output: undefined (primitives cannot hold properties)

‚ùìQ2: let a=[1,2,3];
let b=a;
b.push(4);
console.log(a);
‚úÖ Output: [1,2,3,4] (shared reference)

‚ùìQ3: console.log({}==={});
console.log([]===[]);
‚úÖ Output: false false ( different heap references)

‚ùìQ4: let a=null;
console.log(typeof a);
‚úÖ Output: object (JS historical bug- still part of the specification)

‚ùìQ5: let p = 5;
let q = new Number(5);

console.log(p == q);  // ?
console.log(p === q); // ?
‚úÖ Output: true // coercion
false // strict equality different types(primtive vs object)

‚ùìQ6: let obj = {a: 1};
const arr = [obj];

arr[0].a = 10;
console.log(obj.a);
‚úÖ Output: 10 (arr holds reference to obj)


#################################
üåä Type Conversion and Coercion
#################################
üî∑ Type Conversion vs Type Coercion
| Term                | Who triggers? | Explicit?     | Example      |
| ------------------- | ------------- | ------------- | ------------ |
| **Type Conversion** | Developer     | Yes           | `String(10)` |
| **Type Coercion**   | JavaScript    | No (implicit) | `"5" * 2`    |

üî∑ Explicit Conversion
‚û§ To Number
Number("10") // 10
Number("10a") // NaN
parseInt("10px") // 10
parseFloat("3.14") // 3.14

‚û§ To String    
String(100) // "100"
(100).toString() // "100"

‚û§ To Boolean
Falsy values only: false, 0, "", null, undefined, NaN

üî∑ Implicit Coercion
‚û§ Arithmetic
"5" - 1   // 4 (string ‚Üí number)
"5" * 2   // 10
"5" + 2   // "52" (string concat rule)
'+' operator ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂ if any operand is string ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂ concatenation


‚û§ Boolean 
if("hello") console.log("true"); // true
if(0) console.log("true"); // won't execute

‚û§ Equality Coercion (==)
"5" == 5   // true (coercion)
" " == 0   // true
false == 0 // true
[] == false // true
[] == 0    // true

‚úîÔ∏è Special Cases
null == undefined // true
null === undefined // false 


üî∑ Tricky Questions
‚ùìQ1: console.log("10" - "2");
‚úÖ Output:8

‚ùìQ2: console.log("10" + 2 + 3);
console.log(10 + 2 + "3");
‚úÖ Output: 
"1023"
"123"

‚ùìQ3: console.log(true + true); 
console.log(true + false);
‚úÖ Output:
2
1 (boolean ‚Üí number)

‚ùìQ4: console.log([] == 0);
console.log([1] == 1);
‚úÖ Output:
true   // [] ‚Üí "" ‚Üí 0
true   // [1] ‚Üí "1" ‚Üí 1

‚ùìQ5:console.log(null == 0);
console.log(null >= 0);
console.log(null > 0);
‚úÖ Output:
false
true
false
üëâ Reason -> Relational comparison converts to number, equality does not.

‚ùìQ6: console.log("abc" - 1);
‚úÖ Output:NaN

‚ùìQ7: console.log([] + []); 
console.log([] + {});
console.log({} + []);
‚úÖ Output:
""
"[object Object]"
0   (in console behaves differently but JS sees unary + on {})

‚ùìQ8: console.log(!"");
console.log(!"hello");
‚úÖ Output:
true
false
üëâ Reason -> Falsy vs truthy coercion


########################################################
üåä Operators (Arithmetic, Logical, Comparison, Bitwise)
########################################################
üî∑ Arithmetic Operators(+, -, *, /, %, ++, --, **)

let a = 10;
let b = 3;
console.log(a + b); // 13
console.log(a % b); // 1
console.log(a ** 2); // 100

üëâ + also does string concatenation: "5" + 2 // "52"


üî∑ Comparison Operators
Ordinary Comparisons(<, >, <=, >=)
2 < 3  // true

üîÑ Equality
| Operator | Behavior                          |
| -------- | --------------------------------- |
| `==`     | loose equality ‚Üí coercion happens |
| `===`    | strict equality ‚Üí **no coercion** |
"5" == 5   // true
"5" === 5  // false
üëâ Always prefer === in interviews & real projects.


üî∑ Logical Operators(&&, ||, !)
üëâ They return the actual operand, not boolean always:
console.log("A" && "B"); // "B"  (first truthy stops)
console.log(0 || 42);    // 42   (returns first truthy)
console.log(!"test");    // false

üîÑ Short-Circuiting
1Ô∏è‚É£ && stops on first falsy
2Ô∏è‚É£ || stops on first truthy

Used commonly for:
user && user.name // safe access
name || "Guest"   // default value


üî∑ Bitwise Operators(&, |, ^, ~, <<, >>, >>>)
Work on 32-bit signed integers.

console.log(5 & 3); // 1   (AND)
console.log(5 | 3); // 7   (OR)
console.log(5 ^ 3); // 6   (XOR)
console.log(~5);    // -6  (NOT --> -(n+1))
console.log(5 << 1); // 10 (left shift)
console.log(5 >> 1); // 2  (arith right shift)

Zero-fill right shift (>>>)
console.log(-5 >>> 1); // big positive number (fills zero from left)


üî∑ Trick Questions (Only Operator-Based)
‚ùìQ1: console.log(1 < 2 < 3);
‚úÖ Output: true
( 1 < 2 ‚Üí true ‚Üí true < 3 ‚Üí 1 < 3 ‚Üí true )

‚ùìQ2: console.log(3 > 2 > 1);
‚úÖ Output: false
( 3 > 2 ‚Üí true ‚Üí true > 1 ‚Üí 1 > 1 ‚Üí false )

‚ùìQ3: console.log("5" - 2);
console.log("5" + 2);
‚úÖ Output:
3   (number op)
"52" (string op)

‚ùìQ4: console.log("hello" && 0 && "world");
‚úÖ Output:
 0 (stops on first falsy)

‚ùìQ5:console.log(0 || null || "Hi" || false);
‚úÖ Output:
"Hi" (first truthy value)

‚ùìQ6: console.log(~0);
‚úÖ Output:
 -1 (~n = -(n + 1))

‚ùìQ7: console.log(5 & 1);
‚úÖ Output:
 1 (Binary: 0101 & 0001)

‚ùìQ8:console.log(10 == [10]);
console.log(10 === [10]);
‚úÖ Output:
true   (array ‚Üí "10" ‚Üí number)
false  (type mismatch)



###########################
üåä Control Flow and Loops
###########################
üî∑ Control Flow in JavaScript
Control flow defines the order in which code is executed.

üî∑ Conditional Statements
| Statement       | Usage                                     |
| --------------- | ----------------------------------------- |
| `if`            | Runs code only if condition is true       |
| `if‚Ä¶else`       | Runs alternate code if condition is false |
| `else if`       | Multiple conditions                       |
| `switch`        | Compare value against multiple cases      |
| Ternary (`? :`) | Short if-else for simple expressions      |

‚úÖ Example
let age = 18;

if (age > 18) {
  console.log("Adult");
} else if (age === 18) {
  console.log("Just turned adult");
} else {
  console.log("Minor");
}

‚úÖ Switch Example
let day = 2;

switch(day) {
  case 1: console.log("Mon"); break;
  case 2: console.log("Tue"); break;
  default: console.log("Other day");
}

‚úÖ Ternary Example
let x = 10;
let result = x > 5 ? "Greater" : "Smaller";
console.log(result);


üî∑ Loops in JavaScript
Loops help repeat tasks until a condition is met.
| Loop Type    | Best Use Case                               |
| ------------ | ------------------------------------------- |
| `for`        | Known number of iterations                  |
| `while`      | Loop until condition becomes false          |
| `do‚Ä¶while`   | Runs at least once                          |
| `for‚Ä¶of`     | Iterating over **arrays / iterable values** |
| `for‚Ä¶in`     | Iterating over **object keys**              |
| `.forEach()` | Array iteration (callback based)            |

‚úÖ For Loop Example
for (let i = 0; i < 5; i++) {
  console.log(i);
}

‚úÖ While Loop Example
let i = 0;
while (i < 5) {
  console.log(i);
  i++;
}

‚úÖ Do While Loop Example
let i = 0;
do {
  console.log(i);
  i++;
} while (i < 5);

‚úÖ For of Loop Example
const arr = [10, 20, 30];
for (const item of arr) {
  console.log(item);
}

‚úÖ For in Loop Example
const user = { name: "John", age: 20 };

for (const key in user) {
  console.log(key, user[key]);
}

‚úÖ forEach Loop Example
const nums = [1, 2, 3];

nums.forEach((n, i) => {
  console.log(`Index ${i}: ${n}`);
});

üî∑ Loop Control Keywords
| Keyword    | Purpose                                   |
| ---------- | ----------------------------------------- |
| `break`    | Stop the loop entirely                    |
| `continue` | Skip current iteration & move to next one |

‚úÖ Example
for (let i = 1; i <= 5; i++) {
  if (i === 3) continue;
  console.log(i);
}
‚úÖ Output: 1,2,4,5



######################################
üåä Error Handling (try, catch, throw)
######################################
JavaScript uses exceptions to handle errors in runtime
The main keyword used:
| Keyword   | Purpose                          |
| --------- | -------------------------------- |
| `try`     | Wraps code that may throw error  |
| `catch`   | Handles the error if thrown      |
| `throw`   | Manually create/customize errors |
| `finally` | Runs always (success OR error)   |

üî∑ Basic Syntax
try {
  // Code that might cause an error
} catch(err) {
  // Handle the error
} finally {
  // Always runs (optional)
}

‚úÖ Example: Handling an undefined variable
try {
  console.log(x); // x is not defined
} catch (err) {
  console.log("Error occurred:", err.message);
} finally {
  console.log("Execution completed");
}

üî∑ Throwing Custom Errors
Can throw any types: string, number, object, etc.
function divide(a, b) {
  if (b === 0) {
    throw new Error("Cannot divide by zero");
  }
  return a / b;
}

try {
  console.log(divide(10, 0));
} catch (err) {
  console.log(err.message);
}

üî∑ finally Always Executes
Even if there is a return inside try/catch,
try {
  return 10;
} catch (err) {
  return 20;
} finally {
  console.log("Cleanup action runs always!");
}

üî∑ Error Types in JavaScript
| Error Type     | Example Reason                  |
| -------------- | ------------------------------- |
| ReferenceError | Using undefined variable        |
| TypeError      | Invalid data type operation     |
| SyntaxError    | Code syntax mistake             |
| RangeError     | Invalid length/range            |
| EvalError      | Issues in eval()                |
| URIError       | Wrong encodeURI/decodeURI usage |

‚úÖ Example
let num=5;
num.toUpperCase();
‚úÖ Output: TypeError: num.toUpperCase is not a function

üî∑ Custom Error Class
class ValidationError extends Error {
  constructor(message) {
    super(message);
    this.name = "ValidationError";
  }
}

function validateAge(age) {
  if (age < 18) throw new ValidationError("User must be 18+");
}

try {
  validateAge(15);
} catch (err) {
  console.log(err.name + ": " + err.message);
}

üî∑ "use strict"- Strict Mode in JavaScript
Strict mode enforces a stricter set of JavaScript rules to prevent silent bugs.

Enabled by placing directive:
"use strict";

At top of file/function:
function myFunction() {
  //strict here
}

üî∑ What Strict Mode fixes 
1Ô∏è‚É£ Prevents implicit global variables
"use strict";
x = 10; // ‚ùå ReferenceError


2Ô∏è‚É£ Disallows duplicate parameter names
"use strict";
function fn(a, a) {} // ‚ùå SyntaxError


3Ô∏è‚É£ Prevents deletion of non-deletable properties
"use strict";
delete Object.prototype; // ‚ùå TypeError


4Ô∏è‚É£ this in functions becomes undefined
(No auto global binding)

"use strict";
function show() {
  console.log(this); // undefined
}
show();
üëâ In non-strict ‚Üí this = global object (window)


5Ô∏è‚É£ Blocks usage of bad syntax like octal literals
"use strict";
let num = 010; // ‚ùå SyntaxError


6Ô∏è‚É£ Prevents writing to read-only properties
"use strict";
const obj = {};
Object.freeze(obj);
obj.a = 10; // ‚ùå TypeError


7Ô∏è‚É£ arguments.callee is forbidden
"use strict";
function x() {
  console.log(arguments.callee); // ‚ùå TypeError
}

üî∑ Why Do We Use Strict Mode?
| Benefit               | Explanation                            |
| --------------------- | -------------------------------------- |
| Safer code            | Disallows silent failures              |
| Fast performance      | Allows better engine optimizations     |
| Cleaner scoping       | Prevents accidental globals            |
| Early error detection | Shows errors that otherwise would hide |


üî∑ Trick Questions
‚ùìQ1: function test() {
  console.log(this);
}
test();
‚úÖ Output:
Non-strict: window
Strict: undefined

‚ùìQ2:
"use strict";
function foo() {
  bar = 5;
}
foo();
console.log(bar);
‚úÖ Output:
 ReferenceError (Implicit global is blocked)

‚ùìQ3:"use strict";
var obj = { name: "A" };
Object.defineProperty(obj, "name", { writable: false });
obj.name = "B";
console.log(obj.name);
‚úÖ Output:
 TypeError thrown (Silent failure in non-strict)

‚ùìQ4: "use strict";
function sum(a, a) {
  return a + a;
}
sum(2, 3);
‚úÖ Output: SyntaxError ‚Äî duplicate params not allowed

‚ùìQ5: "use strict";
console.log(this);
‚úÖ Output: Browser ‚Üí undefined in modules or functions, but at top-level inside script ‚Üí still window (Node ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂ {} in modules)

üî∑
üî∑
üî∑
üî∑üî∑

üî∑üî∑
üî∑

üî∑
üî∑

