XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXâœ… Core Concepts Of JavaScript âœ…XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
###########################################
ğŸŒŠ Variables and Scoping (var, let, const)
###########################################
ğŸ”· Scopes in JavaScript
| Scope              | Applies to            | Stored in                              |
| ------------------ | --------------------- | -------------------------------------- |
| **Global Scope**   | `window` / `global`   | Global Object                          |
| **Function Scope** | `var` inside function | Execution Context Variable Environment |
| **Block Scope**    | `{ }`, loops, if      | Lexical Environment                    |


ğŸ”· var vs let vs const
| Feature                            | `var`                            | `let`            | `const`          |
| ---------------------------------- | -------------------------------- | ---------------- | ---------------- |
| Scope                              | Function                         | Block            | Block            |
| Hoisted?                           | Yes (initialized as `undefined`) | Yes (but in TDZ) | Yes (but in TDZ) |
| Re-declaration                     | Allowed                          | âŒ Not allowed   | âŒ Not allowed  |
| Re-assignment                      | Allowed                          | Allowed          | âŒ Not allowed   |
| Attached to Global Object?         | Yes                              | âŒ               | âŒ              |
| Can be declared without assignment | Yes                              | Yes              | âŒ No            |
ğŸ‘‰ TDZ- Temporal Dead Zone
A zone between the start of the scope and declaration where let/const exist but cannot be accessed.


ğŸ”· Hoisting Behavior
console.log(a); // undefined
var a = 10;

console.log(b); // ReferenceError (TDZ)
let b = 20;

console.log(c); // ReferenceError (TDZ)
const c = 30;

ğŸ”· const != Immutable âŒ Misconception
const obj = {name: "A"};
obj.name = "B"; // âœ… Allowed! (mutation)
obj = {}; // âŒ Error (reassignment)
â¤ To freeze an object, use Object.freeze(obj);

â„ï¸ Object.freeze(obj) â€” What Exactly Happens?
After freezing:
âœ‹ You cannot:
âŒ Add new properties
âŒ Remove existing properties
âŒ Change existing property values
âŒ Re-configure properties (writable/configurable becomes false)
âŒ Change the prototype
âŒ Modify nested objects (because freeze is shallow)

ğŸ‘ You can:
âœ”ï¸ Read property values
âœ”ï¸ Work with the same object reference

âœ… Example:
const person = {
  name: "John",
  age: 25
};

Object.freeze(person);

person.age = 30;      // âŒ Ignored (no effect in non-strict mode)
person.city = "NY";   // âŒ Not added
delete person.name;   // âŒ Not deleted

console.log(person);  // { name: "John", age: 25 }

ğŸ‘‰ Freeze is shallow
Nested objects are still mutable:
const user = {
  name: "Alex",
  address: { city: "Delhi" }
};

Object.freeze(user);
user.address.city = "Mumbai"; // âœ”ï¸ Allowed (inner object not frozen)

To make everything frozen â†’ deep freeze using recursive function:
function deepFreeze(obj) {
  Object.keys(obj).forEach(key => {
    if (typeof obj[key] === "object" && obj[key] !== null) {
      deepFreeze(obj[key]);
    }
  });
  return Object.freeze(obj);
}
ğŸ‘‰ In strict mode â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ JavaScript will throw a TypeError if modification is attempted.


ğŸ”· Closure + Loop Traps
â“ Why does var fail inside the loops?
for(var i = 1; i <= 3; i++){
  setTimeout(() => console.log(i), 1000);
}
// Output: 4 4 4
ğŸ‘‰ All callbacks share one i variable, from the function scope and not from the loop scope. This is called a closure.


â“ How to fix? Modern Solution
for(let i = 1; i <= 3; i++){
  setTimeout(() => console.log(i), 1000);
}
// Output: 1 2 3
ğŸ‘‰ Each iteration has its own i variable, from the loop scope.


ğŸ”· Global Leaks(Real-world Bug)
function test() {
  x = 100; // âŒ creates global variable
}
test();
console.log(x); // 100 (bad!)


âœ… Use "use strict" to prevent this:
"use strict";
x=100; // âŒ ReferenceError


#############
ğŸŒŠ Hoisting
#############
JavaScript moves declarations to the top of the current scope (compile phase) before code execution.

Only declarations are hoisted â€” not initializations.

| Type                 | Hoisted?           | Value Before Declaration         | Notes                        |
| -------------------- | ------------------ | -------------------------------- | ---------------------------- |
| `var`                | Yes                | `undefined`                      | Function-scoped              |
| `let`                | Yes                | TDZ (ReferenceError if accessed) | Block-scoped                 |
| `const`              | Yes                | TDZ + must be initialized        | Block-scoped                 |
| Function Declaration | Yes                | Actual function                  | Can be called before defined |
| Function Expression  | Only variable name | `undefined` if accessed early    | Depends on var/let/const     |


âœ… Examples
1ï¸âƒ£ var Hoisting
console.log(a); // undefined
var a = 10;

2ï¸âƒ£ let/const Hoisting+ TDZ
console.log(b); //âŒ ReferenceError (TDZ)
let b = 20;

3ï¸âƒ£ Function Declaration Hoisting
greet(); //"Hello"
function greet(){
  console.log("Hello");
}

4ï¸âƒ£ Function Expression Hoisting
greet(); // âŒ TypeError greet is not a function
var greet = function(){
  console.log("Hello");
}
âœ… greet becomes undefined during hoisting

4ï¸âƒ£.1ï¸âƒ£ Using const/let
greet(); // âŒ Cannot access 'greet' before initialization
const greet = function(){
  console.log("Hello");
}

ğŸ”· Tricky Questions
â“Q1: foo();
function foo(){
    console.log("Called");
}
âœ… Output: Called

â“Q2: var a=1;
function foo(){
    console.log(a);
    var a=2;
}
test();
âœ… Output: undefined (inner a shadowed + hoisted)

â“Q3: console.log(a);
let a=10;
âœ… Output: Uncaught ReferenceError: a is not defined because typeof also fails in TDZ

â“Q4: hello();
function hello() {
  console.log("A");
}
var hello = function() {
  console.log("B");
};
âœ… Output: "A" Function declaration hoisted first â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ overwrites var declaration.


#################################
ğŸŒŠ Primitive vs Reference Types
#################################
ğŸ”· Primitive Types
âœ”ï¸ Stored directly in stack.
âœ”ï¸ Copied by value.
âœ”ï¸ Immutable (value cannot be changed in memory).
ğŸ‘‰ Types: string, number, boolean, null, undefined, symbol, bigint.

let a = 10;
let b = a;
b = 20;

console.log(a); // 10 (unchanged)
console.log(b); // 20

ğŸ”· Reference Types
âœ”ï¸ Stored in heap.
âœ”ï¸ Variables stores reference(pointer) to memory.
âœ”ï¸ Copied by reference.
ğŸ‘‰ Types: object, array, function, date, etc.

let obj1 = { x: 1 };
let obj2 = obj1;
obj2.x = 99;
console.log(obj1.x); // 99 (same reference)

ğŸ”· Comparing Values (===)
10 === 10           // true (value check)
{a:1} === {a:1}     // false (different references)

ğŸ”· Cloning Reference Types 
ğŸ‘‰ Shallow Copy
const obj1 = {a:1, b:{c:2}};
const obj2 = {...obj1};
obj2.b.c = 5;

console.log(obj1.b.c); // 5 (nested ref shared)

ğŸ‘‰ Deep Copy
const obj1 = {a:1, b:{c:2}};
const obj2 = JSON.parse(JSON.stringify(obj1));
obj2.b.c = 5;

console.log(obj1.b.c); // 2 (nested ref not shared)
â— Loses functions, Date, undefined, Infinity

ğŸ”· Primitive Wrappers
JS auto-boxes primitives into temporary objects:
"abc".toUpperCase(); // "ABC" (temporary object)

ğŸ”· Tricky Questions
â“Q1: let a="hi";
a.name="test";
console.log(a.name); 
âœ… Output: undefined (primitives cannot hold properties)

â“Q2: let a=[1,2,3];
let b=a;
b.push(4);
console.log(a);
âœ… Output: [1,2,3,4] (shared reference)

â“Q3: console.log({}==={});
console.log([]===[]);
âœ… Output: false false ( different heap references)

â“Q4: let a=null;
console.log(typeof a);
âœ… Output: object (JS historical bug- still part of the specification)

â“Q5: let p = 5;
let q = new Number(5);

console.log(p == q);  // ?
console.log(p === q); // ?
âœ… Output: true // coercion
false // strict equality different types(primtive vs object)

â“Q6: let obj = {a: 1};
const arr = [obj];

arr[0].a = 10;
console.log(obj.a);
âœ… Output: 10 (arr holds reference to obj)


#################################
ğŸŒŠ Type Conversion and Coercion
#################################
ğŸ”· Type Conversion vs Type Coercion
| Term                | Who triggers? | Explicit?     | Example      |
| ------------------- | ------------- | ------------- | ------------ |
| **Type Conversion** | Developer     | Yes           | `String(10)` |
| **Type Coercion**   | JavaScript    | No (implicit) | `"5" * 2`    |

ğŸ”· Explicit Conversion
â¤ To Number
Number("10") // 10
Number("10a") // NaN
parseInt("10px") // 10
parseFloat("3.14") // 3.14

â¤ To String    
String(100) // "100"
(100).toString() // "100"

â¤ To Boolean
Falsy values only: false, 0, "", null, undefined, NaN

ğŸ”· Implicit Coercion
â¤ Arithmetic
"5" - 1   // 4 (string â†’ number)
"5" * 2   // 10
"5" + 2   // "52" (string concat rule)
'+' operator â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ if any operand is string â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ concatenation


â¤ Boolean 
if("hello") console.log("true"); // true
if(0) console.log("true"); // won't execute

â¤ Equality Coercion (==)
"5" == 5   // true (coercion)
" " == 0   // true
false == 0 // true
[] == false // true
[] == 0    // true

âœ”ï¸ Special Cases
null == undefined // true
null === undefined // false 


ğŸ”· Tricky Questions
â“Q1: console.log("10" - "2");
âœ… Output:8

â“Q2: console.log("10" + 2 + 3);
console.log(10 + 2 + "3");
âœ… Output: 
"1023"
"123"

â“Q3: console.log(true + true); 
console.log(true + false);
âœ… Output:
2
1 (boolean â†’ number)

â“Q4: console.log([] == 0);
console.log([1] == 1);
âœ… Output:
true   // [] â†’ "" â†’ 0
true   // [1] â†’ "1" â†’ 1

â“Q5:console.log(null == 0);
console.log(null >= 0);
console.log(null > 0);
âœ… Output:
false
true
false
ğŸ‘‰ Reason -> Relational comparison converts to number, equality does not.

â“Q6: console.log("abc" - 1);
âœ… Output:NaN

â“Q7: console.log([] + []); 
console.log([] + {});
console.log({} + []);
âœ… Output:
""
"[object Object]"
0   (in console behaves differently but JS sees unary + on {})

â“Q8: console.log(!"");
console.log(!"hello");
âœ… Output:
true
false
ğŸ‘‰ Reason -> Falsy vs truthy coercion


########################################################
ğŸŒŠ Operators (Arithmetic, Logical, Comparison, Bitwise)
########################################################
ğŸ”· Arithmetic Operators(+, -, *, /, %, ++, --, **)

let a = 10;
let b = 3;
console.log(a + b); // 13
console.log(a % b); // 1
console.log(a ** 2); // 100

ğŸ‘‰ + also does string concatenation: "5" + 2 // "52"


ğŸ”· Comparison Operators
Ordinary Comparisons(<, >, <=, >=)
2 < 3  // true

ğŸ”„ Equality
| Operator | Behavior                          |
| -------- | --------------------------------- |
| `==`     | loose equality â†’ coercion happens |
| `===`    | strict equality â†’ **no coercion** |
"5" == 5   // true
"5" === 5  // false
ğŸ‘‰ Always prefer === in interviews & real projects.


ğŸ”· Logical Operators(&&, ||, !)
ğŸ‘‰ They return the actual operand, not boolean always:
console.log("A" && "B"); // "B"  (first truthy stops)
console.log(0 || 42);    // 42   (returns first truthy)
console.log(!"test");    // false

ğŸ”„ Short-Circuiting
1ï¸âƒ£ && stops on first falsy
2ï¸âƒ£ || stops on first truthy

Used commonly for:
user && user.name // safe access
name || "Guest"   // default value


ğŸ”· Bitwise Operators(&, |, ^, ~, <<, >>, >>>)
Work on 32-bit signed integers.

console.log(5 & 3); // 1   (AND)
console.log(5 | 3); // 7   (OR)
console.log(5 ^ 3); // 6   (XOR)
console.log(~5);    // -6  (NOT --> -(n+1))
console.log(5 << 1); // 10 (left shift)
console.log(5 >> 1); // 2  (arith right shift)

Zero-fill right shift (>>>)
console.log(-5 >>> 1); // big positive number (fills zero from left)


ğŸ”· Trick Questions (Only Operator-Based)
â“Q1: console.log(1 < 2 < 3);
âœ… Output: true
( 1 < 2 â†’ true â†’ true < 3 â†’ 1 < 3 â†’ true )

â“Q2: console.log(3 > 2 > 1);
âœ… Output: false
( 3 > 2 â†’ true â†’ true > 1 â†’ 1 > 1 â†’ false )

â“Q3: console.log("5" - 2);
console.log("5" + 2);
âœ… Output:
3   (number op)
"52" (string op)

â“Q4: console.log("hello" && 0 && "world");
âœ… Output:
 0 (stops on first falsy)

â“Q5:console.log(0 || null || "Hi" || false);
âœ… Output:
"Hi" (first truthy value)

â“Q6: console.log(~0);
âœ… Output:
 -1 (~n = -(n + 1))

â“Q7: console.log(5 & 1);
âœ… Output:
 1 (Binary: 0101 & 0001)

â“Q8:console.log(10 == [10]);
console.log(10 === [10]);
âœ… Output:
true   (array â†’ "10" â†’ number)
false  (type mismatch)



###########################
ğŸŒŠ Control Flow and Loops
###########################
ğŸ”· Control Flow in JavaScript
Control flow defines the order in which code is executed.

ğŸ”· Conditional Statements
| Statement       | Usage                                     |
| --------------- | ----------------------------------------- |
| `if`            | Runs code only if condition is true       |
| `ifâ€¦else`       | Runs alternate code if condition is false |
| `else if`       | Multiple conditions                       |
| `switch`        | Compare value against multiple cases      |
| Ternary (`? :`) | Short if-else for simple expressions      |

âœ… Example
let age = 18;

if (age > 18) {
  console.log("Adult");
} else if (age === 18) {
  console.log("Just turned adult");
} else {
  console.log("Minor");
}

âœ… Switch Example
let day = 2;

switch(day) {
  case 1: console.log("Mon"); break;
  case 2: console.log("Tue"); break;
  default: console.log("Other day");
}

âœ… Ternary Example
let x = 10;
let result = x > 5 ? "Greater" : "Smaller";
console.log(result);


ğŸ”· Loops in JavaScript
Loops help repeat tasks until a condition is met.
| Loop Type    | Best Use Case                               |
| ------------ | ------------------------------------------- |
| `for`        | Known number of iterations                  |
| `while`      | Loop until condition becomes false          |
| `doâ€¦while`   | Runs at least once                          |
| `forâ€¦of`     | Iterating over **arrays / iterable values** |
| `forâ€¦in`     | Iterating over **object keys**              |
| `.forEach()` | Array iteration (callback based)            |

âœ… For Loop Example
for (let i = 0; i < 5; i++) {
  console.log(i);
}

âœ… While Loop Example
let i = 0;
while (i < 5) {
  console.log(i);
  i++;
}

âœ… Do While Loop Example
let i = 0;
do {
  console.log(i);
  i++;
} while (i < 5);

âœ… For of Loop Example
const arr = [10, 20, 30];
for (const item of arr) {
  console.log(item);
}

âœ… For in Loop Example
const user = { name: "John", age: 20 };

for (const key in user) {
  console.log(key, user[key]);
}

âœ… forEach Loop Example
const nums = [1, 2, 3];

nums.forEach((n, i) => {
  console.log(`Index ${i}: ${n}`);
});

ğŸ”· Loop Control Keywords
| Keyword    | Purpose                                   |
| ---------- | ----------------------------------------- |
| `break`    | Stop the loop entirely                    |
| `continue` | Skip current iteration & move to next one |

âœ… Example
for (let i = 1; i <= 5; i++) {
  if (i === 3) continue;
  console.log(i);
}
âœ… Output: 1,2,4,5



######################################
ğŸŒŠ Error Handling (try, catch, throw)
######################################
JavaScript uses exceptions to handle errors in runtime
The main keyword used:
| Keyword   | Purpose                          |
| --------- | -------------------------------- |
| `try`     | Wraps code that may throw error  |
| `catch`   | Handles the error if thrown      |
| `throw`   | Manually create/customize errors |
| `finally` | Runs always (success OR error)   |

ğŸ”· Basic Syntax
try {
  // Code that might cause an error
} catch(err) {
  // Handle the error
} finally {
  // Always runs (optional)
}

âœ… Example: Handling an undefined variable
try {
  console.log(x); // x is not defined
} catch (err) {
  console.log("Error occurred:", err.message);
} finally {
  console.log("Execution completed");
}

ğŸ”· Throwing Custom Errors
Can throw any types: string, number, object, etc.
function divide(a, b) {
  if (b === 0) {
    throw new Error("Cannot divide by zero");
  }
  return a / b;
}

try {
  console.log(divide(10, 0));
} catch (err) {
  console.log(err.message);
}

ğŸ”· finally Always Executes
Even if there is a return inside try/catch,
try {
  return 10;
} catch (err) {
  return 20;
} finally {
  console.log("Cleanup action runs always!");
}

ğŸ”· Error Types in JavaScript
| Error Type     | Example Reason                  |
| -------------- | ------------------------------- |
| ReferenceError | Using undefined variable        |
| TypeError      | Invalid data type operation     |
| SyntaxError    | Code syntax mistake             |
| RangeError     | Invalid length/range            |
| EvalError      | Issues in eval()                |
| URIError       | Wrong encodeURI/decodeURI usage |

âœ… Example
let num=5;
num.toUpperCase();
âœ… Output: TypeError: num.toUpperCase is not a function

ğŸ”· Custom Error Class
class ValidationError extends Error {
  constructor(message) {
    super(message);
    this.name = "ValidationError";
  }
}

function validateAge(age) {
  if (age < 18) throw new ValidationError("User must be 18+");
}

try {
  validateAge(15);
} catch (err) {
  console.log(err.name + ": " + err.message);
}

ğŸ”· "use strict"- Strict Mode in JavaScript
Strict mode enforces a stricter set of JavaScript rules to prevent silent bugs.

Enabled by placing directive:
"use strict";

At top of file/function:
function myFunction() {
  //strict here
}

ğŸ”· What Strict Mode fixes 
1ï¸âƒ£ Prevents implicit global variables
"use strict";
x = 10; // âŒ ReferenceError


2ï¸âƒ£ Disallows duplicate parameter names
"use strict";
function fn(a, a) {} // âŒ SyntaxError


3ï¸âƒ£ Prevents deletion of non-deletable properties
"use strict";
delete Object.prototype; // âŒ TypeError


4ï¸âƒ£ this in functions becomes undefined
(No auto global binding)

"use strict";
function show() {
  console.log(this); // undefined
}
show();
ğŸ‘‰ In non-strict â†’ this = global object (window)


5ï¸âƒ£ Blocks usage of bad syntax like octal literals
"use strict";
let num = 010; // âŒ SyntaxError


6ï¸âƒ£ Prevents writing to read-only properties
"use strict";
const obj = {};
Object.freeze(obj);
obj.a = 10; // âŒ TypeError


7ï¸âƒ£ arguments.callee is forbidden
"use strict";
function x() {
  console.log(arguments.callee); // âŒ TypeError
}

ğŸ”· Why Do We Use Strict Mode?
| Benefit               | Explanation                            |
| --------------------- | -------------------------------------- |
| Safer code            | Disallows silent failures              |
| Fast performance      | Allows better engine optimizations     |
| Cleaner scoping       | Prevents accidental globals            |
| Early error detection | Shows errors that otherwise would hide |


ğŸ”· Trick Questions
â“Q1: function test() {
  console.log(this);
}
test();
âœ… Output:
Non-strict: window
Strict: undefined

â“Q2:
"use strict";
function foo() {
  bar = 5;
}
foo();
console.log(bar);
âœ… Output:
 ReferenceError (Implicit global is blocked)

â“Q3:"use strict";
var obj = { name: "A" };
Object.defineProperty(obj, "name", { writable: false });
obj.name = "B";
console.log(obj.name);
âœ… Output:
 TypeError thrown (Silent failure in non-strict)

â“Q4: "use strict";
function sum(a, a) {
  return a + a;
}
sum(2, 3);
âœ… Output: SyntaxError â€” duplicate params not allowed

â“Q5: "use strict";
console.log(this);
âœ… Output: Browser â†’ undefined in modules or functions, but at top-level inside script â†’ still window (Node â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ {} in modules)


###############################################
ğŸŒŠ Function Declaration vs Function Expression
###############################################
ğŸ”· Function Declaration
function add(a, b) {
  return a + b;
}

ğŸ”„ Key Properties
â¤ Hoisted completely (function body available before declaration)
â¤ Can be called before it appears in code
â¤ Has its own function name binding
â¤ add(2, 3); // âœ… works


ğŸ”· Function Expression
const add = function (a, b) {
  return a + b;
};

ğŸ”„ Key Properties
â¤ Not hoisted as a function
â¤ Variable is hoisted (depends on var / let / const)
â¤ Callable only after assignment
â¤ add(2, 3); // âŒ ReferenceError / TypeError (before definition)


ğŸ”· Named vs Anonymous Function Expression
const fn = function inner() {
  console.log(inner.name);
};
fn();       // "inner"
inner();    // âŒ ReferenceError

â¤ Name is scoped inside function only
â¤ Useful for recursion & debugging


ğŸ”· Hoisting Comparison
sayHi(); // âœ… works
function sayHi() {
  console.log("Hi");
}

sayHi(); // âŒ TypeError
var sayHi = function () {
  console.log("Hi");
};
Reason:
var sayHi;        // hoisted
sayHi = function() {}; // assigned later


ğŸ”· Function Expression with let / const
sayHi(); // âŒ ReferenceError (TDZ)
const sayHi = function () {};


ğŸ”· When to Use Which
| Scenario                   | Prefer               |
| -------------------------- | -------------------- |
| Utility / helper functions | Function Declaration |
| Conditional functions      | Function Expression  |
| Callbacks / closures       | Function Expression  |
| Prevent hoisting misuse    | Function Expression  |


ğŸ”· Trick Questions
â“Q1: foo();
function foo() {
  console.log("A");
}
var foo = function () {
  console.log("B");
};
âœ… Output: "A" (Function declaration wins during hoisting)

â“Q2: bar();
var bar = function () {
  console.log("Hello");
};
âœ… Output : TypeError (bar is undefined at call time)

â“Q3: const test = function abc() {
  console.log(typeof abc);
};
test();
console.log(typeof abc);
âœ… Output:
function
undefined

â“Q4: if (true) {
  function x() {}
}
x(); // ?
âœ… Output:
Non-strict: works (environment dependent)
Strict mode: âŒ ReferenceError
(Function declarations are block-scoped in strict)

â“Q5: let fn = function () {};
typeof fn;
âœ… Output: "function"


####################
ğŸŒŠ Arrow Functions
####################
ğŸ”· Syntax
const add = (a, b) => a + b;

Single param: x => x * 2
No params: () => 42

Block body (explicit return):
(a, b) => {
  return a + b;
}

ğŸ”· Key Differences vs Normal Functions
1ï¸âƒ£ No own this
â¤ Arrow functions lexically bind this
â¤ this is taken from outer scope

const obj = {
  name: "A",
  greet: () => {
    console.log(this.name);
  }
};
obj.greet(); // undefined


âœ” Correct usage:

const obj = {
  name: "A",
  greet() {
    setTimeout(() => {
      console.log(this.name);
    }, 100);
  }
};


2ï¸âƒ£ No arguments object
const fn = () => {
  console.log(arguments);
};
fn(1,2); // âŒ ReferenceError
Use rest instead: const fn = (...args) => console.log(args);


3ï¸âƒ£ Cannot be used as constructor
const A = () => {};
new A(); // âŒ TypeError
(No [[Construct]], no prototype)


4ï¸âƒ£ No hoisting
sayHi(); // âŒ ReferenceError
const sayHi = () => {};


5ï¸âƒ£ Implicit return
const square = x => x * x;


âš ï¸ Returning object needs parentheses:
const getUser = () => ({ name: "A" });

ğŸ”„ Valid Use Cases
  âœ”ï¸ Callbacks
  âœ”ï¸ Closures
  âœ”ï¸ Functional utilities (map, filter)
  âœ”ï¸ Preserving this inside async code

âŒ Avoid for:
  âœ”ï¸ Object methods
  âœ”ï¸ Constructors
  âœ”ï¸ Event handlers needing dynamic this

âš ï¸ Trick Questions 
â“Q1:const obj = {
  x: 10,
  fn: () => console.log(this.x)
};
obj.fn();
âœ… Output: undefined

â“Q2:const obj = {
  x: 10,
  fn() {
    const arrow = () => console.log(this.x);
    arrow();
  }
};
obj.fn();
âœ… Output: 10

â“Q3: const fn = () => ({});
console.log(typeof fn());
âœ… Output: "object"

â“Q4: const fn = () => {};
console.log(fn.prototype);
âœ… Output: undefined

â“Q5: (() => {
  console.log(this);
})();
âœ… Output:
Browser (non-module): window
Module / strict: undefined


######################
ğŸŒŠ Default Parameter
######################
âœ”ï¸ Basic Usage
function greet(name = "Guest") {
  return name;
}
greet();        // "Guest"
greet("Ankur"); // "Ankur"
ğŸ‘‰ Default value is used only when argument is undefined.


âœ”ï¸ When Default Applies 
function test(x = 10) {
  return x;
}
test(undefined); // 10  âœ…
test(null);      // null âŒ (no default)
test(0);         // 0


âœ”ï¸ Default Parameters Are Evaluated at Call Time
let count = 0;
function fn(x = ++count) {
  return x;
}
fn(); // 1
fn(); // 2


âœ”ï¸ Using Previous Parameters as Defaults
function sum(a, b = a) {
  return a + b;
}
sum(5); // 10
âŒ Not allowed (right â†’ left only):
function test(a = b, b = 5) {} // ReferenceError


âœ”ï¸ Default Parameters Create Their Own Scope
let x = 10;
function foo(a = x) {
  let x = 20;
  return a;
}
foo(); // 10
(Default params evaluated before function body)


âœ”ï¸ Interaction with arguments
function fn(a = 1) {
  console.log(arguments.length);
}
fn();    // 0
fn(5);   // 1
Default params do NOT sync with arguments.


âœ”ï¸ Default + Destructuring
function createUser({ name = "Guest" } = {}) {
  return name;
}
createUser(); // "Guest" (Important real-world pattern)

This pattern is used to safely extract values from objects/arrays while providing fallback defaults.

âœ”ï¸ Why Itâ€™s Needed

Calling a function with:

missing object

missing properties

would normally cause errors.

âœ”ï¸ Basic Pattern (Most Important)
function createUser({ name = "Guest", age = 18 } = {}) {
  console.log(name, age);
}

How it behaves:
createUser(); 
// name = "Guest", age = 18

createUser({ name: "Ankur" });
// name = "Ankur", age = 18

âœ”ï¸ What = {} Actually Does
function fn({ a } = {}) {}

Prevents this error:
fn(); // âŒ Cannot destructure property 'a' of undefined
= {} provides a safe fallback object

âœ”ï¸ Property-Level Defaults
function test({ x = 10 }) {
  console.log(x);
}
test({});        // 10
test({ x: 5 });  // 5

âš ï¸ Default applies only when property is undefined, not null.
test({ x: null }); // null

âœ”ï¸ Nested Destructuring + Defaults
function config({ server: { port = 3000 } = {} } = {}) {
  console.log(port);
}
config(); 
config({ server: {} });
Both output: 3000

âœ”ï¸ Array Destructuring + Defaults
function sum([a = 0, b = 0] = []) {
  return a + b;
}
sum();        // 0
sum([5]);     // 5
sum([5, 3]);  // 8


âš ï¸ Trick Questions
â“Q1: function test(a = 10) {
  console.log(a);
}
test(null);
âœ… Output: null

â“Q2: function fn(a = 1, b = a) {
  console.log(a, b);
}
fn(5);
âœ… Output: 5 5

â“Q3: function fn(a = 1) {
  a = 5;
  console.log(a);
}
fn();
âœ… Output: 5 (Default only applies at call time)

â“Q4: function test(a = 10) {
  console.log(arguments[0]);
}
test();
âœ… Output: undefined

â“Q5: let x = 100;
function foo(a = x) {
  let x = 200;
  console.log(a);
}
foo();
âœ… Output: 100


#######################
ğŸŒŠ High Order Function
#######################
A Higher-Order Function is a function that does at least one of the following:
1ï¸âƒ£ Takes one or more functions as arguments
2ï¸âƒ£ Returns a function

âœ… Example: Function as Argument
function operate(a, b, operation) {
  return operation(a, b);
}
operate(2, 3, (x, y) => x + y); // 5

âœ… Example: Function Returning Function
function multiplier(factor) {
  return function (num) {
    return num * factor;
  };
}
const double = multiplier(2);
double(5); // 10


âœ”ï¸ Built-in Higher-Order Functions
â¤ map
â¤ filter
â¤ reduce
â¤ forEach
â¤ find
â¤ some
â¤ every

[1, 2, 3].map(x => x * 2); // [2, 4, 6]

ğŸ”„ Callback = Core of HOF
function fetchData(callback) {
  callback("data");
}
fetchData(result => console.log(result));
â¤ Callback is just a function passed to another function
â¤ All callbacks â†’ HOF usage

âœ… Pure HOF Example
const add = x => y => x + y;
add(2)(3); // 5 (Returning function enables currying)

âœ”ï¸ Why HOFs Are Used
1ï¸âƒ£ Code reuse
2ï¸âƒ£ Abstraction
3ï¸âƒ£ Cleaner logic
4ï¸âƒ£ Functional programming style


ğŸ”· Trap Questions
â“Q1: function hof(fn) {
  return fn;
}
console.log(typeof hof(() => {}));
âœ… Output: "function"

â“Q2: function hof(fn) {
  fn();
}
hof(console.log("Hello"));
âœ… Output: "Hello" printed before hof is called (you passed result, not function)
âœ… Correct: hof(() => console.log("Hello"));

â“Q3: const arr = [1, 2, 3];
const result = arr.map(console.log);
âœ… Output:
console.log receives (value, index, array)
Output is unexpected â†’ returns [undefined, undefined, undefined]

â“Q4: const add = x => y => x + y;
typeof add(5);
âœ… Output: "function"

â“Q5: function test() {
  return function () {
    return 10;
  };
}
test()(); // ?
âœ… Output: 10


##############
ğŸŒŠ Callbacks
##############
A callback is a function passed as an argument to another function and executed later.

function greet(name, callback) {
  callback(name);
}

greet("Ankur", n => console.log("Hello", n));

ğŸ”„ Why Callbacks Exist
1ï¸âƒ£ Handle async operations
2ï¸âƒ£ Defer execution
3ï¸âƒ£ Control flow after an operation completes


ğŸ”„ Synchronous Callbac
Executed immediately.

[1, 2, 3].forEach(x => console.log(x));


ğŸ”„ Asynchronous Callback
Executed later.

setTimeout(() => {
  console.log("Async");
}, 1000);


ğŸ”„ Callback Signature Matters
Many JS APIs pass extra arguments.

[10, 20].map((value, index, array) => value);


ğŸ”„ Error-First Callback (Node.js pattern)
function readData(callback) {
  callback(null, "data");
}

readData((err, result) => {
  if (err) return;
  console.log(result);
});
âœ”ï¸ err is always first
âœ”ï¸ If err exists â†’ ignore result


ğŸ”„ Callback Hell (Problem)
setTimeout(() => {
  setTimeout(() => {
    setTimeout(() => {
      console.log("Hell");
    }, 1000);
  }, 1000);
}, 1000);
âœ”ï¸ Deep nesting
âœ”ï¸ Hard to read & maintain


ğŸ”„ How Callback Hell Is Mitigated
âœ”ï¸ Named callbacks
âœ”ï¸ Promises
âœ”ï¸ async / await
(Callbacks still exist under the hood)

âš ï¸ Trap Questions
â“Q1: function test(cb) {
  cb();
}
test(console.log("Hi"));
âœ… Output:
"Hi" prints immediately
âŒ Passed result, not callback
ğŸ”„ Correct:
test(() => console.log("Hi"));


â“Q2: setTimeout(console.log("Hello"), 1000);
âœ… Output:
Prints immediately
Timeout receives undefined


â“Q3: function hof(cb) {
  return cb;
}
hof(() => 10)();
âœ… Output: 10


â“Q4: try {
  setTimeout(() => {
    throw new Error("Error");
  }, 1000);
} catch (e) {
  console.log("Caught");
}
âŒ Error is not caught
Callbacks run in a different call stack

â“Q5: [1, 2, 3].map(parseInt);
âœ… Output:
Unexpected result â†’ [1, NaN, NaN]
Because: parseInt(value, index)


######################
ğŸŒŠ Function Currying
######################
Currying is the process of transforming a function with multiple arguments into a sequence of functions, each taking one argument.

function add(a, b, c) {
  return a + b + c;
}

ğŸ”„ Curried version:
const add = a => b => c => a + b + c;
add(1)(2)(3); // 6


ğŸ”„ Why Currying Is Used
â¤ Partial application
â¤ Reusability
â¤ Function composition
â¤ Clean functional style


ğŸ”„ Partial Application via Currying
const multiply = a => b => a * b;

const double = multiply(2);
double(5); // 10


ğŸ”„ Currying vs Normal Function Call
add(1, 2, 3);   // âŒ not curried
add(1)(2)(3);  // âœ… curried


ğŸ”„ Currying Using Closures
function curry(a) {
  return function (b) {
    return function (c) {
      return a + b + c;
    };
  };
}
ğŸ‘‰ Each inner function remembers previous arguments


ğŸ”„ Generic Curry Function
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn(...args);
    }
    return (...next) => curried(...args, ...next);
  };
}
const sum = (a, b, c) => a + b + c;
const curriedSum = curry(sum);

curriedSum(1)(2)(3); // 6
curriedSum(1, 2)(3); // 6


âš ï¸ Trap Questions
â“Q1: const add = a => b => a + b;
add(2, 3);
âœ… Output: Returns a function, ignores 3


â“Q2: const add = a => b => a + b;
typeof add(5);
âœ… Output: "function"

â“Q3: function sum(a, b, c) {
  return a + b + c;
}
sum(1)(2)(3);
âœ… Output:
âŒ TypeError
Function is not curried


â“Q4: const multiply = a => b => a * b;
multiply(2)(3)(4);
âœ… Output:
 âŒ TypeError
Extra function call on number


â“Q5: const add = a => b => c => a + b + c;
add(1, 2)(3);
âœ… Output:
2 is ignored â†’ returns function expecting b


##################################################
ğŸŒŠ IIFE (Immediately Invoked Function Expression)
##################################################
An IIFE is a function expression that is executed immediately after it is defined.

(function () {
  console.log("IIFE");
})();


ğŸ”„ Why IIFE Exists
â¤ Create a private scope
â¤ Avoid global variable pollution
â¤ Execute code once immediately


ğŸ”„ Function Expression Requirement
âŒ This is invalid:
function test() {}();


ğŸ”„ Must be an expression:
(function test() {})();


ğŸ”„ Arrow Function IIFE
(() => {
  console.log("Arrow IIFE");
})();


ğŸ”„ Passing Arguments to IIFE
(function (name) {
  console.log(name);
})("Ankur");


ğŸ”„ IIFE with Return Value
const result = (function () {
  return 10;
})();
console.log(result); // 10


ğŸ”„ IIFE for Data Encapsulation
const counter = (function () {
  let count = 0;

  return {
    increment() {
      count++;
    },
    getCount() {
      return count;
    }
  };
})();
âœ”ï¸ count is private
âœ”ï¸ Public methods exposed


ğŸ”„ Multiple IIFEs (Semicolon Trap)
(function () {
  console.log("First");
})();

(function () {
  console.log("Second");
})();
â— Missing semicolon before second IIFE can break execution


âš ï¸ Trap Questions 
â“Q1: (function () {
  var a = 10;
})();
console.log(a);
âœ… Output: âŒ ReferenceError


â“Q2: (function () {
  console.log(this);
})();
âœ… Output:
âœ”ï¸ Non-strict â†’ window
âœ”ï¸ Strict mode â†’ undefined


â“Q3: (() => {
  console.log(this);
})();
âœ… Output: Arrow IIFE inherits this from outer scope


â“Q4: (function (a) {
  console.log(a);
})();
âœ… Output: undefined


â“Q5: +function () {
  console.log("IIFE");
}();
âœ… Output: Valid IIFE using unary operator (+)


ğŸ”„ Valid IIFE Syntax Variants
(function(){})()
(function(){}())
!function(){}()
+function(){}()

