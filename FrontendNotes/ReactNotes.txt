===============================
ğŸ”· What is React & Why React
===============================
React is a JavaScript librry for building user interfaces
â¤ Focuses only on the View layer
â¤ UI is built using components
â¤ UI updates are declarative, not imperative


ğŸ”„ What React Is NOT
âŒ Not a framework
âŒ Not a full MVC solution
âŒ Not responsible for routing, HTTP, or state persistence
âŒ Not replacing JavaScript
âœ… React does one thing extremely well â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ UI rendering.


ğŸ”„ Creation of React
Before React (Traditional UI Approach)
    âœ”ï¸ Direct DOM manipulation (jQuery, vanilla JS)
    âœ”ï¸ Manual UI updates
    âœ”ï¸ Tight coupling between state & UI
    âœ”ï¸ Hard to scale as UI grows

Problems:
    ğŸš« DOM updates are slow
    ğŸš« UI logic becomes complex & buggy
    ğŸš« No predictable rendering
    ğŸš« Code becomes unmaintainable in large apps


ğŸ”„ Facebookâ€™s Problem (Real Origin)
1ï¸âƒ£ News Feed UI had:
    âœ”ï¸ Frequent updates
    âœ”ï¸ Complex state
    âœ”ï¸ High interactivity
2ï¸âƒ£ Manual DOM updates became unmanageable
â¡ï¸ React was created to solve UI complexity, not performance initially


ğŸ”„ Core Philosophy of React
1ï¸âƒ£ Declarative UI
â¤ You describe WHAT UI should look like
â¤ React decides HOW to update it

UI = f(state)
ğŸ‘‰ UI is a pure function of state


2ï¸âƒ£ Component-Based Architecture
â¤ UI is broken into independent reusable components
â¤ Each component:
    âœ”ï¸ Has its own logic
    âœ”ï¸ Can manage its own state
    âœ”ï¸ Is reusable & testable


3ï¸âƒ£ Unidirectional Data Flow
â¤ Data flows top â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ down
â¤ Parent controls child
â¤ Predictable state changes


ğŸ”„ React Is Different
1ï¸âƒ£ Virtual DOM
â¤ React creates an in-memory representation of the DOM
â¤ Changes are calculated first
â¤ Only minimal real DOM updates are applied
ğŸ‘‰ Real DOM is expensive, Virtual DOM is cheap


2ï¸âƒ£ Efficient Reconciliation
â¤ React compares previous & next Virtual DOM
â¤ Finds minimal changes (diffing)
â¤ Applies only necessary updates


3ï¸âƒ£ Separation of Concerns
â¤ Logic + UI live together (JSX)
â¤ Opposite of traditional HTML/CSS/JS separation
â¤ Improves maintainability at scale


ğŸ”„ React Instead of Vanilla JS
| Vanilla JS          | React                 |
| ------------------- | --------------------- |
| Imperative          | Declarative           |
| Manual DOM updates  | Auto UI sync          |
| Hard to scale       | Scales well           |
| Spaghetti code risk | Structured components |
| State scattered     | Centralized state     |
Mental Model:
ğŸ‘‰ Vanilla JS = Change this state
ğŸ‘‰ React = Change the state


ğŸ”„ React Instead of jQuery
jQuery:
    âœ”ï¸ Direct DOM manipulation
    âœ”ï¸ No component model
    âœ”ï¸ No state abstraction

React:
    âœ”ï¸ Virtual DOM
    âœ”ï¸ Predictable state
    âœ”ï¸ Reusable components

â¤ jQuery manipulates DOM
â¤ React describes UI


ğŸ”„ Popularity of React
1ï¸âƒ£ Technical Reasons
â¤ Component reusability
â¤ Performance via reconciliation
â¤ Predictable rendering
â¤ Strong ecosystem

2ï¸âƒ£ Business Reasons
â¤ Faster development
â¤ Easier maintenance
â¤ Large developer community
â¤ Backed by Meta


ğŸ”„ Reactâ€™s Role in Modern Apps
â¤ Used for:
    âœ”ï¸ Dashboards
    âœ”ï¸ Admin panels
    âœ”ï¸ SaaS platforms
    âœ”ï¸ Large enterprise apps

â¤ Not ideal for:
    âŒ Simple static websites
    âŒ Minimal UI logic apps


ğŸ”„ Common Misconceptions
âŒ React is fast because Virtual DOM
âœ… React is fast because of efficient diffing

âŒ React replaces backend
âœ… React is frontend only

âŒ React automatically optimizes everything
âœ… Bad code still causes bad performance


=======================================
ğŸ”· SPA vs MPA (from React perspective)
=======================================
ğŸ”„ What is an Application (UI Perspective)
A web application = UI + Data + Navigation

â“ Key question: What happens when the user clicks a link or performs an action?
This answer defines SPA vs MPA.


ğŸ”„ Multi-Page Application (MPA)
â¤ Every navigation loads a new HTML page from the server.
â¤ Browser performs a full page reload.


ğŸ”„ How MPA Works
1ï¸âƒ£ User clicks a link
2ï¸âƒ£ Browser sends request to server
3ï¸âƒ£ Server returns a new HTML document
4ï¸âƒ£ Browser:
    âœ”ï¸ Destroys current DOM
    âœ”ï¸ Loads new DOM
    âœ”ï¸ Re-downloads assets (CSS, JS, images)
5ï¸âƒ£ Page is re-rendered


ğŸ”„ Characteristics of MPA
â¤ Multiple HTML files
â¤ Server-driven rendering
â¤ Each page is independent
â¤ Navigation = network request

âœ… Examples
    âœ”ï¸ Traditional websites
    âœ”ï¸ Old PHP/JSP/ASP apps
    âœ”ï¸ Server-side rendered pages without Hydration


ğŸ”„ Hydration
â¤ React makes the already-loaded HTML interactive in the browser.
â¤ The page looks ready, but buttons donâ€™t work yet.
â¤ Hydration is the step where React connects JavaScript to that HTML so clicks, inputs, etc. start working.

âœ… Simple Example
Step 1ï¸âƒ£: Server sends HTML (SSR)
The server sends this to the browser: <button>Click me</button>
You can see the button, but it does nothing yet.

Step 2ï¸âƒ£: Hydration happens in browser
Reactâ€™s JavaScript loads and runs: <button onClick={() => alert("Hello!")}>Click me</button>

Now React:
â¤ Finds the existing <button>
â¤ Attaches the onClick handler
âœ… The button becomes clickable


ğŸ”„ Problems with MPA (Why React Exists)
1ï¸âƒ£ Performance Issues
    ğŸš« Full page reloads
    ğŸš« UI Flicker
    ğŸš« Re-fetching assets
    ğŸš« Slower user experience

2ï¸âƒ£ Developer Experience Issues
    ğŸš« Repeated layouts
    ğŸš« Hard to manage state across pages
    ğŸš« Complex navigation logic

3ï¸âƒ£ State Problems
    ğŸš« State is lost on every navigation
    ğŸš« Hard to maintain:
        âœ”ï¸ Logged-in state
        âœ”ï¸ UI state
        âœ”ï¸ In-memory data


ğŸ”„ Single-Page Application (SPA)
â¤ Application loads one HTML page once
â¤ UI updates dynamically using JavaScript
â¤ Navigation does NOT reload the page


ğŸ”„ How SPA Works
1ï¸âƒ£ Browser loads index.html once
2ï¸âƒ£ React JS bundle loads
3ï¸âƒ£ React builds UI using JS
4ï¸âƒ£ User clicks a link
5ï¸âƒ£ React
    âœ”ï¸ Change state
    âœ”ï¸ Updates components
    âœ”ï¸ Updates DOM
6ï¸âƒ£ URL may change without page reload
Key Rule: Page never reloads â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ only components change


ğŸ”„ Why React is SPA-Oriented
React is designed for:
    âœ”ï¸ Long-living UI
    âœ”ï¸ Frequent state changes
    âœ”ï¸ Dynamic updates without reloads
    âœ”ï¸ Rich interactions


ğŸ”„ Difference between SPA and MPA
| Aspect            | MPA                 | SPA           |
| ----------------- | ------------------- | ------------- |
| Page Load         | On every navigation | Once          |
| HTML              | Multiple            | Single        |
| Rendering         | Server-driven       | Client-driven |
| Navigation        | Full reload         | JS-based      |
| State Persistence | Lost                | Preserved     |
| UX                | Slower              | Faster        |
| React Fit         | âŒ Poor             | âœ… Perfect   |


ğŸ”„ Routing Difference
1ï¸âƒ£ MPA Routing
â¤ Handled by server such as /login, /home, /profile
â¤ Each route = new HTML page

2ï¸âƒ£ SPA Routing
â¤ Handled by client (React Router)
â¤ Each route = different component view
â¤ URL changes without reload
â¤ Browser History API is used to manage URLs without reloading the page.


ğŸ”„ State Management Implications
1ï¸âƒ£ MPA State Management
â¤ State stored in:
    âœ”ï¸ Server sessions
    âœ”ï¸ Cookies
    âœ”ï¸ DB
â¤ UI state resets on reload

2ï¸âƒ£ SPA State Management
â¤ State stored in:
    âœ”ï¸ In-memory (React state)
    âœ”ï¸ Client storage (localStorage, IndexedDB)
    âœ”ï¸ Context API
    âœ”ï¸ Redux
â¤ UI state persists across navigations


ğŸ”„ Performance Persistence
ğŸ”„ Initial Load
â¤ MPA: âŒ Slower (big JS bundle)
â¤ SPA: âœ… Faster

ğŸ”„ After Initial Load
â¤ MPA: âŒ Slower (full reloads)
â¤ SPA: âœ… Very fast


ğŸ”„ React Optimization Techniques
â¤ Code Splitting
â¤ Lazy Loading
â¤ Memoization
â¤ Caching

ğŸ”„ SEO Perspective
MPA:
    âœ”ï¸ SEO-friendly by default
    âœ”ï¸ HTML available immediately

SPA:
SEO issues historically
Needs:
    âœ”ï¸ Server-Side Rendering (SSR)
    âœ”ï¸ Meta handling
    âœ”ï¸ Pre-rendering
That is why Next.js is popular for React SEO needs.


When React SPA is a Bad Choice
âŒ Simple static sites
âŒ Content-heavy blogs
âŒ Simple landing pages
âŒ Apps needing full SEO (without SSR)


ğŸ”„ When to Choose SPA with React
âœ… Admin Dashboards
âœ… SaaS products
âœ… Social media apps
âœ… E-commerce apps


===============================
ğŸ”· React Architecture Overview
===============================
ğŸ”„ What â€œReact Architectureâ€ Means
From React POV, architecture answers:
â¤ How React thinks
â¤ How React builds UI
â¤ How React updates UI
â¤ How React manages changes over time
ğŸ‘‰ React architecture is about rendering, reconciliation, and committing UI updates efficiently.


ğŸ”„ High-Level React Architecture
React internally works in three major layers:

State / Props Change
        â†“
Render Phase (Virtual DOM)
        â†“
Reconciliation (Diffing)
        â†“
Commit Phase (Real DOM Update)


ğŸ”„ Core Building Blocks of React
1ï¸âƒ£ React Elements
â¤ Smallest unit in React
â¤ Plain JavaScript objects
â¤ Describe what the UI should look like
{
  type: 'div',
  props: { children: 'Hello' }
}
ğŸ‘‰ React elements are NOT DOM nodes


2ï¸âƒ£ Components
â¤ Functions (or classes) that return React elements
â¤ Encapsulate UI + logic
â¤ Reusable and composable


3ï¸âƒ£ Virtual DOM (Fiber Tree)
â¤ In-memory representation of UI
â¤ Stored as a Fiber Tree
â¤ Used to calculate changes before touching real DOM


4ï¸âƒ£ Reconciler
â¤ Compares old Fiber Tree with new one
â¤ Finds minimal set of changes
â¤ Decides what must be updated

5ï¸âƒ£ Renderer
â¤ Applies changes to target platform
âœ… Examples:
    âœ”ï¸ ReactDOM â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Browser
    âœ”ï¸ React Native â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Mobile
    âœ”ï¸ React Three Fiber â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ WebGL


ğŸ”„ React Rendering Pipeline
1ï¸âƒ£ State / props change
2ï¸âƒ£ React calls component functions
3ï¸âƒ£ New React elements are created
4ï¸âƒ£ New Fiber Tree is built
5ï¸âƒ£ Reconciliation happens
6ï¸âƒ£ DOM updates are prepared
7ï¸âƒ£ Changes committed to real DOM


ğŸ”„ Render Phase vs Commit Phase (Very Important)
1ï¸âƒ£ Render Phase
â¤ Pure calculation
â¤ No DOM updates
â¤ Can be paused, restarted, or discarded
â¤ Runs component functions

2ï¸âƒ£ Commit Phase
â¤ Actual DOM updates
â¤ Cannot be interrupted
â¤ Effects (useEffect) are scheduled
ğŸ‘‰ React may render multiple times before committing once


ğŸ”„ React Fiber Architecture (Why React Is Powerful)
1ï¸âƒ£ Why Fiber Was Introduced
â¤ Old Stack reconciler was synchronous
â¤ Large UI updates blocked main thread


2ï¸âƒ£ Fiber Enables
â¤ Interruptible rendering
â¤ Priority-based updates
â¤ Concurrent rendering
â¤ Better UX


3ï¸âƒ£ Fiber Node Represents
â¤ A component
â¤ A DOM element
â¤ A fragment
â¤ A provider


ğŸ”„ Reactâ€™s Internal Trees
React maintains multiple trees:
    âœ”ï¸ Current Tree â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ what user sees
    âœ”ï¸ Work-In-Progress Tree â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ new changes
    âœ”ï¸ Alternate Tree â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ for diffing


ğŸ”„ Scheduling & Priority
React assigns priorities:
    âœ”ï¸ User interactions â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ high priority
    âœ”ï¸ Data fetching â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ low priority
    âœ”ï¸ Background updates â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ deferred
ğŸ‘‰ Enables smooth UI under heavy load


ğŸ”„ Hooks & Architecture
Hooks integrate deeply:
â¤ Hooks run during render phase
â¤ Order of hooks is critical
â¤ Hook state stored in Fiber nodes
â¤ Same hook order = correct mapping


ğŸ”„ Event System Architecture
â¤ React uses Synthetic Events
â¤ Single event listener per event type
â¤ Event delegation at root
â¤ Normalized behavior across browsers


ğŸ”„ Data Flow Architecture
â¤ Unidirectional
â¤ Parent â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Child
â¤ State changes flow downward
â¤ UI updates flow upward via callbacks


ğŸ”„ Separation of Responsibilities
| Layer      | Responsibility  |
| ---------- | --------------- |
| React Core | Component logic |
| Reconciler | Diffing         |
| Renderer   | DOM updates     |
| Scheduler  | Priority        |
| Hooks      | State & effects |


ğŸ”„ What Triggers Re-Render (Architecture POV)
â¤ State update
â¤ Props change
â¤ Context value change
â¤ Parent re-render
ğŸ‘‰ React does NOT re-render because DOM changed


ğŸ”„ Common Architectural Misconceptions
âŒ React updates DOM directly
âœ… React updates Virtual DOM first

âŒ Re-render = DOM update
âœ… Re-render = recalculation

âŒ Hooks store state globally
âœ… State is stored per Fiber 


======================
ğŸ”· React Virtual DOM
======================
ğŸ”„ Real DOM (Browser DOM)
â¤ Tree representation of HTML
â¤ Each node = actual browser object
â¤ Direct manipulation triggers:
    âœ”ï¸ Layout
    âœ”ï¸ Paint
    âœ”ï¸ Reflow
â¤ Expensive operations


ğŸ”„ Problem with Real DOM
â¤ Updating DOM frequently = slow
â¤ Manual DOM manipulation = complex
â¤ Hard to track UI changes


ğŸ”„ What is Virtual DOM
â¤ Virtual DOM is an in-memory JavaScript representation of the real DOM
â¤ Lightweight & fast
â¤ Exists only inside React


ğŸ”„ What Virtual DOM is NOT
âŒ Not a browser feature
âŒ Not faster than real DOM by itself
âŒ Not a magic performance booster
âŒ Not React Fiber itself
ğŸ‘‰ Virtual DOM is a strategy, not a performance hack


ğŸ”„ Why Virtual DOM Was Needed
Core Problem
â¤ UI changes frequently
â¤ DOM operations are expensive
â¤ React needed a way to:
    âœ”ï¸ Batch updates
    âœ”ï¸ Minimize DOM writes
    âœ”ï¸ Make rendering predictable


ğŸ”„ How Virtual DOM Works
1ï¸âƒ£ Initial Render
â¤ JSX â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ React.createElement
â¤ React creates Virtual DOM tree
â¤ React creates Real DOM
â¤ DOM is mounted


2ï¸âƒ£ Update Cycle
â¤ State changes
â¤ Component re-executes
â¤ New Virtual DOM tree created
â¤ Old vs New Virtual DOM compared
â¤ Differences calculated
â¤ Minimal real DOM updates applied


ğŸ”„ Virtual DOM Internals
Virtual DOM nodes are plain JS objects
âœ… Example:

{
  type: 'div',
  props: {
    className: 'box',
    children: 'Hello'
  }
}
â¤ No layout
â¤ No painting
â¤ No browser interaction


ğŸ”„ Virtual DOM vs Real DOM
| Aspect       | Virtual DOM | Real DOM      |
| ------------ | ----------- | ------------- |
| Location     | Memory      | Browser       |
| Speed        | Fast        | Slow          |
| Updates      | Cheap       | Expensive     |
| Structure    | JS Objects  | DOM Nodes     |
| Side Effects | None        | Layout/Reflow |


ğŸ”„ Why Virtual DOM Improves Performance
âŒ Wrong Belief
Virtual DOM is faster than real DOM


âœ… Correct Truth
Virtual DOM allows React to:
    âœ”ï¸ Batch updates
    âœ”ï¸ Calculate minimal DOM operations
    âœ”ï¸ Avoid unnecessary changes
ğŸ‘‰ Performance comes from diffing + batching, not from Virtual DOM itself


ğŸ”„ Virtual DOM & Re-rendering
â¤ State change â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ re-render
â¤ Re-render = new Virtual DOM
â¤ React does NOT update DOM immediately
â¤ DOM update happens after diffing


ğŸ”„ Virtual DOM & Reconciliation
â¤ Reconciliation = process of comparing:
    âœ”ï¸ Previous Virtual DOM
    âœ”ï¸ New Virtual DOM

â¤ Determines:
    âœ”ï¸ What changed
    âœ”ï¸ What stayed same
    âœ”ï¸ What needs DOM updates
ğŸ‘‰ Virtual DOM is the input to reconciliation


ğŸ”„ Fiber & Virtual DOM Relationship
â¤ Fiber is the data structure
â¤ Virtual DOM is the concept
â¤ Fiber nodes represent:
    âœ”ï¸ Components
    âœ”ï¸ DOM elements
    âœ”ï¸ Hooks state


ğŸ”„ Common Virtual DOM Misconceptions
âŒ Virtual DOM avoids DOM completely
âœ… DOM is still updated

âŒ Virtual DOM updates only changed components
âœ… Whole subtree is recalculated, DOM update is selective

âŒ Virtual DOM eliminates re-render cost
âœ… Re-render still costs CPU


ğŸ”„ Performance Pitfalls Related to Virtual DOM
â¤ Unnecessary re-renders
â¤ Large component trees
â¤ Missing keys in lists
â¤ Inline object/array creation
â¤ Expensive render logic


ğŸ”„ When Virtual DOM Doesnâ€™t Help
â¤ Heavy computations in render
â¤ Frequent state updates
â¤ Large unoptimized lists
â¤ Poor component structure


=============================
ğŸ”· Reconciliation Algorithm
=============================
Reconciliation is the process of comparing the previous UI tree with the new UI tree and deciding what needs to change in the real DOM.


ğŸ”„ Why Reconciliation Exists
ğŸŒŸ Core Problem
â¤ On every state/props change:
    âœ”ï¸ React re-executes components
    âœ”ï¸ A new Virtual DOM tree is produced
â¤ Comparing two arbitrary trees is O(nÂ³) (too slow)
â¡ï¸ React uses heuristics to make this O(n).


ğŸ”„ Reconciliation in Reactâ€™s Architecture
State / Props Change
        â†“
Re-render Components
        â†“
New Virtual DOM Tree
        â†“
Reconciliation (Diffing)
        â†“
Minimal DOM Mutations
ğŸ‘‰ Reconciliation runs before the commit phase.


ğŸ”„ Core Assumptions (Heuristics) React Uses
Reactâ€™s reconciliation algorithm is based on two critical assumptions:
1ï¸âƒ£ Different Element Types = Different Trees
<div />
<span />

â¤ React assumes they are completely different
â¤ Old subtree is destroyed
â¤ New subtree is created
ğŸ‘‰ No deep comparison across different types


2ï¸âƒ£ Stable Keys Preserve Identity
{items.map(item => <Item key={item.id} />)}

â¤ Keys help React match:
    âœ”ï¸ Old nodes
    âœ”ï¸ New nodes
â¤ Without keys â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ React falls back to index-based matching


ğŸ”„ Reconciliation Rules
Case 1ï¸âƒ£: Same Type, Same Key
â¤ Reuse existing DOM node
â¤ Update only changed props
â¤ Reconcile children recursively

Case 2ï¸âƒ£: Same Type, Different Props
â¤ DOM node reused
â¤ Only prop differences applied

Case 3ï¸âƒ£: Different Type
â¤ Old node unmounted
â¤ New node mounted
â¤ State is lost

Case 4ï¸âƒ£: Lists with Keys
â¤ Keys define identity
â¤ React:
    âœ”ï¸ Moves nodes
    âœ”ï¸ Inserts new ones
    âœ”ï¸ Removes deleted ones


ğŸ”„ Reconciliation of Lists
1ï¸âƒ£ Without Keys
{items.map(item => <Item />)}

â¤ React uses index
â¤ Causes:
    âœ”ï¸ Wrong DOM reuse
    âœ”ï¸ State bugs
    âœ”ï¸ Performance issues

2ï¸âƒ£ With Keys
{items.map(item => <Item key={item.id} />)}

â¤ Stable identity
â¤ Correct matching
â¤ Minimal DOM updates


ğŸ”„ Why Keys Matter
â¤ Keys tell React: â€œThis element corresponds to the same entity across rendersâ€
â¤ React builds a map of keys â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ fibers
â¤ Efficient lookup instead of sequential matching


ğŸ”„ Reconciliation & Component State
â¤ If component is reused: State is preserved
â¤ If component is destroyed: State is reset
â¤ Reconciliation decides state preservation


ğŸ”„ Fiberâ€™s Role in Reconciliation
â¤ Fiber represents a unit of work
â¤ Reconciliation:
    âœ”ï¸ Creates work-in-progress Fiber tree
    âœ”ï¸ Compares with current Fiber tree
â¤ Fiber enables:
    âœ”ï¸ Pausing
    âœ”ï¸ Resuming
    âœ”ï¸ Aborting reconciliation


ğŸ”„ Render Phase vs Commit Phase
Reconciliation happens in:
    âœ”ï¸ Render phase
    âœ”ï¸ Pure computation
    âœ”ï¸ No DOM mutation

DOM updates happen in:
    âœ”ï¸ Commit phase
    âœ”ï¸ Side effects applied


ğŸ”„ Performance Characteristics
1ï¸âƒ£ Complexity
â¤ O(n) due to heuristics
â¤ Fast enough for large trees

2ï¸âƒ£ Performance Bottlenecks
â¤ Large component trees
â¤ Frequent re-renders
â¤ Poor key choices
â¤ Inline object/array props


ğŸ”„ Common Reconciliation Anti-Patterns
â¤ Using array index as key
â¤ Changing keys on every render
â¤ Conditional component types
â¤ Deep component nesting


ğŸ”„ Traps
âŒ â€œReact compares entire DOM trees deeplyâ€
âœ… React uses heuristics, not deep diff

âŒ â€œKeys improve rendering speed automaticallyâ€
âœ… Keys improve correctness & identity matching

âŒ â€œReconciliation updates DOMâ€
âœ… Reconciliation calculates, commit mutates


=============================
ğŸ”· React Fiber Architecture
=============================
ğŸ”„ React Fiber
â¤ Fiber is Reactâ€™s new internal reconciliation engine
â¤ Introduced in React 16
â¤ Replaced the old Stack Reconciler
ğŸ‘‰ Fiber is not a feature â€” itâ€™s an internal architecture change.


ğŸ”„ Why Fiber Was Introduced
ğŸš« Problem with Old Stack Reconciler
â¤ Rendering was synchronous
â¤ Large updates:
    âœ”ï¸ Blocked the main thread
    âœ”ï¸ Caused jank & freezes
â¤ No way to pause or prioritize work


ğŸ”„ Real-World Issue
â¤ User scrolls
â¤ Large component tree update happens
â¤ UI freezes âŒ
â¡ï¸ Fiber solved this.


ğŸ”„ Core Goal of Fiber
React Fiber enables:
ğŸŸ¢ Interruptible rendering
ğŸŸ¢ Prioritized updates
ğŸŸ¢ Better user experience
ğŸŸ¢ Concurrent features
ğŸ‘‰ Fiberâ€™s goal is responsiveness, not raw speed.


ğŸ”„ Conceptual Understanding of Fiber
1ï¸âƒ£ Fiber (High-Level)
â¤ A unit of work
â¤ A node in Reactâ€™s internal tree
â¤ Each component = one Fiber node

2ï¸âƒ£ Fiber Stores
â¤ Component type
â¤ Props
â¤ State
â¤ Hooks state
â¤ Effect info
â¤ Child / sibling / parent links


ğŸ”„ Fiber Tree vs Virtual DOM
| Concept     | Purpose                |
| ----------- | ---------------------- |
| Virtual DOM | UI description         |
| Fiber Tree  | Execution & scheduling |
ğŸ‘‰ Fiber is the data structure that powers reconciliation.


ğŸ”„ How Fiber Changes Rendering
Old Model (Stack Reconciler)
Render everything â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Block UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Commit


ğŸ”„ Fiber Model
Break work into units
â†“
Pause if needed
â†“
Resume later
â†“
Commit when ready


ğŸ”„ Render Phase in Fiber
Fiber breaks rendering into:
    âœ”ï¸ Small units of work

React can:
    âœ”ï¸ Pause rendering
    âœ”ï¸ Abort rendering
    âœ”ï¸ Restart rendering
ğŸ‘‰ Render phase is interruptible


ğŸ”„ Commit Phase
â¤ Commit phase:
    âœ”ï¸ Applies DOM updates
    âœ”ï¸ Runs effects
â¤ Not interruptible


ğŸ”„ Priority-Based Scheduling
Fiber assigns priorities:
â¤ User input â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ High
â¤ Animations â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Medium
â¤ Data fetch â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Low
ğŸ‘‰ React schedules work accordingly to keep UI responsive.


ğŸ”„ Concurrency
Fiber enables:
â¤ Concurrent rendering
â¤ Time slicing
â¤ Background updates
ğŸ‘‰ React can prepare UI without blocking user interaction.


ğŸ”„ Hooks & Fiber (Why Rules Exist)
â¤ Hooks state is stored on Fiber nodes
â¤ Hook order matters
â¤ Same call order â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ same Fiber mapping
â¡ï¸ This is why Rules of Hooks exist


ğŸ”„ Fiber Enables Modern React Features
Fiber is the foundation for:
â¤ Concurrent rendering
â¤ Transitions
â¤ Suspense
â¤ Deferred updates
â¤ Automatic batching


ğŸ”„ What Fiber Does NOT Do
âŒ Fiber does NOT make React automatically faster
âŒ Fiber does NOT remove re-renders
âŒ Fiber does NOT change public API


ğŸ”„ Traps
âŒ â€œFiber is Virtual DOMâ€
âœ… Fiber implements Virtual DOM

âŒ â€œFiber is async renderingâ€
âœ… Fiber enables interruptible rendering

âŒ â€œFiber is only for performanceâ€
âœ… Fiber is for responsiveness


=======================
ğŸ”· JSX Syntax & Rules
=======================
ğŸ”„ JSX
â¤ JSX = JavaScript XML
â¤ Syntax extension for JavaScript
â¤ Used to describe UI structure
const element = <h1>Hello</h1>;

ğŸ‘‰ JSX is a syntax sugar that allows writing UI code declaratively, which is later transformed into React.createElement calls.


ğŸ”„ JSX is NOT HTML
â¤ JSX looks like HTML
â¤ JSX is JavaScript
â¤ Parsed by Babel, not browser
â¤ Follows JS rules, not HTML rules


ğŸ”„ Why JSX Exists
Problem Without JSX
React.createElement(
  'div',
  null,
  React.createElement('h1', null, 'Hello')
);

â¤ Hard to read
â¤ Hard to maintain
â¤ Poor developer experience

JSX Solves:
â¤ Readability
â¤ Declarative UI
â¤ Component composability


ğŸ”„ JSX Compilation
JSX Code
<h1 className="title">Hello</h1>

Compiles To
React.createElement(
  'h1',
  { className: 'title' },
  'Hello'
);
ğŸ‘‰ JSX never runs in browser directly.


ğŸ”„ JSX Syntax Rules
1ï¸âƒ£ Single Parent Rule
return (
  <div>
    <h1 />
    <p />
  </div>
);

âŒ Invalid:
<h1 />
<p />


2ï¸âƒ£ Use className (Not class)
<div className="box" />
Reason: class is a reserved JS keyword


3ï¸âƒ£ Self-Closing Tags
<img />
<input />


4ï¸âƒ£ CamelCase Attributes
onClick
tabIndex
htmlFor


5ï¸âƒ£ JavaScript Expressions in {}
<h1>{user.name}</h1>
â¤ Allowed:
    âœ”ï¸ Variables
    âœ”ï¸ Function calls
    âœ”ï¸ Ternary expressions

â¤ Not allowed:
    âœ”ï¸ if
    âœ”ï¸ for
    âœ”ï¸ while


ğŸ”„ Conditional Rendering in JSX
â¤ Using Ternary: {isLoggedIn ? <Home /> : <Login />}
â¤ Using Logical AND: {isAdmin && <AdminPanel />}

ğŸ‘‰ Common Trap: {count && <p>{count}</p>}
0 is falsy â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ nothing renders


ğŸ”„ JSX Children Rules
<Component>
  <h1>Hello</h1>
</Component>

â¤ Children passed as props.children
â¤ Can be:
    âœ”ï¸ Element
    âœ”ï¸ String
    âœ”ï¸ Array
    âœ”ï¸ Function


ğŸ”„ JSX & Expressions vs Statements (Important)
| Allowed             | Not Allowed |
| ------------------- | ----------- |
| `user.name`         | `if`        |
| `a + b`             | `for`       |
| `condition ? x : y` | `switch`    |
ğŸ‘‰ JSX allows expressions only


ğŸ”„ JSX & Lists
{items.map(item => (
  <Item key={item.id} />
))}

Rules:
â¤ Always use key
â¤ Keys must be stable
â¤ Avoid index as key


ğŸ”„ JSX Fragments
1ï¸âƒ£ Long Syntax
<React.Fragment>
  <h1 />
  <p />
</React.Fragment>

2ï¸âƒ£ Short Syntax
<>
  <h1 />
  <p />
</>


ğŸ”„ JSX & Boolean / Null Rendering
| Value       | Rendered?  |
| ----------- | ---------  |
| `null`      | âŒ         |
| `undefined` | âŒ         |
| `false`     | âŒ         |
| `true`      | âŒ         |
| `0`         | âœ…         |


ğŸ”„ JSX & Inline Styles
<div style={{ backgroundColor: 'red' }} />

Rules:
â¤ Style is an object
â¤ CamelCase keys
â¤ Values are strings or numbers


ğŸ”„ JSX & Security (XSS)
â¤ JSX escapes values by default
â¤ Prevents XSS attacks
<p>{userInput}</p> // safe

Dangerous API: dangerouslySetInnerHTML


ğŸ”„ Common JSX Anti-Patterns
â¤ Inline object creation
â¤ Complex logic inside JSX
â¤ Using index as key
â¤ Heavy computations in JSX


ğŸ”„ JSX Performance Considerations
â¤ JSX creates new objects on every render
â¤ Expensive expressions cause re-render cost
â¤ Extract logic outside JSX


ğŸ”„ JSX Traps
âŒ JSX is HTML
âœ… JSX is JavaScript

âŒ JSX is required for React
âœ… React works without JSX

âŒ JSX improves performance
âœ… JSX improves readability


======================
ğŸ”· JSX vs JavaScript
======================
â¤ JSX is NOT a new language.
â¤ JSX is NOT HTML.
â¤ JSX is JavaScript with a syntax extension.

ğŸ”„ What Plain JavaScript UI Looks Like (Without JSX)
const element = React.createElement(
  'h1',
  { className: 'title' },
  'Hello'
);
âœ”ï¸ 100% JavaScript
âœ”ï¸ Verbose
âœ”ï¸ Hard to read
âœ”ï¸ Hard to maintain


ğŸ”„ Same Thing Using JSX
const element = <h1 className="title">Hello</h1>;
âœ”ï¸ Cleaner
âœ”ï¸ Declarative
âœ”ï¸ Easier to reason about
â¡ï¸ Both are identical after compilation


ğŸ”„ Core Difference: Syntax vs Semantics
| Aspect    | JavaScript          | JSX                           |
| --------- | ------------------- | ----------------------------- |
| Language  | JavaScript          | JavaScript (syntax extension) |
| Runtime   | Browser / JS Engine | Compiled to JS                |
| Execution | Direct              | After Babel transform         |
| Purpose   | General logic       | UI description                |
ğŸ‘‰ JSX changes how you write, not what runs.


ğŸ”„ JSX is Just a Function Call (Internals)
JSX
<div>Hello</div>

ğŸ‘‰ Becomes
React.createElement('div', null, 'Hello');

â¤ JSX is syntactic sugar
â¤ JavaScript engine never sees JSX


ğŸ”„ Why JSX Feels â€œDifferentâ€ From JS
Because JSX:
â¤ Embeds XML-like syntax inside JS
â¤ Mixes markup & logic
â¤ Uses {} to escape into JS

But internally:
â¤ Itâ€™s still JS expressions
â¤ Produces plain objects


ğŸ”„ Expressions vs Statements
JavaScript
â¤ Supports both:
    âœ”ï¸ Statements (if, for)
    âœ”ï¸ Expressions (a + b)

JSX
â¤ Allows only expressions
{condition && <Component />}

âŒ Not allowed: {if (x) { ... }}


ğŸ”„ Embedding JavaScript in JSX
<h1>{user.name}</h1>
<p>{items.length}</p>

Allowed:
âœ”ï¸ Variables
âœ”ï¸ Function calls
âœ”ï¸ Ternary operators
âœ”ï¸ Logical expressions


ğŸ”„ Why JSX Uses {} Instead of ${}
â¤ {} = JS expression container
â¤ JSX is already inside JS
â¤ Template literals are unnecessary


ğŸ”„ JSX vs Template Engines (Angular / Vue)
| Feature     | JSX              | Templates       |
| ----------- | ---------------- | --------------- |
| Logic       | Full JS          | Limited         |
| Scope       | JS lexical scope | Template scope  |
| Debugging   | JS stack traces  | Template errors |
| Flexibility | High             | Medium          |
ğŸ‘‰ JSX gives full JavaScript power


ğŸ”„ JSX & Type Safety 
JSX works with:
    âœ”ï¸ TypeScript
    âœ”ï¸ ESLint
â¤ Errors caught at compile time
â¤ Safer refactoring


ğŸ”„ Why React Chose JSX
React team believed:
    âœ”ï¸ UI logic and structure are tightly coupled
    âœ”ï¸ Separating them hurts maintainability
    âœ”ï¸ JSX improves cohesion


ğŸ”„ Performance Perspective
â¤ JSX itself has zero runtime cost
â¤ Performance depends on:
    âœ”ï¸ Component design
    âœ”ï¸ Re-render frequency
    âœ”ï¸ Reconciliation


ğŸ”„ Traps
âŒ â€œJSX is faster than JSâ€
âœ… JSX is compiled to JS

âŒ â€œBrowser understands JSXâ€
âœ… Babel handles JSX

âŒ â€œJSX is mandatoryâ€
âœ… React works without JSX


======================================================================
ğŸ”· Babel & JSX Compilation (how JSX converts to React.createElement)
======================================================================
ğŸ”„ Why Babel is Needed in React
âŒ Problem
â¤ Browsers do NOT understand JSX
â¤ JSX is not JavaScript
â¤ JSX looks like HTML but behaves like JS

const element = <h1>Hello</h1>;
ğŸ‘† Browser will throw syntax error

âœ… Solution
â¡ï¸ Babel converts JSX into plain JavaScript
â¡ï¸ That JavaScript is understood by browsers


ğŸ”„ Babel
â¤ Babel is a JavaScript compiler / transpiler
â¤ In React, Babel is used to:
    âœ”ï¸ Convert JSX â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ JavaScript
    âœ”ï¸ Convert modern JS (ES6+) â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ browser-compatible JS


ğŸ”„ Key Responsibility for React
JSX  --->  React.createElement() calls


ğŸ”„ JSX is Just Syntactic Sugar
JSX is just syntactic sugar over React.createElement

JSX Code
const element = <h1>Hello React</h1>;

After Babel Compilation
const element = React.createElement(
  "h1",
  null,
  "Hello React"
);
ğŸ‘‰ Both are 100% equivalent


ğŸ”„ React.createElement
Syntax
React.createElement(type, props, children)

| Parameter  | Meaning                     |
| ---------- | --------------------------- |
| `type`     | HTML tag OR React component |
| `props`    | Attributes / props object   |
| `children` | Text or child elements      |

âœ… Example with Props
<h1 className="title">Hello</h1>

â¬‡ï¸ Compiled output:
React.createElement(
  "h1",
  { className: "title" },
  "Hello"
);


âœ… JSX with Multiple Children
ğŸ”— JSX
<div>
  <h1>Hello</h1>
  <p>Welcome</p>
</div>

ğŸ”— Compiled JavaScript
React.createElement(
  "div",
  null,
  React.createElement("h1", null, "Hello"),
  React.createElement("p", null, "Welcome")
);
ğŸ‘‰ Nested tree structur
ğŸ‘‰ Each JSX element becomes a React.createElement call


ğŸ”„ JSX with JavaScript Expressions
ğŸ”— JSX
const name = "Ankur";
<h1>Hello {name}</h1>

ğŸ”— Compiled Output
React.createElement(
  "h1",
  null,
  "Hello ",
  name
);
ğŸ‘‰ Expressions are passed as children


ğŸ”„ JSX with Components
ğŸ”— JSX
<MyComponent age={25} />

ğŸ”— Compiled Output
React.createElement(
  MyComponent,
  { age: 25 }
);

â¤ If type is string â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ HTML element
â¤ If type is function/class â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ React Component


ğŸ”„ JSX Fragment Compilation
ğŸ”— JSX
<>
  <h1>Title</h1>
  <p>Text</p>
</>

ğŸ”— Compiled Output
React.createElement(
  React.Fragment,
  null,
  React.createElement("h1", null, "Title"),
  React.createElement("p", null, "Text")
);


ğŸ”„ Babel Presets Used in React
@babel/preset-react

Handles:
    âœ”ï¸ JSX â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ React.createElement
    âœ”ï¸ JSX fragments
    âœ”ï¸ JSX spread props


ğŸ”„ Modern React (Automatic Runtime)
â¤ Since React 17+, Babel can generate:
import { jsx as _jsx } from "react/jsx-runtime";

â¤ Instead of:
React.createElement(...)
ğŸ‘‰ This is why React import is not required anymore


ğŸ”„ Classic vs Automatic JSX Runtime
â¤ Classic Runtime (Before React 17)
import React from "react";

â¤ JSX compiles to:
React.createElement(...)

â¤ Automatic Runtime (React 17+)
// No React import needed

â¤ JSX compiles to:
_jsx("h1", { children: "Hello" });
âœ”ï¸ Smaller bundle
âœ”ï¸ Cleaner code
âœ”ï¸ Better DX


ğŸ”„ Why React Uses JSX
â¤ Improves readability
â¤ UI logic + structure together
â¤ Prevents string-based templates
â¤ Enables compile-time optimizations
â¤ Makes UI a pure function of state


ğŸ”„ JSX Compilation Flow
JSX
 â†“
Babel
 â†“
React.createElement / jsx()
 â†“
Virtual DOM Object
 â†“
Reconciliation
 â†“
Real DOM updates


==================================
ğŸ”· React Elements vs Components
==================================
â¤ React Element = What to render
â¤ React Component = How to render


ğŸ”„ React Element
â¤ A React Element is a plain JavaScript object
â¤ It describes what should appear on the UI
â¤ It is immutable

âœ… Example
const element = <h1>Hello React</h1>;
â¬‡ï¸ After JSX compilation:
const element = React.createElement(
  "h1",
  null,
  "Hello React"
);

â“ What does element look like internally?
{
  type: "h1",
  props: {
    children: "Hello React"
  }
}

ğŸ‘‰ Key Takeaways
â¤ Element is NOT a DOM node
â¤ Element is NOT a component
â¤ Element is just a description


ğŸ”„ Key Properties of React Elements
â¤ Immutable (cannot be changed once created)
â¤ Lightweight
â¤ Cheap to create
â¤ Describes UI at a point in time
â¤ Used by React to build Virtual DOM


ğŸ”„ React Component
â¤ A Component is a function or class
â¤ It returns React Elements
â¤ It can have:
    âœ”ï¸ State
    âœ”ï¸ Props
    âœ”ï¸ Lifecycle / Hooks
    âœ”ï¸ Logic

âœ… Functional Component Example
function Greeting() {
  return <h1>Hello React</h1>;
}

âœ… Component with Props
function Greeting({ name }) {
  return <h1>Hello {name}</h1>;
}
ğŸ‘‰ A component is a factory for elements


ğŸ”„ Relationship Between Element & Component
JSX Using Component
<Greeting name="Ankur" />

â¬‡ï¸ Compiles to:
React.createElement(Greeting, { name: "Ankur" });

â¬‡ï¸ React calls the component:
Greeting({ name: "Ankur" });

â¬‡ï¸ Component returns element:
<h1>Hello Ankur</h1>


ğŸ”„ Element vs Component
1ï¸âƒ£ React Element
â¤ Plain JS object
â¤ Immutable
â¤ No logic
â¤ Represents UI snapshot
â¤ Created using JSX or createElement

2ï¸âƒ£ React Component
â¤ Function or class
â¤ Can be reused
â¤ Can hold state
â¤ Can contain business logic
â¤ Returns React Elements


ğŸ”„ Class Component Perspective
Class Component
class Welcome extends React.Component {
  render() {
    return <h1>Hello</h1>;
  }
}
â¤ Welcome â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Component
â¤ <h1>Hello</h1> â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Element
â¤ render() must return React Elements


ğŸ”„ Elements are Immutable â€“ Why It Matters
You CANNOT do this: element.props.children = "Hi";
âŒ Not allowed


ğŸ”„ Correct Way
Create a new element
const newElement = <h1>Hi</h1>;

ğŸ”‘ React uses immutability to:
    âœ”ï¸ Compare previous vs next UI
    âœ”ï¸ Perform efficient reconciliation


ğŸ”„ Components Can Return Different Elements
function Status({ isLoggedIn }) {
  if (isLoggedIn) {
    return <h1>Welcome</h1>;
  }
  return <h1>Please Login</h1>;
}
âœ”ï¸ Same component
âœ”ï¸ Different elements returned


ğŸ”„ Element Creation Flow
Component
  â†“
Returns Elements
  â†“
React compares Elements (old vs new)
  â†“
Reconciliation
  â†“
DOM updates


ğŸ”„ Why React Separates Elements & Components
â¤ Declarative UI
â¤ Predictable rendering
â¤ Easy diffing
â¤ Performance optimization
â¤ Functional programming style


ğŸ”„ Traps
âŒ â€œElements are componentsâ€
WRONG

âŒ â€œComponents are rendered directly to DOMâ€
WRONG
Components return elements, elements are rendered.

âŒ â€œElement is mutableâ€
WRONG


==================================
ğŸ”· Component- Based Architecture
==================================
Component-Based Architecture means building UI by breaking it into small, reusable, independent components, where each component manages its own logic and UI.

In React:
â¤ UI = Tree of Components
â¤ Each component:
    âœ”ï¸ Has a single responsibility
    âœ”ï¸ Can be reused
    âœ”ï¸ Can be composed together


ğŸ”„ Why React Chose Component-Based Architecture
âŒ Problems with Traditional UI Development
â¤ Large monolithic files
â¤ Tight coupling between UI and logic
â¤ Hard to reuse code
â¤ Hard to maintain and scale
â¤ UI updates tightly coupled to DOM manipulation

âœ… Reactâ€™s Solution
â¤ Split UI into small logical units
â¤ Each unit = Component
â¤ Declarative updates instead of manual DOM manipulation


ğŸ”„ What is a Component in This Architecture?
A React Component:
â¤ Is a function (mostly)
â¤ Accepts props
â¤ Manages state
â¤ Returns React elements

function Button({ label }) {
  return <button>{label}</button>;
}
ğŸ‘‰ This is a building block in the architecture.


ğŸ”„ Component Tree
React applications form a hierarchical tree

App
 â”œâ”€â”€ Header
 â”‚    â”œâ”€â”€ Logo
 â”‚    â””â”€â”€ Nav
 â”œâ”€â”€ Main
 â”‚    â”œâ”€â”€ Sidebar
 â”‚    â””â”€â”€ Content
 â”‚         â”œâ”€â”€ Post
 â”‚         â””â”€â”€ Comment
 â””â”€â”€ Footer
ğŸ‘‰ Data flows top â†’ down (unidirectional)


ğŸ”„ Types of Components (Architectural POV)
1ï¸âƒ£ Presentational (UI) Components
â¤ Focus only on UI
â¤ No business logic
â¤ Receive data via props

function Avatar({ image }) {
  return <img src={image} />;
}

2ï¸âƒ£ Container (Smart) Components
â¤ Handle data fetching
â¤ Handle state
â¤ Pass data to UI components

function UserProfile() {
  const [user, setUser] = useState(null);
  return <Avatar image={user?.image} />;
}
ğŸ‘‰ This separation improves maintainability


ğŸ”„ Single Responsibility Principle (SRP)
Each component should:
â¤ Do one thing
â¤ Do it well
âŒ Bad: UserDashboardEverythingComponent

âœ”ï¸ Good:
UserDashboard
 â”œâ”€â”€ UserInfo
 â”œâ”€â”€ UserStats
 â””â”€â”€ UserActions


ğŸ”„ Component Composition
âŒ Instead of inheritance â†’ composition
function Card({ children }) {
  return <div className="card">{children}</div>;
}

âœ… Usage:
<Card>
  <h2>Title</h2>
  <p>Content</p>
</Card>
ğŸ‘‰ This is how flexible UIs are built


ğŸ”„ Reusability & Configurability
Components are:
â¤ Reused via props
â¤ Configured via props

<Button type="primary" />
<Button type="danger" />
ğŸ‘‰ Same component â†’ different behavior/UI


ğŸ”„ Encapsulation
Each component:
â¤ Has its own state
â¤ Has its own logic
â¤ Exposes only props
ğŸ” Internal details are hidden


ğŸ”„ State Ownership in Component Architecture
Rule: State should live in the lowest common ancestor
âœ… Example:
Parent
 â”œâ”€â”€ ChildA (needs state)
 â””â”€â”€ ChildB (needs state)

â¡ï¸ State belongs in Parent
This avoids:
â¤ Duplicate state
â¤ Inconsistent UI


ğŸ”„ Unidirectional Data Flow
State (Parent)
  â†“
Props (Child)
  â†“
UI

Child â†’ Parent communication via: Callback functions
<Child onClick={handleClick} />


ğŸ”„ Component Re-rendering Model
â¤ State change â†’ Component re-renders
â¤ Re-render means:
    âœ”ï¸ Function runs again
    âœ”ï¸ New React elements created
â¤ React compares old vs new elements
ğŸ‘‰ Architecture supports predictable rendering


ğŸ”„ Folder Structure
components/
 â”œâ”€â”€ Button/
 â”‚    â”œâ”€â”€ Button.jsx
 â”‚    â”œâ”€â”€ Button.css
 â”‚    â””â”€â”€ index.js
 â”œâ”€â”€ Card/
 â””â”€â”€ Modal/
ğŸ‘‰ Scales well for large apps.


ğŸ”„ Advantages of Component-Based Architecture
â¤ High reusability
â¤ Easy maintenance
â¤ Better scalability
â¤ Faster development
â¤ Testable units
â¤ Clear separation of concerns


ğŸ”„ Challenges
â¤ Prop drilling
â¤ Too many small components
â¤ Over-abstraction
â¤ State management complexity

âœ… Solved using:
â¤ Context API
â¤ State management libraries
â¤ Better component design


ğŸ”„ React-Specific Architectural Philosophy
â¤ Components are pure functions of props + state
â¤ UI is deterministic
â¤ Same input â†’ same output


========================
ğŸ”· Functional Component
========================
A Functional Component is a JavaScript function that accepts props as input and returns React elements describing the UI.

âœ… Simplest Example
function Hello() {
  return <h1>Hello React</h1>;
}
This function is a React Component because:
    âœ”ï¸ Name starts with capital letter
    âœ”ï¸ Returns JSX (React elements)


ğŸ”„ Why Functional Components Exist
Originally:
    âœ”ï¸ React had Class Components
    âœ”ï¸ Functional components were stateless

Now with Hooks, functional components can:
    âœ”ï¸ Manage state
    âœ”ï¸ Handle side effects
    âœ”ï¸ Access lifecycle behavior
â¡ï¸ Functional components are now the default and recommended approach


ğŸ”„ Anatomy of a Functional Component
function ComponentName(props) {
  // 1. Hooks (state, effects)
  // 2. Business logic
  // 3. Return JSX
}

Or using destructuring:
function ComponentName({ title, count }) {
  return <h1>{title} {count}</h1>;
}


ğŸ”„ Props in Functional Components
â¤ Props are read-only
â¤ Passed from parent to child
â¤ Used to configure component behavior

function Greeting({ name }) {
  return <h1>Hello {name}</h1>;
}

Usage: <Greeting name="Ankur" />


ğŸ”„ Functional Components are Pure Functions
Same props + same state â†’ same UI

function Sum({ a, b }) {
  return <p>{a + b}</p>;
}
ğŸ‘‰ Side effects are NOT allowed directly inside render
They go into Hooks


ğŸ”„ State in Functional Components
Before Hooks âŒ
After Hooks âœ”ï¸

import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);
  return (
    <button onClick={() => setCount(count + 1)}>
      {count}
    </button>
  );
}
ğŸ‘‰ State updates â†’ component re-renders


ğŸ”„ Lifecycle Behavior in Functional Components
â¤ Functional components do NOT have lifecycle methods.
â¤ Instead, lifecycle is handled via:
    âœ”ï¸ useEffect
    âœ”ï¸ useLayoutEffect

âœ… Example:
useEffect(() => {
  console.log("Component mounted");
  return () => {
    console.log("Component unmounted");
  };
}, []);


ğŸ”„ Rendering Behavior
When a functional component re-renders:
â¤ The entire function executes again
â¤ Hooks are re-evaluated
â¤ New React elements are created
ğŸ‘‰ React does NOT recreate the DOM every time


ğŸ”„ Rules of Functional Components
Must Follow:
â¤ Name must start with Capital letter
â¤ Must return JSX or null
â¤ Hooks must be called:
    âœ”ï¸ At top level
    âœ”ï¸ Not inside loops/conditions


ğŸ”„ Functional Components vs Normal Functions
| Normal Function      | Functional Component      |
| -------------------- | ------------------------- |
| Returns any value    | Returns JSX               |
| No React context     | Runs inside React         |
| Not tracked by React | Tracked in component tree |


ğŸ”„ Why Functional Components Are Preferred Over Class Components
âœ… Advantages
â¤ Less boilerplate
â¤ Easier to read
â¤ Easier to test
â¤ No this keyword
â¤ Better tree-shaking
â¤ Better performance optimizations
â¤ Works naturally with Hooks


ğŸ”„ Performance Characteristics
â¤ Lightweight
â¤ Faster creation than classes
â¤ Easier to memoize
â¤ Supports concurrent rendering

export default React.memo(MyComponent);


ğŸ”„ Traps
âŒ â€œFunctional components are statelessâ€
WRONG (pre-hooks myth)

âŒ â€œRe-render means DOM updateâ€
WRONG

âŒ â€œHooks replace componentsâ€
WRONG â€” Hooks enhance functional components


ğŸ”„ Real-World Usage Pattern
function Page() {
  return (
    <>
      <Header />
      <Content />
      <Footer />
    </>
  );
}
ğŸ‘‰ Each part is a functional component

=====================
ğŸ”· Class Components
=====================
A Class Component is a JavaScript class that extends React.Component and implements a render() method that returns React elements.

âœ… Basic Example
class Welcome extends React.Component {
  render() {
    return <h1>Hello React</h1>;
  }
}
ğŸ‘‰ This class is treated as a React Component.


ğŸ”„ Why Class Components Existed
Before React Hooks:
â¤ Functional components âŒ no state
â¤ Functional components âŒ no lifecycle methods

So:
    âœ”ï¸ Class components handled
    âœ”ï¸ State
    âœ”ï¸ Lifecycle methods
    âœ”ï¸ Side effects


ğŸ”„ Core Structure of a Class Component
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {};
  }

  render() {
    return <div />;
  }
}
Mandatory:
    âœ”ï¸ extends React.Component
    âœ”ï¸ render() method


ğŸ”„ State in Class Components
class Counter extends React.Component {
  state = { count: 0 };

  increment = () => {
    this.setState({ count: this.state.count + 1 });
  };

  render() {
    return <button onClick={this.increment}>{this.state.count}</button>;
  }
}
ğŸ‘‰ State updates via setState()


ğŸ”„ Props in Class Components
Accessed via this.props
<h1>{this.props.name}</h1>
ğŸ‘‰ Props are read-only


ğŸ”„ Lifecycle Methods
Class components introduced lifecycle hooks:

1ï¸âƒ£ Mounting
â¤ constructor
â¤ componentDidMount

2ï¸âƒ£ Updating
componentDidUpdate

3ï¸âƒ£ Unmounting
componentWillUnmount

componentDidMount() {
  // API call
}
ğŸ‘‰ These map conceptually to useEffect


ğŸ”„ Why Class Components Are Called â€œLegacyâ€
Problems
â¤ Too much boilerplate
â¤ Confusing this binding
â¤ Lifecycle complexity
â¤ Logic duplication across lifecycles
â¤ Harder to reuse logic


ğŸ”„ Hooks Replaced Class Components
Hooks allow:
    âœ”ï¸ State
    âœ”ï¸ Side effects
    âœ”ï¸ Context
    âœ”ï¸ Custom logic reuse
â¡ï¸ Functional components + hooks replaced class components


9ï¸âƒ£ Functional vs Class
| Functional         | Class              |
| ------------------ | ------------------ |
| Simple functions   | ES6 classes        |
| Hooks              | Lifecycle methods  |
| No `this`          | Heavy `this` usage |
| Recommended        | Legacy             |
| Better readability | Verbose            |


ğŸ”„ When You Might Still See Class Components
â¤ Legacy codebases
â¤ Old enterprise apps
â¤ Libraries written before hooks
â¤ Error boundaries (historically)
ğŸ‘‰ You should be able to read & explain, not necessarily write new ones.


ğŸ”„ Migration Strategy
â¤ Gradually refactor class components to functional components
â¤ Replace lifecycle methods with hooks
â¤ Preserve behavior, not syntax


ğŸ”„ Error Boundaries
Traditionally only supported via class components:

class ErrorBoundary extends React.Component {
  componentDidCatch(error, info) {}
}
ğŸ‘‰ Functional alternatives now exist, but class-based still common


=========================
ğŸ”· React Rendering Flow
=========================
State/Props change â†’ Re-render â†’ Reconciliation â†’ Commit â†’ DOM Update
ğŸ‘‰ Everything in React fits into this pipeline.


ğŸ”„ What Does â€œRenderâ€ Mean in React?
ğŸš¨ Important Clarification
Rendering in React â‰  Updating the DOM

Rendering means:
â¤ Executing component functions
â¤ Creating React Elements (Virtual DOM objects)


ğŸ”„ High-Level Rendering Phases
React rendering happens in two major phases:

1ï¸âƒ£ Render Phase
2ï¸âƒ£ Commit Phase


ğŸ”„ Phase 1ï¸âƒ£: Render Phase (Pure & Interruptible)
What Happens Here?
â¤ React calls your functional components
â¤ JSX â†’ React Elements
â¤ Builds a new Virtual DOM tree
â¤ Diffs with previous tree (reconciliation)
ğŸ‘‰ NO DOM mutations here


ğŸ”„ What Triggers Render Phase?
â¤ Initial load
â¤ setState
â¤ useState update
â¤ Parent re-render
â¤ Context value change
â¤ Props change

âœ… Example
function Counter() {
  const [count, setCount] = useState(0);
  return <button>{count}</button>;
}
â¤ Calling setCount(1):
    âœ”ï¸ Function Counter() runs again
    âœ”ï¸ New element tree created


ğŸ”„ Render Phase Characteristics
â¤ Pure (no side effects allowed)
â¤ Can be paused, restarted, or aborted
â¤ Happens multiple times
â¤ Controlled by Fiber architecture
ğŸ‘‰ Side effects here = bugs


ğŸ”„ Phase 2ï¸âƒ£: Commit Phase (DOM Updates)
What Happens Here?
â¤ React applies actual DOM changes
â¤ Runs lifecycle effects
â¤ Updates refs
â¤ Triggers layout & paint
ğŸ‘‰ This phase cannot be interrupted

Commit Phase Includes:
â¤ DOM insertions
â¤ DOM updates
â¤ DOM deletions
â¤ Running useEffect
â¤ Running cleanup functions


ğŸ”„ Reconciliation (Diffing) Inside Render Phase
React:
â¤ Compares old Virtual DOM vs new Virtual DOM
â¤ Uses keys to identify elements
â¤ Determines minimal DOM changes
Old Tree  vs  New Tree
     â†“
Minimal DOM Operations


ğŸ”„ Complete Rendering Flow
1ï¸âƒ£ Initial Load
   â†“
2ï¸âƒ£ React creates root Fiber
   â†“
3ï¸âƒ£ Component function executes
   â†“
4ï¸âƒ£ JSX â†’ React Elements
   â†“
5ï¸âƒ£ Virtual DOM Tree built
   â†“
6ï¸âƒ£ Reconciliation
   â†“
7ï¸âƒ£ Commit Phase
   â†“
8ï¸âƒ£ Browser paints UI


ğŸ”„ Re-render â‰  DOM Update
React may re-render:
â¤ But decide no DOM changes needed
â¤ Because Virtual DOM diff results in zero updates
ğŸ‘‰ This is why React is fast.


ğŸ”„ What Causes Re-renders
Direct Causes
â¤ setState
â¤ useState setter
â¤ useReducer
â¤ New props
â¤ Context value change

Indirect Causes
â¤ Parent re-render
â¤ New reference objects/functions
â¤ Inline functions


ğŸ”„ Rendering Flow Example
function Parent() {
  const [count, setCount] = useState(0);
  return <Child value={count} />;
}

function Child({ value }) {
  return <p>{value}</p>;
}
setCount(1):
â¤ Parent re-renders
â¤ Child re-renders
â¤ New elements created
â¤ Diff happens
â¤ DOM updates only text node


ğŸ”„ Effects in Rendering Flow
1ï¸âƒ£ useEffect
â¤ Runs after commit
â¤ Non-blocking

2ï¸âƒ£ useLayoutEffect
â¤ Runs after DOM mutation but before paint
â¤ Blocking


ğŸ”„ Strict Mode Rendering
In development:
â¤ React may render components twice
â¤ To detect side effects
ğŸ‘‰ This does NOT happen in production.


ğŸ”„ Performance Optimization Hooks
To control rendering:
â¤ React.memo
â¤ useMemo
â¤ useCallback
â¤ Proper key usage


ğŸ”„ Traps
âŒ â€œRender means DOM updateâ€
âŒ â€œState change directly updates DOMâ€
âŒ â€œReact renders only changed componentâ€
âœ”ï¸ React re-renders components, not DOM directly


#########################################
ğŸ”· Project Setups and Tooling Concepts
#########################################
ğŸ”„ Why Folder Structure Matters
Good structure gives:
â¤ Scalability
â¤ Maintainability
â¤ Team collaboration
â¤ Clear ownership of code
â¤ Easier testing & refactoring

Bad structure leads to:
â¤ Tight coupling
â¤ God components
â¤ Merge conflicts
â¤ Hard onboarding


ğŸ”„ Golden Rules
â¤ Group by feature, not by file type (for large apps)
â¤ Keep components small and focused
â¤ Avoid deep nesting
â¤ Co-locate related files
â¤ Make structure predictable


ğŸ”„ Small App / POC Structure
Good for:
â¤ Small projects
â¤ Assignments
â¤ Learning phase

src/
 â”œâ”€â”€ components/
 â”œâ”€â”€ pages/
 â”œâ”€â”€ hooks/
 â”œâ”€â”€ services/
 â”œâ”€â”€ utils/
 â”œâ”€â”€ App.jsx
 â””â”€â”€ main.jsx
ğŸ‘‰ Simple but not scalable for large apps.


ğŸ”„ Scalable Feature-Based Structure
src/
 â”œâ”€â”€ app/
 â”‚    â”œâ”€â”€ App.jsx
 â”‚    â”œâ”€â”€ routes.jsx
 â”‚    â””â”€â”€ store.js
 â”œâ”€â”€ features/
 â”‚    â”œâ”€â”€ auth/
 â”‚    â”‚    â”œâ”€â”€ components/
 â”‚    â”‚    â”œâ”€â”€ hooks/
 â”‚    â”‚    â”œâ”€â”€ services/
 â”‚    â”‚    â”œâ”€â”€ authSlice.js
 â”‚    â”‚    â””â”€â”€ index.js
 â”‚    â”œâ”€â”€ dashboard/
 â”‚    â””â”€â”€ profile/
 â”œâ”€â”€ shared/
 â”‚    â”œâ”€â”€ components/
 â”‚    â”œâ”€â”€ hooks/
 â”‚    â”œâ”€â”€ utils/
 â”‚    â””â”€â”€ constants/
 â”œâ”€â”€ assets/
 â”œâ”€â”€ styles/
 â””â”€â”€ main.jsx


ğŸ”„ Feature Folder Breakdown
âœ… Example: auth
auth/
 â”œâ”€â”€ components/
 â”‚    â”œâ”€â”€ LoginForm.jsx
 â”‚    â””â”€â”€ RegisterForm.jsx
 â”œâ”€â”€ hooks/
 â”‚    â””â”€â”€ useAuth.js
 â”œâ”€â”€ services/
 â”‚    â””â”€â”€ authApi.js
 â”œâ”€â”€ authSlice.js
 â””â”€â”€ index.js
ğŸ‘‰ Everything related to auth stays together.


ğŸ”„ Component Folder Structure
Button/
 â”œâ”€â”€ Button.jsx
 â”œâ”€â”€ Button.module.css
 â”œâ”€â”€ Button.test.jsx
 â””â”€â”€ index.js
ğŸ‘‰ Improves reusability & isolation.


ğŸ”„ Pages vs Components
1ï¸âƒ£ Pages
â¤ Route-level components
â¤ Mostly composition
â¤ Minimal logic

pages/
 â”œâ”€â”€ Home.jsx
 â”œâ”€â”€ Login.jsx
 â””â”€â”€ Dashboard.jsx

2ï¸âƒ£ Components
â¤ Reusable UI blocks
â¤ No routing awareness


ğŸ”„ Hooks Folder
hooks/
 â”œâ”€â”€ useFetch.js
 â”œâ”€â”€ useDebounce.js
 â””â”€â”€ useAuth.js
ğŸ‘‰ Never mix hooks with components.


ğŸ”„ Services / API Layer
services/
 â”œâ”€â”€ apiClient.js
 â”œâ”€â”€ authApi.js
 â””â”€â”€ userApi.js
ğŸ‘‰ Keeps components clean
ğŸ‘‰ Easy to mock for tests


ğŸ”„ Shared vs Feature Code
shared/
â¤ Used across multiple features
â¤ Pure UI or utilities

features/
â¤ Feature-specific logic
â¤ Business rules


ğŸ”„ State Management Placement
Redux / Zustand
features/
 â”œâ”€â”€ cart/
 â”‚    â”œâ”€â”€ cartSlice.js
 â”‚    â””â”€â”€ Cart.jsx
ğŸ‘‰ State belongs to feature, not global dump.


ğŸ”„ Assets & Styles
assets/
 â”œâ”€â”€ images/
 â”œâ”€â”€ icons/
 â””â”€â”€ fonts/

styles/
 â”œâ”€â”€ globals.css
 â”œâ”€â”€ variables.css
 â””â”€â”€ themes.css


ğŸ”„ Barrel Files (index.js)
export { default as Button } from "./Button";


ğŸ”„ Cleaner imports:
import { Button } from "@/shared/components";


ğŸ”„ Absolute Imports
import Login from "@/features/auth/Login";
âœ”ï¸ Avoids ../../../
âœ”ï¸ Cleaner refactoring


ğŸ”„ How does React know @/shared/components?
ğŸ‘‰ React does NOT know this by default.
You must configure it.

â“Who actually resolves the path?
Not React itself, but:
    âœ”ï¸ TypeScript compiler
    âœ”ï¸ Bundler (Next.js / Vite / Webpack)
ğŸ‘‰ They are told what @ means.

â“ Where do we configure it?
1ï¸âƒ£ TypeScript / JavaScript config
(tsconfig.json or jsconfig.json)
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  }
}
This tells the compiler: â€œWhenever you see @/..., look inside src/...â€

2ï¸âƒ£ Framework support
Next.js â†’ reads tsconfig/jsconfig automatically
Vite / Webpack â†’ need extra alias config

âœ… Example (Vite):
resolve: {
  alias: {
    "@": "/src"
  }
}
If you donâ€™t configure it âŒ
import { Button } from "@/shared/components";
ğŸ‘‰ Error: Module not found


ğŸ”„ Testing Folder Strategy
__tests__/
 â”œâ”€â”€ auth.test.js
 â””â”€â”€ dashboard.test.js
Or co-located: Login.test.jsx
Both are acceptable â€” consistency matters.


ğŸ”„ Traps
âŒ One giant components/ folder
âŒ Logic inside pages
âŒ API calls inside JSX
âŒ Deep nesting
âŒ Global utils dumping ground