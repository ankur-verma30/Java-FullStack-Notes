ğŸ”· TypeScript
â¤ TypeScript is a superset of JavaScript.
â¤ It is a programming language built on JavaScript.
â¤ TypeScript has all the features of JavaScript plus extra features like:
1ï¸âƒ£ interface
2ï¸âƒ£ access modifiers

These features are not available in the latest version of JavaScript.

ğŸ¯ Why Use TypeScript?
â¤ TypeScript makes writing JavaScript easier, cleaner, less error-prone.
â¤ You can write simple code in TypeScript which compiles to complex JavaScript logic.
â¤ Helps avoid bugs and identity

âš ï¸ Limitation of TypeScript
â¤ TypeScript code cannot be executed directly by JavaScript runtimes like:
1ï¸âƒ£ Browser
2ï¸âƒ£ Node.js

âš™ï¸ How TypeScript Works
â¤ TypeScript is also a tool â€” a powerful compiler.
â¤ It compiles TypeScript code into JavaScript code.
â¤ Then this JavaScript code can be run by:
1ï¸âƒ£ Browser
2ï¸âƒ£ Node.js

â¤ We donâ€™t write JavaScript directly when using TypeScript.
â¤ We write TypeScript, then compile it to JavaScript.

ğŸ¤” How can TS use new features if JS doesnâ€™t support them?
â¤ The TypeScript compiler uses workarounds in JavaScript.
â¤ TS features are compiled into equivalent JavaScript using:
1ï¸âƒ£ Existing JavaScript features
2ï¸âƒ£ More complex JS code
â¤ There's no magic
â¤ You write simple code in TypeScript -> gets converted into complex JS code.

TypeScript is strongly typed, whereas Javascript is dynamically typed.


####################################
ğŸ“˜ TypeScript Installation & Setup
####################################
ğŸ”· Compile TypeScript Code
Open terminal in the project folder.

Run the compiler: 
ğŸ”— tsc app.ts
This generates app.js.

ğŸ”— tsc app.ts --watch  #continuously watches the typescript file and changes to Javascript


##########################
ğŸ“˜ TypeScript â€“ Variables
##########################
â¤ A variable is a named storage where we can store a value.

ğŸ”„ Creating Variables in TypeScript
Variables can be created using let or const keywords.

let num=100;
const str="hello world";

ğŸ”„ let vs const
| Feature                 | `let`                      | `const`                               |
| ----------------------- | -------------------------- | ------------------------------------- |
| Initialization Required | âŒNot required immediately | âœ… Must be initialized immediately   |
| Can Reassign Value      | âœ… Yes                     | âŒ No, value cannot be changed       |
| Example (Valid)         | `let x; x = 10;`           | `const y = 5;`                        |
| Example (Invalid)       | â€“                          | `const y;`(âŒ  Error: must initialize)|


################################
ğŸ”„ Type Inference in TypeScript
################################
TypeScript automatically infers the type at the time of initialization.

Example:
let num=100; //inferred as number

Once the type is set, it cannot be changed.
num=true // âŒ Error: boolean not assignable to number

ğŸ”„ Rules for Naming Variables
1. Allowed characters- Letters, digits, _(underscore), {dollar sign}
2. Cannot start with a digit.
3. Valid start characters: A letter, _, $
4. Case Sensitive
5. Reserved Keywords not Allowed


############################
ğŸ“˜ Datatypes in TypeScript
############################

âš¡ Note: 
â¤ With Backticks we can write multi line string, not possible normally also allows expression interpolation.
â¤ TypeScript numbers are always floating point numbers even if we don't see or write it.

ğŸ”„ Common Data Types in  TypeScript
1ï¸âƒ£ string: Textual data or a sequence of characters.
2ï¸âƒ£ number: All numeric values(both integers and float).
3ï¸âƒ£ boolean: true or false

0, null, undefined is a falsy values.

ğŸ“˜ Explicit Typing & Type Inference

ğŸ”„ Explicit Typing: You can explicitly specify data types for:
â¤ Function parameters
â¤ Variables
â¤ Function return value

function sum(num1:number,num2:number):number{
    return num1+num2;
}
If non-number values are passed, TypeScript gives a compile-time error.

ğŸ”„ Without Explicit Types
If no type is specified, any type can be passed, which can lead to unexpected results.

function sum(num1,num2){
    return num1+num2;
}

sum("12",13); //Output: "1213" (string concatenation!)

ğŸ”„ Explicit Types for Variables
let n1:number=10;
let msg:string= "Result is"

ğŸ”„ Type Inference
TypeScript automatically infers the type of a variable when you assign a value during declaration.

let n1=10; //inferred as number
let name= "Ankur" //inferred as string

After inference, the type cannot be changed
n1= "Hello" //âŒ Error: string not assignable to number

ğŸ”„ Type Inference in Functions
If you define parameters without types, any value can be passed (not recommended).
â¤ Always use explicit typing in function parameters for safety.

ğŸ”„ Comparison with JavaScript
| Feature              | JavaScript          | TypeScript               |
| -------------------- | ------------------- | ------------------------ |
| Typing               | Dynamic             | Static (strong typing)   |
| Type Errors          | Detected at runtime | Detected at compile time |
| Variable Type Change | Allowed             | Not Allowed              |


##########################
ğŸ“˜ Objects in TypeScript
##########################
ğŸ”„ Creating Objects in TypeScript

let person={
    name:"John",
    age:30
};
Just like JavaScript- Key value pairs

ğŸ”„ Type Inference for Objects
â¤TypeScript infers the structure of the object at initialization.
â¤If you reassign an object with extra or missing properties, it throws an error.

person={
    name:"Mark",
    age:32,
    gender:"male" //âŒ Error: gender is not expected
};

ğŸ”„ Explicit Object Typing
let person: {name:string,age:number}={
    name:'John",
    age:30
}
Only objects matching this structure can be assigned.

ğŸ”„ Assigning object as a Type (Generic)
let person: object;
Accepts any object, but accessing specific properties will give error(TypeScript doesnâ€™t know what properties exist).

ğŸ”„ Accessing Properties Notations
console.log(person.name); // if name exist
console.log(person["age"]); // square bracket notation

ğŸ”„ Nested Object Typing
let person:{
    name:string;
    age:number;
    address:{
        city: string;
        country: string;
    }
}={
    name:"John",
    age:30,
    address:{
        city:"London",
        country:"UK"
    }
};

ğŸ”„ JavaScript vs TypeScript
| Feature                | JavaScript       | TypeScript             |
| ---------------------- | ---------------  | --------------------   |
| Type Safety            | âŒ No            | âœ… Yes                |
| Extra Property Check   | âŒ Allowed       | âœ… Error              |
| Property Inference     | âŒ Not available | âœ… Strong inference   |
| Accessing Missing Keys | `undefined`      | âŒ Compile-time error  |


##########################
ğŸ“˜ Arrays in TypeScript
##########################
â¤ Just like JavaScript, an array is a collection of values.
â¤ Syntax to create an array is the same [], but TypeScript adds type safety.

ğŸ”„ Type Inference in Arrays
let person=["John",28,"male",1000];

TypeScript infers: (string | number)[] -> An array of string or number.

ğŸ”„ Restriction Based on Inferred Type
person.push(true);// âŒ Error: boolean not allowed
person.push(500);// number allowed

ğŸ”„ Arrays with Single Type
let names= ["Alice", "Bob"] // string[]
Push any value not matching the type -> âŒ Error

ğŸ”„ Explicitly Typing Arrays
let names: string[] = [];           // only strings allowed
names.push("John");                 // âœ… OK
names.push(42);                     // âŒ Error

// Use | (pipe) operator for multiple allowed types:
let person: (string | number)[] = ["John", 28]; // âœ…
person.push(true); // âŒ Error if boolean not included

Accessing of elements we use traditional indexing method

Use for...of loop:
for(let year of birthYears){
    console.log(year);
}

ğŸ“Œ Key Differences from JavaScript
| Feature                   | JavaScript         | TypeScript            |
| ------------------------- | ----------------   | --------------------  |
| Type Safety               | âŒ No             | âœ… Yes                |
| Invalid Type Insertion    | Allowed            | âŒ Compile-time error|
| Explicit Type Declaration | âŒ Not applicable | âœ… Supported          |
| Code Autocompletion       | Limited            | âœ… Strong support    |


###################################
ğŸ”· What is a Tuple in TypeScript?
###################################
â¤ A Tuple is a fixed length, ordered collection of elements.
â¤ Each position in the tuple has a specific data type.
â¤ Not available in JavaScript, but compiled to an array in JS.

let employee:[number,string,number,boolean];
employee=[1123,"John", 2000,true];
â¤ We cannot add 5th element but there is an exception

â— Exception: Push Method
Even though tuples are fixed-length, you can still push values to them without error:

employee.push(100): //âœ…No compiler error
This is a TypeScript limitation, not enforced at runtime or by push.

âŒ Common Errors
â¤ Assigning more/fewer values than defined:
employee = [1, "Mark", 1200];     // âŒ Error: needs 4 elements
employee = [1, "Mark", 1200, true, 100]; // âŒ Error: too many elements

â¤ Assigning wrong types:
employee = ["one", "John", 2000, true]; // âŒ Error: "one" is not a number

ğŸš« Why Not Use Tuples for Random, Long, Mixed Data?
Because:
â¤ Tuples are meant for structure (e.g., [id, name, active])
â¤ Not meant for arbitrary or unpredictable values

Tuples can be reassinged when it have same type of elements in the ordered manner in fixed defined length.


######################
ğŸ”¶ TypeScript enum
######################
â¤ A special data type used to define a set of named constants.
â¤ Not available in plain JavaScript, only in TypeScript.
â¤ Used for cleaner, more readable code especially when dealing with fixed categories(e.g. user roles,states);

enum Roles{
    Admin,
    ReadOnly,
    WriteOnly,
    ReadWrite
}
By default 
â¤ Admin=0, ReadOnly=1,WriteOnly=2,ReadWrite=3

ğŸ”„ Example
let user={
    name:"Ankur",
    age:30,
    role:Roles.Admin
};

if(user.role==Roles.Admin){
    console.log("This user is Admin");
}

âœï¸ Explicit Value Assignment
Numeric:
enum Roles {
  Admin = 100,
  ReadOnly = 200,
  WriteOnly = 300,
  ReadWrite         // â†’ 301 (auto-increment from previous)
}

String:
enum Roles {
  Admin = "ADMIN",
  ReadOnly = "READ_ONLY"
}

Mixed (âš  Not recommended):
enum Roles {
  Admin = "ADMIN",
  ReadOnly = 2
}

Note:Can be mixed with string and number but initialization should end with number only

ğŸŒ€ Compilation to JavaScript
â¤ TypeScript compiles enums to IIFE(Immediately Invoked Function Expression) functions to generate bi-directional mappings.

âœ… When to Use Enum
â¤ When you need fixed categories (roles, permissions, statuses).
â¤ To avoid hardcoded strings or magic numbers in your logic.
â¤ When you want autocompletion + type safety.

ğŸš« Caution
â¤ Enums are not available in JS- they're a TypeScript-only feature.
Use const enum for performance(inlines the values), but it doesn't support reverse mapping.


#########################
ğŸ”¶ TypeScript any Type
#########################
â¤ any is the most flexible type in TypeScript.
â¤ A variable declared as any can hold any kind of value:number, string, boolean, array, object ect.
â¤ Disables type checking, like JavaScript.

let data: any;

data = 42;          // âœ… No error
data = "hello";     // âœ… No error
data = true;        // âœ… No error
data = [1, 2, 3];   // âœ… No error
data = { a: 1 };    // âœ… No error

ğŸ“š any[] â€” Array of Any
let arr: any[] = [1, "two", true, null, undefined];

âš ï¸ Why to Avoid any
â¤ Removes all the benifits of TypeScript.
â¤ Turns TypeScript code into JavaScript-like untyped code.
â¤ May lead to runtime bugs since type saftey is lost.

âœ… Use Case
â¤ When you don't know the type in advance(e.g. external libraries, user inputs, JSON, parsing).
â¤ Type is dynamic or varies at runtime.

ğŸ•µï¸ Variable with No Type or Value
let test;  // No value, no type
console.log(typeof test);  // "undefined"
console.log(test);         // undefined

â¤ TypeScript infers test as any if used without initialization.
â¤ Both type and value will be undefined.


############################
ğŸŸ£ TypeScript: Union Types
############################
â¤ A Union Type allows a variable, parameter or return type to hold more than one type.

let data: string|number; ( | ) know as pipe operator
Here data can hold either a string or a number.

âœ… Example 1: Union in Variables
let user:{name:string,age:number} | null;

âœ… Example 2: Union in Function Parameters
function printStatus(message:string,code:string|number){
    if(typeof code==="string"){ //here typeof is a type guard
        code =code.trim(); //âœ…Safe: Only used if code is string
    }
    console.log(`${message}- Status Code: ${code}`);
}
â¤To access type-specific methods, you need type guards (typeof, instanceof, etc.).

printStatus("Success",200);
printStatus("Not found","404");

â—Common Pitfall
â¤ Trying to call methods that only exist on one of the types:
code.trim(); // âŒ Error: 'trim' might not exist on type 'number'

âœ”ï¸ Fix:
Use a type check:
if (typeof code === "string") {
  code = code.trim();
}

âœ… When to Use Union Types
â¤ When you expect multiple possible input types.
â¤ When a variable can be nullable.
â¤ For flexibility with controlled safety (better than any).


##############################
ğŸŸ¡ TypeScript: Literal Types
##############################
A literal type allows you to restrict a variable to a specific value, not just a general type.
â¤ Unlike string,which accepts any string value, a literal type like "admin" only accepts that exact value

âœ… Example 1: Literal Type in a Constant
const status="hello world";

â¤ TypeScript infers:
status:"hello world"(Literal Type)
â¤ Not just string -- it's exactly "hello world".

ğŸ†š Difference Between const and let
const msg = "hi";       // msg: "hi" (literal)
let msg2 = "hi";        // msg2: string

âœ… Example 2: Literal Types in Function Parameters
function roleMessage(role:"admin" | "read" | "read-write"){
    switch(role){
        case "admin":
        console.log("You have admin permissions");
        break;
        case "read":
        console.log("You have read permissions");
        break;
        case "read-write":
        console.log("You have read-write permissions");
        break;
        default:
        console.log("Unknown role");
    }
}

roleMessage("admin");         // âœ… allowed
roleMessage("read-write");    // âœ… allowed
roleMessage("guest");         // âŒ error at compile time

ğŸ” Literal Types Can Be:
Strings: "start" | "stop"
Numbers: 1 | 2 | 3
Booleans: true | false
Null / Undefined: null | undefined

âš ï¸ Why Use Literal Types?
â¤ Adds strict control over allowed values.
â¤ Prevents invalid inputs at compile time.
â¤ Helps in writing safe and predictable code (especially with switch, API requests, enums, etc.).


##########################
ğŸŸ¡ TypeScript: Type Alias
##########################
â¤ A Type Alias allows you to give a custom name to a type(primitive, union, literal, object etc).
â¤ It helps in writing clean, reusable, and maintainable code by avoiding type repition.

âœ… Syntax
type CustomTypeName = existingType;

âœ… Example 1: Alias for a Primitive Type
type StringType=string;
let message:StringType="Hello World!";
StringType is now a custom alias for string.

âœ… Example 2: Alias for a Union Type
type StringOrNumber= string | number;

function printCode(code: StringOrNumber) {
  console.log(code);
}
â¤ Instead of repeating string | number, you can use the alias StringOrNumber.

âœ… Example 3: Alias for an Object Type
type User={
    firstName:string;
    lastName:string;
    age:number;
};

function getFullName(user:User):string{
    return `${user.firstName} ${user.lastName}`;
}

ğŸ§  Bonus Tip: You can even alias complex types like:

type UserList = User[];
type Callback = (value: number) => void;


#####################################
ğŸŸ¡ TypeScript: Function Return Types
#####################################
â¤ The return type of a function indicates the type of value that function will return.
â¤ You can either:
Let TypeScript infer the return type automatically.
Explicitly define the return type using :type Syntax

âœ… Syntax

function functionName(params): returnType {
  // logic
  return value;
}

âœ… Examples
1ï¸âƒ£ Function That Returns a Value

function add(num1:number,num2:number):number{
    return num1+num2;
}
â¤ Return type is explicitly declared as numbers
â¤ TypeScript can also infer this if return type is not specified.

2ï¸âƒ£ Incorrect Return Type
function add(num1: number, num2: number): string {
  return num1 + num2; // âŒ Error: number is not assignable to string
}

3ï¸âƒ£ Return Type Inferred as string
function add(num1: number, num2: number) {
  return (num1 + num2).toString();
}

4ï¸âƒ£ Function That Returns Nothing
function add(num1: number, num2: number): void {
  console.log(num1 + num2);
}
â¤ void means that function doesn't return anything.
â¤ Even if you use return; without a value, it is still void.

5ï¸âƒ£ Return Type as undefined (Not Recommended)
function add(num1: number, num2: number): undefined {
  console.log(num1 + num2);
  return undefined;
}
Works, but not recommended.
âœ… Prefer void over undefined for clarity and convention.

â¤ If no return statment is used, TypeScript infers return type as void.


################################################
ğŸŸ£ TypeScript: Function Types as Variable Types
################################################
ğŸ§  What You Already Know
â¤ We can add types to function parameters and return types.
â¤ We can assign a function to a variable in Javascript.

ğŸ”¸ Example: Assigning Function to Variable
function greeUser(user:{name:string}){
  console.log(`Hello ${user.name}`)
}

let greet=greeUser; // âœ… Valid
âœ… We can now call greet({name:"John"}) and it will behave like greeUser. 

â— Problem with any Type
If no type is defined for greet, its type is inferred as any:

let greet:any=greeUser;
greet=100; // âŒ Allowed, but dangerous!

â¤Can accidentally assign non-function values (like 100, true, "text") to greet.
â¤This cause runtime errors (e.g. greet is not a function) without compile-time warning.

âœ… Solution 1: Use General Function Type
let greet:Function =greeUser;
greet=100; // âŒ Error at compile time

â¤Function restricts assignment to function values only.
â¤âŒ But it doesnâ€™t check the parameter or return types of the function.

âœ…âœ… Solution 2: Use Specific Function Signature
â¤Specify the exact structure (Signature) of the function:

let greet:(user:{name:string})=>void;

Now only function that:
â¤Accepts a single user object with a name Property
â¤Return void
â¤...can be assigned to greet

ğŸ” Detailed Example
type User = { name: string; age: number };

function greetUser(user: User): void {
  console.log(`Hello ${user.name}`);
}

function isEligible(user: User): void {
  console.log(user.age >= 18);
}

function sum(a: number, b: number): number {
  return a + b;
}

// Declare variable with specific function signature
let greet: (user: User) => void;

greet = greetUser;   // âœ…
greet = isEligible;  // âœ…
greet = sum;         // âŒ Error - Signature mismatch

ğŸŸ¦ TypeScript: Function Types for Variables & Callbacks
###########################################################

We can assign a function to a variable, and define the expected function signature using function types.

let addNumbers:(a:number,b:number) => number;

function sum(x:number,y:number):number{
  return x+y;
}

addNumbers=sum; // âœ… Matches signature

ğŸ” Callback Functions with Function Types
We can also define function types as parameter types (for callback functions).

âœ… Example: Defining a Function with a Callback
function getResult(num1:number,num2:number,print:(msg:string,result:number) =>void):void {
  const result=num1+num2;
  print("Sum =",result);
} 

ğŸ“˜ Callback Function Example
function display(message:string,result:number):void{
  console.log(`${message}${result}`);
}

ğŸ”„ Calling with Callback
getResult(12,13,display); // Output: Sum = 25

âš ï¸ What If We Pass Invalid Types?
If the callback parameter is not a function or does not match the signature, TypeScript shows compile-time errors

ğŸ“Œ Why Use Function Types for Callbacks?
â¤Prevents bugs during runtime.
â¤Ensures correct usage of callbacks.
â¤Helps with IntelliSense and auto-completion.
â¤Makes function contracts clear and safe.

âœ… Best Practice
Always define callback function types explicitly when:
â¤Passing a function as an argument
â¤Returning a function from another function
â¤Storing a function in a variable

ğŸ”„ TypeScript unknown Type
###########################

ğŸ§  What Is unknown?
â¤unknown is a type-safe counterpart of any.
â¤It is used when you don't yet know what type of data a variable can hold.
â¤Unlike any, it forces you to do a type check before using the variable.

âœ… unknown vs any
| Feature                        | `any`          | `unknown`  |
| ------------------------------ | -------------- | ---------- |
| Can hold any value             | âœ… Yes          | âœ… Yes      |
| Type checking before usage     | âŒ Not required | âœ… Required |
| Type-safe                      | âŒ No           | âœ… Yes      |
| Suitable when type is unknown? | âš ï¸ Not ideal   | âœ… Ideal    |

ğŸ’¡ Use Case
let inputVal:unknown;
inputVal = 123;         // valid
inputVal = "hello";     // valid
inputVal = [1, 2, 3];   // valid
âœ… All types can be assigned to unknown.

let uname:string;
uname=inputVal; // âŒ Error: Type 'unknown' is not assignable to type 'string'

We must narrow the type:
if(typeof inputVal==="string") uname=inputVal;

ğŸš« Why Not Use any?
Using any disables all type safety:
let inputVal:any;
let uname:string=inputVal; // âœ… No error, but could lead to runtime bugs

Whereas unknown prevents unsafe assignment unless you explicit verify the type.

ğŸ§ª Real-Life Scenario
You get data from an API reponse or user input and aren't sure of its type at first:

function handleInput(data:unknown){
  if(typeof data==="number"){
    console.log("Square:",data*data);
  }
  else{
    console.log("Invalid number input); 
  }
}

ğŸ”¥ TypeScript never Type
#########################

ğŸš« What Is never?
â¤The never type represents a value that never occurs.
â¤A function with return type (never) never completes normally:
It either throw an error.
Or it runs forever (like an infinite loop).

Itâ€™s more strict than void â€” not even undefined is returned.

âœ… When to Use never
You use never when a function
1. Always thows an error
2. Never finishes executing (infinite loop)

ğŸ” never vs void
| Feature                  | `void`                              | `never`                                              |
| ------------------------ | ----------------------------------- | ---------------------------------------------------- |
| Used for functions that: | Finish but return nothing           | Never finish or always throw                         |
| Returns value?           | âŒ No value, but returns `undefined` | âŒ No return at all â€” not even `undefined`            |
| Logged output            | Logs `undefined`                    | Logs nothing (because function crashes or loops) |

ğŸ§ª Examples
âœ… 1. Error-Throwing Utility Functions
Imagine a utility function that always throws an error when something goes wrong â€” this is a perfect case for never:

function throwError(message: string): never {
  throw new Error(message);
}
âœ… Real-Life Scenario:
In an API or validation library:

function validateUser(data: any) {
  if (!data.email) {
    throwError("Email is required"); // return type: never
  }
}
Here, throwError() stops the execution and will never return.

âŒ No value is ever returned â€” just throws.

2. Function with infinite loop â†’ never
function runForever():never{
  while(true){
    console.log("Running...")
  }
}
ğŸš« Never exits â†’ return type is never.
console.log(runForever());           // keeps running, no output after

âœ… 2. Exhaustive Type Checking (with never)
When you use discriminated unions, never helps ensure that all cases are handled â€” very common in Redux, state machines, or switch cases.

ğŸ”„ Example: Handling shape types

type Shape = 
 { type: "circle"; radius: number } | { type: "square"; side: number };

function getArea(shape: Shape): number {
  switch (shape.type) {
    case "circle":
      return Math.PI * shape.radius * shape.radius;
    case "square":
      return shape.side * shape.side;
    default:
      const _exhaustiveCheck: never = shape; // âŒ Error if new shape type is added but not handled
      throw new Error("Unhandled shape type");
  }
}
âœ… Real-Life Scenario:
In large applications, this pattern ensures that all variants of a type are covered. If a new shape is added (like "triangle"), TypeScript will force you to handle it.

âœ… 3. Unreachable Code Detection
In deeply nested logic or switch cases, never can help identify unreachable code:

function process(value: string | number) {
  if (typeof value === "string") {
    console.log("string value:", value);
  } else if (typeof value === "number") {
    console.log("number value:", value);
  } else {
    const unreachable: never = value; // Will throw error: Type 'string | number' is not assignable to 'never'
  }
}

âš ï¸ Default Behavior
If you donâ€™t write the return type:
â¤Functions that throw or loop forever will not be automatically inferred as never.
â¤You'll have to explicitly set it to never.

ğŸ”¶ What is Array Destructuring?
#################################

Array Destructuring is an ES6 feature that allows unpacking values from arrays  into individual Variables using a clean, concise syntax.

âœ… Traditional Way (Without Destructuring)

const person=["John","Smith",28];
const fName=person[0];
const lName=person[1];
const age=person[2];
This becomes verbose for larger arrays.

âœ… Destructuring Syntax

const [fName,lName,age]=person;

â¤Uses square brackets [].
â¤Assign based on position/index.

ğŸ”· Important Points
1. ğŸ”„ You Can Skip Elements
const [fName,,age]=person; //skips the second element

2. ğŸ”„ Fewer Variables Than Elements
const [fName,lName]=person; //only first two elements used

3. ğŸ”„ More Variables Than Elements
const [fName,lName,age,gender="Male"]=person;
If gender is missing, it will default to "Male" if not defined the default value then it will assigned with undefined.

5. ğŸ”„ Original Array is Untouched
Destructuring does not modify the original array.

âœ… Use Cases
â¤Returning multiple values from a function.
â¤Extracting parts of an API response.
â¤Clean, readable assignments from arrays.

ğŸ”¶ What is Object Destructuring?
##################################

Object destructuring is an ES6 feature that allows ys to extract properties from an object and assign them to variables in a single line using a concise syntax.

âœ… Traditional Way (Without Destructuring)
const user={
  forname:"John",
  age:28,
  gender:"Male"
};

const forname=user.forname;
const age=user.age;
const gender=user.gender;

âœ… With Object Destructuring

const {forname,age,gender}=user;

â¤Uses curly braces {}.
â¤The variable name must match the property name in the object.
â¤Destructuring is based on property names, not order like arrays.

ğŸ”· Important Points

1. ğŸ”„ Variable Names Must Match Object Keys
const {forname}=user; //OK
const {name}=user; // âŒ Error (or `undefined` in JS) â€“ no such property

2. ğŸ”„ Using Aliases for Variables
If you want the variable name to be different from the property name:

const {forname:fname}=user;
console.log(fname);   //John

â¤forname is a property name and fname is the new variable name.

3. ğŸ”„ Mixing Destructuring with Aliases
const {forname:fname,age,gender}=user;

4. ğŸ”„ Handling Non-Existent Properties
const {country}=user; // âŒ Error: Property 'country' does not exist on type

â¤Ensure the object type includes country.
â¤Or use optional chaining (for nested objects)/defaults:
const {country="India"}=user;

âœ… What is the Spread Operator?
##################################
The spread operator(...) is a feature introduced in ES6 that unpacks elements from array or properties from objects into individual values or properties.

const arr=[1,2,3]
console.log(...arr); //Output: 1 2 3

ğŸ”· Use Cases of the Spread Operator

1. ğŸ” Extract Elements from an Array
const user=["John","Mark","Mary"]
console.log(...user)// Output: John Mark Mary

2. ğŸ“‹ Shallow Copy of an Array
const user=["John","Mark","Mary"]
const copyUsers=[...users];

copyUsers.push("Steve");
console.log(copyUsers); // // ["John", "Mark", "Mary", "Steve"]
console.log(users); // // ["John", "Mark", "Mary"]

3. â• Merging Arrays / Adding Elements
const users = ["John", "Mark", "Mary"];
const extendedUsers = ["Ravi", "Steve", ...users];
console.log(extendedUsers); // ["Ravi", "Steve", "John", "Mark", "Mary"]

âœ… Spread brings in elements not as an array, but as individual items.

4. ğŸ“¦ Using Spread in Objects
const person={
  firstName:"John",
  age:28,
  gender:"male"
};

const employee={
  ..person,
  salary:1200,
  company:"Google"
};

console.log(employee);
//Output
{
  firstName:"John",
  age:28,
  gender:"male",
  salary:1200,
  company:"Google"
};

ğŸ”„ Copies all key-value pairs from person into employee.

â— Important Notes
ğŸ”¸ Shallow Copy Only
Spread operator does not deep clone nested structures.and hence the nested object will be copied as reference so when we change in one object it will change the other also.

const nested = [{ name: "John" }];
const copy = [...nested];

copy[0].name = "Steve";
console.log(nested[0].name); // "Steve" ğŸ˜±

âœ… Rest Pattern & Rest Parameters (ES6)
########################################

Both use three dots(...), just like spread operator, but their purpose is opposite.

ğŸ”„ 1. Rest Pattern (Used in Destructuring)
â¤Collects remaining elements in the array
â¤Used on the left side of assignment(=)

Example (Array Destructuring)

const [a,b,...rest]=[1,2,3,4,5]
console.log(a); //1
console.log(b); //2
console.log(rest); //3,4,5
â¡ï¸ rest gathers the remaining elements into a new array

âš ï¸ Note:
â¤Only one rest variable allowed
â¤Must be at the end when destructuring

ğŸ”„ 2. Rest Parameters (Used in Functions)
Allows passing any number of arguments int a single array parameter.
Also used on the left side (in the function parameter list);

ğŸ§ª Example:
function addNumbers(...numbers:numbers){
  let sum=0;
  for(const num of numbers){
    sum+=num;
  }
  return sum;
}

console.log(addNumbers(1,2,3,4,5)); //15
â¡ï¸ numbers becomes an array of all passed arguments.

âœ… Nullish Coalescing Operator (??) in TypeScript
###################################################
To provide a default value only when a variable is null or undefined- not when it's 0,false, or an empty string.

Syntax: let result=value ?? defaultValue;

âœ… TypeScript Example
let username:string | null=null;
let displayName:string=username ?? "Guest";
console.log(displayName); // Guest

ğŸ”¸ Falsy But Valid:
let age:number | undefined=0;
let userAge:number=age ?? 18;

console.log(userage); //0
ğŸ’¡ 0 is falsy, but not null or undefined- so it reamins.

 || ğŸ†š ?? in TypeScript

 let title:string | null ="";

 let result1= title || "untitled"; // untitled
 let result2= title ?? "untitled"; //""

 Explanation:
 || considers ""(empty string) as falsy and uses "untitled"
 ?? keeps the empty string since it's not null or undefined.

 ğŸ” Type Safety Benefit
When you declare a union type:

let message: string | null | undefined;

Using ?? ensures that you handle only the nullish case explicitly

let finalMessage:string=message ?? "No message";
ğŸ”¸No need to check "" or false values seperately- TypeScript knows the variable may be nullish, and ?? fixes that safely.

âœ… Optional Chaining (?.) in TypeScript
########################################
Optional chaining is a safe way to access nested object properties, methods or array elements without having to manually check for null or undefined at each level.

ğŸ”¸ Why We Use It?
When working with:
â¤Backend data (e.g. API response)
â¤Deeply nested objects, Or
â¤DOM elements that might not exist,

you risk runtim errors like:
âŒ Cannot read properties of undefined (reading 'something')

Optional chaining prevents these by short-circuiting the expression when something is null or undefined.

ğŸ§  Syntax
object?.property
object?.[index]
object?.method?.()

âœ… Example in TypeScript

ğŸ”„ Basic Setup:
const products: Product[] = [
  { name: "iPhone", price: 99999, details: { color: "black", ram: "8GB" } },
  { name: "T-shirt", price: 899, details: { color: "blue" } },
  { name: "Book", price: 499 } // no `details` property
];

ğŸ”¸ Without Optional Chaining âŒ (Risky)
for (const prod of products){
  console.log(prod.details.color); // ğŸ’¥ Error for product without `details`
}

âœ… With Optional Chaining
for (const prod of products){
  console.log("Color: ",prod.details?.color); // âœ… Safe access
  console.log("RAM: ",prod.details?.ram); // âœ… Safe access
}

ğŸ§ª Bonus: Optional Chaining with Functions
const user = {
  greet: () => "Hello!"
};

console.log(user.greet?.()); // "Hello!"

const user2 = {};
console.log(user2.greet?.()); // âœ… undefined, no error

ğŸ§­ When to Use Optional Chaining

Use it when:
â¤You're accessing optional or backend-provided nested data.

â¤You want to avoid lengthy if checks like:
if (user && user.details && user.details.name) { ... }

Instead: user?.details?.name

âœ… Arrow Functions in TypeScript
#################################
Arrow functions are a compact way to write functions,introduced in ES6 and fully Supported in TypeScript with type annotations.

ğŸ”„ 1. Three Ways to Declare Functions

ğŸ”¸ a. Function Declaration
function print(message:string):void{
  console.log(message);
}

ğŸ”¸ b. Function Expression
const sum=function(num1:number,num2:number):number{
  return num1+num2;
}

ğŸ”¸ c. Arrow Function
const sum=(num1:number,num2:number):number=>{
  return num1+num2;
}

ğŸ”„ 2. Arrow Function Syntax Simplification

âœ… Full Syntax:
const sum=(a:number,b:number):number=>{
  return a+b;
}

âœ… Shorter Syntax (for 1-liner body):
const sum=(a:number,b:number):number=>a+b;

âœ… Single Parameter: Parentheses Optional (but only in JS):
const square=(x:number):number=> x*x; //âœ… TypeScript requires parentheses if omitted gives error

ğŸ”„ 3. Assigning Arrow Function to a Typed 

You can declare the function type separately:
const sum: (a: number, b: number) => number = (a, b) => a + b;

This allows type inference for parameters.

ğŸ”„ 4. Arrow Function in Callbacks

Arrow functions are perfect for callbacks like event listeners:
const button =document.getElementById("btn");

button?.addEventListener("click",()=>{
  console.log("Button clicked!");
})

ğŸ”„ 5. Arrow Functions and this

Arrow function do not bind their own this. They inherit this from the surrounding (lexical scope) which is helpful in object methods and events callbacks.

class Counter{
  count=0;
  start(){
    setInterval(()=>{
      this.count++;
      console.log(this.count);
    },1000)
  }
}

Using regular function inside setInterval would require bind(this) or saving context in a self variable. Arrow function solves that.

ğŸ’¡ When to Use Arrow Functions
âœ… Ideal for:
â¤Short, concise functions
â¤Callbacks (e.g. map, filter, eventListener)
â¤When you want to preserve this

âŒ Avoid if:
You need dynamic this (e.g., inside some class methods)

âœ… Object-Oriented Programming (OOP) in TypeScript
#####################################################

OOP is a programming paradigm where real-world entities are modeled as object that have:
â¤Properties (State) â€“ Data/attributes
â¤Methods (Behavior) â€“ Functions/actions

ğŸ§± Why Use Classes?
âŒ Without Classes (Object Literal)
Imagine we want to create 100 products.
â¤We are duplicating logic in every object.
â¤Easy to miss properties or functions.
â¤Hard to scale.

âœ… With Classes: A Blueprint

class Product {
  //Properties in class
  name: string;
  price: number;
  color: string;

  constructor(name: string, price: number, color: string) {
    this.name = name;
    this.price = price;
    this.color = color;
  }
  //Methods in class
  calcDiscount(): number {
    return this.price * 0.1;
  }

  availability(): string {
    return "In Stock";
  }
}

ğŸ‘‰ Create Objects (Instances) from the Class:

const p1 = new Product("iPhone 11", 19900, "Black");
const p2 = new Product("Shoes", 3000, "White");

console.log(p1.calcDiscount()); // 1990

â¤Product class is a blueprint.
â¤p1, p2 are instances (actual data).
â¤All instances share same structure but have different values.

ğŸ” Access Modifiers in TypeScript
###################################
Access modifiers control visibility of properties and methods in a class.

âœ… Three Types of Access Modifiers
| Modifier    | Accessible From                                           |
| ----------- | --------------------------------------------------------- |
| `public`    | Anywhere (default)                                        |
| `private`   | Only within the same class                                |
| `protected` |  within the class & its subclasses |

ğŸ§± Class Example: Employee
ğŸ¯ Goal:
Restrict direct modification of sensitive properties like salary and hikePercentage.

ğŸ‘¨â€ğŸ’¼ Sample Code:

class Employee {
  name: string;
  location: string;
  isEligible: boolean;

  private _salary: number;
  private _hikePercentage: number;

  constructor(name: string, _salary: number, location: string, isEligible: boolean, _hikePercentage: number) {
    this.name = name;
    this._salary = _salary;
    this.location = location;
    this.isEligible = isEligible;
    this._hikePercentage = _hikePercentage;
  }

  getSalary(): number {
    if (this.isEligible) {
      return this._getNewSalary(); // Calls private method
    }
    return this.salary;
  }
  private _getNewSalary(): number {
    return this._salary + (this._salary * this._hikePercentage / 100);
  }
}

ğŸš« Problem Without Access Modifiers
Without private, anyone can do this:

const emp = new Employee("John", 10000, "London", true, 20);
emp._salary = 20000; // âŒ Not secure

âœ… Solution With private
â¤salary and hikePercentage can't be modified directly from outside the class.
â¤Controlled access via methods like getSalary().

ğŸ§ª Example in Action
const emp = new Employee("John", 10000, "London", true, 20);
console.log(emp.getSalary()); // 12000

Trying this:
console.log(emp._salary);            // âŒ Error: salary is private
console.log(emp._getNewSalary());   // âŒ Error: private method

ğŸ§  Shorthand Property Initialization
#######################################

In TypeScript, when you add an access modifier (public, private,protected) directly to a constructor parameter, it automatically:

â¤Creates a class property with the same name.
â¤Initializes that property with the argument passed to the constructor.

âœ… Example: Without Shorthand

class Employee {
  public empName: string;
  private _salary: number;

  constructor(empName: string, salary: number) {
    this.empName = empName;
    this.salary = salary;
  }
}

âœ… Example: With Shorthand (Cleaner!)

class Employee {
  constructor(public empName: string, private salary: number) {}
}

ğŸ”„ Behind the scenes:
â¤public empName: string â†’ creates this.empName and assigns the value.
â¤private salary: number â†’ creates this.salary and makes it private.

ğŸ›‘ Be Careful About:
Name Conflicts: You can't use the same name for shorthand and then declare that property again explicitly.

âœ… Readonly Properties in TypeScript
#####################################

â¤Can be assigned only once, either during declaration or inside the constructor.
â¤Can be accessed(read) from outside the class.
â¤Cannot be modified after initialization.

ğŸ”¸ Declaration Syntax
readonly propertyName:type=value; //Initialized during declaration
readonly propertyName:type; //can be initialized in constructor

or using constructor shorthand:

constructor(public readonly empId:number){}

ğŸ”„ Example with Shorthand & Access Modifiers

class Employee {
  constructor(
    public readonly empId: number,               // Readonly & public
    public empName: string,
    private _salary: number,
    public baseLocation: string,
    public isEligible: boolean,
    private _hikePercent: number
  ) {}

  public getSalary(): number {
    return this.isEligible
      ? this._salary + (this._salary * this._hikePercent) / 100
      : this._salary;
  }

  private _getNewSalary(): number {
    return this.getSalary(); // Example of internal method usage
  }
}

const emp = new Employee(101, "John Smith", 10000, "London", true, 20);
console.log(emp.empId);        // âœ… Allowed (read)
emp.empId = 201;               // âŒ Error (cannot assign to readonly)

âœ… Inheritance in TypeScript
###########################
Inheritance is a core concept of OOP that allows a class(child/derived class) to inherit properties and methods from another class (parent/base class).

ğŸ”„ Why Use Inheritance?
â¤Avoid code duplication
â¤Code reusability
â¤Improves Maintainability
â¤Helps in keeping the code organized

Base / Parent Class: The class being inherited from (e.g., Person)
Derived / Child Class: The class that inherits (e.g., Employee, Athlete)

ğŸ”„ Inheritance Syntax in TypeScript
class Child extends Parent {}

ğŸ”„ Calling Parent constructor
Use super(...) inside the child constructor before accessing this.

âœ…Example:
class Person{
  constructor(public name:string,public dob:string,public gender:string){}

  calculateAge():number{
    const currentYear=new Date().getFullYear();
    const birthYear=new Date(this.dob).getFullYear();

    return currentYear-birthYear;
  }
}

class Employee extends Person{
  constructor(public name:string,public dob:string,public gender:string,private _salary:number,private _bonus:number){
    super(name,dob,gender);
  }

  getSalary():number{
    return this._salary+this._bonus;
  }
}

//Create an instanceof
const emp=new Employee("Ankur Verma","2003-08-30,"male",100000,2000);

//Output results
console.log("Name:", emp._name);
console.log("Age:", emp.calculateAge());
console.log("Total Salary:", emp.getSalary());

Overriding & Protected Modifier in TypeScript
################################################

ğŸ”„ What is Method Overriding?
â¤A child class redefine a method of the parent class.
â¤The overridden method in the child class will be called instead of the one in the parent.

ğŸ”„ Access Modifiers Recap:
| Modifier    | Accessible In | Accessible In Child Class |
| ----------- | ------------- | ------------------------- |
| `public`    | Everywhere    | âœ… Yes                     |
| `private`   | Inside class  | âŒ No                      |
| `protected` | Inside class  | âœ… Yes                     |

â¤If a property is marked private, even the child class can't access it.
â¤Use protected if the child class should access the property.

âœ… TypeScript Code Example
class Person{
  constructor(public name:string,protected dob:string,public gender:string){}

  calculateAge():number{
  console.log("calculateAge of Person called");
    const currentYear = new Date().getFullYear();
    const birthYear = new Date(this._dob).getFullYear();
    return currentYear - birthYear; 
  }
}

class Employee extends Person{
  constructor(public name:string,public dob:string,public gender:string,private _salary:number,private _bonus:number){
    super(name,dob,gender);
  }
  
  override calculateAge():number{
    console.log("calculateAge of Employee called");
    return 2024 - new Date(this._dob).getFullYear();
  }

  getSalary():number{
    return this._salary+this._bonus;
  }
}

const emp = new Employee("John", "08/30/1991", "male", 10000, 2000);
console.log("Name:", emp._name);
console.log("Age:", emp.calculateAge());      // Overridden method
console.log("Salary:", emp.getSalary());

const person = new Person("Jane", "05/15/1990", "female");
console.log("Person Age:", person.calculateAge()); // Base class method

ğŸ§  Key Takeaways:
â¤Use protected for properties you want to access in both parent and child classes.
â¤Use override keyword (optional in TypeScript, but good for clarity) when overriding a method.

âœ… Overridden methods are called based on the actual object, not the reference type.
ğŸ”§ Simple Analogy (Real-World):
Imagine you have a reference labeled "Vehicle", but you attach a Car object to it.

Even though the label says "Vehicle", the actual object is a Car.
So if you press the "start" button (i.e., call the start() method), the Car's version of the method will run â€” not the generic Vehicle one.

ğŸ§ª Code Example in TypeScript
class Person {
  constructor(public _name: string) {}

  greet() {
    console.log("Hello from Person");
  }
}

class Employee extends Person {
  greet() {
    console.log("Hello from Employee");
  }
}

// ğŸ‘‡ Reference is of type Person
let someone: Person;

// ğŸ‘‡ But actual object is of type Employee
someone = new Employee("John");

// ğŸ”¥ This will call the Employee's greet(), NOT Person's greet()
someone.greet(); // Output: Hello from Employee.

ğŸ” Why This Happens:
This behavior is called dynamic dispatch or runtime polymorphism â€” the method is selected at runtime based on the actual object type, not the variableâ€™s declared type.

â—If Method Wasn't Overridden:
class Employee extends Person {
  // no override
}

let someone: Person = new Employee("John");
someone.greet(); // Output: Hello from Person
Here, since Employee didnâ€™t override greet(), it calls the parentâ€™s version.

âœ… Getters and Setters
########################
Getters: Used to read private/protected properties safely.
Setters: Used to write/set values with validation if needed.

Common in OOP to encapsulate and control access of data.

ğŸ”§ Basic Example
class Person{
  public name:string;
  private _age:number|null=null;

  constructor(name:string){
    this.name=name;
  }

  //Getters
  get age():number{
    if(this._age!=null) return this._age.
    throw new Error(`Age is not defined for ${this.name}`);
  }

  //Setters
  set age(value:number){
    if(value<0) throw new Error(`Age is not defined for person ${this.name}`)
    this._age=value;
  }
}

âœ… Usage:
const p = new Person("John");

p.age = 30;           // setter gets called âœ…
console.log(p.age);   // getter gets called âœ…

ğŸ§  Why Use Getters and Setters?
| Feature         | Benefit                                                                 |
| --------------- | ----------------------------------------------------------------------- |
| Access control  | Keep property `private`, but expose safe access                         |
| Validation      | Can add rules (e.g., age must be positive) before assigning             |
| Computed values | Can return values derived from private data (like diameter from radius) |
| Encapsulation   | Internal data structure can change without affecting external code      |

ğŸ§® Computed Property Example (Circle Class)

class Circle {
  private _radius: number = 0;

  get radius(): number {
    return this._radius;
  }

  set radius(value: number) {
    this._radius = value;
  }

  // Computed Property
  get diameter(): number {
    return this._radius * 2;
  }

  set diameter(value: number) {
    this._radius = value / 2;
  }
}

âœ… Usage
const c = new Circle();
c.diameter = 10;
console.log(c.radius);    // 5
console.log(c.diameter);  // 10

ğŸ§µ Real-Life Analogy
Think of getters and setters like ATM operations:

Getter â†’ Viewing balance â€” safe, read-only.
Setter â†’ Depositing cash â€” you must follow rules (no fake notes!).

âœ… What Are Static Methods and Properties?
###########################################
Static members belong to class itself, not to instances of class.

ğŸ” Instance vs Static Members
| Category     | Belongs To | Accessed Using        | Copied Per Object? |
| ------------ | ---------- | --------------------- | ------------------ |
| **Instance** | Object     | `objectInstance.name` | âœ… Yes              |
| **Static**   | Class      | `ClassName.name`      | âŒ No (shared)      |

ğŸ”§ Basic Syntax
class Employee {
  static count = 0; // Static property

  constructor(public firstName: string, public lastName: string) {
    Employee.count++; // Access using class name
  }

  static sayHello() {
    return "Hi there"; // Static method
  }
}

const emp1 = new Employee("John", "Doe");
const emp2 = new Employee("Jane", "Smith");

console.log(Employee.count);        // âœ… 2 (shared count)
console.log(Employee.sayHello());   // âœ… "Hi there"

âŒ You cannot do emp1.count or emp1.sayHello() because count and sayHello are not instance members.

ğŸ”¥ Key Rules to Remember
 â¤Use static keyword to declare static members.
 â¤Static members cannot be accessed using this inside the constructor or static methods.
 â¤Access static members using ClassName.staticMember.
 â¤There is only one copy of a static property shared across all instances.

ğŸ§  Real-Life Analogy
Think of static members like company-wide policies:
All employees (instances) share the same policy (static property).
But each employee has their own name, ID (instance properties).

âœ… Abstract Class
###################
An abstract class in TypeScript provides a base class with common logic and abstract methods that must be implemented by derived classes. It cannot be instantiated directly and is mainly used to enforce a structure among subclasses.

ğŸ’¡ Why Use Abstract Classes?
To define a blueprint or base structure for subclasses:
â¤You can define common properties/methods.
â¤You can enforce method implementation.

ğŸ§± Structure & Syntax
abstract class Employee{
  constructor(public firstName:string,public lastName:string){}

  //Abstract method:no implementation here
  abstract getSalary():number;
}

âŒ Cannot Instantiate
const emp=new Employee("Ankur","Verma"); //âŒError:Cannot create an instance of an abstract class

ğŸ§¬ Inheriting Abstract Class
class PermanentEmployee extends Employee{
  constructor(firstName:string,lastName:string,private monthlySalary:number){
    super(firstName,lastName); //call parent constructor
  }

  getSalary():number{
    return this.monthlySalary*12;
  }
}

class ContractEmployee extends Employee{
  constructor(firstName:string,lastName:string,private hourlyRate:number){
    super(firstName,lastName)
  }

  getSalary():number{
    return this.hourlyRate*9*365; //assuming 9hours/day, 365 days/year
  }
}

ğŸš€ Usage
const emp1=new PermanentEmployee("Ankur","Verma",4000);
console.log(emp1.getSalary());// Output: 48000

const emp2= new ContractEmployee("John", "Doe",10);
console.log(emp2.getSalary()) // Output: 32850

â¤If a method is abstract then the class should also be abstract
â¤Contains both abstract & non-abstract code - We can mix implemented and abstract methods. 

ğŸ§  Real-World Analogy
Think of Employee as a template:
You donâ€™t hire an â€œEmployeeâ€ directly.
You hire either a PermanentEmployee or a ContractEmployee, each with their own getSalary() logic.

âœ…private Constructor in TypeScript
####################################
â¤A private constructor prevents a class from beging instantiated directly from outside.
â¤It's used to control object creation,which is essential for design pattern like Singleton.

ğŸ¯ Singleton Design Pattern
A Singleton is a design pattern that ensures a class has only one instance and provides a global access point to it.
In TypeScript, we use a private constructor to restrict instantiation and a static method to return the same instance every time.

ğŸ§± Implementation Steps
class Person{
  //Step 1: Static property to hold the instance
  private static _instance:Person;

  //Step 2: Private constructor to prevent external instantiation
  private constructor() {}

  //Step 3: Static method to control instance creation
  static getInstance():Person{
    if(!Person._instance){
      Person._instance=new Person();
    }
    return Person._instance;
  }
}
cosnt person1=Person.getInstance();
const person2=Person.getInstance();

console.log(person1==person2); //âœ… true-both are same instance

ğŸ“¦ Real-world Use Cases of Singleton
â¤Database connections
â¤Logging services
â¤Configuration managers
â¤Caching
â¤Shared app-wide services(e.g. Usersession, Auth)

âœ… Interface in TypeScript
###########################
â¤An interface in TypeScript is like a contract that forces an object or class to follow a specific structure. It improves code reliability, readability, and allows for polymorphism without inheritance.
â¤It is used for type-checking and enforcing shape without providing any implementation.
â¤Think of it as a blueprint for objects/classes;

ğŸ§± Syntax and Example
inteface User{
  firstName:string;
  lastName:string;
  greetUser():void;
  getFullName():string;
}
Only declaration are allowed- no initialization or implementation.

ğŸ¯ Using Interface as Type
const user1:User={
  firstName:'John',
  lastName:'Smith',
  greetUser():void{
    console.log('Hello User');
  }

  getFullName():string{
    return this.firstName+" "+this.lastName;
  }
};
The object must match all properties and methods defined in the interface.

ğŸ‘¨â€ğŸ« Implementing Interface in Classes
class Admin implements User{
  constructor(public firstName:string,public lastName:string){}

  greetUser(){
    console.log(`Hello Admin ${this.getFullName()}`);
  }

  getFullName(){
    return `${this.firstName} ${this.lastName}`;
  }
}
This class must implment all members of the interface.

ğŸ“Œ Real-world Example â€“ Polymorphism with Interfaces
function displayGreetMessage(user:User){
  user.greeUser();
}

const admin=new Admin("John","Smith");
displayGreetMessage(admin); // Works because admin implements User

â¤You can pass any class instance that implements the interface. 

ğŸ” Interface vs Type Alias
| Feature             | Interface       | Type Alias                 |
| ------------------- | --------------- | -------------------------- |
| Extension           | Can be extended | Can use intersection (`&`) |
| Declaration merging | âœ… Yes           | âŒ No                       |
| Use with classes    | âœ… Preferred     | ğŸ‘ Not ideal               |
| Implementation      | No logic        | No logic                    |


ğŸ”„ Declaration Merging
interface User{
  name:string;
}

interface User{
  age:number;
}

const user:User={
  name:'John',
  age:30
}
â¤ Can add more properties and methods in the interface after the first declaration
console.log(user.name); // Output: John
console.log(user.age); // Output: 30


âš ï¸ Interface vs Abstract Class
| Aspect                | Interface              | Abstract Class               |
| --------------------- | ---------------------- | ---------------------------- |
| Implements logic?     | âŒ Only declarations    | âœ… Can have logic             |
| Multiple inheritance? | âœ… Multiple interfaces  | âŒ Only one abstract class    |
| Object creation?      | âŒ Not allowed          | âŒ Not allowed                |
| Use case              | Contract for structure | Base class with shared logic |

ğŸ” Multiple Interface Implementation
interface Role {
  roleName: string;
}

class Manager implements User, Role {
  constructor(public firstName: string, public lastName: string, public roleName: string) {}

  greetUser() {
    console.log(`Hello Manager ${this.getFullName()}`);
  }

  getFullName(): string {
    return `${this.firstName} ${this.lastName}`;
  }
}

âœ… Benefits of Using Interfaces
â¤Type Safety â€“ Catch errors at compile time.
â¤Code Readability â€“ Acts as clear documentation.
â¤Reusability â€“ Use across classes/functions.
â¤Flexibility â€“ Easily extendable and scalable.

ğŸ›¡ï¸ readonly Properties in Interfaces
######################################
â¤ A readonly property can only be set once (at initialization)
â¤ It prevents mutation after object creation, ensuring immutability.

âœ… Syntax:
interface User{
  readonly company:string;
}

âŒ Wrong: Mutating readonly property

let admin: User = { company: "Google" };
admin.company = "Microsoft"; // âŒ Error: Cannot assign to 'company' because it is a read-only property.

âš ï¸ Important:
The readonly restriction only works if the variable is typed as the interface.
If it's typed as a class (e.g., Admin), and the class doesn't use readonly, it won't throw an error.

âœ… Solution:
Either use readonly in the class definition:
class Admin implements User {
  readonly company = "Google";
}

Or type the object using the interface:
const admin: User = new Admin("John", "Smith"); // Enforces readonly

â“ Optional Properties in Interfaces
######################################
â¤Optional properties may or may not be present in the Implementing class or object.

âœ… Syntax:
interface User{
  location?:string;
}
ğŸ”„ Behavior:
â¤ If location is not defined in a class implementing User, no error occurs.
â¤ If defined, it must be of the correct type.

class Member implements User{
  location?:string; // Optional
  constructor(public firstName:string,public lastName:string,loc?:string){
    this.location=loc;
  }
}

âœ… Optional Constructor Parameters
Use ? to make constructor parameters optional:

constructor(public firstName: string, public lastName: string, loc?: string) {
  this.location = loc ?? "London"; // âœ… Set default value if not provided
}
â— Note:
You cannot use both ? and default value at the same time like loc?: string = "London" â€” it will throw an error.

Instead, use:
this.location = loc ?? "London"; // Fallback to "London" if undefined

âœ… Implementing Multiple Interfaces in a Class
##################################################

interface User {
  name: string;
  getFullName(): string;
}

interface Role {
  getRole(): string;
}

class Admin implements User, Role {
  constructor(public name: string) {}

  getFullName(): string {
    return `Full Name: ${this.name}`;
  }

  getRole(): string {
    return "Admin";
  }
}

ğŸ”¸ Key Points:
â¤ Use commas to implement multiple interfaces.
â¤ You must implement all properties and methods from all interfaces.
â¤ A class can implement as many interfaces as needed.

âœ… Extending an Interface from Another
ğŸ”„ Syntax
interface Role {
  getRole(): string;
}

interface User extends Role {
  name: string;
  getFullName(): string;
}

Now User contains: name, getFullName(), getRole() (from Role)

ğŸ”¸ Key Points:
â¤ Use extends keyword when one interface inherits from another.
â¤ You can extend multiple interfaces:

interface User extends Role, Permissions, MetaData { ... }

Any class implementing User must implement everything from User, Role, Permissions, etc.

âœ… Interface vs Class Extension Rules
| Feature                        | Class                | Interface                  |
| ------------------------------ | -------------------- | -------------------------- |
| Extend multiple types?         | âŒ Only **one** class | âœ… Can extend **multiple**  |
| Implement multiple interfaces? | âœ… Yes                | â€“                          |
| Syntax                         | `class A extends B`  | `interface A extends B, C` |

âœ… Method Access After Extending

If:
interface User extends Role {
  name: string;
}

Then:
let admin: User = new Admin("John");
admin.getRole(); // âœ… Works because `User` extends `Role`

âœ… Defining Function Types in TypeScript
############################################

ğŸ”¸ Using type:
type SumFn=(num1:number,num2:number)=> number;

const add:SumFn=(n1,n2)=>n1+n2;
â¤ You define a type alias with parameters and return type.
â¤ Then use it to assing a funciton to a variable.
â¤ The function must match the declared signature.

ğŸ”¸ Using interface:
interface SumFn{
  (num1:number,num2:number)=>number;
}

const add:SumFn=(n1,n2)=>n1+n2;
â¤ The interface represents a function type.
â¤ Used in the same was as type alias.
â¤ If the function signature doesn't match, TypeScript throws an error.

ğŸ¯ Why Use Function Interfaces?
Mostly useful for:
Complex function structures
Reusability in large codebases

But in real-world use, the type alias is preferred

 ğŸ”· Intersection Types
 #######################

 Union vs. Intersection Types

 ğŸ”„ Union Type (|)
 type StringOrNumber=string | number;

 let x:StringOrNumber
 x='hello';
 x=42;
 x=true;  //// âŒ Error: boolean not assignable
You can assign either a string or a number.

ğŸ”„ Intersection Type (&)
type BoolOrNumber=boolean | number;
type StringOrNumber=string | number;

type MyNumbertype= StringOrNumber & BoolOrNumber;
let x:MyNumbertype;
x=42;       //âœ… OK
x='hello';  // âŒ Error
x=true;     // âŒ Error
âœ… Only the common type between both (i.e., number) is allowed.

ğŸ”· Intersection of Complex Types (Objects)
type User={
  name:string;
  age:number;
};

type Admin={
  name:string;
  role:string;
}

type AdminUser=User & Admin;

cosnt john:AdminUser={
  name:'John',
  age:30,
  role:'admin'
};
âœ… The final object must have all properties from both User and Admin.

ğŸ”§ Using interface with Intersection
interface Order{
  id:number;
  items:string[];
}

function processOrder(order:Order &{status :string}){
  console.log(order.id,order.items,order.status); //combined the property of Order interface and status property
}

processOrder({id:123,items:['item1','item2'],status:'shipped'});
âœ… The function expects an object with both order structure and a status property.

ğŸ§ª Quiz Yourself
What does type A = string & number evaluate to?
âŒ Error â€“ no overlap, results in never

What will be the type of User & Admin?
âœ… { name: string; age: number; role: string }

âœ… Type Guards in TypeScript
###############################
Type Guards help you narrow down the type of a variable withing a conditional block, ensuring type-safe operations on union types.

ğŸ”„ Why Use Type Guards?
In Typescript, we often deal with union types like:
type value=string | number;
You can't safely call string methods on value unless you narrow it to string. That's where type guard come in.

ğŸ”„ Built-in Type Guards
1. typeof (for primitives)
function printLength(value:string | number){
  if(typeof==='string'){
    console.log(value.length); // âœ… Safe: narrowed to string
  }
  else{
    console.log(value.toFixed(2)); // âœ… Safe: narrowed to string
  }
}

2. instanceof (for class instances)
class Dog{
  bark(){
    console.log('Bark');
  }
}

class Cat{
  meow(){
    console.log('Meow');
  }
}

function speak(animal:Dog | Cat){
  if(animal instanceof Dog){
    animal.bark(); // âœ… Dog
  }
  else {
    animal.meow(); // âœ… Cat
  }
}

3. in Operator (for property existance)
type Circle={radius:number};
type Square= { side: number};

function area(shape:Circle | Square){
  if('radius' in shape){
    return Math.PI*shape.radius**2;
  }
  else{
    return shape.side**2;
  }
}

ğŸ”„ Custom Type Guards (User-defined)
Create your own function to check type and narrow:
type Admin={
  role:'admin';
  privileges:string[]
  };
type User={
  role:'user';
  email:string
};

function isAdmin(person: Admin | User): person is Admin{
  return person.role==='admin';
}

function handlePerson(p:Admin | User){
  if(isAdmin(p)){
    console.log(p.privileges); // âœ… Safe: p is admin
  }
  else{
    console.log(p.email); // âœ… Safe: p is user
  }
}

âœ… Discriminated Union in TypeScript
#######################################
Discriminated Union(also called Tagged Union) is a way to implement type guards using a common property (called as "tag") across multiple interfaces.

ğŸ”„ Key Concept:
Each interface is the union includes a common literal property like kind or type. This tag 'discriminates' which type the object belongs to.

ğŸ”¸ Example Setup:
interface Circle{
  kind:'circle'; //literal type
  radius:number;
}

interface Square{
  kind:'square';  //literal type
  length:number;
}

type Shape=Circle | Square;

ğŸ”¸ Function Using Discriminated Union:
function calculateArea(shape:Shape): number{
  switch(shape.kind){
    case 'circle':
    return 3.14*shape.radius**2;
    case 'square':
    return shape.length**2;
  }
}

ğŸ§ª Example Calls:
console.log(calculateArea({kind:'square', length:12}));
console.log(calculateArea({kind:'circle', radius:7}));

ğŸ” Why Use This?
â¤ Helps Typescript infer types inside branches.
â¤ Avoids unsafe property access.
â¤ Scales well when adding more shapes like Rectangle, Triangle, etc.

âœ… Type Casting in TypeScript
###############################
Type castingn is used to explicitly tell the Typescript compiler to treat a variable as a specific type.

ğŸ”„ Scenario:
When accessing an element using document.querySelector, Typescript may infer the type as Element | null, not the exact type like HTMLInputElement.

âœ…Example:
const fname=document.querySelector("#fname"); //inferred as Element | null
Trying to access fname.value will cause an error because Element doestn't guarantee a value property.

ğŸ”¸ Problem:
â¤ fname might be null
â¤ Element does not always have a value property;

ğŸ”¸ Solution: Type Cast
âœ… Method 1: Angle Bracket Syntax
const fname=<HTMLInputElement>document.querySelector("#fname");
fname.value="John";

âœ… Method 2: as Syntax
const fname =document.querySelector("#fname") as HTMLInputElement;
fname.value="John";
Use the as keyword expecially in React/JSX code, as angle brackets can be misinterpreted as JSX.

âš ï¸ Caution:
â¤ Use !(non-null assertion) only if you're sure the element exists.
â¤ If the element might be null, use a conditional check.

âœ…Example:
const fname=document.querySelector("fname");
if(fname){
  (fname as HTMLInputElement).value="John";
}

âœ… Index Signatures (Indexed Properties) in TypeScript
#######################################################
Index signature allow yo uto define objects with dynamic property names- especially useful when property names are not know ahead of time.

ğŸ”¸ Syntax:
interface Example{
  fixedProeprty:string;
  [prop:string]:sting | number;
}
â¤ prop: placeholder for unknown property names( can be named anything)
â¤ string: type of the property name
â¤ string | number : type of the value allowed

ğŸ”¸ Example 1: Product with Optional/Dynamic Properties
interface Product{
  id: number;
  name:string;
  [prop:string]: string | number;
}

const product1={
  id:1,
  name:"T-Shirt",
  color:"Red",
  price:123,
}

const product2: Product = {
  id: 2,
  name: "Mug",
  material: "Ceramic",
  capacity: 300
}

ğŸ”¸ Example 2: Settings with Flexible Keys

interface Settings {
  [props: string]: boolean | string | number;
}

const mySettings: Settings = {
  darkMode: true,
  fontSize: 16,
  customTheme: "Pink"
};

ğŸ§  When to Use Index Signatures:
â¤ When objects can have varying properties.
â¤ When working with settings, prefrences, or configuarations.
â¤ When building collections of heterogeneous objects.

âœ… Function Overloading in TypeScript
########################################
It allows you to define multiple function signature for a single function. Based on the arguments types, Typescript can infer what the return type will be.

ğŸ”„ Why Do We Need It?
When we have a function that:
â¤ Accepts different types of parameters (e.g. number and string).
â¤ Returns different types based on input types
It allows Typescript to infer the correct return type, enabling IntelliSense and type saftey (e.g. method suggestions like .split() for string only).

ğŸ”„ Real-World Example
Suppose we have an addition function that:
Concatenates strings when inputs are strings.
Adds values when inputs are numbers.

Here's the shorthand syntax-based TypeScript implementation:

type StringOrNumber = string | number;

// âœ… Function overloads
function addition(a: number, b: number): number;
function addition(a: string, b: string): string;
function addition(a: number, b: string): string;
function addition(a: string, b: number): string;

// ğŸ”§ Actual implementation (compatible with all overloads)
function addition(a: StringOrNumber, b: StringOrNumber): StringOrNumber {
  return a.toString() + b.toString(); // Concatenate everything
}

// ğŸ§ª Usage

const result1 = addition(10, 20); // number => 30
const result2 = addition("Hello", "World"); // string => HelloWorld
const result3 = addition("Hello", 123); // string => Hello123

// âœ… TypeScript knows result2 is string, so split is allowed
const words = result2.split(""); // Works!

// âŒ This will show error: Property 'split' does not exist on type 'number'.
// const broken = result1.split("");

ğŸ”„ What Problem Does It Solve?
If you donâ€™t use function overloading, TypeScript sees this:
function addition(a: string | number, b: string | number): string | number

Then calling:
const result = addition("hello", "world");
result.split(","); // âŒ Error! split not available on type string | number

Because the type is ambiguous: string | number.
With overloads, TypeScript knows the exact type based on the arguments.

Generics in TypeScript
#######################
Generics are placeholders for types- allowing you to create reusable, type-safe functions, classes, and data structures without knowing the exact types up front.

âœ…Syntax
function identify<T>(value:T):T{
  return value;
}
â¤ Here T is a placeholder type.
â¤ The actual type(e.g. number, string) will be provided when calling the function.

ğŸ”„ Why Use Generics?
Using any breaks type saftey:

âœ…Example
function getItem(arr:any[]):any{
  return arr[0];
}
â¤ You lose access to type-specific methods (e.g. .split() for strings, .toFixed() for numbers).
âœ…Generics preserve type saftey while keeping code flexible.

ğŸ”„ Real Example: swap Function
funciton swap<T>(arr:T[],index1:number,index2:number):T[]{
  const temp=arr[index1];
  arr[index1]=arr[index2];
  arr[index2]=temp;

  return arr;
}
â¤ T represents any type(string, number, object etc).
â¤ Now swap works with:

swap([1, 2, 3], 0, 2);            // number[]
swap(["a", "b", "c"], 0, 1);      // string[]
swap([{ id: 1 }, { id: 2 }], 0, 1); // object[]

ğŸ”„ Built-in Generics in TypeScript
| Type           | Example                     | Explanation                                            |
| -------------- | --------------------------- | ------------------------------------------------------ |
| `Array<T>`     | `const nums: Array<number>` | Same as `number[]`, `T` is `number` here               |
| `Promise<T>`   | `const p: Promise<string>`  | This promise must resolve to a string                  |
| `Record<K, V>` | `Record<string, number>`    | Object where keys are `string` and values are `number` |

ğŸ”„ Arrays Are Generic
const nums:Array<number>=[1,2,3];
Equivalent to:
const nums:number[]=[1,2,3];

â¤ Both are Array<T> where T=number.

ğŸ”„ Promises Are Generic
const p: Promise<number>=new Promise((resolve,reject)=>{
  setTimeout(()=> resolve(100),1000);
});

â¤ You declare the expected return type, so Typescript enforces that only a number can be resolved.

ğŸ”„ Generic Objects
function wrapInObj<T>(value:T):{data:T}{
  return {data:value};
}

const wrapped=wrapInObj("hello");

â—Important Notes
â¤ Generics do not exist in the final JavaScript output. They're erased during compilation.
â¤ You can also extend types in generics for more control:

function printLength<T extends {length:number}>(val:T):void{
  console.log(val.length);
}

Creating Generic Functions in TypeScript
#########################################

âœ…Example 1: swap Function
You built a function that swaps elements in an array regardless of the element types.

ğŸ”¸ Syntax:
function swap<T>(arr:T[],index1:number,index2:number):T[]{
  if(index1<0 || index1>=arr.length || index2<0 || index2>= arr.length){
    throw new Error("Invalid index");
  }
  [arr[index1],arr[index2]]=[arr[index2],arr[index1]];
  return arr;
}

ğŸ”¸ How It Works:
â¤ T is a generic placeholder.
â¤ If you pass an array of numbers, T=number.
â¤ If you pass an array of strings, T=string

ğŸ”¸ Examples:
swap([1, 2, 3], 0, 2);            // returns [3, 2, 1]
swap(["a", "b", "c"], 1, 2);      // returns ["a", "c", "b"]

âœ… Example 2: expand Function
You created a function to merge two objects using generics.

ğŸ”¸ Initial Version:
function expand(obj1: object, obj2: object): object {
  return Object.assign(obj1, obj2);
}

âŒ Problem:
â¤ The return type is object, so TypeScript doesnâ€™t know the merged objectâ€™s shape.
â¤ Accessing combined.name causes a type error: "Property 'name' does not exist".

âœ… Using Multiple Generics
To fix this, introduce generic T and U:

function expand <T,U>(obj1:T, obj2:U){
  return Object.assign(obj1,obj2);
}
Now:
â¤ If obj1 has {name: string, age: number}
â¤ And obj2 has {name:string, gender: string}
â¤ The merged result has type {name:string, age: number, gender: string}

ğŸ”¸ Usage:
const combined=expand(
  {name: 'John', age:28},
  {name:'John', gender:'male'}
);
console.log(combined.name) // âœ… Works!

â— Note on Type Constraints
â¤ The current expand function may still throw an error if obj1 or obj2 is not an object.
â¤ To fix this, Constraints like <T extends object> will be used.

ğŸ§  What Are Generic Constraints in TypeScript?
################################################
â¤ Generic constraints limit what types can be passed to a generic.
â¤ You use extends keyword to apply such constraints.
â¤ This is useful to enforce type saftey in generic utility functions.

ğŸ”§ Use Case: Merging Two Objects Safely
You want to merge two objects safely using a function.

function merge<T extends object, U extends object>(obj1:T,obj2:U){
  return {...obj1,...obj2};
}
Here:
â¤ T and U must be objects(âœ… not allowed: numbers, strings, arrays).
â¤ The constraints T extends object ensures that T must be an object.

ğŸ§ª Code Example with Explanation
const obj1={name:"John", age:25};
const obj2={gender:"Male", name:"Steve"};

const combined=merge(obj1,obj2);
// combined: { name: "Steve", age:25, gender:"Male"};

â¤ This function creates a new object using the spread operator.
â¤ Since both are objects and satisfy the constraint, it works fine.

âŒ What if You Violate the Constraint?
merge(100, { name:"John"}); //âŒ Error: 100 is not an object
merge({name:"John"}, "hello"); //âŒError: string is not an object

â¤ Without extends object, Typescript would allow this and might cause runtime issues.
â¤ Using constraints prevents passing types like number, string, or null.


ğŸ’¡ Why Use Constraints?
â¤ Enforces only valid inputs are passed.
â¤ Improves type inference and developer tooling like IntelliSense.
â¤ Helps you avoid runtime bugs early.

âœ… Bonus Tip
You can also constrain generics to:
â¤ Arrays: T extends any[]
â¤ Specify keys: T extends {id: number}
â¤ Custom interfaces: T extends MyInterface

ğŸ”‘ keyof Constraint in TypeScript
#####################################
To ensure the second parameter passed to a funciton must be a valid key of the object passed as the first parameter.

âœ… Problem Without Constraint
function getPropValue(obj:Object, key: string){
  return obj[key]; //âŒ Typescript will throw error
}
Typescript complains because it can't guarantee key exist on obj.

âœ… Solution Using keyof Constraint
function getPropValue<T extends object, K extends keyof T>(obj:T, key:K){
  return obj[key];
}
â¤ T -> the object type.
â¤ K extends keyof T -> The key must be one of the property names (keys) of T.

ğŸ“Œ Example Usage
const user={
  name:"Alice",
  age:30,
};

const name=getPropValue(user,"name"); //âœ… Works fine
const age=getPropValue(user, "age"); //âœ… Works fine
const gender =getPropValue(user,"gender"); //âŒ Error: "gender" is not a key of user

ğŸ“˜ What keyof T Does
â¤ Turns the object type into a union of its keys:

type User= {name:string, age:number};
type Keys= keyof User; // "name" | "age"
â¤ So now, K extends keyof T ensures key must be "name" or "age" in the above case.

ğŸ¯ Benefits
â¤ Prevents accessing non-existing properties.
â¤ Gives autocomple suggestions.
â¤ Catches errors at compile tiem.
â¤ Improves code type saftey and developer productivity.

âœ… Generic Classes in TypeScript
##################################
Generic classes allow you to write reusable class logic that can work with any data type.

ğŸ’¡ Why use generic classes?
To create flexible classes that work with different data types without duplicating code.

ğŸ§± Syntax Example:
class ShoppingCaryt<T>{
  private _items:T[]=[];

  addItem(item:T){
    this._items.push(item);
  }

  getItems():T[]{
    return this._items;
  }
}
â¤ T is a type placeholder
â¤ T[] means this class will work with an array of whatever type you specify when creating an instance.

ğŸ“¦ Usage Example with Custom Types:
type Book={
  name:string;
  pages:number;
  price:number;
}

type Cloth={
  name:string;
  size:string;
  price:number;
}
const bookCart = new ShoppingCart<Book>();
bookCart.addItem({ name: "Book A", pages: 250, price: 30 });
bookCart.addItem({ name: "Book B", pages: 300, price: 40 });

console.log(bookCart.getItems()); // Array of Book

const clothCart = new ShoppingCart<Cloth>();
clothCart.addItem({ name: "T-Shirt", size: "M", price: 25 });

console.log(clothCart.getItems()); // Array of Cloth

ğŸ”¡ Can Also Be Used with Primitive Types:
const stringCart = new ShoppingCart<string>();
stringCart.addItem("hello");
stringCart.addItem("world");

console.log(stringCart.getItems()); // ["hello", "world"]

ğŸ§  When to Use a Generic Class
Use generic classes when:
â¤ You want the same class logic to work across multiple types.
â¤ You want to keep the class strongly typed based on the provided type.
â¤ You want to avoid repeating similar class code for each type.

ğŸ” With Shorthand Constructor Example:
class Repository<T> {
  constructor(private _items: T[] = []) {}

  add(item: T) {
    this._items.push(item);
  }

  getAll(): T[] {
    return this._items;
  }
}

ğŸ” Generic Types vs Union Types in TypeScript
###############################################
âœ… Generic Types
Generics allow writing reusable code that works with any specific type, provided at the time of usage.

ğŸ§  Concept:
Define type once, use many times with different types, but with strict consistency per instance.

ğŸ“¦ Example: Generic Class
class ShoppingCart<T> {
  private _items: T[] = [];

  addItem(item: T): void {
    this._items.push(item);
  }

  getItems(): T[] {
    return this._items;
  }
}

ğŸ”¸ Usage
const stringCart = new ShoppingCart<string>();
stringCart.addItem("Book");
// stringCart.addItem(100); âŒ Error â€” number not allowed

const numberCart = new ShoppingCart<number>();
numberCart.addItem(100);
// numberCart.addItem("Book"); âŒ Error â€” string not allowed

âœ… Benefits of Generics:
â¤ Type-safe per instance
â¤ Reusable logic without type repetition
â¤ Compile-time error checking
â¤ Better for classes/methods where the type is consistent per use case but can differ across scenarios.

ğŸš« Union Types
Union types allow a variable to be one of several types, but they don't enforce consistency between related values.

ğŸ“¦ Example:
class ShoppingCart {
  private _items: (string | number)[] = [];

  addItem(item: string | number): void {
    this._items.push(item);
  }

  getItems(): (string | number)[] {
    return this._items;
  }
}

const cart = new ShoppingCart();
cart.addItem("Apple");
cart.addItem(42); // âœ… Both allowed, but mixed types inside array

â—Problem:
Union allows both types, so items may become a mix of string and numbers, even if only one was intended.

âš ï¸ Why Union Types Can Be Risky Here

If your items field is declared like:
items: string[] | number[]

â¤ Then Typescript expects only all strings or all numbers.
â¤ But if your method accepts string | number, htis lets you mix types during .push() operations, breaking the contract.

this._items = []; // Initially empty
this.addItem("Apple"); // Adds string
this.addItem(42);       // Now it's mixed: âŒ Not allowed for `string[] | number[]`

âœ… When to Use What
| Use Case                                                                                               | Use Type      |
| ------------------------------------------------------------------------------------------------------ | ------------- |
| A class/method that works with **one consistent type**, but needs to be reused for **different types** | âœ… Generics    |
| A value that can be **one of many types** at the same time (e.g., config input, error types)           | âœ… Union Types |

ğŸ’¡ Interview Insight:
Generics provide parametric polymorphism â€” type determined at usage.
Union types provide ad hoc polymorphism â€” type can vary at runtime.

ğŸ“ TypeScript Built-in Generics: Partial & Readonly
#####################################################
ğŸ”„ Partial<T>
âœ… Purpose: Make all properties of a type optional.
ğŸ“¦ Use Case: When updating or modifying only some fields of an object, not all.

ğŸ§± Example:
interface UserSettings{
  username:string;
  email:string;
  darkMode:string;
  language:string;
}

// Normally, you'd need to pass all fields
const user: UserSettings = {
  username: "John Smith",
  email: "johnsmith@gmail.com",
  darkMode: false,
  language: "en"
};

// Function to update only part of the settings
function updateUserSettings(settings: Partial<UserSettings>) {
  console.log("Updating:", settings);
}

updateUserSettings({
  darkMode: true,
  language: "fr"
});

ğŸ§  Why Useful:
â¤ Accepts parital data like form updates or settings patches.
â¤ Prevents need to provide the full object.
â¤ Does not mutate the original type- just temporarily makes fields optional.

ğŸ”„ Readonly<T>
âœ… Purpose: Makes all properties of a type immutable(cannot be changed after assignment).

ğŸ§± Example: With Arrays
const arr:Readonly<string[]>=["John", "Mark"];
arr.push("Mary"); //âŒ Error: Property 'push' does not exist

ğŸ§± Example: With Objects
interface UserSettings {
  username: string;
  email: string;
  darkMode: boolean;
  language: string;
}

const user: Readonly<UserSettings> = {
  username: "John",
  email: "john@gmail.com",
  darkMode: false,
  language: "en"
};

user.username = "Steve"; // âŒ Error: Cannot assign to 'username'

ğŸ§  Why Useful:
â¤ Prevents accidental mutation of data.
â¤ Helps with immutability in functional programming or state management.
â¤ Clear contracts: ensures certain objects are read-only after creation.

âœ¨ TypeScript Decorators (Introduction)
#########################################
A decorator in Typescript is a function that modifies or enhances the behavior of:
1. Classes
2. Methods
3. Properties
4. Parameters
Decorators are executed at runtime and prefixed with @.

ğŸ”§ How to Enable Decorators
Open tsconfig.json

Enable experimental support: "experimentalDecorators": true

ğŸ”¸ Class Decorator: Basic Example
âœ… Goal:
Log a message whenever the class is loaded.

ğŸ§± Code:
//Decorator function
function Logger(target:Function){
  console.log("Logging...");
  console.log(target); // ğŸ‘‰ Logs the class constructor
}

//Applying the decorator
@Logger
class User{
  name:string="John";
  age:number=28;

  constructor(){
    console.log("User class constructor called");
  }
}

//Creating an instance
const user1=new User();

ğŸ§  Output:
Logging...
[class User]
User class constructor called
â¤ Even if no instance is created, the decorator still runs when the class is parsed!

ğŸ”„ How It Works
â¤ @Logger runs before the class is instantiated.
â¤ The decorator receives the constructor function as its argument.
â¤ The decorator does not need to be called like Logger() unless you're passing arguments. 

ğŸ§ Decorator Factory
#####################
â¤ A function that returns a decorator function.
â¤ It allows you to pass parameters or configuarations to decorators.
â¤ It's useful when you want customized behavior per usuage.

ğŸ§  Why Not Just Use a Decorator Function?
If you write:

@logger
class User {}

â¤ You are not passing any parameters to logger. It's just a plain decorator.
â¤ But when if you want to pass a custom message like:

@loggerDecorator("This is a custom logger")
clas User{}
Then you need a decorator factory.

ğŸ—ï¸ Syntax of a Decorator Factory
function loggerDecorator(message:string){
  return function(constructor:Function){
    console.log(message); //custom behavior
  };
}

Usage:
@loggerDecorator("This is custom logger")
class User {
  constructor() {
    console.log("User constructor called");
  }
}

ğŸŸ¡ Output:
This is custom logger
User constructor called

Key Idea:
Outer function â†’ Accepts custom data.
Inner function â†’ Is the actual decorator, called by TypeScript.

âœ… Why Use Decorator Factory?
â¤ To pass dynamic values or configuration into the decorator.
â¤ To reuse the decorator logic with different parameters.

âœ… Important Notes:
You must call the outer factory function with () to get the actual decorator.

Example:
@loggerDecorator("Logging user...")
class User {}

âœ…DOM-based decorator factory
##################################
1. ğŸ“¦ HTML Setup
<!-- index.html -->
<div id="container"></div>

2. âš™ï¸ Decorator Factory Definition
function Template(template:string, elementId:string){
  return function(target:any){
    const u=new target(); //Create instance of the class

    const container=document.getElementById(elementId);
    if(container){
      container.innerHTML=template;

      const h2=container.querySelector("h2");
      if(h2){
        h2.textContent=`Hello Mr ${u.name}`;
      }
    }
  };
}

This function returnsthe actual decorators.
It inserts a given HTML template into a DOM element.
If the template includes an <h2>, it fills it with the user's name from the class instance.

3. ğŸ‘¤ Class with Decorator Applied
@Template("<h2>Dynamic Header</h2><button>Click</button>", "container")
class User {
  name = "John";

  constructor() {
    console.log("User constructor called");
  }
}

â¤ When User class is defined, the decorator runs.
â¤ It inserts a dynamic HTML header into the #container div
â¤ Then it updates the H2 text using User's name.

ğŸ§  Key Concepts Highlighted
| Concept               | Description                                                                 |
| --------------------- | --------------------------------------------------------------------------- |
| **Decorator Factory** | Allows passing arguments like template string and element ID                |
| **Target**            | Refers to the class constructor when decorating a class                     |
| **DOM Access**        | Uses `getElementById` and `querySelector` to access and manipulate elements |
| **Dynamic Behavior**  | Injects content and updates it using class instance properties              |

ğŸ” Angular Analogy
In Angular:

@Component({
  selector: 'app-root',
  template: `<h2>Hello {{name}}</h2>`
})
class AppComponent {
  name = 'John';
}
In your example:

@Template("<h2>Dynamic Header</h2>", "container")
class User {
  name = "John";
}
ğŸ‘‰ Decorator + Template + DOM Element â€” the same fundamental idea, just implemented manually.

ğŸ”§ Using Multiple Decorators in TypeScript
############################################
âœ… Syntax: Multiple Decorators on a Class
@Logger('Logging...')
@Template('<h1>User Component</h1>', 'app')
class User {
  constructor() {
    console.log('User class Constructor called');
  }
}

ğŸ“Œ Decorator Factory vs Decorator Function
| Type                   | What it does                     | When it runs           |
| ---------------------- | -------------------------------- | ---------------------- |
| Decorator Factory  | Returns the actual decorator     | Runs top to bottom |
| Decorator Function | Modifies class/function/property | Runs bottom to top |

ğŸ“‹ Execution Order
Given:

@Logger('Logger Decorator')  // 1st decorator (top)
@Template('<div>Hello</div>', 'app') // 2nd decorator (bottom)
class User {}

1ï¸âƒ£ Decorator Factory Execution (Top to Bottom):
Logger Decorator Factory runs first
Template Decorator Factory runs second

2ï¸âƒ£ Decorator Function Execution (Bottom to Top):
Template Decorator runs first
Logger Decorator runs second

ğŸ§ª Console Output Example
When decorators are written like:

@Logger()
@Template()
class User {}

The console will show:

Logger decorator factory
Template decorator factory
Template decorator called
Logger decorator called

ğŸ§© Why Is Decorator Execution Bottom to Top?
Typescript(and Javascript) follows the stack model for decorator evaluation:
â¤ Decorators are applied in the order of evaluation stack, so the last one(at the bottom) is pushed to the top of the call stack and executed first.

ğŸ·ï¸ Property Decorators in TypeScript
#####################################
â¤ A property decorator is a function applied to a class property to intercept, modify, or enhance its behavior.
â¤ It is invoked when the class is defined, not when instances are created.

ğŸ§ª Basic Syntax
function capitalize(target:any, propertyKey:string){
  console.log("Capitalize decorator called");
  console.log("Target: ", target);
  console.log("Property Key:", propertyKey);
}

class Product{
  @capitalize
  name:string;
  constructor(name:string){
    this.name=name;
  }
}

âš™ï¸ Parameters of Property Decorator
| Parameter     | Description                                                            |
| ------------- | ---------------------------------------------------------------------- |
| `target`      | Prototype object (for instance properties) or constructor (for static) |
| `propertyKey` | Name of the property being decorated                                   |

ğŸ§  Static vs Instance Property Target
| Property Type     | `target` Value               |
| ----------------- | ---------------------------- |
| Instance property | `Class.prototype` (object)   |
| Static property   | Constructor function (class) |

âœ¨ Practical Example: Capitalize a String Property
function capitalize(target:any, propertyKey:string):any{
  let value:string;

  const getter = () =>{
    return value.charAt(0).toUpperCase();
  };

  const setter=(newVal:string) =>{
    value=newVal.toLowerCase();
  }

  Object.defineProperty(target, propertyKey, {
    get: getter,
    set: setter,
    enumerable: true,
    configurable: true
  });
}

âœ… Usage
class Product{
  @capitalize
  name:string;

  constructor(name:string){
    this.name=name;
  }
}

const p1=new Product("apple");
console.log(p.name); // Output Apple

ğŸ§ª Behavior Breakdown
â¤ When p.name="apple" is called: Setter saves it as "apple" (all lowercase).

â¤When p.name is accessed: Getter capitalize the first letter: "Apple"

ğŸ§  Interview Insight
Q: What does a property decorator return?
A: It can optionally return a property descriptor (object with get, set, etc.) â€” mostly for advanced use like defining accessors.

Q: When is a property decorator executed?
A: At class definition time, not during instance creation.

ğŸ“Œ Decorator Return Type Rule
To avoid TS errors:

function myDecorator(...): any {
  // must return `void` or a descriptor-like object
}

ğŸ·ï¸ Access Decorators in TypeScript
####################################
We created an @accessLogger decorator that:
Logs a message when a getter or setter is accessed.
Internally wraps the original get or set method and adds custom logic(console log) before calling the original behaviour.

ğŸ§  Why does it work on both getter and setter?
Because you used the decorator on one accessor (get price) but getters and setters share the same proeprty name (price). Typescript passes both getter and setter functions in the descriptor,, allowing you to modify both from the same decorator.

ğŸ§© Now, What is target in This Context?
When using decorator in Typescript:
function accessLogger(target:any, name:string, descriptor:PropertyDescriptor){
  console.log(target); 
  console.log(name);  // property name like price
  console.log(descriptor); // contains get/set, configurable, enumerable
}

ğŸ” target meaning:
| Scenario                      | `target` refers to...                     |
| ----------------------------- | ----------------------------------------- |
| Used on instance property | The class prototype object            |
| Used on static property   | The class constructor function itself |

So when the accessor is Not static, target is the prototype of the class, meaning
console.log(target=== Product.prototype); //true

This is important if you ever need to reflect metadata or attach new properties on the class from inside the decorator.

ğŸ§ª Practical Use Case
If we want to track access to certain sensitive fields (like price, password, etc) for logging or auditing purpose in production. Using accessor decorators like this gives you centralized control.

âœ Final Decorator Structure (Simplified):
function accessLogger(target:any, name:string, descriptor:PropertyDescriptor){
  const originalGet=descriptor.get;
  const originalSet=descriptor.set;

  descriptor.get=function(){
    console.log(`Getting {name}`);
    return originalGet?.call(this);
  }

   descriptor.set = function (value: number) {
    console.log(`Setting ${name} to ${value}`);
    originalSet?.call(this, value);
  };

  return descriptor;
}

ğŸ·ï¸ Using It in a Class
class Product{
private _price:number;

constructor (_price:number){
  this._price=_price;
}

@accessLogger
get price(){
  return this._price;
}

set price(value:number){
  if(value<0) throw new Error("Price cannot be negative");
  this._price=value;
}
}

ğŸ§ª Usage
const p = new Product(100);

console.log(p.price); // Triggers decorated getter
p.price = 150;        // Triggers decorated setter

ğŸ§¾ Output Will Be:
Target (prototype): Product {}
Property Name: price
Descriptor: { get: Æ’, set: Æ’, enumerable: false, configurable: true }

ğŸ” Getting value of "price" 100
ğŸ“ Setting value of "price" to 150

âœ… Using Decorators on Methods and Method Parameters in TypeScript
####################################################################
ğŸ”„ Example Class
class Person{
  constructor(private _name:string){}

  @Logger
  calculateAge(@ParamDecorator dob:string){}
}

ğŸ§  Concept Summary

1. Method Parameter Decorator
A decorator placed directly before a method parameter.

function ParamDecorator(target:any, methodName:string, parameterIndex:number){
  console.log("Param Decorator called");
  console.log("Target: ",target);   // Prototype object
  console.log("Method name: ", methodName); // "calculateAge"
  console.log("Parameter Index: ", parameterIndex); // e.g., 0
}

target: Prototype object (for instance method)
methodName: Name of the method the parameter belongs to 
parameterIndex: Position of the parameter in the method signature(0-based);

2. Method Decorator
A decorator applied on a method itself.

function Logger(target:any, methodName:string, descriptor:PropertyDescriptor){
  console.log("Logger Decorator called");
  console.log("Target: ",target);   // Prototype object or class constructor
  console.log("Method name: ", methodName); // "calculateAge"
  console.log("Parameter Index: ", parameterIndex); // PropertyDescriptor object
}

â¤ target: Prototype object (for instance methods)
Constructor function for static methods
â¤ methodName: Name of the decorator method
â¤ descriptor: A PropertyDescriptor that includes:
1. value: Method definition
2. writable, enumerable, configurable

ğŸ”„ Behavior Based on Method Type
| Method Type     | `target` Value                  |
| --------------- | ------------------------------- |
| Instance method | `Person.prototype`              |
| Static method   | `Person` (constructor function) |

ğŸ“¦ What Can You Do With This?
â¤ Log method calls
â¤ Validate parameter inputs
â¤ Modify method behavior (by editing descriptor.value)
â¤ Track usage of certain 

ğŸ’¡ Code Example:
// Parameter Decorator
function LogParameter(target: any, methodName: string, parameterIndex: number) {
  console.log(`ğŸ“Œ Parameter decorator called on:`);
  console.log(`â¡ Method: ${methodName}, Parameter Index: ${parameterIndex}`);
}

// Method Decorator
function LogMethod(target: any, methodName: string, descriptor: PropertyDescriptor) {
  const originalMethod = descriptor.value;

  descriptor.value = function (...args: any[]) {
    console.log(`ğŸš€ Method "${methodName}" called with arguments:`, args);
    return originalMethod.apply(this, args);
  };

  return descriptor;
}

// Class
class Calculator {
  @LogMethod
  multiply(@LogParameter a: number, @LogParameter b: number): number {
    return a * b;
  }
}

// Instantiate and Call
const calc = new Calculator();
const result = calc.multiply(4, 5);
console.log("âœ… Result:", result);

ğŸ§  Output (when run):
ğŸ“Œ Parameter decorator called on:
â¡ Method: multiply, Parameter Index: 1
ğŸ“Œ Parameter decorator called on:
â¡ Method: multiply, Parameter Index: 0
ğŸš€ Method "multiply" called with arguments: [4, 5]
âœ… Result: 20
