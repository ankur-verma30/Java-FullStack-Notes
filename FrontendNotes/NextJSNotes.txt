======================
ğŸ”· What is Next.js?
======================
Next.js is a full-stack React framework that extends React with production-ready features like server rendering, routing, data fetching, backend APIs, caching, and performance optimizations â€” out of the box.
ğŸ‘‰ But thatâ€™s the marketing line.


ğŸ”„ React vs Next.js
1ï¸âƒ£ React
â¤ React is only a UI library
â¤ It answers one question: â€œHow do I build reusable UI components?â€

React does NOT give you:
â¤ Routing
â¤ Server-side rendering
â¤ SEO optimization
â¤ Backend APIs
â¤ Data fetching conventions
â¤ Caching strategy
â¤ Deployment model
ğŸ‘‰ You have to assemble everything yourself.


2ï¸âƒ£ Next.js
â¤ Next.js is an opinionated framework built on top of React
â¤ Next.js is an opinionated framework because it enforces a specific project structure and best practices (App Router, file-based routing, server components).
â¤ It decides the â€œright wayâ€ to handle routing, rendering, data fetching, and performance â€” so you write less boilerplate and ship faster.

â¤ It answers application-level questions:
    âœ”ï¸ How is routing done?
    âœ”ï¸ Where does data come from?
    âœ”ï¸ What runs on server vs client?
    âœ”ï¸ How do we optimize performance?
    âœ”ï¸ How do we deploy?

ğŸ‘‰ Think of it like:
React = bricks
Next.js = complete building plan + plumbing + electricity


ğŸ”„ What Next.js adds on top of React
At a high level, Next.js adds:
1ï¸âƒ£ Rendering strategies
â¤ Server-Side Rendering (SSR)
â¤ Static Site Generation (SSG)
â¤ Incremental Static Regeneration (ISR)
â¤ Streaming


ğŸ” Server-Side Rendering (SSR)
â¤ Page is rendered on the server for every request.
â¤ Always returns fresh data (latest DB/API response).
â¤ Pros: Great for SEO, real-time content, personalized pages.
â¤ Cons: Slower than static pages + higher server load.
â¤ Next.js: getServerSideProps() (Pages Router) / fetch(..., { cache: "no-store" }) (App Router)

ğŸ”„ Real Life Analogy
SSR (Server-Side Rendering) â€” Restaurant â€œCook After Orderâ€
â¤ ğŸ½ï¸ You order food â†’ the chef cooks it fresh every time â†’ then serves you.
â¤ Fresh + personalized
â¤ But you wait each time because itâ€™s made on demand


ğŸ” Static Site Generation (SSG)
â¤ Page is pre-rendered at build time â†’ served as ready HTML + JS.
â¤ Content is same for all users until next deployment.
â¤ Pros: Fastest, cheap hosting (CDN), best performance + SEO.
â¤ Cons: Not good for frequently changing data.
â¤ Next.js: getStaticProps() (Pages Router) / default cached fetch (App Router)

ğŸ”„ Real Life Analogy
SSG (Static Site Generation) â€” Packed Lunch / Ready Meal
ğŸ¥ª Food is prepared earlier in the morning and packed â†’ you just pick and eat instantly.
â¤ Super fast
â¤ But if menu changes, you need to prepare again (rebuild/redeploy)


ğŸ” Incremental Static Regeneration (ISR)
â¤ Page is static like SSG, but can update automatically after a time interval.
â¤ First user gets cached page, Next.js regenerates page in background.
â¤ Pros: Best balance of speed + freshness.
â¤ Cons: Data may be slightly stale until regeneration happens.
â¤ Next.js: revalidate: 60 or fetch(..., { next: { revalidate: 60 } })

ğŸ”„ Real Life Analogy
ISR (Incremental Static Regeneration) â€” Ready Meal + Refilled Every Hour
ğŸ¥¡ Food is ready and kept on the counter â†’ you get it instantly
â³ but every 1 hour the kitchen replaces it with a fresh batch.
â¤ Fast like SSG
â¤ Updates automatically like SSR (but not instantly)


ğŸ” Streaming
â¤ Instead of waiting for the full page, server streams UI in parts (chunks).
â¤ User sees content earlier (like header first, then sections load).
â¤ Pros: Faster perceived loading, better UX for heavy pages.
â¤ Cons: More complex debugging and component boundaries.
â¤ Next.js: Works with React Server Components + Suspense (<Suspense fallback="...">)


ğŸ”„ Real Life Analogy: Streaming â€” Serving Food in Parts
â¤ ğŸ› Instead of waiting for the full meal, waiter brings:
â¤ starters first ğŸ¥—
â¤ then main course ğŸ²
â¤ then dessert ğŸ°
â¤ You start consuming immediately
â¤ Full experience completes step-by-step


2ï¸âƒ£ Server-first architecture
â¤ React Server Components
â¤ Code runs on the server by default

3ï¸âƒ£ Routing
â¤ File-based routing
â¤ Nested layouts
â¤ Parallel & intercepting routes

4ï¸âƒ£ Backend capabilities
â¤ API routes
â¤ Server Actions
â¤ Middleware
â¤ Edge functions

5ï¸âƒ£ Performance optimizations
â¤ Automatic code splitting
â¤ Image optimization
â¤ Font optimization
â¤ Caching & revalidation
ğŸ‘‰ All without wiring multiple libraries together.


ğŸ”„ What Next.js is NOT
âŒ Not a replacement for React
âŒ Not just a frontend framework
âŒ Not only SSR
âŒ Not only for websites
ğŸ‘‰ Next.js is a full-stack web framework.


ğŸ”„ Why Next.js Exists
Problem 1ï¸âƒ£: Traditional React apps (CSR)
Typical React setup
Browser â†’ index.html â†’ JS bundle â†’ API calls â†’ render UI

Problems:
âŒ Blank screen until JS loads
âŒ Poor SEO (content rendered after JS)
âŒ Slow first paint
âŒ Heavy JS bundle
âŒ Manual optimization

âœ… Example:
â¤ Google bot loads your page
â¤ Sees almost empty HTML
â¤ SEO suffers


Problem 2ï¸âƒ£: SEO & Performance
Search engines and users care about:
â¤ First Contentful Paint (FCP)
â¤ Time to Interactive (TTI)
â¤ Crawlable HTML
ğŸ‘‰ React CSR fails here.


Problem 3ï¸âƒ£: Too much tooling glue
In real projects, you need:
    âœ”ï¸ React
    âœ”ï¸ React Router
    âœ”ï¸ Webpack/Vite
    âœ”ï¸ Babel
    âœ”ï¸ Express
    âœ”ï¸ API layer
    âœ”ï¸ Auth
    âœ”ï¸ SSR setup
    âœ”ï¸ Caching
    âœ”ï¸ Deployment config
This leads to:
âŒ Boilerplate explosion
âŒ Inconsistent architecture
âŒ Hard onboarding
âŒ Debugging hell


Problem 4ï¸âƒ£: Server + Client separation was manual
Before Next.js:
â¤ You manually decided what runs on server
â¤ You manually hydrated UI
â¤ You manually cached data
â¤ You manually served static files
â¤ You manually handled errors
â¤ You manually handled redirects


ğŸ”„ What Next.js Solves
1ï¸âƒ£ Server-Side Rendering (SSR)
â¤ Next.js can render pages on the server: Request â†’ Server â†’ HTML â†’ Browser
â¤ Benefits:
    âœ”ï¸ Faster first load
    âœ”ï¸ SEO-friendly HTML
    âœ”ï¸ Better perceived performance


2ï¸âƒ£ Static Site Generation (SSG)
Generate pages at build time: Build â†’ Pre-generated HTML â†’ CDN
Benefits:
âœ”ï¸ Extremely fast
âœ”ï¸ Cheap to serve
âœ”ï¸ Perfect for marketing pages, blogs


3ï¸âƒ£ Hybrid Rendering
Same app can have:
â¤ Home page â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ SSG
â¤ Dashboard â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ SSR
â¤ Profile page â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Dynamic
â¤ Admin panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Client-heavy
This hybrid model is Next.jsâ€™s superpower.


4ï¸âƒ£ File-based Routing
â¤ Instead of: <Route path="/users/:id" />
â¤ You do: app/users/[id]/page.tsx

âœ… Benefits:
â¤ Less boilerplate
â¤ Predictable structure
â¤ Scales well for large apps


5ï¸âƒ£ Backend inside frontend project
Next.js lets you write backend logic inside the same repo:
â¤ API routes
â¤ Server Actions
â¤ Middleware

This enables:
â¤ Faster development
â¤ Better DX(Develper Experience)
â¤ End-to-end type safety


âœ… Performance by default
Next.js automatically:
â¤ Splits JS per route
â¤ Optimizes images
â¤ Optimizes fonts
â¤ Prefetches routes
â¤ Caches data
ğŸ‘‰ You donâ€™t have to remember to do these.


============
ğŸ”· Layouts
============
A layout is a special React component (layout.tsx) that wraps pages and nested routes, providing shared UI that persists across navigation.

In short:
âœ… Layout = common structure
âœ… Page = unique content

ğŸ”„ Why Layouts Exist?
Before layouts, in React you typically do:
â¤ One big App.jsx wrapper
â¤ Or manual route wrappers with React Router
â¤ Or duplicate Navbar/Sidebar across pages

Problems:
â¤ Re-rendering / remounting Navbar every navigation
â¤ Hard to build nested dashboards cleanly
â¤ No standardized routing structure

Layouts solve:
â¤ Shared UI once
â¤ Clean nested route composition
â¤ Persistent UI without manual work


ğŸ”„ Where Layouts Live?
Layouts exist inside the App Router directory:
app/
  layout.tsx
  page.tsx

â¤ app/layout.tsx is the Root Layout
â¤ Every route segment can have its own layout.tsx


ğŸ”„ Root Layout
âœ… Rule: In App Router, Root Layout is required.

âœ… Example File:
app/layout.tsx

âœ… Example Root Layout
// app/layout.tsx
import "./globals.css";

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body>
        <header style={{ padding: 12, borderBottom: "1px solid #ddd" }}>
          <h2>My App</h2>
        </header>

        <main style={{ padding: 12 }}>{children}</main>

        <footer style={{ padding: 12, borderTop: "1px solid #ddd" }}>
          Footer
        </footer>
      </body>
    </html>
  );
}
Key points:
â¤ Must return <html> and <body>
â¤ children represents the current route content
â¤ Root layout wraps everything


ğŸ”„ Nested Layouts (Most Powerful Feature)
Next.js builds UI like a tree.

âœ… Folder example:
app/
  layout.tsx
  page.tsx

  dashboard/
    layout.tsx
    page.tsx

    settings/
      page.tsx

How wrapping works:
â¤ / uses only app/layout.tsx
â¤ /dashboard uses:
    âœ”ï¸ app/layout.tsx
    âœ”ï¸ app/dashboard/layout.tsx
    âœ”ï¸ app/dashboard/page.tsx

/dashboard/settings uses:
    âœ”ï¸ app/layout.tsx
    âœ”ï¸ app/dashboard/layout.tsx
    âœ”ï¸ app/dashboard/settings/page.tsx


âœ… Example: Dashboard Layout
// app/dashboard/layout.tsx
import Link from "next/link";

export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <section style={{ display: "flex", minHeight: "80vh" }}>
      <aside style={{ width: 220, borderRight: "1px solid #ddd", padding: 12 }}>
        <h3>Dashboard</h3>
        <nav style={{ display: "flex", flexDirection: "column", gap: 8 }}>
          <Link href="/dashboard">Home</Link>
          <Link href="/dashboard/settings">Settings</Link>
        </nav>
      </aside>

      <div style={{ flex: 1, padding: 12 }}>{children}</div>
    </section>
  );
}

Dashboard page:
// app/dashboard/page.tsx
export default function DashboardPage() {
  return <h1>Dashboard Home</h1>;
}

Settings page:
// app/dashboard/settings/page.tsx
export default function SettingsPage() {
  return <h1>Settings</h1>;
}


ğŸ”„ The BIG Layout Feature: Persistence
When you navigate: /dashboard â†’ /dashboard/settings
    âœ”ï¸ dashboard/layout.tsx stays mounted
    âœ”ï¸ Sidebar stays as-is
    âœ”ï¸ Only the children changes

Benefits:
    âœ”ï¸ Better performance
    âœ”ï¸ Less re-render/remount
    âœ”ï¸ Better UX (sidebar scroll position preserved)


ğŸ”„ Layout vs Page
| Feature                    | layout.tsx                  | page.tsx              |
| -------------------------- | --------------------------- | --------------------- |
| Purpose                    | Shared UI wrapper           | Route content         |
| Persists across navigation | âœ… Yes                       | âŒ No                  |
| Can be nested              | âœ… Yes                       | âŒ No                  |
| Mandatory?                 | Root layout yes             | Not mandatory         |
| Used for                   | Navbar, sidebar, auth shell | Actual screen content |


ğŸ”„ Layouts are Server Components by Default
In Next.js App Router:
âœ… layout.tsx is a Server Component unless you add "use client"

Meaning:
â¤ Runs on the server
â¤ Can fetch data directly
â¤ No access to browser APIs (window, localStorage)
â¤ No React hooks like useState, useEffect


ğŸ”„ When Layout Should Be Client Component
Only when you need client-only features like:
â¤ useState, useEffect
â¤ Theme toggle using localStorage
â¤ Sidebar collapse state
â¤ Listening to route changes
â¤ DOM APIs

âœ… Example Client Layout (NOT recommended unless needed)
// app/dashboard/layout.tsx
"use client";

import { useState } from "react";

export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const [collapsed, setCollapsed] = useState(false);

  return (
    <section style={{ display: "flex" }}>
      <aside style={{ width: collapsed ? 80 : 220 }}>
        <button onClick={() => setCollapsed((v) => !v)}>
          Toggle Sidebar
        </button>
      </aside>

      <main style={{ padding: 12 }}>{children}</main>
    </section>
  );
}
âŒ Donâ€™t make layouts client unless required
âœ… Prefer a small client component inside a server layout

âœ… Example pattern:
    âœ”ï¸ Layout stays server
    âœ”ï¸ Sidebar component becomes client


ğŸ”„ Layout + Loading + Error = Route Segment UI System
Layouts work together with these files:
â¤ loading.tsx â†’ shows fallback while segment loads
â¤ error.tsx â†’ handles runtime errors in that segment
â¤ not-found.tsx â†’ handles 404 for that segment

âœ… Example:
app/dashboard/
  layout.tsx
  loading.tsx
  error.tsx
  page.tsx
ğŸ‘‰ This gives you route-level UX boundaries, which is more scalable than global spinners.


ğŸ”„ Layouts + Metadata
Layouts can define metadata that applies to all nested pages.

âœ… Example:
// app/dashboard/layout.tsx
import type { Metadata } from "next";

export const metadata: Metadata = {
  title: "Dashboard",
};

export default function DashboardLayout({ children }: { children: React.ReactNode }) {
  return <div>{children}</div>;
}
ğŸ‘‰ Then nested pages can override/extend it.


ğŸ”„ Common Mistakes
âŒ Mistake 1ï¸âƒ£: Using hooks in Server Layout
// âŒ This will fail if layout is server
useState(...)

Fix: either
    âœ”ï¸ move logic into client component, OR
    âœ”ï¸ mark layout "use client"


âŒ Mistake 2ï¸âƒ£: Putting per-page logic inside layout
Layouts should not become â€œgod componentsâ€.
Bad:
    âœ”ï¸ Layout fetching page-specific data
    âœ”ï¸ Layout handling page-specific state


âŒ Mistake 3ï¸âƒ£: Duplicating layout UI inside pages
If navbar is common, it belongs in layout.


âŒ Mistake 4ï¸âƒ£: Overusing client layout
Making root layout client increases JS and hydration cost.


=============
ğŸ”· Templates
=============
A template is a special wrapper component (template.tsx) that wraps a route segment like a layout, BUT it re-mounts on every navigation inside that segment.

ğŸ‘‰ File name: template.tsx

ğŸ‘‰ So:
    âœ”ï¸ layout.tsx â†’ persists
    âœ”ï¸ template.tsx â†’ recreates (fresh instance) every navigation


ğŸ”„ Why Templates Exist?
â¤ Sometimes you donâ€™t want persistence.
â¤ Because persistence can cause:
    âœ”ï¸ State staying when you donâ€™t want it
    âœ”ï¸ Animations not re-triggering
    âœ”ï¸ Old UI transitions not resetting
    âœ”ï¸ Form values staying unexpectedly
    âœ”ï¸ Scroll/DOM states persisting in ways that feel wrong


Templates exist to force:
âœ… Fresh mount
âœ… Fresh state
âœ… Fresh effects
âœ… Fresh UI lifecycle

ğŸ”„ Layout vs Template
ğŸ”— Core Behavior
1ï¸âƒ£ layout.tsx
â¤ Mounted once
â¤ Stays alive across sibling navigation
â¤ Preserves state

2ï¸âƒ£ template.tsx
â¤ Mounted again on each navigation
â¤ Does NOT preserve state
â¤ Great for â€œreset UI per route changeâ€


ğŸ”„ Quick Comparison Table
| Feature                    | layout.tsx     | template.tsx           |
| -------------------------- | -------------- | ---------------------- |
| Persists across navigation | âœ… Yes        | âŒ No                  |
| Re-mounts on route change  | âŒ No         | âœ… Yes                 |
| Preserves state            | âœ… Yes        | âŒ No                  |
| Good for                   | Navbar/sidebar | Animations/reset forms |
| Default usage              | Very common    | Rare but important     |


ğŸ”„ Where Templates Fit in Routing Tree
âœ… Example structure:

app/
  dashboard/
    layout.tsx
    template.tsx
    page.tsx
    settings/
      page.tsx

ğŸ‘‰ For navigation: /dashboard â†’ /dashboard/settings
â¤ dashboard/layout.tsx persists
â¤ dashboard/template.tsx re-mounts
â¤ Page changes as usual

So the wrapper chain becomes:
RootLayout
  DashboardLayout (persistent)
    DashboardTemplate (re-mounted)
      Page (changes)


âœ… Template Example
app/dashboard/template.tsx
// app/dashboard/template.tsx
"use client";

import { useEffect } from "react";

export default function DashboardTemplate({
  children,
}: {
  children: React.ReactNode;
}) {
  useEffect(() => {
    console.log("Template mounted (fresh on navigation)");
    return () => console.log("Template unmounted");
  }, []);

  return (
    <div style={{ border: "2px dashed #999", padding: 12 }}>
      <p style={{ fontWeight: 600 }}>Dashboard Template Wrapper</p>
      {children}
    </div>
  );
}
ğŸ‘‰ Now when you move between dashboard routes:
â¤ Youâ€™ll see mount/unmount logs every time
â¤ That confirms the â€œfresh instanceâ€ behavior


ğŸ”„ Real Use Cases of Templates
Templates are not used daily, but when needed, they solve very specific problems.


âœ… Use Case 1ï¸âƒ£: Resetting Client State on Navigation
âœ… Example: You have a wizard-like UI:
    âœ”ï¸ /checkout/address
    âœ”ï¸ /checkout/payment
    âœ”ï¸ /checkout/review
â¤ You want each step to have a fresh state.
â¤ If you used layout, state might persist unexpectedly.
â¤ Template forces reset.


âœ… Use Case 2ï¸âƒ£: Re-triggering Animations on Route Change
Sometimes you want:
    âœ”ï¸ fade-in animation
    âœ”ï¸ slide transition
    âœ”ï¸ page-enter animation
â¤ Layouts persist â†’ animation might not replay.
â¤ Template remounts â†’ animation runs again.


âœ… Use Case 3ï¸âƒ£: Resetting Forms Automatically
Imagine:
    âœ”ï¸ /admin/users/new
    âœ”ï¸ /admin/users/edit/123
If you navigate from one to another, and you want the form to reset fully,
template is a clean solution.


âœ… Use Case 4ï¸âƒ£: Clearing UI caches / local component memory
âœ… Example:
    âœ”ï¸ search UI that stores query state
    âœ”ï¸ filters
    âœ”ï¸ UI derived state
ğŸ‘‰ Template ensures fresh start.


ğŸ”„ Templates and Server/Client Components
By default:
â¤ Templates are Server Components
â¤ But many template use-cases require "use client"


â“ Why?
Because templates are often used for:
â¤ state reset
â¤ animation hooks
â¤ effects
â¤ client UI
ğŸ‘‰ So youâ€™ll commonly see: "use client";


ğŸ”„ Layout + Template Together
In production, the clean pattern is:
    âœ”ï¸ Layout = stable shell (sidebar, navbar)
    âœ”ï¸ Template = resets per navigation (transitions, state)

âœ… Example:
app/dashboard/
  layout.tsx     // sidebar persists
  template.tsx   // page transitions reset
  page.tsx
  analytics/page.tsx
  settings/page.tsx


ğŸ”„ Common Mistakes (Traps)
âŒ Mistake 1ï¸âƒ£: Using Template when you want persistence
â¤ If you want sidebar state to persist (collapsed/expanded),
template will break that because it remounts.
â¤ Use layout for persistence.


âŒ Mistake 2ï¸âƒ£: Making template heavy
â¤ Template remounts frequently â†’ heavy logic causes performance hit.
â¤ Keep it lightweight.


âŒ Mistake 3ï¸âƒ£: Confusing â€œre-renderâ€ vs â€œremountâ€
â¤ Re-render = same component instance updates UI
â¤ Remount = component destroyed + created again (state reset)
â¤ Templates cause remount.


=============
ğŸ”· Page.tsx
=============
page.tsx is a special file that defines the UI for a route (a URL path) in the App Router.
âœ… Example: app/page.tsx

This represents: âœ… Route: /


ğŸ”„ Why page.tsx exists?
â¤ React alone cannot map files â†’ URLs.
â¤ Next.js solves routing using filesystem conventions:

â¤ Folder = route segment
â¤ page.tsx = actual route endpoint UI

So Next.js knows:
  âœ”ï¸ Which URL exists
  âœ”ï¸ What component should render for that URL
ğŸ‘‰ No manual router setup needed.


ğŸ”„ Basic Routing with page.tsx
File structure:
app/
  page.tsx
  about/
    page.tsx
  contact/
    page.tsx

Routes created:
  âœ”ï¸ app/page.tsx â†’ /
  âœ”ï¸ app/about/page.tsx â†’ /about
  âœ”ï¸ app/contact/page.tsx â†’ /contact


âœ… Minimal page.tsx Example
// app/page.tsx
export default function HomePage() {
  return <h1>Home Page</h1>;
}
âœ… Must export a default component
âœ… That component is the route UI


ğŸ”„ page.tsx is a Server Component by default
â¤ This is a huge Next.js shift.
â¤ Meaning: By default, your page.tsx runs on the server.

So you can do:
âœ… Fetch data directly
âœ… Access server secrets safely
âœ… Avoid sending unnecessary JS to browser

âœ… Example: Server-side data fetching inside page.tsx
// app/users/page.tsx
type User = {
  id: number;
  name: string;
};

export default async function UsersPage() {
  const res = await fetch("https://jsonplaceholder.typicode.com/users");
  const users: User[] = await res.json();

  return (
    <div>
      <h1>Users</h1>
      <ul>
        {users.map((u) => (
          <li key={u.id}>{u.name}</li>
        ))}
      </ul>
    </div>
  );
}
Key points:
  âœ”ï¸ page.tsx can be async
  âœ”ï¸ fetch() runs on server by default
  âœ”ï¸ HTML can be returned with real data


ğŸ”„ When page.tsx should be a Client Component?
Only if your page needs:
â¤ useState, useEffect
â¤ DOM APIs (window, localStorage)
â¤ client-only libraries (charts, animations, etc.)

âœ… Example: Client Page
// app/counter/page.tsx
"use client";

import { useState } from "react";

export default function CounterPage() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <h1>Counter</h1>
      <button onClick={() => setCount((c) => c + 1)}>+</button>
      <p>{count}</p>
    </div>
  );
}
ğŸ‘‰ best practice:
Avoid making full pages client unless necessary.
Prefer server page + small client components.


ğŸ”„ Production Pattern
â¤ page.tsx stays Server Component
â¤ Client interactivity goes into child components

âœ… Example:
app/products/page.tsx
components/AddToCartButton.tsx

page.tsx (Server)
// app/products/page.tsx
import AddToCartButton from "@/components/AddToCartButton";

export default async function ProductsPage() {
  const products = [
    { id: "p1", name: "Laptop" },
    { id: "p2", name: "Mouse" },
  ];

  return (
    <div>
      <h1>Products</h1>
      {products.map((p) => (
        <div key={p.id} style={{ marginBottom: 12 }}>
          <p>{p.name}</p>
          <AddToCartButton productId={p.id} />
        </div>
      ))}
    </div>
  );
}

Client Component
// components/AddToCartButton.tsx
"use client";

export default function AddToCartButton({ productId }: { productId: string }) {
  return (
    <button
      onClick={() => alert(`Added ${productId} to cart`)}
      style={{ padding: 8 }}
    >
      Add to Cart
    </button>
  );
}
ğŸ‘‰ This gives you:
  âœ”ï¸ SSR performance + SEO
  âœ”ï¸ Minimal JS shipped
  âœ”ï¸ Interactivity where needed


ğŸ”„ Dynamic Routes + page.tsx
File structure: app/users/[id]/page.tsx
This creates route: âœ… /users/:id

âœ… Example:
// app/users/[id]/page.tsx
export default function UserProfilePage({
  params,
}: {
  params: { id: string };
}) {
  return <h1>User Profile: {params.id}</h1>;
}
ğŸ‘‰ params is provided by Next.js.


ğŸ”„ Search Params in page.tsx
âœ… URL example: /products?category=laptops&sort=price

You can read them using searchParams:
// app/products/page.tsx
export default function ProductsPage({
  searchParams,
}: {
  searchParams: { category?: string; sort?: string };
}) {
  return (
    <div>
      <h1>Products</h1>
      <p>Category: {searchParams.category}</p>
      <p>Sort: {searchParams.sort}</p>
    </div>
  );
}


ğŸ”„ page.tsx vs layout.tsx
1ï¸âƒ£ page.tsx
â¤ Defines the actual route UI
â¤ Changes per navigation

2ï¸âƒ£ layout.tsx
â¤ Wraps pages
â¤ Persists across navigation
âœ… Example chain: layout.tsx â†’ page.tsx


ğŸ”„ Important Rules / Constraints
Rule 1ï¸âƒ£: page.tsx must export default
export default function Page() {}

Rule 2ï¸âƒ£: A folder becomes a route only if it has page.tsx
Just having: app/about/
does nothing unless it contains page.tsx.

Rule 3ï¸âƒ£: page.tsx is the â€œroute endpointâ€
Layouts can exist without pages, but route isnâ€™t accessible without a page.


ğŸ”„ Common Mistakes
âŒ Mistake 1ï¸âƒ£: Using useState in server page
Will error unless "use client" is added.


âŒ Mistake 2ï¸âƒ£: Making everything client
Bad for:
  âœ”ï¸ performance
  âœ”ï¸ SEO
  âœ”ï¸ bundle size


âŒ Mistake 3ï¸âƒ£: Doing heavy client fetch inside page
Better:
  âœ”ï¸ fetch on server in page.tsx
  âœ”ï¸ pass data to UI


âŒ Mistake 4ï¸âƒ£: Not using params correctly
Dynamic routes always pass params like:
params: { id: string }
