JUnit is a popular unit testing framework for Java used to write and run automated tests.
It helps developers verify that small pieces of code (methods, classes) work correctly before integrating them into the full system.

âš¡ Think of it as a tool that lets you:
â¤ Test your code automatically
â¤ Detect bugs early
â¤ Ensure that future code changes donâ€™t break existing features (regression testing)
â¤ Improve code quality and reliability

JUnit is part of the xUnit family of testing frameworks and is widely used in Java development, Spring Boot, Microservices, and CI/CD pipelines.

ğŸ”¥ Why JUnit is Important
â¤ Ensures code correctness
â¤ Makes code maintainable
â¤ Helps in TDD (Test-Driven Development)
â¤ Supports automation (Maven/Gradle, Jenkins, GitHub Actions)
â¤ Very helpful in Spring Boot application testing

ğŸ”„ JUnit Lifecycle Annotations
| Annotation    | Meaning                             |
| ------------- | ----------------------------------- |
| `@BeforeAll`  | Runs once before all tests (static) |
| `@BeforeEach` | Runs before each test               |
| `@Test`       | The actual test                     |
| `@AfterEach`  | Runs after each test                |
| `@AfterAll`   | Runs once after all tests           |


ğŸ”„ Where JUnit is Used in Real Development
â¤ Spring Boot REST API testing
â¤ DAO/Repository layer testing
â¤ Service layer testing + Mockito
â¤ Testing microservices workflows
â¤ CI/CD to block broken builds
â¤ TDD-based development


ğŸ§ª Basic Concepts in JUnit
1ï¸âƒ£ Test Case: A method that tests a specific functionality.
2ï¸âƒ£ Test Suite: A group of test cases.

3ï¸âƒ£ Assertions: Used to check expected results
1ï¸âƒ£ assertEquals(expected, actual)
âœ”ï¸ Checks that two values are equal.
âœ”ï¸ Use-case: Testing return values of functions.

assertEquals(10, calc.add(7, 3));

2ï¸âƒ£ assertNotEquals(unexpected, actual)
âœ”ï¸ Fails if both values are equal.
âœ”ï¸ Use-case: Ensure method does NOT return something.

assertNotEquals(0, divide(10, 2));

3ï¸âƒ£ assertTrue(condition)
âœ”ï¸ Passes if the condition is true.
âœ”ï¸ Use-case: Validating boolean expressions.

assertTrue(age > 18);

4ï¸âƒ£ assertFalse(condition)
âœ”ï¸ Passes if the condition is false.
âœ”ï¸ Use-case: Ensuring invalid states or flags.

assertFalse(list.isEmpty());

5ï¸âƒ£ assertNull(actual)
âœ”ï¸ Passes if the value is null.
âœ”ï¸ Use-case: When a repository returns nothing.

assertNull(userRepository.find(99));

6ï¸âƒ£ assertNotNull(actual)
âœ”ï¸ Passes if the value is NOT null.
âœ”ï¸ Use-case: Dependency or service must not be null.

assertNotNull(service.getUser(1));

7ï¸âƒ£ assertSame(expected, actual)
âœ”ï¸ Checks if two references point to the same object (==).
âœ”ï¸ Use-case: Singleton pattern, object identity tests.

assertSame(singletonObj, Singleton.getInstance());

8ï¸âƒ£ assertNotSame(unexpected, actual)
âœ”ï¸ Checks if two references are not the same object.
âœ”ï¸ Use-case: Ensure new objects are created each time.

assertNotSame(user1, user2);

9ï¸âƒ£assertArrayEquals(expected[], actual[])
âœ”ï¸ Checks if two arrays contain same elements in same order.
âœ”ï¸ Use-case: Sorting, conversions, splitting.

assertArrayEquals(new int[]{1,2,3}, sortArray(input));

1ï¸âƒ£0ï¸âƒ£ assertIterableEquals(expectedIterable, actualIterable)
âœ”ï¸ Checks two iterables (List, Set, etc.) element-by-element.
âœ”ï¸ assertIterableEquals(List.of(1,2,3), resultList);


1ï¸âƒ£1ï¸âƒ£ assertLinesMatch(expectedLines, actualLines)
âœ”ï¸ Used to match multi-line text or outputs.
âœ”ï¸ Use-case: Comparing long strings (logs, files).

assertLinesMatch(List.of("Hello", "World"), lines);

1ï¸âƒ£2ï¸âƒ£ assertThrows(ExceptionClass, executable)
âœ”ï¸ Checks if a method throws a specific exception.
âœ”ï¸ Use-case: Testing error flows.

assertThrows(ArithmeticException.class, () -> divide(10, 0));

1ï¸âƒ£3ï¸âƒ£ assertDoesNotThrow(executable)
âœ”ï¸ Passes when the code block does not throw exception.
âœ”ï¸ Use-case: Validating safe operations.

assertDoesNotThrow(() -> service.saveUser(user));

1ï¸âƒ£4ï¸âƒ£ assertTimeout(Duration, executable)
âœ”ï¸ Fails if execution exceeds given time.
âœ”ï¸ Use-case: Performance constraints.

assertTimeout(Duration.ofMillis(200), () -> service.process());

1ï¸âƒ£5ï¸âƒ£ assertTimeoutPreemptively(Duration, executable)
âœ”ï¸ Similar to above but interrupts the task when timeout occurs.
âœ”ï¸ Use-case: Strict performance testing.

assertTimeoutPreemptively(Duration.ofSeconds(1), () -> longTask());

1ï¸âƒ£6ï¸âƒ£ fail(message)
âœ”ï¸ Explicitly fails a test.
âœ”ï¸ Use-case: When code should never reach a specific point.

if (status == INVALID) {
    fail("Invalid status reached!");
}


4ï¸âƒ£ Annotations
1ï¸âƒ£ @Test
âœ”ï¸ Marks a method as a test case.

@Test
void testMethod() { }

2ï¸âƒ£ @BeforeEach
âœ”ï¸ Runs before every test method.
âœ”ï¸ Used for setting up test data.

@BeforeEach
void setup() { }

3ï¸âƒ£ @AfterEach
âœ”ï¸ Runs after every test method.
âœ”ï¸ Used for cleanup.

@AfterEach
void cleanup() { }

4ï¸âƒ£ @BeforeAll
âœ”ï¸ Runs once before all test methods (must be static).
âœ”ï¸ Used to initialize shared resources.

@BeforeAll
static void initAll() { }

5ï¸âƒ£ @AfterAll
âœ”ï¸ Runs once after all tests finish (must be static).
âœ”ï¸ Used to release shared resources.

@AfterAll
static void tearDownAll() { }

6ï¸âƒ£ @DisplayName
âœ”ï¸ Gives a custom readable name for a test.

@DisplayName("Testing addition method")
void testAdd() {}

7ï¸âƒ£ @Disabled
âœ”ï¸ Disables a test or a class from execution.

@Disabled("Feature not ready")
void testFeature() { }

8ï¸âƒ£ @Timeout
âœ”ï¸ Fails the test if it runs longer than the specified time.

@Timeout(2) // fails if takes > 2 seconds
void testTimeout() { }

9ï¸âƒ£ @Tag
âœ”ï¸ Used to group and filter tests.

@Tag("integration")
void testDb() { }

1ï¸âƒ£0ï¸âƒ£ @RepeatedTest
âœ”ï¸ Runs a test multiple times.

@RepeatedTest(5)
void repeatTest() { }

1ï¸âƒ£1ï¸âƒ£ @Nested
âœ”ï¸ Creates logical grouping inside test classes.

 @Nested
class InnerTests { }

1ï¸âƒ£2ï¸âƒ£@ParameterizedTest
âœ”ï¸ Runs the same test with multiple input values.

1ï¸âƒ£3ï¸âƒ£ @ValueSource
âœ”ï¸ Provides single-parameter values to a test.

@ParameterizedTest
@ValueSource(ints = {1, 2, 3})
void runMultiple(int num) { }

1ï¸âƒ£4ï¸âƒ£ @CsvSource
âœ”ï¸ Provides multiple parameters using CSV format.

@ParameterizedTest
@CsvSource({"2,4", "3,6"})
void testMultiply(int input, int expected) { }

1ï¸âƒ£5ï¸âƒ£ @EnumSource
âœ”ï¸ Provides enum constants.

@ParameterizedTest
@EnumSource(TimeUnit.class)
void testEnums(TimeUnit unit) { }

1ï¸âƒ£6ï¸âƒ£ @MethodSource
âœ”ï¸ Provides parameters using a static method.

static Stream<Integer> data() { return Stream.of(1,2,3); }

@ParameterizedTest
@MethodSource("data")
void testMethodSource(int num) { }

1ï¸âƒ£7ï¸âƒ£ @ExtendWith
âœ”ï¸ Adds JUnit extensions (Mockito, Spring, etc.)

@ExtendWith(MockitoExtension.class)
class TestClass { }

1ï¸âƒ£8ï¸âƒ£ @TestInstance
âœ”ï¸ Controls test instance lifecycle.

@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class TestClass { }

1ï¸âƒ£9ï¸âƒ£ @TestMethodOrder
âœ”ï¸ Controls order of test execution.

@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
class TestClass { }

2ï¸âƒ£0ï¸âƒ£ @Order
âœ”ï¸ Specifies test priority/order.

@Test
@Order(1)
void testFirst() { }

2ï¸âƒ£1ï¸âƒ£ @TempDir
âœ”ï¸ Provides a temporary directory for testing I/O operations.

@TempDir
Path tempDir;

2ï¸âƒ£2ï¸âƒ£ @RegisterExtension
âœ”ï¸ Manually registers an extension.

 @Assertions (Not annotation, but used)
Used inside tests to verify results.


ğŸ”· Mockito
Mockito is a mocking framework used with JUnit that helps you:
â¤ Mock dependencies
â¤ Avoid calling real DB, APIs, files, or external services
â¤ Test only the business logic
â¤ Perform Unit testing (not integration testing)

Mockito creates fake objects (mocks) that imitate real classes.

ğŸ”„ Why Mockito is Used?
To isolate and test only the class under test by replacing:
â¤ Service â†’ mock repository
â¤ Controller â†’ mock service
â¤ Business logic â†’ mock API calls
â¤ Microservices â†’ mock HTTP calls

This avoids actual database/API calls and speeds up testing.

âœ… Example of When Mockito Helps
Suppose you test a UserService, which needs a UserRepository.

In real world:
â¤ Repository â†’ hits database
â¤ APIClient â†’ hits external server

In unit test:
âŒ This is slow and unnecessary.
âœ” Mockito gives you a fake repository so the service can be tested alone.


ğŸ”„Core Mockito Concepts (Super Important)
1ï¸âƒ£ Mock
â¤ A fake object that imitates real behavior.

@Mock
UserRepository repo;

2ï¸âƒ£ InjectMocks
â¤ Creates the object under test and injects @Mock objects into it.

@InjectMocks
UserService service;

3ï¸âƒ£ Stubbing
â¤ Defining what a mock should return when called.

when(repo.findById(1)).thenReturn(new User(1, "John"));

4ï¸âƒ£ Verification
â¤ Check if a method was called.

verify(repo, times(1)).save(any());

5ï¸âƒ£ Argument Matchers
â¤ Flexible input matching.

when(repo.findByName(anyString())).thenReturn(user);

Common matchers:
    âœ”ï¸ anyInt()
    âœ”ï¸ anyString()
    âœ”ï¸ any()
    âœ”ï¸ eq(value)

6ï¸âƒ£ Spies
â¤ Partial mocks â†’ real methods + override specific ones.

@Spy
List<String> spyList = new ArrayList<>();

ğŸ”„ All JUnit + Mockito Annotations
| Annotation                            | Framework | Meaning                                 |
| ------------------------------------- | --------- | --------------------------------------- |
| `@ExtendWith(MockitoExtension.class)` | Mockito   | Enables Mockito in JUnit 5              |
| `@Mock`                               | Mockito   | Creates a mock object                   |
| `@InjectMocks`                        | Mockito   | Injects mocks into the class under test |
| `@Spy`                                | Mockito   | Creates a spy (partial mock)            |
| `@Captor`                             | Mockito   | Captures method arguments               |
| `@Test`                               | JUnit     | Marks a test case                       |
| `@BeforeEach`                         | JUnit     | Setup before each test                  |
| `@AfterEach`                          | JUnit     | Cleanup after each                      |
| `@DisplayName`                        | JUnit     | Custom test name                        |
| `@Disabled`                           | JUnit     | Skip test                               |
| `@Order`                              | JUnit     | Controls test order                     |


âœ…Example: JUnit + Mockito in Action
public class UserService {

    private final UserRepository repo;

    public UserService(UserRepository repo) {
        this.repo = repo;
    }

    public User getUser(int id) {
        return repo.findById(id).orElse(null);
    }

    public User saveUser(User user) {
        return repo.save(user);
    }
}

âœ… Repository
public interface UserRepository {
    Optional<User> findById(int id);
    User save(User user);
}


âœ… JUnit + Mockito Test Class
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

import org.junit.jupiter.api.*;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Spy;
import org.mockito.Captor;
import org.mockito.ArgumentCaptor;
import org.mockito.junit.jupiter.MockitoExtension;
import java.util.Optional;

@ExtendWith(MockitoExtension.class)
class UserServiceTest {

    @Mock
    UserRepository repo;   // Fake object

    @InjectMocks
    UserService service;   // Injects repo into service

    @Captor
    ArgumentCaptor<User> userCaptor; // Captures parameters

    @Spy
    UserService spyService = new UserService(repo);  // Partial mock

    @BeforeEach
    void setup() {
        System.out.println("Before each test");
    }

    @Test
    @DisplayName("Test get user by ID")
    void testGetUser() {
        User mockUser = new User(1, "Ankur");

        when(repo.findById(1)).thenReturn(Optional.of(mockUser));

        User result = service.getUser(1);

        assertEquals("Ankur", result.getName());
        verify(repo, times(1)).findById(1);
    }

    @Test
    @DisplayName("Test saving user")
    void testSaveUser() {
        User user = new User(2, "Rahul");

        when(repo.save(any(User.class))).thenReturn(user);

        service.saveUser(user);

        verify(repo).save(userCaptor.capture());

        assertEquals(2, userCaptor.getValue().getId());
    }

    @Test
    @DisplayName("Spy object test")
    void testSpy() {
        when(repo.findById(10)).thenReturn(Optional.of(new User(10, "SpyTest")));

        User result = spyService.getUser(10);

        assertEquals("SpyTest", result.getName());
    }
}
âœ… Explanation of What Happened in This Code
âœ”ï¸ @Mock
â¤ Created fake repository.

âœ”ï¸ @InjectMocks
â¤ Created real UserService with the mock repo injected automatically.

âœ”ï¸ when(...)
â¤ Stubs behavior â†’ â€œIf repo.findById(1) called â‡’ return mock userâ€.

âœ”ï¸ verify(...)
â¤ Ensures repository methods are actually called.

âœ”ï¸ @Captor
â¤ Captured what repo.save() actually received.

âœ”ï¸ @Spy
â¤ Created partial mock to test combination of real + mocked behavior.


ğŸ”„ Mockito Cheat Sheet (Important Commands)
ğŸ‘‰ Stubbing
when(mock.method()).thenReturn(value);
when(mock.method()).thenThrow(new RuntimeException());

ğŸ‘‰ Argument matchers
when(repo.findById(anyInt())).thenReturn(Optional.of(user));

ğŸ‘‰ Verification
verify(repo).save(any());
verify(repo, times(2)).findAll();
verify(repo, never()).deleteById(1);

ğŸ‘‰ Capturing arguments
verify(repo).save(userCaptor.capture());

ğŸ‘‰ Spy
doReturn(value).when(spy).method();
