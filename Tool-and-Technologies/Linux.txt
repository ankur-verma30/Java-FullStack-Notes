Linux Operating System (OS)?
ğŸ‘‰ Linux is a community-driven OS, not owned by any single company.
ğŸ‘‰ Linux is free and open-source, allowing customization and flexibility.
ğŸ‘‰ Linux is highly secure, eliminating the need for antivirus software.
ğŸ‘‰ Linux is primarily CLI-based (Command Line Interface), offering powerful control over the system.
ğŸ‘‰ Linux is widely used in businesses for efficient server management and enterprise solutions.

Different Types of Linux Distributions:
â¤ Amazon Linuxâ€‹
â¤ Ubuntuâ€‹
â¤ Red Hatâ€‹
â¤ Debianâ€‹
â¤ Kaliâ€‹
â¤ Fedoraâ€‹
â¤ CentOSâ€‹

ğŸ§ Linux Commands 
ğŸ”„ 1. Structure of a Linux Command
Format: command [options] [arguments]
â¤ command â†’ name of the program (e.g., cat, ls, ncal)
â¤ options â†’ modify the behavior of the command
    âœ”ï¸ short form â†’ -n
    âœ”ï¸ long form â†’ --number
â¤ arguments â†’ file, directory, or input on which the command operates
âš¡ Key Point: Options are case-sensitive and multiple options can be combined.

ğŸ”„ 2. File Viewing: cat
â¤ cat (short for concatenate) is one of the most frequently used commands in Linux.
â¤ It is used to create, view, concatenate, and redirect files.

ğŸ”¹ Syntax: cat [options] [file...]

ğŸ”¹ Key Options
âœ”ï¸ -n â†’ Number all output lines
âœ”ï¸ -b â†’ Number only non-blank lines
âœ”ï¸ -s â†’ Squeeze (remove) repeated empty lines
âœ”ï¸ -E â†’ Show end of line ($)
âœ”ï¸ -T â†’ Show TAB characters as ^I
âœ”ï¸ -v â†’ Show non-printing characters (useful for debugging hidden characters)

ğŸ”— cat file.txt  # print the content of a file
ğŸ”— cat file1.txt file2.txt  #Display multiple files
ğŸ”— cat > newFile.txt  #Create a new file
ğŸ‘‰Type text, then press Ctrl+D to save and exit

ğŸ”— cat >> existing.txt  #Append text to an existing file
ğŸ”— cat file1.txt file2.txt > newFile.txt  #Redirect the output of multiple files to a new file
ğŸ”— cat file1 >> file2  #Append the content of file1 to file2
ğŸ‘‰It can create the newFile if it does not exist for both append (>>) and overwrite (>).

ğŸ”— cat -n file.txt  #Print the content of a file with line numbers
ğŸ”— cat -s filex.txt  #Remove blank lines and display
ğŸ”— cat -T file.txt  #Print the content of a file with tabs as ^i
ğŸ”— cat -E file.txt  #Print the content of a file with line endings$(debugging whitespace issues)

ğŸ”¶ Tricky Questions on cat
ğŸ§  Q: What happens if you run cat > file.txt?
âœ”ï¸ ğŸ‘‰ It will overwrite the file and wait for user input. Typing text followed by CTRL+D saves it. (If you press Enter multiple times, those newlines are also saved).

ğŸ§  Q: Difference between cat file1 > file2 and cat file1 >> file2?
âœ”ï¸ ğŸ‘‰ > overwrites file2 with contents of file1.
ğŸ‘‰ >> appends contents of file1 to file2.

ğŸ§  Q: Can cat be used to create an empty file?
âœ”ï¸ ğŸ‘‰ Yes:
ğŸ”— cat > empty.txt     # press CTRL+D immediately
Or simply:
ğŸ”— > empty.txt   # preferred method

ğŸ§  Q: Explain the difference between cat file | less and less file.
âœ”ï¸ ğŸ‘‰ Functionally similar, but less file is directly efficient (less opens file itself).
ğŸ‘‰ cat file | less is a Useless Use of Cat (UUOC) 

ğŸ§  Q: How do you display line numbers only for non-empty lines using cat?
âœ”ï¸ ğŸ‘‰ ğŸ”— cat -b file.txt

ğŸ§  Q: How can you display hidden characters (like tabs, end-of-line, non-printable)?
âœ… ğŸ‘‰
ğŸ”— cat -T file.txt   # shows tabs
ğŸ”— cat -E file.txt   # shows end of lines
ğŸ”— cat -v file.txt   # shows non-printable chars

ğŸ’¡ Interview Tip: cat is mainly for concatenating & small file viewing.

ğŸ”„ 3. Directory Listing: ls
ğŸ”— ls â†’ list current directory contents
ğŸ”— ls -a â†’ show all files (including hidden, starting with .)
ğŸ”— ls -l â†’ long format (permissions, size, owner, date, etc.)
ğŸ”— ls -al or ls -la â†’ combine options: all files + long format
ğŸ’¡ Common in interviews: Explain what ls -al does.

ğŸ”„ 4. Calendar: ncal
ğŸ”— ncal â†’ show current month calendar
ğŸ”— ncal 2022 â†’ show full year 2022
ğŸ”— ncal july 2022 â†’ show July 2022
ğŸ”— ncal november 2022 -w â†’ show Nov 2022 with week numbers
ğŸ”— ncal -3 â†’ previous, current, and next month
ğŸ’¡ Interview Tip: Difference between cal (horizontal layout) vs ncal (vertical layout).

ğŸ”„ 5. Manual Pages: man
man cat â†’ shows detailed documentation of cat
man ls â†’ options for ls
Navigation inside man:
Space â†’ next page
b â†’ previous page
q â†’ quit

ğŸ’¡ Interview Tip: man is your go-to help tool in Linux.

ğŸ”„ 6. File Copy: cp
cp abc.txt abc2.txt â†’ copy abc.txt into abc2.txt
cp file1 file2 dir/ â†’ copy multiple files into directory
cp -r dir1 dir2 â†’ copy directories recursively

ğŸ”· Working with Files and Folders (Linux)
ğŸ“ Basic Navigation
ğŸ”— pwd â†’ print current working directory (absolute path)
ğŸ”— cd â†’ change directory
ğŸ”— cd / â†’ go to root directory
ğŸ”— cd .. â†’ move to parent directory
ğŸ”— cd ~ â†’ go to home directory
ğŸ”— cd /home/user/Documents â†’ navigate via absolute path
ğŸ”— cd Documents/ â†’ navigate via relative path

ğŸ’¡ Key Point:
â¤ Absolute path â†’ starts from / (root).
â¤ Relative path â†’ starts from current location.

ğŸ“‚ Listing Files
ğŸ”— ls -alh â†’ list all files (including hidden) in long format with human-readable sizes
ğŸ”— ls -t â†’ sort by time (newest first)
ğŸ”— ls -t -r â†’ sort by time (oldest first)
ğŸ”— ls -r â†’ sort in reverse order (alphabetical or as per option)
ğŸ”— ls temp/ â†’ list contents of temp/ folder

ğŸ“ Creating and Deleting
ğŸ”— mkdir temp/ â†’ create folder temp/
ğŸ”— rm -r temp/ â†’ remove folder temp/ recursively

ğŸ’¡ Safety Tip: Use rm -rf cautiously in interviews â€” interviewer may test your awareness of its danger.

ğŸ  Directory Structure Insight
ğŸ”— / â†’ root directory (top-level, contains everything)
ğŸ”— /home/ â†’ user directories (/home/ankur, /home/user)
ğŸ”— Other important system directories under / include:
ğŸ”— /bin â†’ essential binaries
ğŸ”— /etc â†’ configuration files
ğŸ”— /var â†’ variable data (logs, cache)
ğŸ”— /usr â†’ user-installed programs

ğŸ¯ Insights
â¤ Root vs Home â†’ / is system root, ~ is userâ€™s home.
â¤ ls -alh is a common test to check if you know hidden files (.) and human-readable sizes.
â¤ Recursive remove (rm -r) is dangerous â€” mention caution to score points.

âš¡nano food.txt â†’ edit file in-place
Ctrl + x â†’ save and exit

ğŸ”· TimeStamps:Modification, Access, and Change TimeStamps
we have a directory in which we have a file named food.txt.
ğŸ”— ls food.txt â†’ show file content
ğŸ”— ls -l food.txt â†’ show file modification time
ğŸ”— stat food.txt â†’ show file stats
ğŸ”— ls -lc â†’ shows the change time of the file
ğŸ”— ls -lu â†’ shows the access time of the file

ğŸ”· File Management Commands (Linux)
ğŸ“‚ Directory Management
ğŸ”— mkdir folderName â†’ create a directory
ğŸ”— rm folderName â†’ remove an empty directory
ğŸ”— mkdir folderName1 folderName2 folderName3 â†’ create multiple directories at once
ğŸ”— rm folderName1 folderName2 folderName3 â†’ remove multiple directories (empty only)
ğŸ”— rm -r folderName1 folderName2 folderName3 â†’ remove multiple directories recursively (including their contents)
ğŸ”— mkdir -p folderName1/folderName2/folderName3 â†’ create nested directories (parent dirs auto-created if missing)
ğŸ”— rmdir foldername â†’ Used to remove (delete) empty directory.
ğŸ”— rmdir folder1 folder2 â†’ Used to remove (delete) empty directories.
ğŸ”— rmdir -p a/b/c â†’ remove nested empty directories (removes c, then b, then a if empty)


ğŸ’¡ Interview Tip: rm -r is destructive. Always mention caution when using it.

ğŸ“„ File Creation & Time Management
ğŸ”— touch fileName
    âœ”ï¸ If file does not exist â†’ creates it
    âœ”ï¸ If file exists â†’ updates timestamps (access + modification time)
ğŸ”— touch -m fileName â†’ update only modification time
ğŸ”— touch -a fileName â†’ update only access time

ğŸ’¡ Common Test Question:
Difference between access time (atime) and modification time (mtime).
âœ”ï¸  atime â†’ last time file was read.
âœ”ï¸  mtime â†’ last time file content was modified.

ğŸ“Š File Type & Metadata
ğŸ”— file fileName â†’ shows file type and encoding (inspects content, not extension)

âœ… Example:
If fileName.txt contains:
Apple
Banana
Cherry

ğŸ”— Command: file fileName.txt
âœ… Output: ASCII text

ğŸ”— Example with misleading extension:
File: temp.mp4 (but contains text)
ğŸ”— Command: file temp.mp4
âœ… Output: ASCII text

ğŸ’¡ Interview Tip: Demonstrates Linux philosophy â€” file extensions donâ€™t determine file type; content does.

ğŸ“Œ Special Cases
touch 'a b' â†’ create a file with spaces in the name (quotes escape special characters)

ğŸ¯ Interview Insights
â¤ Difference between rm and rm -r â†’ recursive vs non-recursive.
â¤ Difference between mkdir and mkdir -p â†’ -p avoids errors when parent dirs donâ€™t exist.
â¤ touch command â†’ often asked: creates files and updates timestamps.
â¤ file command â†’ works on content, not extensions.

ğŸ”· Working with Nano
â¤ Nano is a simle, easyto-use text editor that operates within a terminal window.
â¤ If a file is not there, it creates and open it.

ğŸ”— nano food.txt

ğŸŒŸ Navigation inside the editor
â¤ Ctrl+ upKey â†’ move cursor up
â¤ Ctrl+ downKey â†’ move cursor down
â¤ Ctrl+ leftKey â†’ move cursor left
â¤ Ctrl+ rightKey â†’ move cursor right
â¤ Alt+G â†’ Go to a specific line, asks linenumber and columnnumber(1-based indexing)

ğŸŒŸ Basic Editing in Nano
â¤ Ctrl+Shift+C: Copy to global
â¤ Ctrl+Shift+V: Paste from global
â¤ Ctrl-K: Cut a line/selected(current line)
â¤ Alt+^: Copy the line/selected(current line)
â¤ Ctrl-U: Paste
â¤ Alt:U: Undo

ğŸŒŸ Searching/replace in nano
â¤ Ctrl+W - Search for a string or a regular expression(case in-sensitive).
â¤ Ctrl+\ - Replace a string

â¤ Ctrl + e â†’ move cursor to end of line
â¤ Ctrl + a â†’ move cursor to beginning of line
â¤ Ctrl + x â†’ Close the current file buffer and exit the editor
â¤ Ctrl + o â†’ write the current file to disk
â¤ Ctrl + q â†’ exit without saving

ğŸ”· File Operations
ğŸ‘‰ Removing the files
â¤ rm fileName â†’ remove a file
â¤ rm -d dirName â†’ remove only the empty directory
â¤ rm -r dirName â†’ remove a directory with its contents
â¤ rm file1 file2 dirName â†’ remove multiple files and directories

ğŸ‘‰ Moving and Copying
â¤ cp fileName1 fileName2 â†’ copy a file
â¤ cp -r dirName1 dirName2 â†’ copy a directory(copying recursively)
â¤ mv fileName1 fileName2 â†’ move a file
â¤ mv -r dirName1 dirName2 â†’ move a directory

ğŸ‘‰ Move and copy command can Rename the file or directory
â¤ mv another.mp4 ../horror/another_2012.mp4 â†’ move the another.mp4 to horror folder and changed its name to another_2012.mp4
â¤ cp another.mp4 ../horror/another_2012.mp4 â†’ copy the another.mp4 to horror folder and changed its name to another_2012.mp4

âš¡Key Insight: cp a.mp4 a â†’ copy the a.mp4 and paste to same directory and changed its name to a.mp4 but if a folder already exist then a.mp4 will be copied to that folder

ğŸ”· Working with cat Command
ğŸ”— cat fileName â†’ print the content of a file
ğŸ”— cat -n fileName â†’ print the content of a file with line numbers
ğŸ”— cat --number fileName â†’ same, with long option
ğŸ”— cat file1 file2 â†’ take file1 and file2 and concatenate them and show their content one after another.
ğŸ”— cat file1 file2 > file3 â†’ concatenate the content of file1 and file2 and put them inside the file3(overwrite)
ğŸ”— cat file1 file2 >> file3 â†’ concatenate the content of file1 and file2 and put them inside the file3(append)
ğŸ”— cat >> a.txt â†’  write the content then append to the a.txt use Ctrl+D to tell it is the end of the input then Ctrl+C to exit writing
ğŸ”— cat > a.txt â†’  write the content then overwrite to the a.txt use Ctrl+D to tell that it is the end of the input then use Ctrl+C to exit writing
ğŸ”— tac fileName â†’ vertically invert the contents of the file by lineNumber other workings are same as cat command just in reverse
ğŸ”— rev fileName â†’ reverse the content horizontally every line, vertical order is same 

â—Same things can be achived through echo command

ğŸ’¡ Interview Tip: cat is used for quick viewing, concatenating, or creating files.

ğŸ“Œ Special Cases
cat 'a b' â†’ print the content of a file with spaces in the name (quotes escape special characters)

ğŸ”· Viewing File Content in Linux
ğŸ“– 1. head â€“ View Beginning of File
ğŸ”— head foods.txt â†’ prints first 10 lines (default)
ğŸ”— head -n 5 foods.txt â†’ prints first 5 lines
ğŸ’¡ Useful for quickly checking file headers, configs, or log starts.

ğŸ“– 2. tail â€“ View End of File
ğŸ”— tail foods.txt â†’ prints last 10 lines (default)
ğŸ”— tail -n 5 foods.txt â†’ prints last 5 lines
ğŸ”— tail -f foods.txt â†’ prints last 10 lines and keeps watching for changes in real-time
ğŸ’¡ Commonly used for monitoring log files (tail -f /var/log/syslog).

ğŸ“– 3. less â€“ Scrollable File Viewer
ğŸ”— less foods.txt â†’ open file with navigation:
âœ”ï¸ Space / â†“ â†’ scroll down
âœ”ï¸ â†‘ / b â†’ scroll up
âœ”ï¸ /word â†’ search forward
âœ”ï¸ ?word â†’ search backward
âœ”ï¸ q â†’ quit
ğŸ’¡ Preferred over cat for large files (doesnâ€™t load everything into memory).

ğŸ¯ Interview Insights
â¤ Difference between head, tail, cat, less
    âœ”ï¸ cat â†’ dump full file
    âœ”ï¸ head/tail â†’ preview start/end
    âœ”ï¸ less â†’ navigate inside file efficiently
â¤ tail -f is often asked â†’ used in real-time log monitoring (very common in DevOps/production).

â¤ Combination usage:
    âœ”ï¸ head -n 20 file | tail -n 5 â†’ prints lines 16â€“20.

ğŸ”· Standard Output (stdout) & Standard Error (stderr) in Linux
ğŸ“ Basics

â¤ Every command/program produces:
    âœ”ï¸ stdout (1) â†’ normal output (default stream)
    âœ”ï¸ stderr (2) â†’ error messages
ğŸ’¡ By default, both are displayed in the terminal.

ğŸ“‚ Redirection Operators
â¤ > â†’ redirect (overwrite)
â¤ >> â†’ append

ğŸ“– Redirecting Standard Output
â¤ ls > a.txt â†’ redirect output to a.txt (overwrite if exists)
â¤ ls >> a.txt â†’ append output to a.txt
ğŸ’¡ Stream number 1 (stdout) is implied.
So ls > a.txt â‰¡ ls 1> a.txt

ğŸ“– Redirecting Standard Error
â¤ ls -z 2> a.txt â†’ redirect errors only into a.txt
â¤ ls -z 2>> a.txt â†’ append errors only into a.txt
ğŸ’¡ 2 explicitly denotes stderr.

ğŸ“– Redirecting Both stdout and stderr
â¤ ls -z > output.txt 2> error.tx
    âœ”ï¸ stdout â†’ output.tx
    âœ”ï¸ stderr â†’ error.tx
â¤ ls -z >> output.txt 2>> error.tx
    âœ”ï¸ append stdout â†’ output.tx
    âœ”ï¸ append stderr â†’ error.txt

ğŸ¯ Interview Insights
â¤ Stream numbers:
    âœ”ï¸ 0 â†’ stdin (input)
    âœ”ï¸ 1 â†’ stdout (output)
    âœ”ï¸ 2 â†’ stderr (errors)
Default: > means 1> unless otherwise specified.

ğŸ”· sort Command in Linux
The sort command is used to arrange lines of text in files or input streams.

âš¡Syntax: sort [options] fileName

ğŸ“– Common Options
ğŸ”— sort fileName â†’ sort file content in ascending (alphabetical) order
ğŸ”— sort -r fileName â†’ sort in reverse (descending) order
ğŸ”— sort -n fileName â†’ sort numerically (instead of alphabetically)
ğŸ”— sort -nr fileName â†’ sort numerically in reverse order
ğŸ”— sort -u fileName â†’ sort and remove duplicates

ğŸ“Š Sorting by Column
ğŸ”— sort -k5h fileName â†’ sort using 5th column, numbers in human-readable format (K, M, G, etc.)
ğŸ”— sort -k5hr fileName â†’ sort by 5th column, human-readable, in reverse order
ğŸ’¡ Example with ls -alh output: ls -alh | sort -k5h
Sorts files by size (column 5).

ğŸ¯ Interview Insights
â¤ Default behavior: sorts alphabetically (lexicographic order).
â¤ -n is important â€” without it, 10 comes before 2 (alphabetical).
â¤ -u is often tested for removing duplicates.
â¤ Column sorting (-k) is frequently used with commands like ls, ps, and df.
â¤ Human-readable (-h) helps when sorting sizes with suffixes (K, M, G).

ğŸ”· Pipe Operator (|) in Linux
â¤ The pipe (|) operator takes the output of one command and uses it as the input to another command.
â¤ Enables command chaining without creating intermediate files.

ğŸ“– Example â€“ Without Pipe
ls -lh >> files        # save directory listing to 'files'
sort -k5hr files       # sort by 5th column (size) in reverse

ğŸ“– Example â€“ With Pipe
ğŸ”— ls -lh | sort -k5hr >> files

â¤ ls -lh â†’ list files with human-readable sizes
â¤ sort -k5hr â†’ sort by size (descending)
â¤ >> files â†’ append result to files
ğŸ’¡ Pipe makes it a single streamlined command.

ğŸ“– Multiple Pipes
You can chain multiple pipes:
ps aux | sort -k3nr | head -n 5

â¤ ps aux â†’ list running processes
â¤ sort -k3nr â†’ sort by CPU usage (column 3, numeric, reverse)
â¤ head -n 5 â†’ show top 5 CPU-consuming processes

ğŸ¯ Interview Insights
â¤ Pipe vs Redirection:
    âœ”ï¸ > / >> â†’ redirect output to a file
    âœ”ï¸ | â†’ send output directly to another command
Common usage:
â¤ ls | grep txt â†’ list only .txt files
â¤ dmesg | less â†’ scroll through logs
â¤ cat file | wc -l â†’ count lines in a file

ğŸ”· Searching in Linux â€“ grep Command

ğŸ“ Basic Usage: grep "pattern" fileName
â¤ Searches pattern inside fileName.
â¤ Case-sensitive by default.
â¤ Use double quotes to protect special characters (*, ?, |).

ğŸ“– Common Options
âœ”ï¸ -i â†’ ignore case
ğŸ”— grep -i "error" logs.txt

âœ”ï¸ -c â†’ count matches (integer only)
ğŸ”— grep -ic "error" logs.txt

âœ”ï¸ -w â†’ match whole word only (not substrings)
ğŸ”— grep -iw "cat" animals.txt   # matches "cat", not "concatenate"

âœ”ï¸ -n â†’ show line numbers of matches
ğŸ”— grep -in "error" logs.txt

ğŸ“– Context Options
âœ”ï¸ -B n â†’ show n lines before match
âœ”ï¸ -A n â†’ show n lines after match
âœ”ï¸ -C n â†’ show n lines before & after match

âœ… Examples:
ğŸ”— grep -iB2 "error" app.log    # 2 lines before match
ğŸ”— grep -iA2 "error" app.log    # 2 lines after match
ğŸ”— grep -iC2 "error" app.log    # 2 lines before & after
ğŸ”— grep -iB2 -A3 "error" app.log  # 2 before, 3 after

ğŸ“– Recursive Search
Search in all files under a directory:

ğŸ”— grep -r "pattern" dirName
ğŸ”— grep -r "pattern"   # searches in current directory

ğŸ“– Multiple Files
ğŸ”— grep "pattern" file1 file2

ğŸ“– Combination with Other Commands
ğŸ”— ls -lh | grep "txt" â†’ show only .txt files
ğŸ”— tail -f app.log | grep "error" -C10 â†’ live monitor logs, showing 10 lines before & after each "error"

ğŸ¯ Insights
â¤ Pipe + grep is a favorite interview question â†’ e.g., ps aux | grep java
â¤ Regex supported â†’ grep -E "cat|dog" (use -E for extended regex)
â¤ grep â†’ basic regex
â¤ egrep (or grep -E) â†’ extended regex (+, ?, {})
â¤ fgrep (or grep -F) â†’ fixed string search, no regex (faster)

â—Common traps:
âš¡ Forgetting quotes â†’ shell may expand special characters before grep sees them.
âš¡ Case sensitivity â†’ by default grep is case-sensitive.
âš¡ Large log search â†’ always combine with tail -f or less for efficiency.

ğŸ”· Arithmetic Operations and Expressions in Linux
ğŸ”— $(command) â†’ Command substitution (runs a command inside).
ğŸ”— $((expression)) â†’ Arithmetic expansion (evaluates math expressions).

ğŸ”— Arithmetic with $(( ))
âœ”ï¸ echo $((2 + 3))    # 5
âœ”ï¸ echo $((2 * 3))    # 6
âœ”ï¸ echo $((2 - 3))    # -1
âœ”ï¸ echo $((2 / 3))    # 0 â†’ integer division only
âœ”ï¸ echo $((2 % 3))    # 2 â†’ modulo operator
âœ”ï¸ echo $((2**3))     # 8 â†’ exponentiation


âš¡ Key Insights:
Integer-only: $(( )) supports only integers, not decimals.
For floating-point, use bc:
âœ”ï¸ echo "2/3" | bc -l    # 0.666666...

You can also use variables inside:
a=10; b=3
âœ”ï¸ echo $((a + b))    # 13

ğŸ”— Command Substitution $( )
Runs a command inside, not math:

ğŸ”— echo $(pwd)     # prints current directory
ğŸ”— echo $(date)    # prints current date

ğŸ”— Logical Chaining in Linux

ğŸ‘‰; â†’ Always runs commands sequentially
ğŸ”— d Downloads/ ; ls

ğŸ‘‰ â†’ Even if cd fails, ls runs.
ğŸ‘‰ && â†’ Run second only if first succeeds

ğŸ”— cd Downloads/ && ls â†’ If cd works, then list contents.

ğŸ‘‰ || â†’ Run second only if first fails 
ğŸ”— cd Downloads/ || ls
âœ”ï¸ If cd fails, then run ls in current dir.

ğŸ¯ Interview Insights
â¤ $(( )) is faster than using expr command (old style).
â¤ Donâ€™t confuse $( ) vs $(( )):
    âœ”ï¸ $( ) â†’ run command
    âœ”ï¸ $(( )) â†’ run math

â¤ let is another way but less preferred:
let x=2+3
echo $x   # 5


ğŸ”· Linux Terminal Shortcuts
âŒ¨ï¸ Navigation
ğŸ‘‰ Ctrl + A â†’ Move to beginning of line
ğŸ‘‰ Ctrl + E â†’ Move to end of line
ğŸ‘‰ Alt + B â†’ Move one word backward
ğŸ‘‰ Alt + F â†’ Move one word forward

ğŸ“ Editing
ğŸ‘‰ Ctrl + K â†’ Delete from cursor to end of line
ğŸ‘‰ Ctrl + U â†’ Delete from cursor to beginning of line
ğŸ‘‰ Ctrl + W â†’ Delete word backwards (up to space)
ğŸ‘‰ Alt + D â†’ Delete word forwards (up to space)
ğŸ‘‰ Ctrl + Y â†’ Paste last cut text (yank)

ğŸ” History & Searc
ğŸ‘‰ Ctrl + R â†’ Reverse search through history ((reverse-i-search)
ğŸ‘‰ Ctrl + G â†’ Exit history search without running a comman
ğŸ‘‰ â†‘ / â†“ â†’ Navigate through command history

ğŸ–¥ï¸ Screen Control
ğŸ‘‰ Ctrl + L â†’ Clear screen (like clear)
ğŸ‘‰ Ctrl + D â†’ Logout / exit terminal (EOF signal)
ğŸ‘‰ Ctrl + Z â†’ Suspend current job (can resume with fg)

ğŸ”— Tabs & Session
ğŸ‘‰ Ctrl + Alt + T â†’ Open new terminal windo
ğŸ‘‰ Ctrl + Shift + T â†’ Open new terminal tab (in supporting terminals like GNOME)

ğŸ”¤ Font & Display
ğŸ‘‰ Ctrl + Shift + â€œ+â€ â†’ Increase font size
ğŸ‘‰ Ctrl + â€œ-â€ â†’ Decrease font size
ğŸ‘‰ Ctrl + 0 â†’ Reset font size

âš¡ Productivity Boosters
ğŸ‘‰ Tab â†’ Auto-complete command/file names
ğŸ‘‰ Tab Tab â†’ Show all possible completions
ğŸ‘‰ !! â†’ Run last command again
ğŸ‘‰ !<word> â†’ Run last command starting with <word> (e.g., !ls)
ğŸ‘‰ Ctrl + C â†’ Kill current process
ğŸ‘‰ Ctrl + Shift + C â†’ Copy text
ğŸ‘‰ Ctrl + Shift + V â†’ Paste text

ğŸ¯ Insights
Ctrl + D vs Ctrl + C
Ctrl + D â†’ End Of File (exit shell if nothing to read).
Ctrl + C â†’ Interrupt/kill the running process.
Job Control (Ctrl + Z, fg, bg) is a hidden gem often asked in interviews.


ğŸ”· Find Command in Linux
ğŸ‘‰ Used to search for files/directories in a given path with conditions.
ğŸ‘‰ Syntax: find [path...] [expression]

ğŸ‘‰ Case-sensitive by default â†’ use -iname for case-insensitive search.

ğŸŒŸ Wildcard Characters in find -name
* â†’ Any number of characters
? â†’ Any single character
[abc] â†’ Matches a, b, or c
[!abc] â†’ Matches anything except a, b, or c
[0-9] â†’ Any digit from 0â€“9
[!0-9] â†’ Not a digit

âœ… Examples:
ğŸ‘‰ ğŸ”— find . -name "*.txt" â†’ Find all text files in the current directory

ğŸ”¹ Search by Type
ğŸ”— find /path -type f -name "*.txt"   # files
ğŸ”— find /path -type d -name "*.txt"   # directories

ğŸ”¹ Search by Size
ğŸ”— find /path -type f -size +100k -size -200k   # files between 100KBâ€“200KB
ğŸ”— find /path -type d -size +1M                 # directories > 1MB

ğŸ”¹ Search by Time
âœ”ï¸ -mmin / -mtime â†’ Modified time
âœ”ï¸ -amin / -atime â†’ Accessed time
âœ”ï¸ -cmin / -ctime â†’ Metadata changed

â¤ Note: min gives minutes and time is in days
âœ… Examples:
ğŸ”— find /path -mtime -7    # modified in last 7 days
ğŸ”— find /path -mtime +7    # modified more than 7 days ago
ğŸ”— find /path -mtime 7     # modified exactly 7 days ago
ğŸ”— find /path -mmin -30    # modified in last 30 minutes

ğŸ”¹ Logical Operators
ğŸ”— find /path -type f -name "*.txt" -size +100k -mtime -7   # AND condition
ğŸ”— find /path \( -name "*.txt" -o -name "*.pdf" \)          # OR condition
ğŸ”— find /path ! -name "*.txt"   # NOT condition

ğŸ”¹ Empty Files/Directories
ğŸ”— find /path -type f -empty    # empty files
ğŸ”— find /path -type d -empty    # empty directories

ğŸ”¹ Execute Commands on Results
ğŸ”— find /path -name "*.txt" -exec cat {} \;    # run `cat` on each file
ğŸ”— find /path -empty -exec rm -rf {} \;        # delete empty files/dirs
âœ”ï¸ {} â†’ placeholder for current file
âœ”ï¸ \; â†’ end of exec command

ğŸ”¹ Using xargs
ğŸ”— find . -name "*.log" | xargs rm     # delete all .log files
ğŸ”— find . | xargs file                 # run `file` command on each

ğŸ”¹ -exec vs xargs
â¤ -exec â†’ runs inside find, handles spaces/special chars safely
â¤ xargs â†’ more efficient for bulk operations, but may fail on files with spaces/newlines

ğŸ”· Permissions in Linux
lrwxrwxrwx
l can be:
    â¤ - â†’ regular file
    â¤ l- â†’ symbolic link
    â¤ d â†’ directory
    â¤ b â†’ block device file
    â¤ c â†’ character device file
    â¤ p â†’ named pipe
    â¤ s â†’ socket

ğŸŒŸ Permission Bits (rwx)
â¤ r â†’ Read
    âœ”ï¸ File: allows viewing contents
    âœ”ï¸ Directory: allows listing files (ls)

â¤ w â†’ Write
    âœ”ï¸ File: allows modifying contents
    âœ”ï¸ Directory: allows adding/removing files

â¤ x â†’ Execute
    âœ”ï¸ File: allows executing as a program/script
    âœ”ï¸ Directory: allows entering (cd) and accessing metadata

possibilities of characters:
â¤ first character: r or -
â¤ second character: w or -
â¤ third character: x or -   

ğŸŒŸ Permission Groups (3 sets of 3 bits = 9 characters)
âœ… Example: -rwxr-xr--
ğŸ‘‰ Owner (User): first 3 bits â†’ rwx
ğŸ‘‰ Group: next 3 bits â†’ r-x
ğŸ‘‰ Others: last 3 bits â†’ r--

rest 9 characters will be divided into three groups: rwx,rwx,rwx
â¤ first set of 3 characters â†’ owner permissions
â¤ second set of 3 characters â†’ group permissions
â¤ third set of 3 characters â†’ other permissions


ğŸ”· Changing Permissions with chmod
âœ… Syntax: chmod [options] [permissions] [files...]

ğŸ”¹ Permission Categories
âœ”ï¸ u â†’ user (owner)
âœ”ï¸ g â†’ group
âœ”ï¸ o â†’ others
âœ”ï¸ a â†’ all (user + group + others)

ğŸ”¹ Operators
âœ”ï¸ + â†’ add permission
âœ”ï¸ - â†’ remove permission
âœ”ï¸ = â†’ set exact permission (overwrites existing)

ğŸ”¹ Permission Types
âœ”ï¸ r â†’ read
âœ”ï¸ w â†’ write
âœ”ï¸ x â†’ execute

ğŸ”¹ Common Options
âœ”ï¸ -R â†’ recursive (apply to directories + contents)
âœ”ï¸ -v â†’ verbose (show changes)
âœ”ï¸ -f â†’ force (suppress errors)

ğŸ”¹ Symbolic Method Examples
ğŸ”— chmod u+x sample.txt     # add execute for user
ğŸ”— chmod g-w sample.txt     # remove write from group
ğŸ”— chmod o=r sample.txt     # others only read
ğŸ”— chmod a+x sample.txt     # all users get execute
ğŸ”— chmod u=rwx,g=rx,o=      # explicit overwrite

ğŸ”¹ Octal (Numeric) Method

Permission values:
r = 4, w = 2, x = 1
Calculate sum for each group:
7 = rwx
6 = rw-
5 = r-x
4 = r--
0 = ---

âœ… Examples:
ğŸ”— chmod 755 sample.txt    # rwx r-x r-x
ğŸ”— chmod 644 sample.txt    # rw- r-- r--
ğŸ”— chmod 700 sample.txt    # rwx --- ---
ğŸ”— chmod 777 sample.txt    # rwx rwx rwx (full access to everyone âŒ not recommended)

ğŸ”¹ Special Cases
â¤ Directories â†’ need x to enter (cd).
â¤ Scripts/Programs â†’ need x to execute.

âœ… Recursive Example:
ğŸ”— chmod -R 755 project/

ğŸ¯ Interview Insights
â¤ chmod works in symbolic and octal forms.
â¤ Use octal when setting multiple permissions at once.
â¤ Directories without x â†’ you can list files but not enter them.
â¤ 777 permissions are insecure (everyone can read/write/execute).


ğŸ”· Su command in Linux
âœ… Purpose: 
ğŸ‘‰ su = substitute user or switch user.
ğŸ‘‰ It allows you to switch to another user account within the same terminal session.
ğŸ‘‰ By default, it switches to the root user (superuser).

whoami â†’ show current user
su - username â†’ switch to username


ğŸ”· Mastering Linux Groups
ğŸ”¹ Viewing Groups
ğŸ”— groups â†’ lists groups of the current user
ğŸ”— groups username â†’ lists groups of a specific user

ğŸ”¹ Creating Groups
ğŸ”— addgroup groupname â†’ create a new group
(on some distros: groupadd groupname)

ğŸ”¹ Adding Users to Groups
ğŸ”— adduser username groupname â†’ add user to group
(alternative: usermod -aG groupname username â†’ safer, adds without removing from other groups)

ğŸ”¹ Removing Users from Groups
ğŸ”— deluser username groupname â†’ remove user from a group
(alternative: gpasswd -d username groupname)

ğŸ”¹ Deleting Groups
ğŸ”— delgroup groupname â†’ delete a group
(alternative: groupdel groupname)

ğŸ”¹ Switching Groups
ğŸ”— newgrp groupname â†’ switch current shell to the specified group

ğŸ”¹ File Permissions with Groups
Every file has: owner, group, others
If user belongs to fileâ€™s group â†’ group permissions apply

âœ… Example:
chgrp groupname filename   # change group ownership of a file

ğŸ¯ Interview / Notes Insights
â¤ Groups help in role-based access control.
â¤ primary group â†’ assigned at user creation (default group).
â¤ secondary groups â†’ additional groups user can belong to.
â¤ Best practice: Use groups instead of giving everyone root access.


ğŸ”· Sudo Command in Linux
â¤ sudo â†’ SuperUser DO
â¤ Allows permitted users to execute commands as root or another user (as defined in /etc/sudoers).
â¤ Safer than logging in directly as root.

ğŸ”¹ Usage: sudo command

âœ… Example:
ğŸ”— sudo mkdir meals   # create a directory as root
ğŸ”— sudo apt update    # update package list
ğŸ”— sudo cat /etc/shadow   # view restricted file

ğŸ”¹ Authentication Behavior
â¤ First time sudo is used in a session â†’ password required.
â¤ After successful authentication â†’ no password needed for 15 minutes (default).
â¤ Timeout can be changed in /etc/sudoers file (using visudo).

ğŸ”¹ Running as Different User
ğŸ”— sudo -u username command

âœ… Example:
sudo -u postgres psql   # run as postgres user

ğŸ”¹ Common Options
âœ”ï¸ -u user â†’ run as specific user
âœ”ï¸ -k â†’ invalidate timestamp immediately (next sudo needs password)
âœ”ï¸ -v â†’ extend sudo timeout without running command
âœ”ï¸ -l â†’ list allowed commands for current user
âœ”ï¸ -s â†’ open a shell as root (without login shell)
âœ”ï¸ -i â†’ simulate root login shell

ğŸ”¹ Notes & Interview Insights
â¤ sudo access is controlled via /etc/sudoers (edit with visudo).
â¤ NOPASSWD: directive allows passwordless sudo for specific commands.
â¤ Root login is often disabled for security; sudo is preferred.


ğŸ”·Bashrc in Linux
ğŸ”— source .bashrc   # run commands from .bashrc file automatically to restart the terminal

â¤ .bashrc is a shell script file executed whenever a new interactive non-login shell is started.
â¤ Location:
    âœ”ï¸ User-specific: ~/.bashrc (inside home directory).
    âœ”ï¸ Global: /etc/bash.bashrc (applies to all users).
â¤ It customizes the bash shell environment for the user.

ğŸ”¹ When is it executed?
â¤ Every time you open a new terminal window/tab.
â¤ Not executed for login shells (those read ~/.bash_profile, ~/.profile, or /etc/profile).

ğŸ”¹ Common Uses
â¤ Setting environment variables
â¤ Adding aliases (shortcuts for commands)
â¤ Customizing prompt (PS1)
â¤ Running startup scripts
â¤ Adding functions

âœ… Example:
# ~/.bashrc
alias ll='ls -lh'
alias gs='git status'
export PATH=$PATH:~/scripts
PS1='\u@\h:\w$ '   # Custom prompt

ğŸ”¹ Reload .bashrc without restarting terminal
source ~/.bashrc
# or
. ~/.bashrc

ğŸ”¹ Interview Insights
â¤ .bashrc â†’ for interactive non-login shells.
â¤ .bash_profile or .profile â†’ for login shells.
â¤ Often .bash_profile calls .bashrc inside it to unify configs.


ğŸ”· Using chown command in Linux
â¤ chown (change owner) is used to change the ownership of files and directories.
â¤ Every file/directory in Linux has:
    âœ”ï¸ Owner (user)
    âœ”ï¸ Group

ğŸ”¹ Syntax
chown [OPTIONS] USER[:GROUP] FILE...

ğŸ”¹ Common Usage

â¤ Change file ownership to a specific user
ğŸ”— sudo chown username filename

â¤ Change fileâ€™s group only
ğŸ”— sudo chown :groupname filename

â¤ Change both user and group
ğŸ”— sudo chown username:groupname filename

â¤ Change ownership recursively (directory + subfiles)
ğŸ”— sudo chown -R username:groupname dirName

ğŸ”¹ Useful Options
âœ”ï¸ -R â†’ recursive (apply to all subfiles and directories)
âœ”ï¸ -c â†’ report changes made
âœ”ï¸ -v â†’ verbose (show details for every file changed)
âœ”ï¸ -f â†’ suppress errors

âœ… Ownership + Permissions Example
sudo chown ankur:developers project.txt   # give file to user "ankur" and group "developers"
sudo chmod g+w project.txt                # allow group members to write

ğŸ”¹ Interview Insights
â¤ Ownership (chown) and permissions (chmod) work together.
â¤ ls -l â†’ shows both owner and group.
â¤ Difference:
    âœ”ï¸ chown â†’ changes ownership (user/group).
    âœ”ï¸ chmod â†’ changes permission (r/w/x).
â¤ Root (or sudo) privileges are required for chown.


ğŸ”· Sessions in Linux
â¤ A session in Linux = an instance of a running shell (bash, zsh, etc.).
â¤ Each session has its own process ID (PID).
â¤ Sessions can be nested inside each other.

ğŸ”¹ Commands
â¤ Get current session ID (PID of the shell)
ğŸ”— echo $$

â¤ Start a new nested session
ğŸ”— bash
ğŸ‘‰ This creates a new shell session inside the current one.
ğŸ‘‰ Each new session has a different PID.

â¤ Exit a nested session
ğŸ”— exit
(or Ctrl+D) â†’ returns to the parent session.

âœ… Session Chain Example
echo $$       # prints 1234 (current session PID)
bash          # start new nested session
echo $$       # prints 5678 (new session PID)
exit          # return to previous session
echo $$       # back to 1234

ğŸ”¹ Insights (Interview Traps)
â¤ Each terminal window/tab = a separate session.
â¤ Sessions are processes, visible in ps -ef or pstree.
â¤ Environment variables are session-specific (not shared unless exported to child processes).
â¤ If you start a session inside another, youâ€™re essentially running bash inside bash.


ğŸ”· Linux Environment variables
â¤ Environment variables are key-value pairs maintained by the shell.
â¤ They define system-wide or session-specific settings (e.g., PATH, HOME, USER).
â¤ They are inherited by child processes.

ğŸ”¹ Commands
â¤ List all environment variables
ğŸ”— printenv

â¤ Get value of a specific variable
ğŸ”— printenv VAR_NAME
ğŸ”— echo $VAR_NAME

â¤ Set an environment variable (session only)
ğŸ”— export VAR_NAME=value

â¤ Unset/remove an environment variable
ğŸ”— unset VAR_NAME

ğŸ”¹ Persistence of Variables
â¤ By default, variables set using export exist only for the current session.
â¤ To make them permanent, add to:
    âœ”ï¸ ~/.bashrc (for user-specific, non-login shells)
    âœ”ï¸ ~/.profile or ~/.bash_profile (for login shells)
    âœ”ï¸ /etc/environment (system-wide)

ğŸ”¹ Useful Environment Variables (Common in Interviews)
â¤ PATH â†’ directories searched for executables.
â¤ HOME â†’ current userâ€™s home directory.
â¤ USER â†’ logged-in username.
â¤ SHELL â†’ current shell.
â¤ PWD â†’ current working directory.

ğŸ”¹ Insights (Interview Angle)
Difference between local variable vs environment variable:
    âœ”ï¸ Local â†’ exists only in current shell.
    âœ”ï¸ Environment â†’ exported and available to child processes.
To temporarily modify PATH:
    âœ”ï¸ export PATH=$PATH:/new/dir


ğŸ”·Understanding Alias Commands for Efficiency
â¤ An alias in Linux is a shortcut for a command or group of commands.
â¤ Saves time and reduces repetitive typing.
â¤ Aliases exist only in the current shell session unless added to configuration files (~/.bashrc, ~/.zshrc).

ğŸ”¹ Check Command Type
ğŸ”— type commandName
â¤ Shows whether the command is:
    âœ”ï¸ builtin â†’ part of the shell itself.
    âœ”ï¸ hashed â†’ external command stored in memory for faster lookup.
    âœ”ï¸ aliased â†’ customized alias of another command.

âœ… Examples:
ğŸ”— type pwd   # pwd is a shell builtin
ğŸ”— type cat   # cat is hashed (/usr/bin/cat)
ğŸ”— type ls    # ls is aliased to 'ls --color=auto'

ğŸ”¹ Create an Alias
alias aliasName='commandName arguments'

âœ… Examples:
ğŸ”— alias ll='ls -alh'     # quick way to list files with details
ğŸ”— alias grep='grep --color=auto'  # color highlight search
ğŸ”— alias cls='clear'      # alias cls to clear terminal

ğŸ”¹ Remove an Alias
ğŸ”— unalias aliasName

ğŸ”¹ View All Aliases
ğŸ”— alias

ğŸ”¹ Making Aliases Permanent
â¤ Add them to:
    âœ”ï¸ ~/.bashrc or ~/.zshrc for user-specific aliases.
    âœ”ï¸ /etc/bash.bashrc for system-wide aliases.
â¤ Reload file after editing:
source ~/.bashrc

ğŸ”¹ Interview Insights
â¤ Aliases override system commands (e.g., ls often aliased to ls --color=auto).
â¤ If you want to bypass an alias â†’ use command keyword:
ğŸ”— command ls
ğŸ‘‰ Runs the original ls, ignoring alias.
â¤ Good to mention: Aliases are shell features, not kernel-level.


ğŸ”· Mastering Bash in Linux
A shell is a command-line interface(CLI) that allows users to interact with an operating system by typing commands.

There are several types of shells, and they can be broadly categorized into two main groups:
â¤ Unix-like shells
â¤ Windows shells

ğŸŒŸ Unix-like shells
ğŸ‘‰ Bourne Shell (sh): The Bourne Shell was one of the earliest Unix shells and served as the basis for many subsequent shells. It provides basic functionality and is often used for scripting.

ğŸ‘‰ Bash(Bourne Again Shell): Bash is the default shell in many Unix-like Operating systems, including Linux and macOS. It extends the capabilities of the original Bourne Shell and incorporates features from other shells like the Korn Shell and the C Shell.

ğŸ‘‰ Korn Shell (ksh): Korn Shell was developed by David Korn as enhancement to the Bourne Shell. It includes features from both the Bourne Shell and the C Shell, making it a powerful and user-friendly shell.

ğŸ‘‰ C Shell (csh): The C Shell has a syntax that is somewhat C-like and was developed to provide interactive features not present in the original Bourne shell. Its successors, tcsh, is an improved version with additional features.

ğŸ‘‰ Zsh (Z Shell): Zsh is a shell that incorporates features from bash, ksh, and tcsh. It includes advanced scripting abilities and interactive for users.

ğŸŒŸ Windows Shell
ğŸ‘‰ Command Prompt(cmd.exe): The Command Prompt is the traditional command-line interface for windows. While it lacks some advanced features found in Unix-like shells, it provides a basic command-line environment.

ğŸ‘‰ Powershell: Powershell is a more recent and powerful shell for windows. It is designed for automation and task scripting, with a focus on managing system components through command-line interface.


ğŸ”·$PATH in Bash
â¤ $PATH is an environment variable in Linux/Unix shells.
â¤ It contains a colon-separated list of directories.
â¤ When a command is run, the shell searches these directories (in order) to find the executable.

âœ… Example:
ğŸ”— echo $PATH
# /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

ğŸ”¹ Locate Executable for a Command
ğŸ”— which ls
ğŸ‘‰ Returns the full path of the commandâ€™s executable (/bin/ls).

ğŸ”¹ Adding Directories to $PATH
â¤ Temporary (session only):
ğŸ”— export PATH=$PATH:/path/to/directory

â¤ Permanent (user-specific):
Add the line to ~/.bashrc or ~/.zshrc:
ğŸ”— PATH=$PATH:/path/to/directory

Reload file:
ğŸ”— source ~/.bashrc

â¤ Permanent (system-wide):
Add directory to /etc/environment.

ğŸ”¹ Insights 
â¤ The shell searches directories in $PATH sequentially; first match is executed.
â¤ If two commands with the same name exist, the one earlier in $PATH takes priority.
â¤ $PATH can be modified by scripts, installers, or user configs.
â¤ To reset PATH to default:
ğŸ”— export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

âš¡ Common Trap Question
ğŸ§  â€œIf you create a script called ls in your current directory, why might it not run when you type ls?â€
ğŸ‘‰ Because current directory (.) is usually not in $PATH. Youâ€™d need to run ./ls or add . to $PATH.


ğŸ”· Mastering Linux Scripts
â“What is Script?
In Linux, a script is a series of commands written in a scripting language(like Bash) that can be executed by the shell.

Bash is both a command-line interpreter(shell) and a scripting language.


Creating a Simple Script
#!/bin/bash
echo "Hello, Linux scripting!"

When you execute a script, the system typically relies on the shebang(the #!/bin/bash line at the beginning of the script) to determine the interpreter that should be used, regardless of the file extension. This allows you to name your scripts with or without a .sh extension.

â“How to execute a Script
âœ”ï¸ bash fileNName: This explicitly tells the Bash shell to execute the script. It's commonly used in Bash Scripts.

âœ”ï¸ sh fileName: This instructs the system to use the default shell (usually /bin/sh) to execute the script.

âš¡Note: Above two commands runs the script in the new subshell which does not affect the current shell environment.

âœ”ï¸ source fileName: This runs the script in the current shell session instead of spawning a new process. It's often used to execute the scripts that modify the environment, such as setting environment variables.

âœ”ï¸ ./fileName:Returns the script to be made executable
If the file is found and has execute permission, the shell executes it using the appropriate interpreter specified in the shebang line.


â—What if you wat to run a script as if it were a command, without specifying the path of the script every time
â¤ Add the script to a Directory in the PATH.


ğŸ”·Mastering Linux Corn Jobs
â¤ Cron is a Linux utility to schedule repetitive tasks at specific times/dates.
â¤ Managed by the cron daemon (crond).
â¤ Each user can define their own cron jobs using crontab.

ğŸ”¹ Basic Commands
ğŸ”— crontab -e   # edit crontab file (default editor: nano if selected)
ğŸ”— crontab -l   # list current userâ€™s cron jobs
ğŸ”— crontab -r   # remove all cron jobs for current user
ğŸ”— crontab -k   # kill the cron daemon

ğŸ”¹ Crontab Syntax
* * * * * command_to_be_executed
â”‚ â”‚ â”‚ â”‚ â”‚
â”‚ â”‚ â”‚ â”‚ â””â”€â”€ Day of week (0-6, Sunday=0)
â”‚ â”‚ â”‚ â””â”€â”€â”€â”€ Month (1-12)
â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€ Day of month (1-31)
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€ Hour (0-23)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Minute (0-59)

âœ… Examples
âœ”ï¸ 30 3 * * *     # Every day at 3:30 AM
âœ”ï¸ 15 13 * * 1    # Every Monday at 1:15 PM
âœ”ï¸ 45 4 * 1,2 0   # On Sundays in Jan & Feb at 4:45 AM
âœ”ï¸ 30 8 * * 1-5   # Weekdays (Monâ€“Fri) at 8:30 AM
âœ”ï¸ */5 * * * *    # Every 5 minutes
âœ”ï¸ 0 */6 * * *    # Every 6 hours

Special Characters
ğŸ‘‰ * â†’ any value (wildcard)
ğŸ‘‰ , â†’ list of values (1,15 â†’ 1st and 15th)
ğŸ‘‰ - â†’ range (1-5 â†’ Mon to Fri)
ğŸ‘‰ / â†’ step values (*/10 â†’ every 10 units)

ğŸŒŸ Special Keywords (Shortcuts)
ğŸ”— @reboot     # Run once, at startup
ğŸ”— @yearly     # Once a year (0 0 1 1 *)
ğŸ”— @monthly    # Once a month (0 0 1 * *)
ğŸ”— @weekly     # Once a week (0 0 * * 0)
ğŸ”— @daily      # Once a day (0 0 * * *)
ğŸ”— @hourly     # Once an hour (0 * * * *)

â¤ Output & Logging
By default, cron mails output to the user (if mail is configured).
To log output:
* * * * * /path/script.sh >> /var/log/cron.log 2>&1

ğŸ§  Insights
âš¡ Difference between cron and at command:
â¤ cron â†’ schedules repetitive tasks.
â¤ at â†’ schedules a one-time task.

âš¡ Crontab file location:
â¤ User-specific: /var/spool/cron/username
â¤ System-wide: /etc/crontab, /etc/cron.* directories.


ğŸ”· History Command
â¤ The history command shows the list of recently executed commands in the shell
â¤ Useful for re-executing, searching, and managing past commands.

ğŸ”¹ Basic Usage
ğŸ”— history            # list all recent commands
ğŸ”— history 10         # show last 10 commands
ğŸ”— !!                 # run last command
ğŸ”— !n                 # run the nth command from history
ğŸ”— !string            # run the most recent command starting with "string"

ğŸ”„ Managing History
ğŸ”— history -c         # clear history for current session
ğŸ”— history -d N       # delete the Nth command from history
ğŸ”— history -a         # append current sessionâ€™s commands to history file (~/.bash_history)

ğŸ”„History Variables
âœ”ï¸ $HISTSIZE â†’ number of commands stored in memory (default: 1000).
ğŸ”— echo $HISTSIZE

âœ”ï¸ $HISTFILESIZE â†’ max number of lines stored in history file (~/.bash_history) (default: 2000).
ğŸ”— echo $HISTFILESIZE

ğŸ”„ Searching History
Interactive reverse search:
Ctrl + r    # search backward in history
Ctrl + s    # search forward (if enabled)

Exit reverse search â†’ Ctrl + c or Ctrl + g.

ğŸ§  Insights (Interview Angle)
â¤ History is stored per user in ~/.bash_history.
â¤ Sensitive commands (like passwords in CLI) can get stored â€” security risk.
â¤ Can disable history logging temporarily:
ğŸ”— HISTSIZE=0

â¤ Use !$ to reference last argument of previous command.
cat file.txt
vim !$
ğŸ‘‰ Opens the same file.txt in vim.