ğŸ§ Linux Commands 
ğŸ”„ 1. Structure of a Linux Command
Format: command [options] [arguments]
â¤ command â†’ name of the program (e.g., cat, ls, ncal)
â¤ options â†’ modify the behavior of the command
    âœ”ï¸ short form â†’ -n
    âœ”ï¸ long form â†’ --number
â¤ arguments â†’ file, directory, or input on which the command operates
âš¡ Key Point: Options are case-sensitive and multiple options can be combined.

ğŸ”„ 2. File Viewing: cat
ğŸ”— cat abc.txt â†’ show file content
ğŸ”— cat -n abc.txt â†’ show content with line numbers (short option)
ğŸ”— cat --number abc.txt â†’ same, with long option
ğŸ’¡ Used for quick viewing, concatenating, or creating files.

ğŸ”„ 3. Directory Listing: ls
ğŸ”— ls â†’ list current directory contents
ğŸ”— ls -a â†’ show all files (including hidden, starting with .)
ğŸ”— ls -l â†’ long format (permissions, size, owner, date, etc.)
ğŸ”— ls -al or ls -la â†’ combine options: all files + long format
ğŸ’¡ Common in interviews: Explain what ls -al does.

ğŸ”„ 4. Calendar: ncal
ğŸ”— ncal â†’ show current month calendar
ğŸ”— ncal 2022 â†’ show full year 2022
ğŸ”— ncal july 2022 â†’ show July 2022
ğŸ”— ncal november 2022 -w â†’ show Nov 2022 with week numbers
ğŸ”— ncal -3 â†’ previous, current, and next month
ğŸ’¡ Interview Tip: Difference between cal (horizontal layout) vs ncal (vertical layout).

ğŸ”„ 5. Manual Pages: man
man cat â†’ shows detailed documentation of cat
man ls â†’ options for ls
Navigation inside man:
Space â†’ next page
b â†’ previous page
q â†’ quit

ğŸ’¡ Interview Tip: man is your go-to help tool in Linux.

ğŸ”„ 6. File Copy: cp
cp abc.txt abc2.txt â†’ copy abc.txt into abc2.txt
cp file1 file2 dir/ â†’ copy multiple files into directory
cp -r dir1 dir2 â†’ copy directories recursively

ğŸ”· Working with Files and Folders (Linux)
ğŸ“ Basic Navigation
ğŸ”— pwd â†’ print current working directory (absolute path)
ğŸ”— cd â†’ change directory
ğŸ”— cd / â†’ go to root directory
ğŸ”— cd .. â†’ move to parent directory
ğŸ”— cd ~ â†’ go to home directory
ğŸ”— cd /home/user/Documents â†’ navigate via absolute path
ğŸ”— cd Documents/ â†’ navigate via relative path

ğŸ’¡ Key Point:
â¤ Absolute path â†’ starts from / (root).
â¤ Relative path â†’ starts from current location.

ğŸ“‚ Listing Files
ğŸ”— ls -alh â†’ list all files (including hidden) in long format with human-readable sizes
ğŸ”— ls -t â†’ sort by time (newest first)
ğŸ”— ls -t -r â†’ sort by time (oldest first)
ğŸ”— ls -r â†’ sort in reverse order (alphabetical or as per option)
ğŸ”— ls temp/ â†’ list contents of temp/ folder

ğŸ“ Creating and Deleting
ğŸ”— mkdir temp/ â†’ create folder temp/
ğŸ”— rm -r temp/ â†’ remove folder temp/ recursively

ğŸ’¡ Safety Tip: Use rm -rf cautiously in interviews â€” interviewer may test your awareness of its danger.

ğŸ  Directory Structure Insight
ğŸ”— / â†’ root directory (top-level, contains everything)
ğŸ”— /home/ â†’ user directories (/home/ankur, /home/user)
ğŸ”— Other important system directories under / include:
ğŸ”— /bin â†’ essential binaries
ğŸ”— /etc â†’ configuration files
ğŸ”— /var â†’ variable data (logs, cache)
ğŸ”— /usr â†’ user-installed programs

ğŸ¯ Insights
â¤ Root vs Home â†’ / is system root, ~ is userâ€™s home.
â¤ ls -alh is a common test to check if you know hidden files (.) and human-readable sizes.
â¤ Recursive remove (rm -r) is dangerous â€” mention caution to score points.

âš¡nano food.txt â†’ edit file in-place
Ctrl + x â†’ save and exit

ğŸ”· TimeStamps:Modification, Access, and Change TimeStamps
we have a directory in which we have a file named food.txt.
ğŸ”— ls food.txt â†’ show file content
ğŸ”— ls -l food.txt â†’ show file modification time
ğŸ”— stat food.txt â†’ show file stats
ğŸ”— ls -lc â†’ shows the change time of the file
ğŸ”— ls -lu â†’ shows the access time of the file

ğŸ”· File Management Commands (Linux)
ğŸ“‚ Directory Management
ğŸ”— mkdir folderName â†’ create a directory
ğŸ”— rm folderName â†’ remove an empty directory
ğŸ”— mkdir folderName1 folderName2 folderName3 â†’ create multiple directories at once
ğŸ”— rm folderName1 folderName2 folderName3 â†’ remove multiple directories (empty only)
ğŸ”— rm -r folderName1 folderName2 folderName3 â†’ remove multiple directories recursively (including their contents)
ğŸ”— mkdir -p folderName1/folderName2/folderName3 â†’ create nested directories (parent dirs auto-created if missing)

ğŸ’¡ Interview Tip: rm -r is destructive. Always mention caution when using it.

ğŸ“„ File Creation & Time Management
ğŸ”— touch fileName
    âœ”ï¸ If file does not exist â†’ creates it
    âœ”ï¸ If file exists â†’ updates timestamps (access + modification time)
ğŸ”— touch -m fileName â†’ update only modification time
ğŸ”— touch -a fileName â†’ update only access time

ğŸ’¡ Common Test Question:
Difference between access time (atime) and modification time (mtime).
âœ”ï¸  atime â†’ last time file was read.
âœ”ï¸  mtime â†’ last time file content was modified.

ğŸ“Š File Type & Metadata
ğŸ”— file fileName â†’ shows file type and encoding (inspects content, not extension)

âœ… Example:
If fileName.txt contains:
Apple
Banana
Cherry

ğŸ”— Command: file fileName.txt
âœ… Output: ASCII text

ğŸ”— Example with misleading extension:
File: temp.mp4 (but contains text)
ğŸ”— Command: file temp.mp4
âœ… Output: ASCII text

ğŸ’¡ Interview Tip: Demonstrates Linux philosophy â€” file extensions donâ€™t determine file type; content does.

ğŸ“Œ Special Cases
touch 'a b' â†’ create a file with spaces in the name (quotes escape special characters)

ğŸ¯ Interview Insights
â¤ Difference between rm and rm -r â†’ recursive vs non-recursive.
â¤ Difference between mkdir and mkdir -p â†’ -p avoids errors when parent dirs donâ€™t exist.
â¤ touch command â†’ often asked: creates files and updates timestamps.
â¤ file command â†’ works on content, not extensions.

ğŸ”· Working with Nano
â¤ Nano is a simle, easyto-use text editor that operates within a terminal window.
â¤ If a file is not there, it creates and open it.

ğŸ”— nano food.txt

ğŸŒŸ Navigation inside the editor
â¤ Ctrl+ upKey â†’ move cursor up
â¤ Ctrl+ downKey â†’ move cursor down
â¤ Ctrl+ leftKey â†’ move cursor left
â¤ Ctrl+ rightKey â†’ move cursor right
â¤ Alt+G â†’ Go to a specific line, asks linenumber and columnnumber(1-based indexing)

ğŸŒŸ Basic Editing in Nano
â¤ Ctrl+Shift+C: Copy to global
â¤ Ctrl+Shift+V: Paste from global
â¤ Ctrl-K: Cut a line/selected(current line)
â¤ Alt+^: Copy the line/selected(current line)
â¤ Ctrl-U: Paste
â¤ Alt:U: Undo

ğŸŒŸ Searching/replace in nano
â¤ Ctrl+W - Search for a string or a regular expression(case in-sensitive).
â¤ Ctrl+\ - Replace a string

â¤ Ctrl + e â†’ move cursor to end of line
â¤ Ctrl + a â†’ move cursor to beginning of line
â¤ Ctrl + x â†’ Close the current file buffer and exit the editor
â¤ Ctrl + o â†’ write the current file to disk
â¤ Ctrl + q â†’ exit without saving

ğŸ”· File Operations

ğŸ‘‰ Removing the files
â¤ rm fileName â†’ remove a file
â¤ rm -d dirName â†’ remove only the empty directory
â¤ rm -r dirName â†’ remove a directory with its contents
â¤ rm file1 file2 dirName â†’ remove multiple files and directories

ğŸ‘‰ Moving and Copying
â¤ cp fileName1 fileName2 â†’ copy a file
â¤ cp -r dirName1 dirName2 â†’ copy a directory(copying recursively)
â¤ mv fileName1 fileName2 â†’ move a file
â¤ mv -r dirName1 dirName2 â†’ move a directory

ğŸ‘‰ Move and copy command can Rename the file or directory
â¤ mv another.mp4 ../horror/another_2012.mp4 â†’ move the another.mp4 to horror folder and changed its name to another_2012.mp4
â¤ cp another.mp4 ../horror/another_2012.mp4 â†’ copy the another.mp4 to horror folder and changed its name to another_2012.mp4

âš¡Key Insight: cp a.mp4 a â†’ copy the a.mp4 and paste to same directory and changed its name to a.mp4 but if a folder already exist then a.mp4 will be copied to that folder

ğŸ”· Working with cat Command
ğŸ”— cat fileName â†’ print the content of a file
ğŸ”— cat -n fileName â†’ print the content of a file with line numbers
ğŸ”— cat --number fileName â†’ same, with long option
ğŸ”— cat file1 file2 â†’ take file1 and file2 and concatenate them and show their content one after another.
ğŸ”— cat file1 file2 > file3 â†’ concatenate the content of file1 and file2 and put them inside the file3(overwrite)
ğŸ”— cat file1 file2 >> file3 â†’ concatenate the content of file1 and file2 and put them inside the file3(append)
ğŸ”— cat >> a.txt â†’  write the content then append to the a.txt use Ctrl+D to tell it is the end of the input then Ctrl+C to exit writing
ğŸ”— cat > a.txt â†’  write the content then overwrite to the a.txt use Ctrl+D to tell that it is the end of the input then use Ctrl+C to exit writing
ğŸ”— tac fileName â†’ vertically invert the contents of the file by lineNumber other workings are same as cat command just in reverse
ğŸ”— rev fileName â†’ reverse the content horizontally every line, vertical order is same 

â—Same things can be achived through echo command

ğŸ’¡ Interview Tip: cat is used for quick viewing, concatenating, or creating files.

ğŸ“Œ Special Cases
cat 'a b' â†’ print the content of a file with spaces in the name (quotes escape special characters)

ğŸ”· Viewing File Content in Linux
ğŸ“– 1. head â€“ View Beginning of File
ğŸ”— head foods.txt â†’ prints first 10 lines (default)
ğŸ”— head -n 5 foods.txt â†’ prints first 5 lines
ğŸ’¡ Useful for quickly checking file headers, configs, or log starts.

ğŸ“– 2. tail â€“ View End of File
ğŸ”— tail foods.txt â†’ prints last 10 lines (default)
ğŸ”— tail -n 5 foods.txt â†’ prints last 5 lines
ğŸ”— tail -f foods.txt â†’ prints last 10 lines and keeps watching for changes in real-time
ğŸ’¡ Commonly used for monitoring log files (tail -f /var/log/syslog).

ğŸ“– 3. less â€“ Scrollable File Viewer
ğŸ”— less foods.txt â†’ open file with navigation:
âœ”ï¸ Space / â†“ â†’ scroll down
âœ”ï¸ â†‘ / b â†’ scroll up
âœ”ï¸ /word â†’ search forward
âœ”ï¸ ?word â†’ search backward
âœ”ï¸ q â†’ quit
ğŸ’¡ Preferred over cat for large files (doesnâ€™t load everything into memory).

ğŸ¯ Interview Insights
â¤ Difference between head, tail, cat, less
    âœ”ï¸ cat â†’ dump full file
    âœ”ï¸ head/tail â†’ preview start/end
    âœ”ï¸ less â†’ navigate inside file efficiently
â¤ tail -f is often asked â†’ used in real-time log monitoring (very common in DevOps/production).

â¤ Combination usage:
    âœ”ï¸ head -n 20 file | tail -n 5 â†’ prints lines 16â€“20.

ğŸ”· Standard Output (stdout) & Standard Error (stderr) in Linux
ğŸ“ Basics

â¤ Every command/program produces:
    âœ”ï¸ stdout (1) â†’ normal output (default stream)
    âœ”ï¸ stderr (2) â†’ error messages
ğŸ’¡ By default, both are displayed in the terminal.

ğŸ“‚ Redirection Operators
â¤ > â†’ redirect (overwrite)
â¤ >> â†’ append

ğŸ“– Redirecting Standard Output
â¤ ls > a.txt â†’ redirect output to a.txt (overwrite if exists)
â¤ ls >> a.txt â†’ append output to a.txt
ğŸ’¡ Stream number 1 (stdout) is implied.
So ls > a.txt â‰¡ ls 1> a.txt

ğŸ“– Redirecting Standard Error
â¤ ls -z 2> a.txt â†’ redirect errors only into a.txt
â¤ ls -z 2>> a.txt â†’ append errors only into a.txt
ğŸ’¡ 2 explicitly denotes stderr.

ğŸ“– Redirecting Both stdout and stderr
â¤ ls -z > output.txt 2> error.tx
    âœ”ï¸ stdout â†’ output.tx
    âœ”ï¸ stderr â†’ error.tx
â¤ ls -z >> output.txt 2>> error.tx
    âœ”ï¸ append stdout â†’ output.tx
    âœ”ï¸ append stderr â†’ error.txt

ğŸ¯ Interview Insights
â¤ Stream numbers:
    âœ”ï¸ 0 â†’ stdin (input)
    âœ”ï¸ 1 â†’ stdout (output)
    âœ”ï¸ 2 â†’ stderr (errors)
Default: > means 1> unless otherwise specified.

ğŸ”· sort Command in Linux
The sort command is used to arrange lines of text in files or input streams.

âš¡Syntax: sort [options] fileName

ğŸ“– Common Options
ğŸ”— sort fileName â†’ sort file content in ascending (alphabetical) order
ğŸ”— sort -r fileName â†’ sort in reverse (descending) order
ğŸ”— sort -n fileName â†’ sort numerically (instead of alphabetically)
ğŸ”— sort -nr fileName â†’ sort numerically in reverse order
ğŸ”— sort -u fileName â†’ sort and remove duplicates

ğŸ“Š Sorting by Column
ğŸ”— sort -k5h fileName â†’ sort using 5th column, numbers in human-readable format (K, M, G, etc.)
ğŸ”— sort -k5hr fileName â†’ sort by 5th column, human-readable, in reverse order
ğŸ’¡ Example with ls -alh output: ls -alh | sort -k5h
Sorts files by size (column 5).

ğŸ¯ Interview Insights
â¤ Default behavior: sorts alphabetically (lexicographic order).
â¤ -n is important â€” without it, 10 comes before 2 (alphabetical).
â¤ -u is often tested for removing duplicates.
â¤ Column sorting (-k) is frequently used with commands like ls, ps, and df.
â¤ Human-readable (-h) helps when sorting sizes with suffixes (K, M, G).

ğŸ”· Pipe Operator (|) in Linux
â¤ The pipe (|) operator takes the output of one command and uses it as the input to another command.
â¤ Enables command chaining without creating intermediate files.

ğŸ“– Example â€“ Without Pipe
ls -lh >> files        # save directory listing to 'files'
sort -k5hr files       # sort by 5th column (size) in reverse

ğŸ“– Example â€“ With Pipe
ğŸ”— ls -lh | sort -k5hr >> files

â¤ ls -lh â†’ list files with human-readable sizes
â¤ sort -k5hr â†’ sort by size (descending)
â¤ >> files â†’ append result to files
ğŸ’¡ Pipe makes it a single streamlined command.

ğŸ“– Multiple Pipes
You can chain multiple pipes:
ps aux | sort -k3nr | head -n 5

â¤ ps aux â†’ list running processes
â¤ sort -k3nr â†’ sort by CPU usage (column 3, numeric, reverse)
â¤ head -n 5 â†’ show top 5 CPU-consuming processes

ğŸ¯ Interview Insights
â¤ Pipe vs Redirection:
    âœ”ï¸ > / >> â†’ redirect output to a file
    âœ”ï¸ | â†’ send output directly to another command
Common usage:
â¤ ls | grep txt â†’ list only .txt files
â¤ dmesg | less â†’ scroll through logs
â¤ cat file | wc -l â†’ count lines in a file

ğŸ”· Searching in Linux â€“ grep Command

ğŸ“ Basic Usage: grep "pattern" fileName
â¤ Searches pattern inside fileName.
â¤ Case-sensitive by default.
â¤ Use double quotes to protect special characters (*, ?, |).

ğŸ“– Common Options
âœ”ï¸ -i â†’ ignore case
ğŸ”— grep -i "error" logs.txt

âœ”ï¸ -c â†’ count matches (integer only)
ğŸ”— grep -ic "error" logs.txt

âœ”ï¸ -w â†’ match whole word only (not substrings)
ğŸ”— grep -iw "cat" animals.txt   # matches "cat", not "concatenate"

âœ”ï¸ -n â†’ show line numbers of matches
ğŸ”— grep -in "error" logs.txt

ğŸ“– Context Options
âœ”ï¸ -B n â†’ show n lines before match
âœ”ï¸ -A n â†’ show n lines after match
âœ”ï¸ -C n â†’ show n lines before & after match

âœ… Examples:
ğŸ”— grep -iB2 "error" app.log    # 2 lines before match
ğŸ”— grep -iA2 "error" app.log    # 2 lines after match
ğŸ”— grep -iC2 "error" app.log    # 2 lines before & after
ğŸ”— grep -iB2 -A3 "error" app.log  # 2 before, 3 after

ğŸ“– Recursive Search
Search in all files under a directory:

ğŸ”— grep -r "pattern" dirName
ğŸ”— grep -r "pattern"   # searches in current directory

ğŸ“– Multiple Files
ğŸ”— grep "pattern" file1 file2

ğŸ“– Combination with Other Commands
ğŸ”— ls -lh | grep "txt" â†’ show only .txt files
ğŸ”— tail -f app.log | grep "error" -C10 â†’ live monitor logs, showing 10 lines before & after each "error"

ğŸ¯ Insights
â¤ Pipe + grep is a favorite interview question â†’ e.g., ps aux | grep java
â¤ Regex supported â†’ grep -E "cat|dog" (use -E for extended regex)
â¤ grep â†’ basic regex
â¤ egrep (or grep -E) â†’ extended regex (+, ?, {})
â¤ fgrep (or grep -F) â†’ fixed string search, no regex (faster)

â—Common traps:
âš¡ Forgetting quotes â†’ shell may expand special characters before grep sees them.
âš¡ Case sensitivity â†’ by default grep is case-sensitive.
âš¡ Large log search â†’ always combine with tail -f or less for efficiency.

ğŸ”· Arithmetic Operations and Expressions in Linux
ğŸ”— $(command) â†’ Command substitution (runs a command inside).
ğŸ”— $((expression)) â†’ Arithmetic expansion (evaluates math expressions).

ğŸ”— Arithmetic with $(( ))
âœ”ï¸ echo $((2 + 3))    # 5
âœ”ï¸ echo $((2 * 3))    # 6
âœ”ï¸ echo $((2 - 3))    # -1
âœ”ï¸ echo $((2 / 3))    # 0 â†’ integer division only
âœ”ï¸ echo $((2 % 3))    # 2 â†’ modulo operator
âœ”ï¸ echo $((2**3))     # 8 â†’ exponentiation


âš¡ Key Insights:
Integer-only: $(( )) supports only integers, not decimals.
For floating-point, use bc:
âœ”ï¸ echo "2/3" | bc -l    # 0.666666...

You can also use variables inside:
a=10; b=3
âœ”ï¸ echo $((a + b))    # 13

ğŸ”— Command Substitution $( )
Runs a command inside, not math:

ğŸ”— echo $(pwd)     # prints current directory
ğŸ”— echo $(date)    # prints current date

ğŸ”— Logical Chaining in Linux

ğŸ‘‰; â†’ Always runs commands sequentially
ğŸ”— d Downloads/ ; ls

ğŸ‘‰ â†’ Even if cd fails, ls runs.
ğŸ‘‰ && â†’ Run second only if first succeeds

ğŸ”— cd Downloads/ && ls â†’ If cd works, then list contents.

ğŸ‘‰ || â†’ Run second only if first fails 
ğŸ”— cd Downloads/ || ls
âœ”ï¸ If cd fails, then run ls in current dir.

ğŸ¯ Interview Insights
â¤ $(( )) is faster than using expr command (old style).
â¤ Donâ€™t confuse $( ) vs $(( )):
    âœ”ï¸ $( ) â†’ run command
    âœ”ï¸ $(( )) â†’ run math

â¤ let is another way but less preferred:
let x=2+3
echo $x   # 5


ğŸ”· Linux Terminal Shortcuts
âŒ¨ï¸ Navigation
ğŸ‘‰ Ctrl + A â†’ Move to beginning of line
ğŸ‘‰ Ctrl + E â†’ Move to end of line
ğŸ‘‰ Alt + B â†’ Move one word backward
ğŸ‘‰ Alt + F â†’ Move one word forward

ğŸ“ Editing
ğŸ‘‰ Ctrl + K â†’ Delete from cursor to end of line
ğŸ‘‰ Ctrl + U â†’ Delete from cursor to beginning of line
ğŸ‘‰ Ctrl + W â†’ Delete word backwards (up to space)
ğŸ‘‰ Alt + D â†’ Delete word forwards (up to space)
ğŸ‘‰ Ctrl + Y â†’ Paste last cut text (yank)

ğŸ” History & Searc
ğŸ‘‰ Ctrl + R â†’ Reverse search through history ((reverse-i-search)
ğŸ‘‰ Ctrl + G â†’ Exit history search without running a comman
ğŸ‘‰ â†‘ / â†“ â†’ Navigate through command history

ğŸ–¥ï¸ Screen Control
ğŸ‘‰ Ctrl + L â†’ Clear screen (like clear)
ğŸ‘‰ Ctrl + D â†’ Logout / exit terminal (EOF signal)
ğŸ‘‰ Ctrl + Z â†’ Suspend current job (can resume with fg)

ğŸ”— Tabs & Session
ğŸ‘‰ Ctrl + Alt + T â†’ Open new terminal windo
ğŸ‘‰ Ctrl + Shift + T â†’ Open new terminal tab (in supporting terminals like GNOME)

ğŸ”¤ Font & Display
ğŸ‘‰ Ctrl + Shift + â€œ+â€ â†’ Increase font size
ğŸ‘‰ Ctrl + â€œ-â€ â†’ Decrease font size
ğŸ‘‰ Ctrl + 0 â†’ Reset font size

âš¡ Productivity Boosters
ğŸ‘‰ Tab â†’ Auto-complete command/file names
ğŸ‘‰ Tab Tab â†’ Show all possible completions
ğŸ‘‰ !! â†’ Run last command again
ğŸ‘‰ !<word> â†’ Run last command starting with <word> (e.g., !ls)
ğŸ‘‰ Ctrl + C â†’ Kill current process
ğŸ‘‰ Ctrl + Shift + C â†’ Copy text
ğŸ‘‰ Ctrl + Shift + V â†’ Paste text

ğŸ¯ Insights
Ctrl + D vs Ctrl + C
Ctrl + D â†’ End Of File (exit shell if nothing to read).
Ctrl + C â†’ Interrupt/kill the running process.
Job Control (Ctrl + Z, fg, bg) is a hidden gem often asked in interviews.


ğŸ”· Find Command in Linux
ğŸ‘‰ Used to search for files/directories in a given path with conditions.
ğŸ‘‰ Syntax: find [path...] [expression]

ğŸ‘‰ Case-sensitive by default â†’ use -iname for case-insensitive search.

ğŸŒŸ Wildcard Characters in find -name
* â†’ Any number of characters
? â†’ Any single character
[abc] â†’ Matches a, b, or c
[!abc] â†’ Matches anything except a, b, or c
[0-9] â†’ Any digit from 0â€“9
[!0-9] â†’ Not a digit

âœ… Examples:
ğŸ‘‰ ğŸ”— find . -name "*.txt" â†’ Find all text files in the current directory

ğŸ”¹ Search by Type
ğŸ”— find /path -type f -name "*.txt"   # files
ğŸ”— find /path -type d -name "*.txt"   # directories

ğŸ”¹ Search by Size
ğŸ”— find /path -type f -size +100k -size -200k   # files between 100KBâ€“200KB
ğŸ”— find /path -type d -size +1M                 # directories > 1MB

ğŸ”¹ Search by Time
âœ”ï¸ -mmin / -mtime â†’ Modified time
âœ”ï¸ -amin / -atime â†’ Accessed time
âœ”ï¸ -cmin / -ctime â†’ Metadata changed

â¤ Note: min gives minutes and time is in days
âœ… Examples:
ğŸ”— find /path -mtime -7    # modified in last 7 days
ğŸ”— find /path -mtime +7    # modified more than 7 days ago
ğŸ”— find /path -mtime 7     # modified exactly 7 days ago
ğŸ”— find /path -mmin -30    # modified in last 30 minutes

ğŸ”¹ Logical Operators
ğŸ”— find /path -type f -name "*.txt" -size +100k -mtime -7   # AND condition
ğŸ”— find /path \( -name "*.txt" -o -name "*.pdf" \)          # OR condition
ğŸ”— find /path ! -name "*.txt"   # NOT condition

ğŸ”¹ Empty Files/Directories
ğŸ”— find /path -type f -empty    # empty files
ğŸ”— find /path -type d -empty    # empty directories

ğŸ”¹ Execute Commands on Results
ğŸ”— find /path -name "*.txt" -exec cat {} \;    # run `cat` on each file
ğŸ”— find /path -empty -exec rm -rf {} \;        # delete empty files/dirs
âœ”ï¸ {} â†’ placeholder for current file
âœ”ï¸ \; â†’ end of exec command

ğŸ”¹ Using xargs
ğŸ”— find . -name "*.log" | xargs rm     # delete all .log files
ğŸ”— find . | xargs file                 # run `file` command on each

ğŸ”¹ -exec vs xargs
â¤ -exec â†’ runs inside find, handles spaces/special chars safely
â¤ xargs â†’ more efficient for bulk operations, but may fail on files with spaces/newlines

ğŸ”· Permissions in Linux
lrwxrwxrwx
l can be:
    â¤ - â†’ regular file
    â¤ l- â†’ symbolic link
    â¤ d â†’ directory
    â¤ b â†’ block device file
    â¤ c â†’ character device file
    â¤ p â†’ named pipe
    â¤ s â†’ socket

ğŸŒŸ Permission Bits (rwx)
â¤ r â†’ Read
    âœ”ï¸ File: allows viewing contents
    âœ”ï¸ Directory: allows listing files (ls)

â¤ w â†’ Write
    âœ”ï¸ File: allows modifying contents
    âœ”ï¸ Directory: allows adding/removing files

â¤ x â†’ Execute
    âœ”ï¸ File: allows executing as a program/script
    âœ”ï¸ Directory: allows entering (cd) and accessing metadata

possibilities of characters:
â¤ first character: r or -
â¤ second character: w or -
â¤ third character: x or -   

ğŸŒŸ Permission Groups (3 sets of 3 bits = 9 characters)
âœ… Example: -rwxr-xr--
ğŸ‘‰ Owner (User): first 3 bits â†’ rwx
ğŸ‘‰ Group: next 3 bits â†’ r-x
ğŸ‘‰ Others: last 3 bits â†’ r--

rest 9 characters will be divided into three groups: rwx,rwx,rwx
â¤ first set of 3 characters â†’ owner permissions
â¤ second set of 3 characters â†’ group permissions
â¤ third set of 3 characters â†’ other permissions


ğŸ”· Changing the Permissions chmod command
