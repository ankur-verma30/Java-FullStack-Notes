Linux Operating System (OS)?
👉 Linux is a community-driven OS, not owned by any single company.
👉 Linux is free and open-source, allowing customization and flexibility.
👉 Linux is highly secure, eliminating the need for antivirus software.
👉 Linux is primarily CLI-based (Command Line Interface), offering powerful control over the system.
👉 Linux is widely used in businesses for efficient server management and enterprise solutions.

Different Types of Linux Distributions:
➤ Amazon Linux​
➤ Ubuntu​
➤ Red Hat​
➤ Debian​
➤ Kali​
➤ Fedora​
➤ CentOS​

🐧 Linux Commands 
🔄 1. Structure of a Linux Command
Format: command [options] [arguments]
➤ command → name of the program (e.g., cat, ls, ncal)
➤ options → modify the behavior of the command
    ✔️ short form → -n
    ✔️ long form → --number
➤ arguments → file, directory, or input on which the command operates
⚡ Key Point: Options are case-sensitive and multiple options can be combined.

🔄 2. File Viewing: cat
➤ cat (short for concatenate) is one of the most frequently used commands in Linux.
➤ It is used to create, view, concatenate, and redirect files.

🔹 Syntax: cat [options] [file...]

🔹 Key Options
✔️ -n → Number all output lines
✔️ -b → Number only non-blank lines
✔️ -s → Squeeze (remove) repeated empty lines
✔️ -E → Show end of line ($)
✔️ -T → Show TAB characters as ^I
✔️ -v → Show non-printing characters (useful for debugging hidden characters)

🔗 cat file.txt  # print the content of a file
🔗 cat file1.txt file2.txt  #Display multiple files
🔗 cat > newFile.txt  #Create a new file
👉Type text, then press Ctrl+D to save and exit

🔗 cat >> existing.txt  #Append text to an existing file
🔗 cat file1.txt file2.txt > newFile.txt  #Redirect the output of multiple files to a new file
🔗 cat file1 >> file2  #Append the content of file1 to file2
👉It can create the newFile if it does not exist for both append (>>) and overwrite (>).

🔗 cat -n file.txt  #Print the content of a file with line numbers
🔗 cat -s filex.txt  #Remove blank lines and display
🔗 cat -T file.txt  #Print the content of a file with tabs as ^i
🔗 cat -E file.txt  #Print the content of a file with line endings$(debugging whitespace issues)

🔶 Tricky Questions on cat
🧠 Q: What happens if you run cat > file.txt?
✔️ 👉 It will overwrite the file and wait for user input. Typing text followed by CTRL+D saves it. (If you press Enter multiple times, those newlines are also saved).

🧠 Q: Difference between cat file1 > file2 and cat file1 >> file2?
✔️ 👉 > overwrites file2 with contents of file1.
👉 >> appends contents of file1 to file2.

🧠 Q: Can cat be used to create an empty file?
✔️ 👉 Yes:
🔗 cat > empty.txt     # press CTRL+D immediately
Or simply:
🔗 > empty.txt   # preferred method

🧠 Q: Explain the difference between cat file | less and less file.
✔️ 👉 Functionally similar, but less file is directly efficient (less opens file itself).
👉 cat file | less is a Useless Use of Cat (UUOC) 

🧠 Q: How do you display line numbers only for non-empty lines using cat?
✔️ 👉 🔗 cat -b file.txt

🧠 Q: How can you display hidden characters (like tabs, end-of-line, non-printable)?
✅ 👉
🔗 cat -T file.txt   # shows tabs
🔗 cat -E file.txt   # shows end of lines
🔗 cat -v file.txt   # shows non-printable chars

💡 Interview Tip: cat is mainly for concatenating & small file viewing.

🔄 3. Directory Listing: ls
🔗 ls → list current directory contents
🔗 ls -a → show all files (including hidden, starting with .)
🔗 ls -l → long format (permissions, size, owner, date, etc.)
🔗 ls -al or ls -la → combine options: all files + long format
💡 Common in interviews: Explain what ls -al does.

🔄 4. Calendar: ncal
🔗 ncal → show current month calendar
🔗 ncal 2022 → show full year 2022
🔗 ncal july 2022 → show July 2022
🔗 ncal november 2022 -w → show Nov 2022 with week numbers
🔗 ncal -3 → previous, current, and next month
💡 Interview Tip: Difference between cal (horizontal layout) vs ncal (vertical layout).

🔄 5. Manual Pages: man
man cat → shows detailed documentation of cat
man ls → options for ls
Navigation inside man:
Space → next page
b → previous page
q → quit

💡 Interview Tip: man is your go-to help tool in Linux.

🔄 6. File Copy: cp
cp abc.txt abc2.txt → copy abc.txt into abc2.txt
cp file1 file2 dir/ → copy multiple files into directory
cp -r dir1 dir2 → copy directories recursively

🔷 Working with Files and Folders (Linux)
📍 Basic Navigation
🔗 pwd → print current working directory (absolute path)
🔗 cd → change directory
🔗 cd / → go to root directory
🔗 cd .. → move to parent directory
🔗 cd ~ → go to home directory
🔗 cd /home/user/Documents → navigate via absolute path
🔗 cd Documents/ → navigate via relative path

💡 Key Point:
➤ Absolute path → starts from / (root).
➤ Relative path → starts from current location.

📂 Listing Files
🔗 ls -alh → list all files (including hidden) in long format with human-readable sizes
🔗 ls -t → sort by time (newest first)
🔗 ls -t -r → sort by time (oldest first)
🔗 ls -r → sort in reverse order (alphabetical or as per option)
🔗 ls temp/ → list contents of temp/ folder

📁 Creating and Deleting
🔗 mkdir temp/ → create folder temp/
🔗 rm -r temp/ → remove folder temp/ recursively

💡 Safety Tip: Use rm -rf cautiously in interviews — interviewer may test your awareness of its danger.

🏠 Directory Structure Insight
🔗 / → root directory (top-level, contains everything)
🔗 /home/ → user directories (/home/ankur, /home/user)
🔗 Other important system directories under / include:
🔗 /bin → essential binaries
🔗 /etc → configuration files
🔗 /var → variable data (logs, cache)
🔗 /usr → user-installed programs

🎯 Insights
➤ Root vs Home → / is system root, ~ is user’s home.
➤ ls -alh is a common test to check if you know hidden files (.) and human-readable sizes.
➤ Recursive remove (rm -r) is dangerous — mention caution to score points.

⚡nano food.txt → edit file in-place
Ctrl + x → save and exit

🔷 TimeStamps:Modification, Access, and Change TimeStamps
we have a directory in which we have a file named food.txt.
🔗 ls food.txt → show file content
🔗 ls -l food.txt → show file modification time
🔗 stat food.txt → show file stats
🔗 ls -lc → shows the change time of the file
🔗 ls -lu → shows the access time of the file

🔷 File Management Commands (Linux)
📂 Directory Management
🔗 mkdir folderName → create a directory
🔗 rm folderName → remove an empty directory
🔗 mkdir folderName1 folderName2 folderName3 → create multiple directories at once
🔗 rm folderName1 folderName2 folderName3 → remove multiple directories (empty only)
🔗 rm -r folderName1 folderName2 folderName3 → remove multiple directories recursively (including their contents)
🔗 mkdir -p folderName1/folderName2/folderName3 → create nested directories (parent dirs auto-created if missing)
🔗 rmdir foldername → Used to remove (delete) empty directory.
🔗 rmdir folder1 folder2 → Used to remove (delete) empty directories.
🔗 rmdir -p a/b/c → remove nested empty directories (removes c, then b, then a if empty)


💡 Interview Tip: rm -r is destructive. Always mention caution when using it.

📄 File Creation & Time Management
🔗 touch fileName
    ✔️ If file does not exist → creates it
    ✔️ If file exists → updates timestamps (access + modification time)
🔗 touch -m fileName → update only modification time
🔗 touch -a fileName → update only access time

💡 Common Test Question:
Difference between access time (atime) and modification time (mtime).
✔️  atime → last time file was read.
✔️  mtime → last time file content was modified.

📊 File Type & Metadata
🔗 file fileName → shows file type and encoding (inspects content, not extension)

✅ Example:
If fileName.txt contains:
Apple
Banana
Cherry

🔗 Command: file fileName.txt
✅ Output: ASCII text

🔗 Example with misleading extension:
File: temp.mp4 (but contains text)
🔗 Command: file temp.mp4
✅ Output: ASCII text

💡 Interview Tip: Demonstrates Linux philosophy — file extensions don’t determine file type; content does.

📌 Special Cases
touch 'a b' → create a file with spaces in the name (quotes escape special characters)

🎯 Interview Insights
➤ Difference between rm and rm -r → recursive vs non-recursive.
➤ Difference between mkdir and mkdir -p → -p avoids errors when parent dirs don’t exist.
➤ touch command → often asked: creates files and updates timestamps.
➤ file command → works on content, not extensions.

🔷 Working with Nano
➤ Nano is a simle, easyto-use text editor that operates within a terminal window.
➤ If a file is not there, it creates and open it.

🔗 nano food.txt

🌟 Navigation inside the editor
➤ Ctrl+ upKey → move cursor up
➤ Ctrl+ downKey → move cursor down
➤ Ctrl+ leftKey → move cursor left
➤ Ctrl+ rightKey → move cursor right
➤ Alt+G → Go to a specific line, asks linenumber and columnnumber(1-based indexing)

🌟 Basic Editing in Nano
➤ Ctrl+Shift+C: Copy to global
➤ Ctrl+Shift+V: Paste from global
➤ Ctrl-K: Cut a line/selected(current line)
➤ Alt+^: Copy the line/selected(current line)
➤ Ctrl-U: Paste
➤ Alt:U: Undo

🌟 Searching/replace in nano
➤ Ctrl+W - Search for a string or a regular expression(case in-sensitive).
➤ Ctrl+\ - Replace a string

➤ Ctrl + e → move cursor to end of line
➤ Ctrl + a → move cursor to beginning of line
➤ Ctrl + x → Close the current file buffer and exit the editor
➤ Ctrl + o → write the current file to disk
➤ Ctrl + q → exit without saving

🔷 File Operations
👉 Removing the files
➤ rm fileName → remove a file
➤ rm -d dirName → remove only the empty directory
➤ rm -r dirName → remove a directory with its contents
➤ rm file1 file2 dirName → remove multiple files and directories

👉 Moving and Copying
➤ cp fileName1 fileName2 → copy a file
➤ cp -r dirName1 dirName2 → copy a directory(copying recursively)
➤ mv fileName1 fileName2 → move a file
➤ mv -r dirName1 dirName2 → move a directory

👉 Move and copy command can Rename the file or directory
➤ mv another.mp4 ../horror/another_2012.mp4 → move the another.mp4 to horror folder and changed its name to another_2012.mp4
➤ cp another.mp4 ../horror/another_2012.mp4 → copy the another.mp4 to horror folder and changed its name to another_2012.mp4

⚡Key Insight: cp a.mp4 a → copy the a.mp4 and paste to same directory and changed its name to a.mp4 but if a folder already exist then a.mp4 will be copied to that folder

🔷 Working with cat Command
🔗 cat fileName → print the content of a file
🔗 cat -n fileName → print the content of a file with line numbers
🔗 cat --number fileName → same, with long option
🔗 cat file1 file2 → take file1 and file2 and concatenate them and show their content one after another.
🔗 cat file1 file2 > file3 → concatenate the content of file1 and file2 and put them inside the file3(overwrite)
🔗 cat file1 file2 >> file3 → concatenate the content of file1 and file2 and put them inside the file3(append)
🔗 cat >> a.txt →  write the content then append to the a.txt use Ctrl+D to tell it is the end of the input then Ctrl+C to exit writing
🔗 cat > a.txt →  write the content then overwrite to the a.txt use Ctrl+D to tell that it is the end of the input then use Ctrl+C to exit writing
🔗 tac fileName → vertically invert the contents of the file by lineNumber other workings are same as cat command just in reverse
🔗 rev fileName → reverse the content horizontally every line, vertical order is same 

❗Same things can be achived through echo command

💡 Interview Tip: cat is used for quick viewing, concatenating, or creating files.

📌 Special Cases
cat 'a b' → print the content of a file with spaces in the name (quotes escape special characters)

🔷 Viewing File Content in Linux
📖 1. head – View Beginning of File
🔗 head foods.txt → prints first 10 lines (default)
🔗 head -n 5 foods.txt → prints first 5 lines
💡 Useful for quickly checking file headers, configs, or log starts.

📖 2. tail – View End of File
🔗 tail foods.txt → prints last 10 lines (default)
🔗 tail -n 5 foods.txt → prints last 5 lines
🔗 tail -f foods.txt → prints last 10 lines and keeps watching for changes in real-time
💡 Commonly used for monitoring log files (tail -f /var/log/syslog).

📖 3. less – Scrollable File Viewer
🔗 less foods.txt → open file with navigation:
✔️ Space / ↓ → scroll down
✔️ ↑ / b → scroll up
✔️ /word → search forward
✔️ ?word → search backward
✔️ q → quit
💡 Preferred over cat for large files (doesn’t load everything into memory).

🎯 Interview Insights
➤ Difference between head, tail, cat, less
    ✔️ cat → dump full file
    ✔️ head/tail → preview start/end
    ✔️ less → navigate inside file efficiently
➤ tail -f is often asked → used in real-time log monitoring (very common in DevOps/production).

➤ Combination usage:
    ✔️ head -n 20 file | tail -n 5 → prints lines 16–20.

🔷 Standard Output (stdout) & Standard Error (stderr) in Linux
📍 Basics

➤ Every command/program produces:
    ✔️ stdout (1) → normal output (default stream)
    ✔️ stderr (2) → error messages
💡 By default, both are displayed in the terminal.

📂 Redirection Operators
➤ > → redirect (overwrite)
➤ >> → append

📖 Redirecting Standard Output
➤ ls > a.txt → redirect output to a.txt (overwrite if exists)
➤ ls >> a.txt → append output to a.txt
💡 Stream number 1 (stdout) is implied.
So ls > a.txt ≡ ls 1> a.txt

📖 Redirecting Standard Error
➤ ls -z 2> a.txt → redirect errors only into a.txt
➤ ls -z 2>> a.txt → append errors only into a.txt
💡 2 explicitly denotes stderr.

📖 Redirecting Both stdout and stderr
➤ ls -z > output.txt 2> error.tx
    ✔️ stdout → output.tx
    ✔️ stderr → error.tx
➤ ls -z >> output.txt 2>> error.tx
    ✔️ append stdout → output.tx
    ✔️ append stderr → error.txt

🎯 Interview Insights
➤ Stream numbers:
    ✔️ 0 → stdin (input)
    ✔️ 1 → stdout (output)
    ✔️ 2 → stderr (errors)
Default: > means 1> unless otherwise specified.

🔷 sort Command in Linux
The sort command is used to arrange lines of text in files or input streams.

⚡Syntax: sort [options] fileName

📖 Common Options
🔗 sort fileName → sort file content in ascending (alphabetical) order
🔗 sort -r fileName → sort in reverse (descending) order
🔗 sort -n fileName → sort numerically (instead of alphabetically)
🔗 sort -nr fileName → sort numerically in reverse order
🔗 sort -u fileName → sort and remove duplicates

📊 Sorting by Column
🔗 sort -k5h fileName → sort using 5th column, numbers in human-readable format (K, M, G, etc.)
🔗 sort -k5hr fileName → sort by 5th column, human-readable, in reverse order
💡 Example with ls -alh output: ls -alh | sort -k5h
Sorts files by size (column 5).

🎯 Interview Insights
➤ Default behavior: sorts alphabetically (lexicographic order).
➤ -n is important — without it, 10 comes before 2 (alphabetical).
➤ -u is often tested for removing duplicates.
➤ Column sorting (-k) is frequently used with commands like ls, ps, and df.
➤ Human-readable (-h) helps when sorting sizes with suffixes (K, M, G).

🔷 Pipe Operator (|) in Linux
➤ The pipe (|) operator takes the output of one command and uses it as the input to another command.
➤ Enables command chaining without creating intermediate files.

📖 Example – Without Pipe
ls -lh >> files        # save directory listing to 'files'
sort -k5hr files       # sort by 5th column (size) in reverse

📖 Example – With Pipe
🔗 ls -lh | sort -k5hr >> files

➤ ls -lh → list files with human-readable sizes
➤ sort -k5hr → sort by size (descending)
➤ >> files → append result to files
💡 Pipe makes it a single streamlined command.

📖 Multiple Pipes
You can chain multiple pipes:
ps aux | sort -k3nr | head -n 5

➤ ps aux → list running processes
➤ sort -k3nr → sort by CPU usage (column 3, numeric, reverse)
➤ head -n 5 → show top 5 CPU-consuming processes

🎯 Interview Insights
➤ Pipe vs Redirection:
    ✔️ > / >> → redirect output to a file
    ✔️ | → send output directly to another command
Common usage:
➤ ls | grep txt → list only .txt files
➤ dmesg | less → scroll through logs
➤ cat file | wc -l → count lines in a file

🔷 Searching in Linux – grep Command

📍 Basic Usage: grep "pattern" fileName
➤ Searches pattern inside fileName.
➤ Case-sensitive by default.
➤ Use double quotes to protect special characters (*, ?, |).

📖 Common Options
✔️ -i → ignore case
🔗 grep -i "error" logs.txt

✔️ -c → count matches (integer only)
🔗 grep -ic "error" logs.txt

✔️ -w → match whole word only (not substrings)
🔗 grep -iw "cat" animals.txt   # matches "cat", not "concatenate"

✔️ -n → show line numbers of matches
🔗 grep -in "error" logs.txt

📖 Context Options
✔️ -B n → show n lines before match
✔️ -A n → show n lines after match
✔️ -C n → show n lines before & after match

✅ Examples:
🔗 grep -iB2 "error" app.log    # 2 lines before match
🔗 grep -iA2 "error" app.log    # 2 lines after match
🔗 grep -iC2 "error" app.log    # 2 lines before & after
🔗 grep -iB2 -A3 "error" app.log  # 2 before, 3 after

📖 Recursive Search
Search in all files under a directory:

🔗 grep -r "pattern" dirName
🔗 grep -r "pattern"   # searches in current directory

📖 Multiple Files
🔗 grep "pattern" file1 file2

📖 Combination with Other Commands
🔗 ls -lh | grep "txt" → show only .txt files
🔗 tail -f app.log | grep "error" -C10 → live monitor logs, showing 10 lines before & after each "error"

🎯 Insights
➤ Pipe + grep is a favorite interview question → e.g., ps aux | grep java
➤ Regex supported → grep -E "cat|dog" (use -E for extended regex)
➤ grep → basic regex
➤ egrep (or grep -E) → extended regex (+, ?, {})
➤ fgrep (or grep -F) → fixed string search, no regex (faster)

❗Common traps:
⚡ Forgetting quotes → shell may expand special characters before grep sees them.
⚡ Case sensitivity → by default grep is case-sensitive.
⚡ Large log search → always combine with tail -f or less for efficiency.

🔷 Arithmetic Operations and Expressions in Linux
🔗 $(command) → Command substitution (runs a command inside).
🔗 $((expression)) → Arithmetic expansion (evaluates math expressions).

🔗 Arithmetic with $(( ))
✔️ echo $((2 + 3))    # 5
✔️ echo $((2 * 3))    # 6
✔️ echo $((2 - 3))    # -1
✔️ echo $((2 / 3))    # 0 → integer division only
✔️ echo $((2 % 3))    # 2 → modulo operator
✔️ echo $((2**3))     # 8 → exponentiation


⚡ Key Insights:
Integer-only: $(( )) supports only integers, not decimals.
For floating-point, use bc:
✔️ echo "2/3" | bc -l    # 0.666666...

You can also use variables inside:
a=10; b=3
✔️ echo $((a + b))    # 13

🔗 Command Substitution $( )
Runs a command inside, not math:

🔗 echo $(pwd)     # prints current directory
🔗 echo $(date)    # prints current date

🔗 Logical Chaining in Linux

👉; → Always runs commands sequentially
🔗 d Downloads/ ; ls

👉 → Even if cd fails, ls runs.
👉 && → Run second only if first succeeds

🔗 cd Downloads/ && ls → If cd works, then list contents.

👉 || → Run second only if first fails 
🔗 cd Downloads/ || ls
✔️ If cd fails, then run ls in current dir.

🎯 Interview Insights
➤ $(( )) is faster than using expr command (old style).
➤ Don’t confuse $( ) vs $(( )):
    ✔️ $( ) → run command
    ✔️ $(( )) → run math

➤ let is another way but less preferred:
let x=2+3
echo $x   # 5


🔷 Linux Terminal Shortcuts
⌨️ Navigation
👉 Ctrl + A → Move to beginning of line
👉 Ctrl + E → Move to end of line
👉 Alt + B → Move one word backward
👉 Alt + F → Move one word forward

📝 Editing
👉 Ctrl + K → Delete from cursor to end of line
👉 Ctrl + U → Delete from cursor to beginning of line
👉 Ctrl + W → Delete word backwards (up to space)
👉 Alt + D → Delete word forwards (up to space)
👉 Ctrl + Y → Paste last cut text (yank)

🔎 History & Searc
👉 Ctrl + R → Reverse search through history ((reverse-i-search)
👉 Ctrl + G → Exit history search without running a comman
👉 ↑ / ↓ → Navigate through command history

🖥️ Screen Control
👉 Ctrl + L → Clear screen (like clear)
👉 Ctrl + D → Logout / exit terminal (EOF signal)
👉 Ctrl + Z → Suspend current job (can resume with fg)

🔗 Tabs & Session
👉 Ctrl + Alt + T → Open new terminal windo
👉 Ctrl + Shift + T → Open new terminal tab (in supporting terminals like GNOME)

🔤 Font & Display
👉 Ctrl + Shift + “+” → Increase font size
👉 Ctrl + “-” → Decrease font size
👉 Ctrl + 0 → Reset font size

⚡ Productivity Boosters
👉 Tab → Auto-complete command/file names
👉 Tab Tab → Show all possible completions
👉 !! → Run last command again
👉 !<word> → Run last command starting with <word> (e.g., !ls)
👉 Ctrl + C → Kill current process
👉 Ctrl + Shift + C → Copy text
👉 Ctrl + Shift + V → Paste text

🎯 Insights
Ctrl + D vs Ctrl + C
Ctrl + D → End Of File (exit shell if nothing to read).
Ctrl + C → Interrupt/kill the running process.
Job Control (Ctrl + Z, fg, bg) is a hidden gem often asked in interviews.


🔷 Find Command in Linux
👉 Used to search for files/directories in a given path with conditions.
👉 Syntax: find [path...] [expression]

👉 Case-sensitive by default → use -iname for case-insensitive search.

🌟 Wildcard Characters in find -name
* → Any number of characters
? → Any single character
[abc] → Matches a, b, or c
[!abc] → Matches anything except a, b, or c
[0-9] → Any digit from 0–9
[!0-9] → Not a digit

✅ Examples:
👉 🔗 find . -name "*.txt" → Find all text files in the current directory

🔹 Search by Type
🔗 find /path -type f -name "*.txt"   # files
🔗 find /path -type d -name "*.txt"   # directories

🔹 Search by Size
🔗 find /path -type f -size +100k -size -200k   # files between 100KB–200KB
🔗 find /path -type d -size +1M                 # directories > 1MB

🔹 Search by Time
✔️ -mmin / -mtime → Modified time
✔️ -amin / -atime → Accessed time
✔️ -cmin / -ctime → Metadata changed

➤ Note: min gives minutes and time is in days
✅ Examples:
🔗 find /path -mtime -7    # modified in last 7 days
🔗 find /path -mtime +7    # modified more than 7 days ago
🔗 find /path -mtime 7     # modified exactly 7 days ago
🔗 find /path -mmin -30    # modified in last 30 minutes

🔹 Logical Operators
🔗 find /path -type f -name "*.txt" -size +100k -mtime -7   # AND condition
🔗 find /path \( -name "*.txt" -o -name "*.pdf" \)          # OR condition
🔗 find /path ! -name "*.txt"   # NOT condition

🔹 Empty Files/Directories
🔗 find /path -type f -empty    # empty files
🔗 find /path -type d -empty    # empty directories

🔹 Execute Commands on Results
🔗 find /path -name "*.txt" -exec cat {} \;    # run `cat` on each file
🔗 find /path -empty -exec rm -rf {} \;        # delete empty files/dirs
✔️ {} → placeholder for current file
✔️ \; → end of exec command

🔹 Using xargs
🔗 find . -name "*.log" | xargs rm     # delete all .log files
🔗 find . | xargs file                 # run `file` command on each

🔹 -exec vs xargs
➤ -exec → runs inside find, handles spaces/special chars safely
➤ xargs → more efficient for bulk operations, but may fail on files with spaces/newlines

🔷 Permissions in Linux
lrwxrwxrwx
l can be:
    ➤ - → regular file
    ➤ l- → symbolic link
    ➤ d → directory
    ➤ b → block device file
    ➤ c → character device file
    ➤ p → named pipe
    ➤ s → socket

🌟 Permission Bits (rwx)
➤ r → Read
    ✔️ File: allows viewing contents
    ✔️ Directory: allows listing files (ls)

➤ w → Write
    ✔️ File: allows modifying contents
    ✔️ Directory: allows adding/removing files

➤ x → Execute
    ✔️ File: allows executing as a program/script
    ✔️ Directory: allows entering (cd) and accessing metadata

possibilities of characters:
➤ first character: r or -
➤ second character: w or -
➤ third character: x or -   

🌟 Permission Groups (3 sets of 3 bits = 9 characters)
✅ Example: -rwxr-xr--
👉 Owner (User): first 3 bits → rwx
👉 Group: next 3 bits → r-x
👉 Others: last 3 bits → r--

rest 9 characters will be divided into three groups: rwx,rwx,rwx
➤ first set of 3 characters → owner permissions
➤ second set of 3 characters → group permissions
➤ third set of 3 characters → other permissions


🔷 Changing Permissions with chmod
✅ Syntax: chmod [options] [permissions] [files...]

🔹 Permission Categories
✔️ u → user (owner)
✔️ g → group
✔️ o → others
✔️ a → all (user + group + others)

🔹 Operators
✔️ + → add permission
✔️ - → remove permission
✔️ = → set exact permission (overwrites existing)

🔹 Permission Types
✔️ r → read
✔️ w → write
✔️ x → execute

🔹 Common Options
✔️ -R → recursive (apply to directories + contents)
✔️ -v → verbose (show changes)
✔️ -f → force (suppress errors)

🔹 Symbolic Method Examples
🔗 chmod u+x sample.txt     # add execute for user
🔗 chmod g-w sample.txt     # remove write from group
🔗 chmod o=r sample.txt     # others only read
🔗 chmod a+x sample.txt     # all users get execute
🔗 chmod u=rwx,g=rx,o=      # explicit overwrite

🔹 Octal (Numeric) Method

Permission values:
r = 4, w = 2, x = 1
Calculate sum for each group:
7 = rwx
6 = rw-
5 = r-x
4 = r--
0 = ---

✅ Examples:
🔗 chmod 755 sample.txt    # rwx r-x r-x
🔗 chmod 644 sample.txt    # rw- r-- r--
🔗 chmod 700 sample.txt    # rwx --- ---
🔗 chmod 777 sample.txt    # rwx rwx rwx (full access to everyone ❌ not recommended)

🔹 Special Cases
➤ Directories → need x to enter (cd).
➤ Scripts/Programs → need x to execute.

✅ Recursive Example:
🔗 chmod -R 755 project/

🎯 Interview Insights
➤ chmod works in symbolic and octal forms.
➤ Use octal when setting multiple permissions at once.
➤ Directories without x → you can list files but not enter them.
➤ 777 permissions are insecure (everyone can read/write/execute).


🔷 Su command in Linux
✅ Purpose: 
👉 su = substitute user or switch user.
👉 It allows you to switch to another user account within the same terminal session.
👉 By default, it switches to the root user (superuser).

whoami → show current user
su - username → switch to username


🔷 Mastering Linux Groups
🔹 Viewing Groups
🔗 groups → lists groups of the current user
🔗 groups username → lists groups of a specific user

🔹 Creating Groups
🔗 addgroup groupname → create a new group
(on some distros: groupadd groupname)

🔹 Adding Users to Groups
🔗 adduser username groupname → add user to group
(alternative: usermod -aG groupname username → safer, adds without removing from other groups)

🔹 Removing Users from Groups
🔗 deluser username groupname → remove user from a group
(alternative: gpasswd -d username groupname)

🔹 Deleting Groups
🔗 delgroup groupname → delete a group
(alternative: groupdel groupname)

🔹 Switching Groups
🔗 newgrp groupname → switch current shell to the specified group

🔹 File Permissions with Groups
Every file has: owner, group, others
If user belongs to file’s group → group permissions apply

✅ Example:
chgrp groupname filename   # change group ownership of a file

🎯 Interview / Notes Insights
➤ Groups help in role-based access control.
➤ primary group → assigned at user creation (default group).
➤ secondary groups → additional groups user can belong to.
➤ Best practice: Use groups instead of giving everyone root access.


🔷 Sudo Command in Linux
➤ sudo → SuperUser DO
➤ Allows permitted users to execute commands as root or another user (as defined in /etc/sudoers).
➤ Safer than logging in directly as root.

🔹 Usage: sudo command

✅ Example:
🔗 sudo mkdir meals   # create a directory as root
🔗 sudo apt update    # update package list
🔗 sudo cat /etc/shadow   # view restricted file

🔹 Authentication Behavior
➤ First time sudo is used in a session → password required.
➤ After successful authentication → no password needed for 15 minutes (default).
➤ Timeout can be changed in /etc/sudoers file (using visudo).

🔹 Running as Different User
🔗 sudo -u username command

✅ Example:
sudo -u postgres psql   # run as postgres user

🔹 Common Options
✔️ -u user → run as specific user
✔️ -k → invalidate timestamp immediately (next sudo needs password)
✔️ -v → extend sudo timeout without running command
✔️ -l → list allowed commands for current user
✔️ -s → open a shell as root (without login shell)
✔️ -i → simulate root login shell

🔹 Notes & Interview Insights
➤ sudo access is controlled via /etc/sudoers (edit with visudo).
➤ NOPASSWD: directive allows passwordless sudo for specific commands.
➤ Root login is often disabled for security; sudo is preferred.


🔷Bashrc in Linux
🔗 source .bashrc   # run commands from .bashrc file automatically to restart the terminal

➤ .bashrc is a shell script file executed whenever a new interactive non-login shell is started.
➤ Location:
    ✔️ User-specific: ~/.bashrc (inside home directory).
    ✔️ Global: /etc/bash.bashrc (applies to all users).
➤ It customizes the bash shell environment for the user.

🔹 When is it executed?
➤ Every time you open a new terminal window/tab.
➤ Not executed for login shells (those read ~/.bash_profile, ~/.profile, or /etc/profile).

🔹 Common Uses
➤ Setting environment variables
➤ Adding aliases (shortcuts for commands)
➤ Customizing prompt (PS1)
➤ Running startup scripts
➤ Adding functions

✅ Example:
# ~/.bashrc
alias ll='ls -lh'
alias gs='git status'
export PATH=$PATH:~/scripts
PS1='\u@\h:\w$ '   # Custom prompt

🔹 Reload .bashrc without restarting terminal
source ~/.bashrc
# or
. ~/.bashrc

🔹 Interview Insights
➤ .bashrc → for interactive non-login shells.
➤ .bash_profile or .profile → for login shells.
➤ Often .bash_profile calls .bashrc inside it to unify configs.


🔷 Using chown command in Linux
➤ chown (change owner) is used to change the ownership of files and directories.
➤ Every file/directory in Linux has:
    ✔️ Owner (user)
    ✔️ Group

🔹 Syntax
chown [OPTIONS] USER[:GROUP] FILE...

🔹 Common Usage

➤ Change file ownership to a specific user
🔗 sudo chown username filename

➤ Change file’s group only
🔗 sudo chown :groupname filename

➤ Change both user and group
🔗 sudo chown username:groupname filename

➤ Change ownership recursively (directory + subfiles)
🔗 sudo chown -R username:groupname dirName

🔹 Useful Options
✔️ -R → recursive (apply to all subfiles and directories)
✔️ -c → report changes made
✔️ -v → verbose (show details for every file changed)
✔️ -f → suppress errors

✅ Ownership + Permissions Example
sudo chown ankur:developers project.txt   # give file to user "ankur" and group "developers"
sudo chmod g+w project.txt                # allow group members to write

🔹 Interview Insights
➤ Ownership (chown) and permissions (chmod) work together.
➤ ls -l → shows both owner and group.
➤ Difference:
    ✔️ chown → changes ownership (user/group).
    ✔️ chmod → changes permission (r/w/x).
➤ Root (or sudo) privileges are required for chown.


🔷 Sessions in Linux
➤ A session in Linux = an instance of a running shell (bash, zsh, etc.).
➤ Each session has its own process ID (PID).
➤ Sessions can be nested inside each other.

🔹 Commands
➤ Get current session ID (PID of the shell)
🔗 echo $$

➤ Start a new nested session
🔗 bash
👉 This creates a new shell session inside the current one.
👉 Each new session has a different PID.

➤ Exit a nested session
🔗 exit
(or Ctrl+D) → returns to the parent session.

✅ Session Chain Example
echo $$       # prints 1234 (current session PID)
bash          # start new nested session
echo $$       # prints 5678 (new session PID)
exit          # return to previous session
echo $$       # back to 1234

🔹 Insights (Interview Traps)
➤ Each terminal window/tab = a separate session.
➤ Sessions are processes, visible in ps -ef or pstree.
➤ Environment variables are session-specific (not shared unless exported to child processes).
➤ If you start a session inside another, you’re essentially running bash inside bash.


🔷 Linux Environment variables
➤ Environment variables are key-value pairs maintained by the shell.
➤ They define system-wide or session-specific settings (e.g., PATH, HOME, USER).
➤ They are inherited by child processes.

🔹 Commands
➤ List all environment variables
🔗 printenv

➤ Get value of a specific variable
🔗 printenv VAR_NAME
🔗 echo $VAR_NAME

➤ Set an environment variable (session only)
🔗 export VAR_NAME=value

➤ Unset/remove an environment variable
🔗 unset VAR_NAME

🔹 Persistence of Variables
➤ By default, variables set using export exist only for the current session.
➤ To make them permanent, add to:
    ✔️ ~/.bashrc (for user-specific, non-login shells)
    ✔️ ~/.profile or ~/.bash_profile (for login shells)
    ✔️ /etc/environment (system-wide)

🔹 Useful Environment Variables (Common in Interviews)
➤ PATH → directories searched for executables.
➤ HOME → current user’s home directory.
➤ USER → logged-in username.
➤ SHELL → current shell.
➤ PWD → current working directory.

🔹 Insights (Interview Angle)
Difference between local variable vs environment variable:
    ✔️ Local → exists only in current shell.
    ✔️ Environment → exported and available to child processes.
To temporarily modify PATH:
    ✔️ export PATH=$PATH:/new/dir


🔷Understanding Alias Commands for Efficiency
➤ An alias in Linux is a shortcut for a command or group of commands.
➤ Saves time and reduces repetitive typing.
➤ Aliases exist only in the current shell session unless added to configuration files (~/.bashrc, ~/.zshrc).

🔹 Check Command Type
🔗 type commandName
➤ Shows whether the command is:
    ✔️ builtin → part of the shell itself.
    ✔️ hashed → external command stored in memory for faster lookup.
    ✔️ aliased → customized alias of another command.

✅ Examples:
🔗 type pwd   # pwd is a shell builtin
🔗 type cat   # cat is hashed (/usr/bin/cat)
🔗 type ls    # ls is aliased to 'ls --color=auto'

🔹 Create an Alias
alias aliasName='commandName arguments'

✅ Examples:
🔗 alias ll='ls -alh'     # quick way to list files with details
🔗 alias grep='grep --color=auto'  # color highlight search
🔗 alias cls='clear'      # alias cls to clear terminal

🔹 Remove an Alias
🔗 unalias aliasName

🔹 View All Aliases
🔗 alias

🔹 Making Aliases Permanent
➤ Add them to:
    ✔️ ~/.bashrc or ~/.zshrc for user-specific aliases.
    ✔️ /etc/bash.bashrc for system-wide aliases.
➤ Reload file after editing:
source ~/.bashrc

🔹 Interview Insights
➤ Aliases override system commands (e.g., ls often aliased to ls --color=auto).
➤ If you want to bypass an alias → use command keyword:
🔗 command ls
👉 Runs the original ls, ignoring alias.
➤ Good to mention: Aliases are shell features, not kernel-level.


🔷 Mastering Bash in Linux
A shell is a command-line interface(CLI) that allows users to interact with an operating system by typing commands.

There are several types of shells, and they can be broadly categorized into two main groups:
➤ Unix-like shells
➤ Windows shells

🌟 Unix-like shells
👉 Bourne Shell (sh): The Bourne Shell was one of the earliest Unix shells and served as the basis for many subsequent shells. It provides basic functionality and is often used for scripting.

👉 Bash(Bourne Again Shell): Bash is the default shell in many Unix-like Operating systems, including Linux and macOS. It extends the capabilities of the original Bourne Shell and incorporates features from other shells like the Korn Shell and the C Shell.

👉 Korn Shell (ksh): Korn Shell was developed by David Korn as enhancement to the Bourne Shell. It includes features from both the Bourne Shell and the C Shell, making it a powerful and user-friendly shell.

👉 C Shell (csh): The C Shell has a syntax that is somewhat C-like and was developed to provide interactive features not present in the original Bourne shell. Its successors, tcsh, is an improved version with additional features.

👉 Zsh (Z Shell): Zsh is a shell that incorporates features from bash, ksh, and tcsh. It includes advanced scripting abilities and interactive for users.

🌟 Windows Shell
👉 Command Prompt(cmd.exe): The Command Prompt is the traditional command-line interface for windows. While it lacks some advanced features found in Unix-like shells, it provides a basic command-line environment.

👉 Powershell: Powershell is a more recent and powerful shell for windows. It is designed for automation and task scripting, with a focus on managing system components through command-line interface.


🔷$PATH in Bash
➤ $PATH is an environment variable in Linux/Unix shells.
➤ It contains a colon-separated list of directories.
➤ When a command is run, the shell searches these directories (in order) to find the executable.

✅ Example:
🔗 echo $PATH
# /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

🔹 Locate Executable for a Command
🔗 which ls
👉 Returns the full path of the command’s executable (/bin/ls).

🔹 Adding Directories to $PATH
➤ Temporary (session only):
🔗 export PATH=$PATH:/path/to/directory

➤ Permanent (user-specific):
Add the line to ~/.bashrc or ~/.zshrc:
🔗 PATH=$PATH:/path/to/directory

Reload file:
🔗 source ~/.bashrc

➤ Permanent (system-wide):
Add directory to /etc/environment.

🔹 Insights 
➤ The shell searches directories in $PATH sequentially; first match is executed.
➤ If two commands with the same name exist, the one earlier in $PATH takes priority.
➤ $PATH can be modified by scripts, installers, or user configs.
➤ To reset PATH to default:
🔗 export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

⚡ Common Trap Question
🧠 “If you create a script called ls in your current directory, why might it not run when you type ls?”
👉 Because current directory (.) is usually not in $PATH. You’d need to run ./ls or add . to $PATH.


🔷 Mastering Linux Scripts
❓What is Script?
In Linux, a script is a series of commands written in a scripting language(like Bash) that can be executed by the shell.

Bash is both a command-line interpreter(shell) and a scripting language.


Creating a Simple Script
#!/bin/bash
echo "Hello, Linux scripting!"

When you execute a script, the system typically relies on the shebang(the #!/bin/bash line at the beginning of the script) to determine the interpreter that should be used, regardless of the file extension. This allows you to name your scripts with or without a .sh extension.

❓How to execute a Script
✔️ bash fileNName: This explicitly tells the Bash shell to execute the script. It's commonly used in Bash Scripts.

✔️ sh fileName: This instructs the system to use the default shell (usually /bin/sh) to execute the script.

⚡Note: Above two commands runs the script in the new subshell which does not affect the current shell environment.

✔️ source fileName: This runs the script in the current shell session instead of spawning a new process. It's often used to execute the scripts that modify the environment, such as setting environment variables.

✔️ ./fileName:Returns the script to be made executable
If the file is found and has execute permission, the shell executes it using the appropriate interpreter specified in the shebang line.


❗What if you wat to run a script as if it were a command, without specifying the path of the script every time
➤ Add the script to a Directory in the PATH.


🔷Mastering Linux Corn Jobs
➤ Cron is a Linux utility to schedule repetitive tasks at specific times/dates.
➤ Managed by the cron daemon (crond).
➤ Each user can define their own cron jobs using crontab.

🔹 Basic Commands
🔗 crontab -e   # edit crontab file (default editor: nano if selected)
🔗 crontab -l   # list current user’s cron jobs
🔗 crontab -r   # remove all cron jobs for current user
🔗 crontab -k   # kill the cron daemon

🔹 Crontab Syntax
* * * * * command_to_be_executed
│ │ │ │ │
│ │ │ │ └── Day of week (0-6, Sunday=0)
│ │ │ └──── Month (1-12)
│ │ └────── Day of month (1-31)
│ └──────── Hour (0-23)
└────────── Minute (0-59)

✅ Examples
✔️ 30 3 * * *     # Every day at 3:30 AM
✔️ 15 13 * * 1    # Every Monday at 1:15 PM
✔️ 45 4 * 1,2 0   # On Sundays in Jan & Feb at 4:45 AM
✔️ 30 8 * * 1-5   # Weekdays (Mon–Fri) at 8:30 AM
✔️ */5 * * * *    # Every 5 minutes
✔️ 0 */6 * * *    # Every 6 hours

Special Characters
👉 * → any value (wildcard)
👉 , → list of values (1,15 → 1st and 15th)
👉 - → range (1-5 → Mon to Fri)
👉 / → step values (*/10 → every 10 units)

🌟 Special Keywords (Shortcuts)
🔗 @reboot     # Run once, at startup
🔗 @yearly     # Once a year (0 0 1 1 *)
🔗 @monthly    # Once a month (0 0 1 * *)
🔗 @weekly     # Once a week (0 0 * * 0)
🔗 @daily      # Once a day (0 0 * * *)
🔗 @hourly     # Once an hour (0 * * * *)

➤ Output & Logging
By default, cron mails output to the user (if mail is configured).
To log output:
* * * * * /path/script.sh >> /var/log/cron.log 2>&1

🧠 Insights
⚡ Difference between cron and at command:
➤ cron → schedules repetitive tasks.
➤ at → schedules a one-time task.

⚡ Crontab file location:
➤ User-specific: /var/spool/cron/username
➤ System-wide: /etc/crontab, /etc/cron.* directories.


🔷 History Command
➤ The history command shows the list of recently executed commands in the shell
➤ Useful for re-executing, searching, and managing past commands.

🔹 Basic Usage
🔗 history            # list all recent commands
🔗 history 10         # show last 10 commands
🔗 !!                 # run last command
🔗 !n                 # run the nth command from history
🔗 !string            # run the most recent command starting with "string"

🔄 Managing History
🔗 history -c         # clear history for current session
🔗 history -d N       # delete the Nth command from history
🔗 history -a         # append current session’s commands to history file (~/.bash_history)

🔄History Variables
✔️ $HISTSIZE → number of commands stored in memory (default: 1000).
🔗 echo $HISTSIZE

✔️ $HISTFILESIZE → max number of lines stored in history file (~/.bash_history) (default: 2000).
🔗 echo $HISTFILESIZE

🔄 Searching History
Interactive reverse search:
Ctrl + r    # search backward in history
Ctrl + s    # search forward (if enabled)

Exit reverse search → Ctrl + c or Ctrl + g.

🧠 Insights (Interview Angle)
➤ History is stored per user in ~/.bash_history.
➤ Sensitive commands (like passwords in CLI) can get stored — security risk.
➤ Can disable history logging temporarily:
🔗 HISTSIZE=0

➤ Use !$ to reference last argument of previous command.
cat file.txt
vim !$
👉 Opens the same file.txt in vim.