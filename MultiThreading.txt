Program❓
A Program is a set of instructions written in a programming language that tells the computer how to perform a specific task.
✅ For Example: Microsoft Word is a program that allows you to write and edit documents. It is a program that is used to create and edit documents.

Process❓
A process is an instance of a program that is being executed. When a program runs, the operating system creates a process to manage its execution.
When we open Microsoft Word, it becomes a process in the operating system.          

Thread❓
A thread is the smallesst unit of execution within a process. A process can have multiple threads, which share the same resources but can run independently.
A thread is a light-weight process that can be created and destroyed at runtime.
✅For Example: A we browser like Google Chrome might use multiple threads for different tabs, with each tab running in its own thread.

Multitasking❓
Multitasking is the ability of a computer to run multiple tasks or programs at the same time. On single-core CPUs, this is done through time-sharing, rapdily switching between tasks. On multi-core CPUs, this is done through parallelism, where multiple cores, true paralled execution occurs, with tasks distributed across the cores. The OS scheduler balances the load, ensuring efficient and resposive system performance.

It utilizes the capabilities of a CPU and its cores. When an OS performs multitasking, it can assign different tasks to different cores. This is mroe efficient than assigning all tasks to a single core.
✅For Example: We are browsing the internet while listening to music and dowloading files at the same time.

MultiThreading❓
Multithreading is a technique in which multiple threads of execution are created within a single process. Each thread is a separate execution path within the process.
Multithreading is used to improve the performance of a program by allowing it to execute multiple tasks concurrently.
✅For Example: A web browser can use mutlithreading by having seperate threads for rendering the page, running JavaScript, and handling user input. This makes the browser more resposive and efficient.

It enhances the efficiency of multitasking by breaking down individual tasks into smaller sub-tasks or threads. These threads can be processed simultaneously, making better use of the CPU's capabilities and resources.

📝In Single-Core System:
Both threads and processes are managed by the OS scheduler through time slicing ad context switching to create the illusion of simultaneous execution.
📝In Multi-Core System:
Both threads and processes can run in true parallelism, with tasks distributed across the cores to optimize performance.

🔷 Thread Creation Techniques

1. Using Thread Class

package p1;

public class World extends Thread {
	@Override
	public void run() {
		for (; ; ) {
			System.out.println(Thread.currentThread().getName());
		}
	}
}

package p1;

public class intro {

	public static void main(String[] args) {
		World w = new World();
		w.start();
		for (; ;) {
			System.out.println(Thread.currentThread().getName());
		}
	}

}
🔗 Steps:
➤ A new class World is created that extends Thread.
➤ The run method is overridden to define the code constitutes the new thread.
➤ start method is called to initiate the new thread.

2. Using Runnable Interface

package p1;

public class World implements Runnable {
    @Override
    public void run() {
        for (; ; ) {
            System.out.println(Thread.currentThread().getName());
        }
    }
}

package p1;

public class intro {

    public static void main(String[] args) {
        Thread t = new Thread(new World());
        t.start();
        for (; ;) {
            System.out.println(Thread.currentThread().getName());
        }
    }
}
🔗 Steps:
➤ A new class World is created that implements Runnable.
➤ The run method is overridden to define the code constitutes the new thread.
➤ A Thread object is created by passing an instance of the World class to the Thread constructor.
➤ The start method is called to initiate the new thread.


🔷 Thread Lifecycle
The lifecycle of a thread is Java consist of several states, which a thread can move through during its execution.
The lifecycle of a thread is as follows:

1. New: A new thread is created but not yet started.
2. Runnable: After the start method is called, the thread becomes runnable. It's ready to ru and is waiting for CPU time.
3. Running: The thread is in this state when it is executing.
4. Blocked/Waiting: A thread is in this state when it is  waiting for a resource or for another thread to perform an action.
5. Terminated: The thread has completed its execution.


🔷 Thread Methods in Java
🔄 start()
➤ Used to start a new thread of execution.
➤ Internally calls the run() method in a new call stack.
➤ Cannot call start() on the same thread object more than once → throws IllegalThreadStateException.

t1.start();  // starts execution of thread

🔄 run()
➤ Contains the code that will be executed by the thread.
➤ If run() is called directly (without start()), it will behave like a normal method → no new thread is created.

@Override
public void run() {
    System.out.println("Thread is running...");
}

🔄 sleep(milliseconds)
➤ ➤ Causes the currently executing thread to pause temporarily for a given time.
➤ ➤ Throws InterruptedException if another thread interrupts the sleeping one.
➤ ➤ Static method → belongs to the class, not an object.

Thread.sleep(1000);  // pauses current thread for 1 second

🔄 join()
➤ Allows one thread to wait for another thread to finish execution before continuing.
➤ Ensures sequential execution when required.
➤ Overloads:
    ✔️ join() → waits until thread finishes.
    ✔️ join(long millis) → waits for max specified time.

t1.join();  // main thread waits until t1 finishes

🔄 setPriority(int priority)
➤ Used to set priority of a thread.
➤ Range: 1 (MIN_PRIORITY) → 10 (MAX_PRIORITY), default = 5 (NORM_PRIORITY).
➤ Just a hint to the scheduler (not guaranteed).

t1.setPriority(Thread.MAX_PRIORITY);

🔄 interrupt()
➤ Used to interrupt a thread that is sleeping, waiting, or blocked.
➤ Sets the interrupt status flag of the thread.
➤ If the thread is in sleep() or join(), it will throw InterruptedException.

t1.interrupt();

🔷 Extra Content from Your Code
👉 Naming Threads
A thread can be given a name by passing it in the constructor:

ThreadMethodDemo t1 = new ThreadMethodDemo("FirstThread");
System.out.println(t1.getName());  // prints: FirstThread

✅ Example with Priority + Name
package p1;

public class ThreadMethodDemo extends Thread {
    public ThreadMethodDemo(String name) {
        super(name);  // assigning thread name
    }

    public static void main(String[] args) {
        ThreadMethodDemo t1 = new ThreadMethodDemo("FirstThread");
        t1.setPriority(Thread.NORM_PRIORITY); // setting priority
        t1.start();
    }

    @Override
    public void run() {
        for(int i=1; i<=5; i++) {
            System.out.println(Thread.currentThread().getName() + 
                               " Priority: " + Thread.currentThread().getPriority() +
                               " Value: " + i);
        }
    }
}

📝 Notes
➤ start() → creates a new thread and calls run().
➤ run() → thread’s task logic.
➤ sleep() → pauses execution (can throw InterruptedException).
➤ join() → makes one thread wait for another.
➤ setPriority() → changes thread priority (1–10).
➤ interrupt() → signals thread interruption.
➤ Threads can be named (super(name) in constructor).
➤ Thread priorities are scheduler hints, not guarantees.