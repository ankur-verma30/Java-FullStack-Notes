❓ Define JDK, JRE, and JVM
🔹 1. JVM (Java Virtual Machine)
➤ JVM is an abstract machine that provides a runtime environment to execute Java bytecode.

⚡Responsibilities:
✔️ Converts bytecode → machine code using JIT (Just-In-Time compiler).
✔️ Provides platform independence (“Write Once, Run Anywhere”).
✔️ Manages memory (heap, stack, method area, GC).
✔️ Ensures security via bytecode verification.
🔧 Key Point: JVM is platform-dependent (different implementations for Windows/Linux/Mac), but bytecode is platform-independent.

➡️ Interview Insight:
Many confuse JVM = Java compiler → Wrong! Compiler (javac) converts Java code → bytecode; JVM executes that bytecode.

🔹 2. JRE (Java Runtime Environment)
➤ JRE provides libraries, JVM, and other components to run Java applications.

Includes:
✔️ JVM
✔️ Core libraries (like java.lang, java.util, java.io)
✔️ Supporting files
🔧 Key Point: JRE does not include development tools (compiler, debugger). It’s only for running Java programs.

➡️ Interview Trap:
If asked, “Can you run Java code with just JRE?” → Yes, if you already have compiled bytecode. But you cannot compile .java files with JRE.

🔹 3. JDK (Java Development Kit)
➤ JDK is the full package required for Java development.

Includes:
✔️ JRE (which has JVM + libraries)
✔️ Development tools → javac (compiler), jdb (debugger), javadoc, jar, etc.
🔧 Key Point: JDK is for developers; JRE is for users.

➡️ Interview Trap:
Some interviewers ask: “If JDK contains JRE, and JRE contains JVM, can we say JDK = JVM?”
Answer: No. JDK = JRE + Development Tools. JVM is just part of JRE.

🔹 Hierarchy Diagram
JDK 
 └── JRE 
      └── JVM

🔹 One-Liner for Revision
➤ JVM → Runs bytecode.
➤ JRE → JVM + Libraries (to run Java apps).
➤ JDK → JRE + Tools (to develop Java apps).

❓ Significance of public static void main(String[] args)
The main() method is the entry point of every Java program. The JVM calls it to start execution. Each keyword has a special meaning:

🔹 1. public
➤ Reason: Must be accessible to JVM outside the class.
➤ JVM looks for main() from anywhere, so it cannot be private or default.
➤ If not public → main method not found error.

➡️ Interview Trap:
Q: “What if I make main() private or protected?”
A: JVM won’t be able to access it → runtime error.

🔹 2. static
➤ Reason: JVM doesn’t need to create an object of the class to call main().
➤ Being static, it belongs to the class rather than an object.
➤ Ensures execution starts immediately when the class is loaded.

➡️ Interview Trap:
Q: “Can main() be non-static?”
A: Yes, it compiles, but JVM won’t recognize it as a valid entry point.

🔹 3. void
➤ Reason: main() doesn’t return any value to JVM.
➤ JVM doesn’t expect a return type.
➤ If you try to return something, compilation error occurs.

🔹 4. main
➤ Reason: Name is predefined and reserved by JVM as the entry point.
➤ If you change it, JVM won’t start execution.

🔹 5. (String[] args)
➤ Reason: Accepts command-line arguments when program is executed.
✅ Example:
class Demo {
    public static void main(String[] args) {
        System.out.println(args[0]); // prints first command line argument
    }
}
Run: java Demo Hello → Output: Hello

➡️ Alternate forms accepted by JVM:
✔️ public static void main(String args[])
✔️ public static void main(String... args) (var-args since Java 5)

🔹 One-Liner for Quick Revision
✔️ public → JVM can access.
✔️ static → No object needed.
✔️ void → No return value.
✔️ main → JVM’s entry point.
✔️ String[] args → Command-line inputs.

🔹 Interview Insights
➤ “What if signature is public static int main()?” → Compilation error.
➤ “What if I overload main()?” → Allowed, but JVM only calls the public static void main(String[] args).
➤ “What if args is changed to String... args?” → Still valid.


❓ Why does the main method support String[] args?
🔹 1. Command-Line Arguments Support
String[] args lets us pass data from outside (command line) to the program at runtime.
✅ Example:

class Demo {
    public static void main(String[] args) {
        System.out.println("First argument: " + args[0]);
    }
}
⚡ Run: java Demo Hello
Output: First argument: Hello

➡️ Without String[] args, the JVM couldn’t pass inputs from command line.

🔹 2. Why Specifically String?
➤ Every input from command line is text-based.
➤ JVM collects arguments as strings (e.g., "123" not number 123).

➤ If you need another type (int, double), you must parse it manually:
int num = Integer.parseInt(args[0]); // converts "123" → 123

🔹 3. Why Array []?
➤ Because we may pass multiple arguments separated by space.

✅ Example:
java Demo Alice Bob Charlie

Then:
args[0] = "Alice"
args[1] = "Bob"
args[2] = "Charlie"
➡️ An array is the best way to store variable-length inputs.

🔹 4. Alternative Forms Accepted by JVM
➤ JVM doesn’t strictly enforce String[] args.
➤ The following are also valid:
    ✔️ String args[]
    ✔️ String... args (var-args since Java 5).

🔹 5. What if we remove it?
If you write: public static void main()
❗ Compiles fine, but JVM won’t recognize it as a valid entry point → Runtime error:
❌ Error: Main method not found in class Demo

🔹 One-Liner for Quick Revisio
👉 String[] args is used because JVM needs a standard way to pass runtime command-line arguments, and all inputs are strings by default.

🔹 Interview Insights
🧠 Trick Q: “Why not int[] args or Object[] args?”
➤ Because JVM can only guarantee that inputs will be Strings from command line.
🧠 Trick Q: “Can we overload main() with different parameters?”
➤ Yes, but JVM only calls public static void main(String[] args). Others can only be called manually inside code.

❓ Constructor Chaining in Java
Constructor Chaining means calling one constructor from another constructor (in the same class or parent class) to reuse initialization code and avoid duplication.

🔹 Types of Constructor Chaining

🔄 Within the same class → using this()
    ✔️ Calls another constructor of the same class.
    ✔️ Must be the first statement in the constructor.

🔄 Between parent and child class → using super()
    ✔️ Calls the parent class constructor.
    ✔️ Must be the first statement in the constructor.

✅ Example 1: Same Class (this())
class Student {
    private String name;
    private int age;

    // Constructor 1
    Student() {
        this("Unknown", 18);  // calling parameterized constructor
    }

    // Constructor 2
    Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    void display() {
        System.out.println(name + " - " + age);
    }
}

public class Demo {
    public static void main(String[] args) {
        Student s1 = new Student();
        Student s2 = new Student("Alice", 22);
        s1.display(); // Unknown - 18
        s2.display(); // Alice - 22
    }
}
➡️ Here, default constructor calls the parameterized constructor to avoid duplicate code.

✅ Example 2: Parent → Child (super())
class Person {
    Person() {
        System.out.println("Person constructor");
    }
}

class Employee extends Person {
    Employee() {
        super();  // calls parent constructor
        System.out.println("Employee constructor");
    }
}

public class Demo {
    public static void main(String[] args) {
        new Employee();
    }
}
✅ Output:
Person constructor
Employee constructor
➡️ Here, super() ensures parent class initialization happens first.

🔹 Rules of Constructor Chaining
➤ Either this() or super() must be the first statement.
➤ Circular calls (like a constructor calling itself) → compile-time error.
➤ If you don’t write super(), the compiler automatically inserts super() (default constructor).
➤ Cannot use both this() and super() in the same constructor → only one allowed.

🔹 Why is it Important?
➤ Code Reusability → No duplication of initialization logic.
➤ Readability → Clear execution order.
➤ Mandatory for Inheritance → Parent must always be initialized before child.

🔹 One-Liner for Quick Revision
👉 Constructor Chaining = Calling one constructor from another (same class via this(), parent class via super()) to reuse initialization logic.

🔹 Interview Insights
🧠 Q: “What happens if parent has only parameterized constructor and child does not call it?”
➤ Compilation error (because compiler inserts super() but no default constructor exists).
🧠 Q: “Can this() and super() be used together?”
➤ No, only one can be the first line.
🧠 Q: “What if I call a method before super() inside a constructor?”
➤ Compilation error: Constructor call must be the first statement.


❓ OOPs Concepts(Inheritance, Polymorphism, Encapsulation, Abstraction)
🔹 1. Encapsulation → Data Hiding + Binding
➤ Wrapping variables (data) and methods (logic) into a single unit (class). Provides controlled access via getters/setters.

✅ Daily Life Example:
A bank account: Your balance is hidden (private), but you can access it using deposit/withdraw methods.
➤ One-liner: “Encapsulation = data hiding using access modifiers + methods.”

🔹 2. Abstraction → Hiding Implementation
➤ Showing only essential details, hiding internal complexity. Achieved using abstract classes / interfaces.

✅ Daily Life Example:
Car driving: You use the steering wheel, accelerator, brakes without knowing how the engine, gears, and sensors work internally.
➤ One-liner: “Abstraction = show what it does, hide how it does.”

🔹 3. Inheritance → Reusability
➤ One class acquires properties and methods of another (parent → child). Promotes code reuse.

✅ Daily Life Example:
    ✔️ Father → Son: A child inherits properties (like eye color) and behaviors (like habits) from parents.
    ✔️ In software: class Dog extends Animal.
➤ One-liner: “Inheritance = child gets features from parent.”

🔹 4. Polymorphism → Many Forms
➤ Same method/operation behaves differently in different contexts.
    ✔️ Compile-time polymorphism → Method overloading.
    ✔️ Runtime polymorphism → Method overriding.

✅ Daily Life Example:
Mobile Phone Button:
    ✔️ Single button = different actions (tap → open app, double tap → camera, long press → assistant).
➤ One-liner: “Polymorphism = same name, different behavior.”

🔹 Interview-Ready Summary (One Sentence)
👉 OOPs = Encapsulation (data hiding), Abstraction (hiding implementation), Inheritance (reusability), and Polymorphism (same method different forms) — just like real-world objects such as cars, bank accounts, or family inheritance.

❓ Difference between Interface and Abstract Class
➤ Interface: A contract that specifies what a class must do, but not how.
➤ Abstract Class: A class that may have partial implementation (some abstract methods + some concrete methods).

🔹 2. Method Implementation
➤ Interface:
    ✔️ Before Java 8 → only abstract methods (implicitly public abstract).
    ✔️ Java 8 → allowed default & static methods.
    ✔️ Java 9 → allowed private methods.

➤ Abstract Class:
    ✔️ Can have both abstract and concrete methods.
    ✔️ Can provide partial implementation.

🔹 3. Variables
➤ Interface:
    ✔️ Variables are always public static final (constants).
    ✔️ Must be initialized at declaration.

➤ Abstract Class:
    ✔️ Can have instance variables.
    ✔️ Can use any access modifier (private, protected, etc.).

🔹 4. Inheritance & Multiple Inheritance
Interface: Supports multiple inheritance (a class can implement multiple interfaces).
Abstract Class: Supports single inheritance only (a class can extend only one abstract class).

🔹 5. Constructors
Interface: ❌ Cannot have constructors (cannot be instantiated).
Abstract Class: ✅ Can have constructors (called when subclass object is created).

🔹 6. Use Cases
➤ Interface:
    ✔️ Used to define a contract/blueprint for unrelated classes.
    ✅ Example: Comparable, Runnable, Serializable.

➤ Abstract Class:
    ✔️ Used when classes share common behavior + state but still have some abstract methods.

✅ Example: AbstractList in Java Collections.

🔹 7. Code Example
// Interface example
interface Vehicle {
    void start(); // abstract method
}

class Car implements Vehicle {
    public void start() {
        System.out.println("Car starts with key");
    }
}

// Abstract class example
abstract class Animal {
    abstract void sound();   // abstract method
    void sleep() {           // concrete method
        System.out.println("Sleeping...");
    }
}

class Dog extends Animal {
    void sound() {
        System.out.println("Bark");
    }
}

🔹 8. One-Liner for Interview
➤ Interface → “Defines what to do, no state.”
➤ Abstract Class → “Defines what to do + partial how to do, can have state.”

🔹 9. Interview Traps & Insights
🧠 Q: “Can an interface extend another interface?” → ✅ Yes (multiple inheritance of interfaces allowed).
🧠 Q: “Can an abstract class implement an interface?” → ✅ Yes, but must provide implementation for methods or remain abstract.
🧠 Q: “Which is faster, abstract class or interface?” → Abstract class is slightly faster (direct method call vs dynamic dispatch in interfaces).
🧠 Q: “When to prefer interface over abstract class?” → Use interface when unrelated classes need common behavior (e.g., Flyable, Drivable). Use abstract class when related classes share state/logic (e.g., Shape).

❓ Multi-catch Block in Java
➤ A multi-catch block allows you to handle multiple exceptions in a single catch block using the | (pipe) operator.
➤ Introduced in Java 7 to reduce code duplication.

✅ Example (Before Java 7 → Repetitive Code)
try {
    int arr[] = new int[5];
    arr[5] = 10 / 0;
} catch (ArithmeticException e) {
    System.out.println("Arithmetic Exception: " + e.getMessage());
} catch (ArrayIndexOutOfBoundsException e) {
    System.out.println("Array Index Exception: " + e.getMessage());
}
❌ Problem: Code is repetitive; two separate blocks with same logic.

✅ Example (After Java 7 → Multi-Catch)
try {
    int arr[] = new int[5];
    arr[5] = 10 / 0;
} catch (ArithmeticException | ArrayIndexOutOfBoundsException e) {
    System.out.println("Exception: " + e.getMessage());
}
➡️ Same result with cleaner code.

🔹 Rules of Multi-catch
➤ Use | (pipe) to separate multiple exception types.
➤ Exceptions must be unrelated (not parent-child).

✅ Allowed: IOException | SQLException
❌ Not Allowed: IOException | FileNotFoundException (because FileNotFoundException is a subclass of IOException).

⚡ The exception variable (e) is final implicitly → You cannot reassign it inside the block.

🔹 Why Multi-catch is Useful?
➤ Reduces boilerplate code (no duplicate catch blocks).
➤ Improves readability.
➤ Optimizes bytecode (compiler generates smaller, efficient bytecode).

🔹 One-Liner for Quick Revision
👉 Multi-catch block = Handle multiple exceptions in one catch block using | operator (Java 7+), avoiding code duplication.

🔹 Interview Insights
🧠 Q: “Can we catch exceptions in order?”
In multi-catch, order doesn’t matter because it’s a single block.
🧠 Q: “What if exceptions have parent-child relation?”
Compile-time error. Use separate catch blocks instead.
🧠 Q: “Is the exception object final in multi-catch?”
Yes, you cannot assign e = new Exception() inside.


❓ Difference between final, finally, and finalize()
🔹 1. final (Keyword)
➤ Usage: Restrict modification.
➤ Applied to: Variable → makes it a constant (cannot be reassigned).

final int x = 10;
// x = 20; ❌ Compile-time error

➤ Method → prevents overriding in child class.
class A {
    final void show() { System.out.println("A"); }
}
class B extends A {
    // void show() {} ❌ Not allowed
}

➤ Class → prevents inheritance.
final class A {}
// class B extends A {} ❌ Not allowed
➡️ One-liner: final = constant / no overriding / no inheritance.

🔹 2. finally (Block)
➤ Usage: Used in exception handling.
➤ Purpose: Ensures a block of code always executes, regardless of exception occurrence.
➤ Commonly used for resource cleanup (closing files, DB connections).

✅ Example:
try {
    int x = 10 / 0;
} catch (ArithmeticException e) {
    System.out.println("Exception: " + e);
} finally {
    System.out.println("Finally block always executes");
}

✅ Output:
Exception: java.lang.ArithmeticException: / by zero
Finally block always executes

➡️ Special case: If you call System.exit(0), the finally block won’t execute.
➡️ One-liner: finally = block that always executes (for cleanup).

🔹 3. finalize() (Method)
A method in Object class called by Garbage Collector (GC) before destroying an object.
Usage: To release resources (like closing file handles, DB connections) before object is removed.

✅ Example:
class Demo {
    protected void finalize() {
        System.out.println("Finalize method called before GC");
    }
    public static void main(String[] args) {
        Demo d = new Demo();
        d = null;
        System.gc(); // Suggests JVM to call GC
    }
}
✅ Output: Finalize method called before GC


➡️ Important Notes:
➤ finalize() execution is not guaranteed. GC may or may not run.
➤ From Java 9, finalize() is deprecated (use try-with-resources instead).
➡️ One-liner: finalize() = method called by GC before object destruction (deprecated).

🔹 Interview-Ready Comparison
| Feature           | `final` (Keyword)                        | `finally` (Block)            | `finalize()` (Method)                 |
| ----------------- | ---------------------------------------- | ---------------------------- | ------------------------------------- |
| **Category**      | Modifier                                 | Block                        | Method in `Object` class              |
| **Used For**      | Constants, no overriding, no inheritance | Cleanup code after try-catch | Cleanup before object destruction     |
| **When Executes** | At compile-time restriction              | Always after try-catch       | Called by GC before destroying object |
| **Control**       | Programmer                               | Programmer                   | JVM/GC decides                        |
| **Deprecation**   | ❌ Not deprecated                         | ❌ Not deprecated             | ✅ Deprecated in Java 9+               |


❓ Why is String inheritable? (or is it?)
🔹 Truth about String class
The String class in Java is declared as:
✅ Code Structure:
public final class String implements Serializable, Comparable<String>, CharSequence
Notice the final keyword → this means:
    ✔️ String cannot be inherited (cannot have a subclass).
    ✔️ This is done to ensure immutability and security.
➡️ So, String is NOT inheritable. If you try to extend it:
class MyString extends String {} // ❌ Compile-time error

🔹 Why did Java make String final?
➤ Immutability: Prevents someone from extending String and overriding methods to break immutability.
➤ Security: Strings are used in sensitive areas (file paths, DB URLs, network connections). If String could be inherited and tampered, it would be a major security risk.
➤ Performance: String pool (interning) relies on immutability. If strings were mutable or extendable, pooling would fail.

❓ How can we create our own inheritance class?
If you want a custom class that supports inheritance, don’t mark it as final. Example:

// Parent class
class Vehicle {
    String brand = "Generic";

    void start() {
        System.out.println("Vehicle starting...");
    }
}

// Child class
class Car extends Vehicle {
    int wheels = 4;

    @Override
    void start() {
        System.out.println(brand + " Car starting with " + wheels + " wheels!");
    }
}

public class Demo {
    public static void main(String[] args) {
        Car c = new Car();
        c.brand = "Tesla";
        c.start(); // Tesla Car starting with 4 wheels!
    }
}

🔹 Rules for creating an inheritance class
➤ Use extends keyword for class inheritance.
➤ Use implements for interface implementation.
➤ Methods in parent can be overridden in child (unless final/static/private).
➤ Parent’s constructor is always called first (via super()).
➤ Multiple inheritance of classes is not allowed in Java → solve via interfaces.

❓What is Runtime Polymorphism?
Runtime polymorphism in Java is method overriding — when a method call is resolved at runtime (not compile-time).
It’s also called Dynamic Method Dispatch.

✅ Example: Method Overriding
class Animal {
    void sound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("Dog barks");
    }
}

class Cat extends Animal {
    @Override
    void sound() {
        System.out.println("Cat meows");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal a1 = new Dog();  // reference is Animal, object is Dog
        Animal a2 = new Cat();  // reference is Animal, object is Cat

        a1.sound();   // Dog barks  (resolved at runtime)
        a2.sound();   // Cat meows  (resolved at runtime)
    }
}

🔹 Key Points
➤ Happens via method overriding.
➤ The object’s actual type (Dog, Cat) decides which method gets executed.
➤ The reference type (Animal) only decides which methods are accessible.
➤ Achieved only with non-static, non-final, non-private methods.

🔸 Static vs Runtime Polymorphism
✔️ Compile-time (Static) Polymorphism → Method Overloading.
(Resolved during compilation).
✔️ Runtime Polymorphism → Method Overriding.
(Resolved during execution using Dynamic Method Dispatch).

📌 Interview Insights
➤ If a superclass reference points to a subclass object, and an overridden method is called → subclass version runs (not superclass).
➤ Constructors cannot be overridden, so runtime polymorphism does not apply to them.
➤ Helps in loose coupling → code works on interface/superclass reference, actual object can vary.


❓ What is the need of creating incomplete methods in Interface?
Interfaces define a contract/blueprint for classes.
They say “these methods must exist” but do not dictate how they should be implemented.

✅ Needs & Advantages:
⚡ Achieve Abstraction
    ✔️ Interface methods are incomplete because the how depends on the class.

✅ Example:
interface Vehicle {
    void start();  // every vehicle must start, but differently
}

class Car implements Vehicle {
    public void start() { 
        System.out.println("Car starts with a key"); 
    }
}

class Bike implements Vehicle {
    public void start() { 
        System.out.println("Bike starts with a self-start button"); 
    }
}


⚡ Multiple Implementations (Polymorphism)
    ✔️ Same method, different behavior → achieved by leaving method incomplete in the interface.

Car.start() ≠ Bike.start(), but both guarantee they implement start().

⚡ Standardization / Contract
    ✔️ Interfaces ensure all implementing classes must follow a standard contract.

✅ Example: Comparable interface → any class implementing it must define compareTo().

⚡Loose Coupling
    ✔️ Code depends on interface (contract) and not on concrete classes.
This allows swapping implementations easily.

✅ Example:
List<String> list = new ArrayList<>();
list = new LinkedList<>();  // works fine, same interface


Future Extensibility
    ✔️ Library/framework writers define interfaces → application developers provide their own implementations.
✅ Example: JDBC → Connection, Statement, ResultSet are interfaces.

Oracle, MySQL, PostgreSQL → provide their own implementations.

🔸 Why not give default method bodies?
➤ Before Java 8, interfaces could only have incomplete methods → pure abstraction.
➤ Since Java 8 → default and static methods allowed in interfaces (to provide common behavior if needed).
➤ But abstract (incomplete) methods are still necessary → to enforce implementation.

❓ Difference between this and super keyword?
| Feature                   | this                                                           | super                                                          |
| Refers to                 | Current class object                                           | Immediate parent class object                                      |
| Usage in constructor      | Calls another constructor in the same class → `this()`         | Calls parent class constructor → `super()`                         |
| Access                    | Access current class fields, methods, and constructors         | Access parent class fields, methods, and constructors              |
| Variable access           | Resolves name conflict between instance variable and local variable  | Resolves name conflict between child and parent class variable |
| Method access             | Calls current class method (can be used explicitly,usually implicit)| Calls parent class method (useful in overriding)                   |
| Constructor call position | `this()` must be the first statement in a constructor                | `super()` must also be the first statement in a constructor    |
| Inheritance               | Does not involve inheritance (refers to same object)                 | Used in inheritance (refers to parent part of the object)          |

✅ Examples
1. Variable Shadowing
class A {
    int x = 10;
}

class B extends A {
    int x = 20;

    void show() {
        System.out.println(x);        // 20 → child’s variable
        System.out.println(this.x);   // 20 → child’s variable explicitly
        System.out.println(super.x);  // 10 → parent’s variable
    }
}

2. Constructor Chaining
class A {
    A() {
        System.out.println("Parent constructor");
    }
}

class B extends A {
    B() {
        super(); // calls parent constructor
        System.out.println("Child constructor");
    }
}

3. Method Overriding
class A {
    void display() {
        System.out.println("Parent display");
    }
}

class B extends A {
    void display() {
        System.out.println("Child display");
    }

    void test() {
        this.display();   // Child display
        super.display();  // Parent display
    }
}

❓ What is a ClassLoader in Java?
➤ A ClassLoader is a part of JVM responsible for loading classes into memory (RAM) when they are first referenced in a Java program.
➤ It loads .class bytecode files from file system, network, or other sources into JVM’s method area.
➤ Without ClassLoader, JVM wouldn’t know how to find and use your classes.

✅ Types of ClassLoaders (Hierarchy)

➤ Bootstrap ClassLoader
    ✔️ Loads core Java classes (rt.jar, java.lang, java.util, etc.).
    ✔️ Part of native JVM code (not a Java class).
✅ Example: String, Integer.

➤ Extension (Platform) ClassLoader
    ✔️ Loads classes from JDK extensions (jre/lib/ext or modules).
✅ Example: javax.* packages.

➤ Application (System) ClassLoader
    ✔️ Loads classes from the classpath (-cp or CLASSPATH env var).
    ✔️ This is the default loader for your project classes.
✅ Example: your com.myapp.Student class.

✅ ClassLoader Hierarchy (Parent Delegation Model)
Bootstrap ClassLoader
        ↓
Extension (Platform) ClassLoader
        ↓
Application (System) ClassLoader
        ↓
Your Custom ClassLoader (optional)

👉 Whenever a class is needed:
➤ Application loader asks parent first.
➤ If parent doesn’t find it, the current loader loads it.
(This avoids multiple loaders loading the same core classes.)

✅ Example
public class ClassLoaderDemo {
    public static void main(String[] args) {
        // String class → core class → loaded by Bootstrap
        System.out.println(String.class.getClassLoader()); 
        // null (Bootstrap is written in native code)

        // This class → loaded by Application ClassLoader
        System.out.println(ClassLoaderDemo.class.getClassLoader()); 
    }
}

📌 Key Interview Insights
🧠 Why parent delegation model?
To prevent security issues (e.g., custom malicious java.lang.String class).
🧠 Can we write a custom ClassLoader?
Yes, by extending ClassLoader and overriding findClass() (used in frameworks like Spring, Tomcat, Hibernate).

🧠 Tricky point:
Bootstrap loader returns null in getClassLoader() because it’s implemented in native code.

❓ What are access specifiers in Java?
Access Specifiers (or Modifiers) control the visibility/scope of classes, methods, constructors, and variables in Java.

There are 4 main access specifiers:

✅ 1. public
➤ Visible everywhere (inside same class, package, subclass, outside package).
➤ Can be accessed from anywhere in the project.

public class Student {
    public String name;
    public void display() {
        System.out.println("Name: " + name);
    }
}

✅ 2. protected
Accessible:
    ✔️ Inside the same package
    ✔️ In subclasses (even if in different package)
    ✔️ Not visible to non-subclasses outside the package.

class Person {
    protected int age;
}
class Student extends Person {
    void showAge() {
        System.out.println(age); // ✅ allowed (in subclass)
    }
}

✅ 3. default (package-private → when no specifier is written)
➤ Accessible only within the same package.
➤ Cannot be accessed outside the package, even in subclasses.

class Teacher {  // default access
    String subject;
    void printSubject() {
        System.out.println(subject);
    }
}

✅ 4. private
➤ Accessible only within the same class.
➤ Not visible to subclass or other classes.

class Account {
    private double balance;
    private void displayBalance() {
        System.out.println(balance);
    }
}

| Specifier     | Same Class | Same Package | Subclass (diff pkg) | Outside Package |
| ------------- | ---------- | ------------ | ------------------- | --------------- |
| **public**    | ✅         | ✅          | ✅                  | ✅             |
| **protected** | ✅         | ✅          | ✅                  | ❌             |
| **default**   | ✅         | ✅          | ❌                  | ❌             |
| **private**   | ✅         | ❌          | ❌                  | ❌             |

📌 Interview Insights
➤ default keyword does not exist — it just means no specifier is written.
➤ protected is commonly misunderstood — it allows subclass access even outside package.
➤ private → best practice for encapsulation (fields should be private + exposed via getters/setters).
➤ Classes can only be public or default (not protected or private).