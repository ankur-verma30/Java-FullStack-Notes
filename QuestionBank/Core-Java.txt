â“ Define JDK, JRE, and JVM
ğŸ”¹ 1. JVM (Java Virtual Machine)
â¤ JVM is an abstract machine that provides a runtime environment to execute Java bytecode.

âš¡Responsibilities:
âœ”ï¸ Converts bytecode â†’ machine code using JIT (Just-In-Time compiler).
âœ”ï¸ Provides platform independence (â€œWrite Once, Run Anywhereâ€).
âœ”ï¸ Manages memory (heap, stack, method area, GC).
âœ”ï¸ Ensures security via bytecode verification.
ğŸ”§ Key Point: JVM is platform-dependent (different implementations for Windows/Linux/Mac), but bytecode is platform-independent.

â¡ï¸ Interview Insight:
Many confuse JVM = Java compiler â†’ Wrong! Compiler (javac) converts Java code â†’ bytecode; JVM executes that bytecode.

ğŸ”¹ 2. JRE (Java Runtime Environment)
â¤ JRE provides libraries, JVM, and other components to run Java applications.

Includes:
âœ”ï¸ JVM
âœ”ï¸ Core libraries (like java.lang, java.util, java.io)
âœ”ï¸ Supporting files
ğŸ”§ Key Point: JRE does not include development tools (compiler, debugger). Itâ€™s only for running Java programs.

â¡ï¸ Interview Trap:
If asked, â€œCan you run Java code with just JRE?â€ â†’ Yes, if you already have compiled bytecode. But you cannot compile .java files with JRE.

ğŸ”¹ 3. JDK (Java Development Kit)
â¤ JDK is the full package required for Java development.

Includes:
âœ”ï¸ JRE (which has JVM + libraries)
âœ”ï¸ Development tools â†’ javac (compiler), jdb (debugger), javadoc, jar, etc.
ğŸ”§ Key Point: JDK is for developers; JRE is for users.

â¡ï¸ Interview Trap:
Some interviewers ask: â€œIf JDK contains JRE, and JRE contains JVM, can we say JDK = JVM?â€
Answer: No. JDK = JRE + Development Tools. JVM is just part of JRE.

ğŸ”¹ Hierarchy Diagram
JDK 
 â””â”€â”€ JRE 
      â””â”€â”€ JVM

ğŸ”¹ One-Liner for Revision
â¤ JVM â†’ Runs bytecode.
â¤ JRE â†’ JVM + Libraries (to run Java apps).
â¤ JDK â†’ JRE + Tools (to develop Java apps).

â“ Significance of public static void main(String[] args)
The main() method is the entry point of every Java program. The JVM calls it to start execution. Each keyword has a special meaning:

ğŸ”¹ 1. public
â¤ Reason: Must be accessible to JVM outside the class.
â¤ JVM looks for main() from anywhere, so it cannot be private or default.
â¤ If not public â†’ main method not found error.

â¡ï¸ Interview Trap:
Q: â€œWhat if I make main() private or protected?â€
A: JVM wonâ€™t be able to access it â†’ runtime error.

ğŸ”¹ 2. static
â¤ Reason: JVM doesnâ€™t need to create an object of the class to call main().
â¤ Being static, it belongs to the class rather than an object.
â¤ Ensures execution starts immediately when the class is loaded.

â¡ï¸ Interview Trap:
Q: â€œCan main() be non-static?â€
A: Yes, it compiles, but JVM wonâ€™t recognize it as a valid entry point.

ğŸ”¹ 3. void
â¤ Reason: main() doesnâ€™t return any value to JVM.
â¤ JVM doesnâ€™t expect a return type.
â¤ If you try to return something, compilation error occurs.

ğŸ”¹ 4. main
â¤ Reason: Name is predefined and reserved by JVM as the entry point.
â¤ If you change it, JVM wonâ€™t start execution.

ğŸ”¹ 5. (String[] args)
â¤ Reason: Accepts command-line arguments when program is executed.
âœ… Example:
class Demo {
    public static void main(String[] args) {
        System.out.println(args[0]); // prints first command line argument
    }
}
Run: java Demo Hello â†’ Output: Hello

â¡ï¸ Alternate forms accepted by JVM:
âœ”ï¸ public static void main(String args[])
âœ”ï¸ public static void main(String... args) (var-args since Java 5)

ğŸ”¹ One-Liner for Quick Revision
âœ”ï¸ public â†’ JVM can access.
âœ”ï¸ static â†’ No object needed.
âœ”ï¸ void â†’ No return value.
âœ”ï¸ main â†’ JVMâ€™s entry point.
âœ”ï¸ String[] args â†’ Command-line inputs.

ğŸ”¹ Interview Insights
â¤ â€œWhat if signature is public static int main()?â€ â†’ Compilation error.
â¤ â€œWhat if I overload main()?â€ â†’ Allowed, but JVM only calls the public static void main(String[] args).
â¤ â€œWhat if args is changed to String... args?â€ â†’ Still valid.


â“ Why does the main method support String[] args?
ğŸ”¹ 1. Command-Line Arguments Support
String[] args lets us pass data from outside (command line) to the program at runtime.
âœ… Example:

class Demo {
    public static void main(String[] args) {
        System.out.println("First argument: " + args[0]);
    }
}
âš¡ Run: java Demo Hello
Output: First argument: Hello

â¡ï¸ Without String[] args, the JVM couldnâ€™t pass inputs from command line.

ğŸ”¹ 2. Why Specifically String?
â¤ Every input from command line is text-based.
â¤ JVM collects arguments as strings (e.g., "123" not number 123).

â¤ If you need another type (int, double), you must parse it manually:
int num = Integer.parseInt(args[0]); // converts "123" â†’ 123

ğŸ”¹ 3. Why Array []?
â¤ Because we may pass multiple arguments separated by space.

âœ… Example:
java Demo Alice Bob Charlie

Then:
args[0] = "Alice"
args[1] = "Bob"
args[2] = "Charlie"
â¡ï¸ An array is the best way to store variable-length inputs.

ğŸ”¹ 4. Alternative Forms Accepted by JVM
â¤ JVM doesnâ€™t strictly enforce String[] args.
â¤ The following are also valid:
    âœ”ï¸ String args[]
    âœ”ï¸ String... args (var-args since Java 5).

ğŸ”¹ 5. What if we remove it?
If you write: public static void main()
â— Compiles fine, but JVM wonâ€™t recognize it as a valid entry point â†’ Runtime error:
âŒ Error: Main method not found in class Demo

ğŸ”¹ One-Liner for Quick Revisio
ğŸ‘‰ String[] args is used because JVM needs a standard way to pass runtime command-line arguments, and all inputs are strings by default.

ğŸ”¹ Interview Insights
ğŸ§  Trick Q: â€œWhy not int[] args or Object[] args?â€
â¤ Because JVM can only guarantee that inputs will be Strings from command line.
ğŸ§  Trick Q: â€œCan we overload main() with different parameters?â€
â¤ Yes, but JVM only calls public static void main(String[] args). Others can only be called manually inside code.

â“ Constructor Chaining in Java
Constructor Chaining means calling one constructor from another constructor (in the same class or parent class) to reuse initialization code and avoid duplication.

ğŸ”¹ Types of Constructor Chaining

ğŸ”„ Within the same class â†’ using this()
    âœ”ï¸ Calls another constructor of the same class.
    âœ”ï¸ Must be the first statement in the constructor.

ğŸ”„ Between parent and child class â†’ using super()
    âœ”ï¸ Calls the parent class constructor.
    âœ”ï¸ Must be the first statement in the constructor.

âœ… Example 1: Same Class (this())
class Student {
    private String name;
    private int age;

    // Constructor 1
    Student() {
        this("Unknown", 18);  // calling parameterized constructor
    }

    // Constructor 2
    Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    void display() {
        System.out.println(name + " - " + age);
    }
}

public class Demo {
    public static void main(String[] args) {
        Student s1 = new Student();
        Student s2 = new Student("Alice", 22);
        s1.display(); // Unknown - 18
        s2.display(); // Alice - 22
    }
}
â¡ï¸ Here, default constructor calls the parameterized constructor to avoid duplicate code.

âœ… Example 2: Parent â†’ Child (super())
class Person {
    Person() {
        System.out.println("Person constructor");
    }
}

class Employee extends Person {
    Employee() {
        super();  // calls parent constructor
        System.out.println("Employee constructor");
    }
}

public class Demo {
    public static void main(String[] args) {
        new Employee();
    }
}
âœ… Output:
Person constructor
Employee constructor
â¡ï¸ Here, super() ensures parent class initialization happens first.

ğŸ”¹ Rules of Constructor Chaining
â¤ Either this() or super() must be the first statement.
â¤ Circular calls (like a constructor calling itself) â†’ compile-time error.
â¤ If you donâ€™t write super(), the compiler automatically inserts super() (default constructor).
â¤ Cannot use both this() and super() in the same constructor â†’ only one allowed.

ğŸ”¹ Why is it Important?
â¤ Code Reusability â†’ No duplication of initialization logic.
â¤ Readability â†’ Clear execution order.
â¤ Mandatory for Inheritance â†’ Parent must always be initialized before child.

ğŸ”¹ One-Liner for Quick Revision
ğŸ‘‰ Constructor Chaining = Calling one constructor from another (same class via this(), parent class via super()) to reuse initialization logic.

ğŸ”¹ Interview Insights
ğŸ§  Q: â€œWhat happens if parent has only parameterized constructor and child does not call it?â€
â¤ Compilation error (because compiler inserts super() but no default constructor exists).
ğŸ§  Q: â€œCan this() and super() be used together?â€
â¤ No, only one can be the first line.
ğŸ§  Q: â€œWhat if I call a method before super() inside a constructor?â€
â¤ Compilation error: Constructor call must be the first statement.


â“ OOPs Concepts(Inheritance, Polymorphism, Encapsulation, Abstraction)
ğŸ”¹ 1. Encapsulation â†’ Data Hiding + Binding
â¤ Wrapping variables (data) and methods (logic) into a single unit (class). Provides controlled access via getters/setters.

âœ… Daily Life Example:
A bank account: Your balance is hidden (private), but you can access it using deposit/withdraw methods.
â¤ One-liner: â€œEncapsulation = data hiding using access modifiers + methods.â€

ğŸ”¹ 2. Abstraction â†’ Hiding Implementation
â¤ Showing only essential details, hiding internal complexity. Achieved using abstract classes / interfaces.

âœ… Daily Life Example:
Car driving: You use the steering wheel, accelerator, brakes without knowing how the engine, gears, and sensors work internally.
â¤ One-liner: â€œAbstraction = show what it does, hide how it does.â€

ğŸ”¹ 3. Inheritance â†’ Reusability
â¤ One class acquires properties and methods of another (parent â†’ child). Promotes code reuse.

âœ… Daily Life Example:
    âœ”ï¸ Father â†’ Son: A child inherits properties (like eye color) and behaviors (like habits) from parents.
    âœ”ï¸ In software: class Dog extends Animal.
â¤ One-liner: â€œInheritance = child gets features from parent.â€

ğŸ”¹ 4. Polymorphism â†’ Many Forms
â¤ Same method/operation behaves differently in different contexts.
    âœ”ï¸ Compile-time polymorphism â†’ Method overloading.
    âœ”ï¸ Runtime polymorphism â†’ Method overriding.

âœ… Daily Life Example:
Mobile Phone Button:
    âœ”ï¸ Single button = different actions (tap â†’ open app, double tap â†’ camera, long press â†’ assistant).
â¤ One-liner: â€œPolymorphism = same name, different behavior.â€

ğŸ”¹ Interview-Ready Summary (One Sentence)
ğŸ‘‰ OOPs = Encapsulation (data hiding), Abstraction (hiding implementation), Inheritance (reusability), and Polymorphism (same method different forms) â€” just like real-world objects such as cars, bank accounts, or family inheritance.

â“ Difference between Interface and Abstract Class
â¤ Interface: A contract that specifies what a class must do, but not how.
â¤ Abstract Class: A class that may have partial implementation (some abstract methods + some concrete methods).

ğŸ”¹ 2. Method Implementation
â¤ Interface:
    âœ”ï¸ Before Java 8 â†’ only abstract methods (implicitly public abstract).
    âœ”ï¸ Java 8 â†’ allowed default & static methods.
    âœ”ï¸ Java 9 â†’ allowed private methods.

â¤ Abstract Class:
    âœ”ï¸ Can have both abstract and concrete methods.
    âœ”ï¸ Can provide partial implementation.

ğŸ”¹ 3. Variables
â¤ Interface:
    âœ”ï¸ Variables are always public static final (constants).
    âœ”ï¸ Must be initialized at declaration.

â¤ Abstract Class:
    âœ”ï¸ Can have instance variables.
    âœ”ï¸ Can use any access modifier (private, protected, etc.).

ğŸ”¹ 4. Inheritance & Multiple Inheritance
Interface: Supports multiple inheritance (a class can implement multiple interfaces).
Abstract Class: Supports single inheritance only (a class can extend only one abstract class).

ğŸ”¹ 5. Constructors
Interface: âŒ Cannot have constructors (cannot be instantiated).
Abstract Class: âœ… Can have constructors (called when subclass object is created).

ğŸ”¹ 6. Use Cases
â¤ Interface:
    âœ”ï¸ Used to define a contract/blueprint for unrelated classes.
    âœ… Example: Comparable, Runnable, Serializable.

â¤ Abstract Class:
    âœ”ï¸ Used when classes share common behavior + state but still have some abstract methods.

âœ… Example: AbstractList in Java Collections.

ğŸ”¹ 7. Code Example
// Interface example
interface Vehicle {
    void start(); // abstract method
}

class Car implements Vehicle {
    public void start() {
        System.out.println("Car starts with key");
    }
}

// Abstract class example
abstract class Animal {
    abstract void sound();   // abstract method
    void sleep() {           // concrete method
        System.out.println("Sleeping...");
    }
}

class Dog extends Animal {
    void sound() {
        System.out.println("Bark");
    }
}

ğŸ”¹ 8. One-Liner for Interview
â¤ Interface â†’ â€œDefines what to do, no state.â€
â¤ Abstract Class â†’ â€œDefines what to do + partial how to do, can have state.â€

ğŸ”¹ 9. Interview Traps & Insights
ğŸ§  Q: â€œCan an interface extend another interface?â€ â†’ âœ… Yes (multiple inheritance of interfaces allowed).
ğŸ§  Q: â€œCan an abstract class implement an interface?â€ â†’ âœ… Yes, but must provide implementation for methods or remain abstract.
ğŸ§  Q: â€œWhich is faster, abstract class or interface?â€ â†’ Abstract class is slightly faster (direct method call vs dynamic dispatch in interfaces).
ğŸ§  Q: â€œWhen to prefer interface over abstract class?â€ â†’ Use interface when unrelated classes need common behavior (e.g., Flyable, Drivable). Use abstract class when related classes share state/logic (e.g., Shape).

â“ Multi-catch Block in Java
â¤ A multi-catch block allows you to handle multiple exceptions in a single catch block using the | (pipe) operator.
â¤ Introduced in Java 7 to reduce code duplication.

âœ… Example (Before Java 7 â†’ Repetitive Code)
try {
    int arr[] = new int[5];
    arr[5] = 10 / 0;
} catch (ArithmeticException e) {
    System.out.println("Arithmetic Exception: " + e.getMessage());
} catch (ArrayIndexOutOfBoundsException e) {
    System.out.println("Array Index Exception: " + e.getMessage());
}
âŒ Problem: Code is repetitive; two separate blocks with same logic.

âœ… Example (After Java 7 â†’ Multi-Catch)
try {
    int arr[] = new int[5];
    arr[5] = 10 / 0;
} catch (ArithmeticException | ArrayIndexOutOfBoundsException e) {
    System.out.println("Exception: " + e.getMessage());
}
â¡ï¸ Same result with cleaner code.

ğŸ”¹ Rules of Multi-catch
â¤ Use | (pipe) to separate multiple exception types.
â¤ Exceptions must be unrelated (not parent-child).

âœ… Allowed: IOException | SQLException
âŒ Not Allowed: IOException | FileNotFoundException (because FileNotFoundException is a subclass of IOException).

âš¡ The exception variable (e) is final implicitly â†’ You cannot reassign it inside the block.

ğŸ”¹ Why Multi-catch is Useful?
â¤ Reduces boilerplate code (no duplicate catch blocks).
â¤ Improves readability.
â¤ Optimizes bytecode (compiler generates smaller, efficient bytecode).

ğŸ”¹ One-Liner for Quick Revision
ğŸ‘‰ Multi-catch block = Handle multiple exceptions in one catch block using | operator (Java 7+), avoiding code duplication.

ğŸ”¹ Interview Insights
ğŸ§  Q: â€œCan we catch exceptions in order?â€
In multi-catch, order doesnâ€™t matter because itâ€™s a single block.
ğŸ§  Q: â€œWhat if exceptions have parent-child relation?â€
Compile-time error. Use separate catch blocks instead.
ğŸ§  Q: â€œIs the exception object final in multi-catch?â€
Yes, you cannot assign e = new Exception() inside.


â“ Difference between final, finally, and finalize()
ğŸ”¹ 1. final (Keyword)
â¤ Usage: Restrict modification.
â¤ Applied to: Variable â†’ makes it a constant (cannot be reassigned).

final int x = 10;
// x = 20; âŒ Compile-time error

â¤ Method â†’ prevents overriding in child class.
class A {
    final void show() { System.out.println("A"); }
}
class B extends A {
    // void show() {} âŒ Not allowed
}

â¤ Class â†’ prevents inheritance.
final class A {}
// class B extends A {} âŒ Not allowed
â¡ï¸ One-liner: final = constant / no overriding / no inheritance.

ğŸ”¹ 2. finally (Block)
â¤ Usage: Used in exception handling.
â¤ Purpose: Ensures a block of code always executes, regardless of exception occurrence.
â¤ Commonly used for resource cleanup (closing files, DB connections).

âœ… Example:
try {
    int x = 10 / 0;
} catch (ArithmeticException e) {
    System.out.println("Exception: " + e);
} finally {
    System.out.println("Finally block always executes");
}

âœ… Output:
Exception: java.lang.ArithmeticException: / by zero
Finally block always executes

â¡ï¸ Special case: If you call System.exit(0), the finally block wonâ€™t execute.
â¡ï¸ One-liner: finally = block that always executes (for cleanup).

ğŸ”¹ 3. finalize() (Method)
A method in Object class called by Garbage Collector (GC) before destroying an object.
Usage: To release resources (like closing file handles, DB connections) before object is removed.

âœ… Example:
class Demo {
    protected void finalize() {
        System.out.println("Finalize method called before GC");
    }
    public static void main(String[] args) {
        Demo d = new Demo();
        d = null;
        System.gc(); // Suggests JVM to call GC
    }
}
âœ… Output: Finalize method called before GC


â¡ï¸ Important Notes:
â¤ finalize() execution is not guaranteed. GC may or may not run.
â¤ From Java 9, finalize() is deprecated (use try-with-resources instead).
â¡ï¸ One-liner: finalize() = method called by GC before object destruction (deprecated).

ğŸ”¹ Interview-Ready Comparison
| Feature           | `final` (Keyword)                        | `finally` (Block)            | `finalize()` (Method)                 |
| ----------------- | ---------------------------------------- | ---------------------------- | ------------------------------------- |
| **Category**      | Modifier                                 | Block                        | Method in `Object` class              |
| **Used For**      | Constants, no overriding, no inheritance | Cleanup code after try-catch | Cleanup before object destruction     |
| **When Executes** | At compile-time restriction              | Always after try-catch       | Called by GC before destroying object |
| **Control**       | Programmer                               | Programmer                   | JVM/GC decides                        |
| **Deprecation**   | âŒ Not deprecated                         | âŒ Not deprecated             | âœ… Deprecated in Java 9+               |


â“ Why is String inheritable? (or is it?)
ğŸ”¹ Truth about String class
The String class in Java is declared as:
âœ… Code Structure:
public final class String implements Serializable, Comparable<String>, CharSequence
Notice the final keyword â†’ this means:
    âœ”ï¸ String cannot be inherited (cannot have a subclass).
    âœ”ï¸ This is done to ensure immutability and security.
â¡ï¸ So, String is NOT inheritable. If you try to extend it:
class MyString extends String {} // âŒ Compile-time error

ğŸ”¹ Why did Java make String final?
â¤ Immutability: Prevents someone from extending String and overriding methods to break immutability.
â¤ Security: Strings are used in sensitive areas (file paths, DB URLs, network connections). If String could be inherited and tampered, it would be a major security risk.
â¤ Performance: String pool (interning) relies on immutability. If strings were mutable or extendable, pooling would fail.

â“ How can we create our own inheritance class?
If you want a custom class that supports inheritance, donâ€™t mark it as final. Example:

// Parent class
class Vehicle {
    String brand = "Generic";

    void start() {
        System.out.println("Vehicle starting...");
    }
}

// Child class
class Car extends Vehicle {
    int wheels = 4;

    @Override
    void start() {
        System.out.println(brand + " Car starting with " + wheels + " wheels!");
    }
}

public class Demo {
    public static void main(String[] args) {
        Car c = new Car();
        c.brand = "Tesla";
        c.start(); // Tesla Car starting with 4 wheels!
    }
}

ğŸ”¹ Rules for creating an inheritance class
â¤ Use extends keyword for class inheritance.
â¤ Use implements for interface implementation.
â¤ Methods in parent can be overridden in child (unless final/static/private).
â¤ Parentâ€™s constructor is always called first (via super()).
â¤ Multiple inheritance of classes is not allowed in Java â†’ solve via interfaces.

â“What is Runtime Polymorphism?
Runtime polymorphism in Java is method overriding â€” when a method call is resolved at runtime (not compile-time).
Itâ€™s also called Dynamic Method Dispatch.

âœ… Example: Method Overriding
class Animal {
    void sound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("Dog barks");
    }
}

class Cat extends Animal {
    @Override
    void sound() {
        System.out.println("Cat meows");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal a1 = new Dog();  // reference is Animal, object is Dog
        Animal a2 = new Cat();  // reference is Animal, object is Cat

        a1.sound();   // Dog barks  (resolved at runtime)
        a2.sound();   // Cat meows  (resolved at runtime)
    }
}

ğŸ”¹ Key Points
â¤ Happens via method overriding.
â¤ The objectâ€™s actual type (Dog, Cat) decides which method gets executed.
â¤ The reference type (Animal) only decides which methods are accessible.
â¤ Achieved only with non-static, non-final, non-private methods.

ğŸ”¸ Static vs Runtime Polymorphism
âœ”ï¸ Compile-time (Static) Polymorphism â†’ Method Overloading.
(Resolved during compilation).
âœ”ï¸ Runtime Polymorphism â†’ Method Overriding.
(Resolved during execution using Dynamic Method Dispatch).

ğŸ“Œ Interview Insights
â¤ If a superclass reference points to a subclass object, and an overridden method is called â†’ subclass version runs (not superclass).
â¤ Constructors cannot be overridden, so runtime polymorphism does not apply to them.
â¤ Helps in loose coupling â†’ code works on interface/superclass reference, actual object can vary.


â“ What is the need of creating incomplete methods in Interface?
Interfaces define a contract/blueprint for classes.
They say â€œthese methods must existâ€ but do not dictate how they should be implemented.

âœ… Needs & Advantages:
âš¡ Achieve Abstraction
    âœ”ï¸ Interface methods are incomplete because the how depends on the class.

âœ… Example:
interface Vehicle {
    void start();  // every vehicle must start, but differently
}

class Car implements Vehicle {
    public void start() { 
        System.out.println("Car starts with a key"); 
    }
}

class Bike implements Vehicle {
    public void start() { 
        System.out.println("Bike starts with a self-start button"); 
    }
}


âš¡ Multiple Implementations (Polymorphism)
    âœ”ï¸ Same method, different behavior â†’ achieved by leaving method incomplete in the interface.

Car.start() â‰  Bike.start(), but both guarantee they implement start().

âš¡ Standardization / Contract
    âœ”ï¸ Interfaces ensure all implementing classes must follow a standard contract.

âœ… Example: Comparable interface â†’ any class implementing it must define compareTo().

âš¡Loose Coupling
    âœ”ï¸ Code depends on interface (contract) and not on concrete classes.
This allows swapping implementations easily.

âœ… Example:
List<String> list = new ArrayList<>();
list = new LinkedList<>();  // works fine, same interface


Future Extensibility
    âœ”ï¸ Library/framework writers define interfaces â†’ application developers provide their own implementations.
âœ… Example: JDBC â†’ Connection, Statement, ResultSet are interfaces.

Oracle, MySQL, PostgreSQL â†’ provide their own implementations.

ğŸ”¸ Why not give default method bodies?
â¤ Before Java 8, interfaces could only have incomplete methods â†’ pure abstraction.
â¤ Since Java 8 â†’ default and static methods allowed in interfaces (to provide common behavior if needed).
â¤ But abstract (incomplete) methods are still necessary â†’ to enforce implementation.

â“ Difference between this and super keyword?
| Feature                   | this                                                           | super                                                          |
| Refers to                 | Current class object                                           | Immediate parent class object                                      |
| Usage in constructor      | Calls another constructor in the same class â†’ `this()`         | Calls parent class constructor â†’ `super()`                         |
| Access                    | Access current class fields, methods, and constructors         | Access parent class fields, methods, and constructors              |
| Variable access           | Resolves name conflict between instance variable and local variable  | Resolves name conflict between child and parent class variable |
| Method access             | Calls current class method (can be used explicitly,usually implicit)| Calls parent class method (useful in overriding)                   |
| Constructor call position | `this()` must be the first statement in a constructor                | `super()` must also be the first statement in a constructor    |
| Inheritance               | Does not involve inheritance (refers to same object)                 | Used in inheritance (refers to parent part of the object)          |

âœ… Examples
1. Variable Shadowing
class A {
    int x = 10;
}

class B extends A {
    int x = 20;

    void show() {
        System.out.println(x);        // 20 â†’ childâ€™s variable
        System.out.println(this.x);   // 20 â†’ childâ€™s variable explicitly
        System.out.println(super.x);  // 10 â†’ parentâ€™s variable
    }
}

2. Constructor Chaining
class A {
    A() {
        System.out.println("Parent constructor");
    }
}

class B extends A {
    B() {
        super(); // calls parent constructor
        System.out.println("Child constructor");
    }
}

3. Method Overriding
class A {
    void display() {
        System.out.println("Parent display");
    }
}

class B extends A {
    void display() {
        System.out.println("Child display");
    }

    void test() {
        this.display();   // Child display
        super.display();  // Parent display
    }
}

â“ What is a ClassLoader in Java?
â¤ A ClassLoader is a part of JVM responsible for loading classes into memory (RAM) when they are first referenced in a Java program.
â¤ It loads .class bytecode files from file system, network, or other sources into JVMâ€™s method area.
â¤ Without ClassLoader, JVM wouldnâ€™t know how to find and use your classes.

âœ… Types of ClassLoaders (Hierarchy)

â¤ Bootstrap ClassLoader
    âœ”ï¸ Loads core Java classes (rt.jar, java.lang, java.util, etc.).
    âœ”ï¸ Part of native JVM code (not a Java class).
âœ… Example: String, Integer.

â¤ Extension (Platform) ClassLoader
    âœ”ï¸ Loads classes from JDK extensions (jre/lib/ext or modules).
âœ… Example: javax.* packages.

â¤ Application (System) ClassLoader
    âœ”ï¸ Loads classes from the classpath (-cp or CLASSPATH env var).
    âœ”ï¸ This is the default loader for your project classes.
âœ… Example: your com.myapp.Student class.

âœ… ClassLoader Hierarchy (Parent Delegation Model)
Bootstrap ClassLoader
        â†“
Extension (Platform) ClassLoader
        â†“
Application (System) ClassLoader
        â†“
Your Custom ClassLoader (optional)

ğŸ‘‰ Whenever a class is needed:
â¤ Application loader asks parent first.
â¤ If parent doesnâ€™t find it, the current loader loads it.
(This avoids multiple loaders loading the same core classes.)

âœ… Example
public class ClassLoaderDemo {
    public static void main(String[] args) {
        // String class â†’ core class â†’ loaded by Bootstrap
        System.out.println(String.class.getClassLoader()); 
        // null (Bootstrap is written in native code)

        // This class â†’ loaded by Application ClassLoader
        System.out.println(ClassLoaderDemo.class.getClassLoader()); 
    }
}

ğŸ“Œ Key Interview Insights
ğŸ§  Why parent delegation model?
To prevent security issues (e.g., custom malicious java.lang.String class).
ğŸ§  Can we write a custom ClassLoader?
Yes, by extending ClassLoader and overriding findClass() (used in frameworks like Spring, Tomcat, Hibernate).

ğŸ§  Tricky point:
Bootstrap loader returns null in getClassLoader() because itâ€™s implemented in native code.

â“ What are access specifiers in Java?
Access Specifiers (or Modifiers) control the visibility/scope of classes, methods, constructors, and variables in Java.

There are 4 main access specifiers:

âœ… 1. public
â¤ Visible everywhere (inside same class, package, subclass, outside package).
â¤ Can be accessed from anywhere in the project.

public class Student {
    public String name;
    public void display() {
        System.out.println("Name: " + name);
    }
}

âœ… 2. protected
Accessible:
    âœ”ï¸ Inside the same package
    âœ”ï¸ In subclasses (even if in different package)
    âœ”ï¸ Not visible to non-subclasses outside the package.

class Person {
    protected int age;
}
class Student extends Person {
    void showAge() {
        System.out.println(age); // âœ… allowed (in subclass)
    }
}

âœ… 3. default (package-private â†’ when no specifier is written)
â¤ Accessible only within the same package.
â¤ Cannot be accessed outside the package, even in subclasses.

class Teacher {  // default access
    String subject;
    void printSubject() {
        System.out.println(subject);
    }
}

âœ… 4. private
â¤ Accessible only within the same class.
â¤ Not visible to subclass or other classes.

class Account {
    private double balance;
    private void displayBalance() {
        System.out.println(balance);
    }
}

| Specifier     | Same Class | Same Package | Subclass (diff pkg) | Outside Package |
| ------------- | ---------- | ------------ | ------------------- | --------------- |
| **public**    | âœ…         | âœ…          | âœ…                  | âœ…             |
| **protected** | âœ…         | âœ…          | âœ…                  | âŒ             |
| **default**   | âœ…         | âœ…          | âŒ                  | âŒ             |
| **private**   | âœ…         | âŒ          | âŒ                  | âŒ             |

ğŸ“Œ Interview Insights
â¤ default keyword does not exist â€” it just means no specifier is written.
â¤ protected is commonly misunderstood â€” it allows subclass access even outside package.
â¤ private â†’ best practice for encapsulation (fields should be private + exposed via getters/setters).
â¤ Classes can only be public or default (not protected or private).

â“Difference between Object Oriented Programming (OOP) and Procedure Oriented Programming (POP)?
| Feature                | Procedure-Oriented Programming (POP)                              | Object-Oriented Programming (OOP)
| Approach           | Focuses on functions (procedures) that operate on data.           | Focuses on objects that encapsulate both data & behavior.                    |
| Data Security      | Data is global and can be accessed by any function â†’ less secure. | Data is encapsulated inside objects â†’ more secure.                           |
| Modularity         | Functions are the building blocks.                                | Classes & objects are the building blocks.                                   |
| Reusability        | Limited reusability, functions need rewriting for new requirements.   | High reusability via inheritance & polymorphism.                       |
| Example Language   | C, Pascal                                                             | Java, C++,Python                                                         |
| Scalability        | Harder to manage large codebases â†’ less scalable.                    | Easier to manage large projects â†’ more scalable.                          |
| Data Handling      | Data moves **freely between functions**.                              | Data is hidden & accessed via methods (getters/setters).                 |
| Abstraction        | No direct support, manual handling.                                   | Strong support with **abstract classes & interfaces.                     |
| Real-World Mapping | Poor real-world representation.                                      | Maps naturally to real-world entities (Car, Employee, BankAccount, etc.). |

Interview One-Liners
â¤ POP = "Functions-first, Data-second"
â¤ OOP = "Data-first, Functions bound to Data"
â¤ POP is like writing a recipe step by step, OOP is like designing a kitchen with appliances (objects).


â“Is Java 100% Object-Oriented?
â¤ No, Java is not 100% Object-Oriented.
â¤ Even though Java follows Object-Oriented Programming principles (Encapsulation, Inheritance, Polymorphism, Abstraction), it is not purely OOP.

Reasons Why Java is NOT 100% OOP:
ğŸ”„ Primitive Data Types
    âœ”ï¸ Java has 8 primitive types (int, char, byte, short, long, float, double, boolean).
    âœ”ï¸ These are not objects; they are stored directly in memory for performance.
    âœ”ï¸ If Java was 100% OOP, even these would be objects.
(Wrapper classes like Integer, Double, etc., were later introduced to wrap primitives.)

ğŸ”„ Static Members
    âœ”ï¸ static keyword allows access without creating an object.
    âœ”ï¸ This violates the â€œeverything should be an objectâ€ rule.

ğŸ”„ main() Method
    âœ”ï¸ public static void main(String[] args) is static, so JVM can call it without creating an object.

ğŸ”„ Other Non-OOP Features
    âœ”ï¸ Use of operator overloading is not allowed (only + for String is overloaded).
    âœ”ï¸ Supports procedural code inside static methods.

âœ… Conclusion
    âœ”ï¸ Java is Object-Oriented, but not 100% OOP.
    âœ”ï¸ The major reason: primitives + static context.


â“Why Pointers in not used in Java?
Java does not support explicit pointers (like in C/C++) because of security, simplicity, and memory management reasons. Instead, Java uses references to access objects.

Detailed Reasons

ğŸ”„ Security
    âœ”ï¸ Pointers allow direct memory access.
    âœ”ï¸ This can lead to:
        ğŸ‘‰ Unauthorized access to memory (hacking, buffer overflow).
        ğŸ‘‰ Modification of critical JVM memory areas.
    âœ”ï¸ By removing pointers, Java prevents such security vulnerabilities.

ğŸ”„ Simplicity & Readability
    âœ”ï¸ Pointers make code complex (pointer arithmetic, dangling pointers, memory leaks).
    âœ”ï¸ Java was designed to be beginner-friendly, so pointers were avoided.
    âœ”ï¸ Instead, Java developers work with references (safe pointers handled internally by JVM).

ğŸ”„ Automatic Memory Management (Garbage Collection)
    âœ”ï¸ In C/C++, developers must manually allocate (malloc) and free (free) memory.
    âœ”ï¸ Pointers complicate memory management, leading to memory leaks.
    âœ”ï¸ Java uses Garbage Collector (GC) to manage memory automatically, and explicit pointers would interfere with GC.

ğŸ”„ Platform Independence
    âœ”ï¸ Pointers are machine-dependent (addressing varies across architectures).
Javaâ€™s motto is â€œWrite Once, Run Anywhereâ€.
    âœ”ï¸ By avoiding pointers, Java programs remain portable across different systems.

ğŸ”„ Use of References Instead
    âœ”ï¸ In Java, when you create an object:
String s = new String("Hello");

    âœ”ï¸ s is a reference, not a pointer.
    âœ”ï¸ You can use it to access the object, but you cannot perform pointer arithmetic (like s+1).

One-Liner
ğŸ‘‰ "Java does not support explicit pointers to ensure security, simplicity, automatic memory management, and platform independence. Instead, Java uses references, which are safe and managed by JVM."

âœ… Common Trap in Interviews:
ğŸ§ If asked "But arenâ€™t references in Java like pointers?" 
âœ… Answer:
"Yes, references are somewhat like pointers, but they donâ€™t allow pointer arithmetic or direct memory access, making them safer and JVM-controlled."


â“Functional Interface and Lambda Expression. How these two are related to each other?
âœ”ï¸Answer:
â¤ Functional interface that has exactly one abstract method.
â¤ Can have:
    ğŸ‘‰One abstract method
    ğŸ‘‰Any number of default and static methods
â¤ Annotated with @FunctionalInterface (optional, but good practice).

âœ… Examples from JDK:
1. Runnable (run())
2. Callable (call())
3. Comparator (compare())
4. Predicate<T> (test())
5. Function<T, R> (apply())

âš¡ Code Example:
@FunctionalInterface
interface MyFunctionalInterface {
    void sayHello();
}

âœ… Lambda Expression
short-cut way of writing an anonymous implementation of a functional interface.
â— Syntax: (parameters) -> expression_or_block

âš¡Code Example:
public class Test {
    public static void main(String[] args) {
        // Traditional Anonymous Class
        MyFunctionalInterface obj1 = new MyFunctionalInterface() {
            public void sayHello() {
                System.out.println("Hello World");
            }
        };

        // Using Lambda Expression
        MyFunctionalInterface obj2 = () -> System.out.println("Hello World");

        obj1.sayHello();
        obj2.sayHello();
    }
}

âœ… Output:
Hello World
Hello World

âœ… Relationship Between Them
â¤ Lambda expressions can only be used with functional interfaces.
â¤ The functional interface provides the target type for the lambda.
â¤ ompiler maps the lambda expression â†’ single abstract method of the functional interface.

ğŸ‘‰ Example:
Runnable r = () -> System.out.println("Running...");  
// Here Runnable is functional interface, lambda implements run()

ğŸ”„ Why Introduced?
To support functional programming style in Java 8.
Makes code shorter, cleaner, and more readable (especially in Streams API).


â“Use of Marker Interfaces?
âœ”ï¸ Answer: 
A Marker Interface is an interface with no methods or fields.
Also called tagging interfaces.
Purpose: to mark/tag a class so that JVM or frameworks can give it special behavior.

ğŸ‘‰ Examples in JDK:
1. Serializable
2. Cloneable
3. Remote

ğŸ”„ Use of Marker Interfaces
âœ”ï¸ Provide Metadata to JVM / Compiler
    â¤ Marker interfaces act as tags for classes.
    âœ… Example: If a class implements Serializable, JVM knows objects of this class can be serialized.

âœ”ï¸ Enable Special Behavior at Runtime
JVM / frameworks check with instanceof to see if a class is marked.
âœ… Example:
if(obj instanceof Serializable) {
    // JVM will allow serialization
}

âœ”ï¸ Provide Strong Type Checking
    â¤ Marker interface is part of type system.
    â¤ Compiler ensures only tagged classes are passed where required.

âœ”ï¸ Used in Frameworks / Libraries
Many frameworks (Hibernate, Spring, etc.) use marker interfaces for configuration and behavior control.

âœ… Code Example:
import java.io.*;

class Student implements Serializable {   // Marker interface
    int id;
    String name;
    Student(int id, String name) {
        this.id = id;
        this.name = name;
    }
}

public class MarkerDemo {
    public static void main(String[] args) throws Exception {
        Student s = new Student(1, "Ankur");

        // Serialize object
        FileOutputStream fos = new FileOutputStream("data.ser");
        ObjectOutputStream oos = new ObjectOutputStream(fos);
        oos.writeObject(s);  // Works only because Student implements Serializable
        oos.close();

        System.out.println("Object serialized successfully!");
    }
}

âœ… Output:
Object serialized successfully!

â— If Student did not implement Serializable, above code would throw NotSerializableException.

âš¡ Follow-up Trap Question:
ğŸ‘‰ â€œSince Java 5 introduced annotations, are Marker Interfaces still useful?â€
Answer: â€œAnnotations are now preferred for metadata, but marker interfaces still provide type safety and are widely used in legacy code.â€


â“What is object class and which methods are present in the object class.
âœ”ï¸ Answer:
â¤ Object is the parent/base class of all classes in Java.
â¤ Every class in Java directly or indirectly inherits from Object.
â¤ It is present in java.lang package.
â¤ Provides common methods that every Java class gets by default.

ğŸ‘‰ Example:
class Student {
    int id;
    String name;
}

â¤ Even though we didnâ€™t extend anything, Student extends Object internally.

âœ… Methods Present in Object Class
| **Method**                                     | **Description / Use**                                                        |
| ---------------------------------------------- | ---------------------------------------------------------------------------- |
| `public String toString()`                     | Returns string representation of object (default: className\@hashCode).      |
| `public boolean equals(Object obj)`            | Compares two objects for equality (default: reference equality).             |
| `public int hashCode()`                        | Returns hash code of object (used in HashMap, HashSet, etc.).                |
| `protected Object clone()`                     | Creates and returns a copy of the object (class must implement `Cloneable`). |
| `protected void finalize()`                    | Called by GC before object is destroyed (deprecated in Java 9).              |
| `public final Class<?> getClass()`             | Returns runtime class (reflection).                                          |
| `protected void wait()`                        | Causes current thread to wait until notified.                                |
| `protected void wait(long timeout)`            | Wait with timeout.                                                           |
| `protected void wait(long timeout, int nanos)` | Wait with timeout + nanos.                                                   |
| `public final void notify()`                   | Wakes up one waiting thread on objectâ€™s monitor.                             |
| `public final void notifyAll()`                | Wakes up all waiting threads on objectâ€™s monitor.                            |


âœ… Example Usage
class Student {
    int id;
    String name;

    Student(int id, String name) {
        this.id = id;
        this.name = name;
    }

    // Override toString()
    public String toString() {
        return "Student[id=" + id + ", name=" + name + "]";
    }
}

public class ObjectDemo {
    public static void main(String[] args) {
        Student s1 = new Student(1, "Ankur");
        Student s2 = new Student(1, "Ankur");

        // toString()
        System.out.println(s1);  // Student[id=1, name=Ankur]

        // equals()
        System.out.println(s1.equals(s2));  // false (unless overridden)

        // hashCode()
        System.out.println(s1.hashCode());
    }
}

âš¡ Follow-up (commonly asked):
ğŸ‘‰ â€œWhy should we override equals() and hashCode() together?â€


â“What is Exception Handling and Explain Exception handling hierarchy.
âœ”ï¸ Answer:
Exception Handling in Java is a mechanism to handle runtime errors (like divide by zero, null pointer, array index out of bound, etc.) so the program continues execution without crashing.

ğŸ”„ Purpose:
    â¤ Ensure normal flow of the application.
    â¤ Provide meaningful messages instead of abrupt termination.
    â¤ Makes code robust and maintainable.

ğŸ”„ Key keywords used in Java Exception Handling:
    â¤ try â†’ Code that might throw an exception.
    â¤ catch â†’ Block to handle the exception.
    â¤ finally â†’ Always executed (cleanup code).
    â¤ throw â†’ Used to throw an exception.
    â¤ throws â†’ Declares exceptions a method might throw.

ğŸ‘‰ Example:
public class ExceptionDemo {
    public static void main(String[] args) {
        try {
            int a = 10 / 0; // ArithmeticException
        } catch (ArithmeticException e) {
            System.out.println("Can't divide by zero!");
        } finally {
            System.out.println("Finally block always executes.");
        }
    }
}


âœ… Exception Handling Hierarchy

Java divides exceptions into Checked and Unchecked.
Hereâ€™s the hierarchy (interviewers love this diagram ğŸ‘‡):
                Throwable
                   |
     --------------------------------
     |                              |
  Exception                      Error
     |
  ----------------------------
  |                          |
Checked Exception       Unchecked Exception
(IOException,           (RuntimeException,
SQLException, etc.)     NullPointerException,
                        ArithmeticException,
                        ArrayIndexOutOfBounds, etc.)


ğŸ”¹ Explanation of Hierarchy
ğŸ”„ Throwable
    â¤ The root class for all errors and exceptions.
    â¤ Has two main subclasses: Exception and Error.

ğŸ”„ Error
    â¤ Represents serious issues that are beyond the control of the program.
    â¤ Example: OutOfMemoryError, StackOverflowError.
    â¤ Should NOT be handled in normal application flow.

ğŸ”„ Exception
Represents conditions the program can catch and handle.

ğŸ‘‰ Types:
ğŸ”„ Checked Exceptions (Compile-time exceptions)
    â¤ Checked by the compiler.
    â¤ Must be either caught or declared with throws.
    â¤ Examples: IOException, SQLException, ClassNotFoundException.

ğŸ”„ Unchecked Exceptions (Runtime exceptions)
    â¤ Occur at runtime. Compiler does not force handling.
    â¤ Subclasses of RuntimeException.
    â¤ Examples: NullPointerException, ArithmeticException, ArrayIndexOutOfBoundsException.

âš¡ Common Interview Follow-up:
ğŸ‘‰ â€œCan we catch Error in Java?â€
âœ”ï¸ Answer: Yes, Error is a subclass of Throwable, so we can catch it in the same way we catch Exception.


â“Difference between throw and throws keywords in Java
Difference between throw and throws in Java

Aspect                 throw                                  throws
-----------------------------------------------------------------------------------------
Definition             Used to explicitly throw an            Used in method declaration 
                       exception object.                      to declare exceptions.

Usage Place            Inside a method or block.              In method signature.

Number of Exceptions   Can throw only one exception           Can declare multiple 
                       at a time.                             exceptions separated by commas.

Execution Time         Actually throws the exception          Just declares that the method 
                       object at runtime.                     might throw exceptions.

Checked/Unchecked      Can throw both checked and             Generally used for checked 
                       unchecked exceptions.                  exceptions.

Syntax                 throw new ExceptionType("msg");        returnType methodName() 
                                                              throws Exception1, Exception2

Example                void demo() {                          void readFile() throws IOException {
                       throw new ArithmeticException(); }     FileReader fr = new FileReader("abc.txt"); }

âœ… Example with Both
import java.io.*;

class ThrowThrowsDemo {

    // using throws
    void readFile() throws IOException {
        FileReader fr = new FileReader("abc.txt"); // may throw IOException
    }

    // using throw
    void divide() {
        throw new ArithmeticException("Divide by zero not allowed!");
    }

    public static void main(String[] args) {
        ThrowThrowsDemo obj = new ThrowThrowsDemo();

        try {
            obj.readFile();
        } catch (IOException e) {
            System.out.println("Handled IOException: " + e);
        }

        obj.divide(); // will throw ArithmeticException
    }
}


â“What is serialization and deserialization in Java?
âœ”ï¸ Answer:
Serialization is the process of converting an object into a byte stream so that it can be saved to a file, sent over a network, or stored in a database.

Key Points:
    â¤ Implemented using java.io.Serializable interface (marker interface).
    â¤ Translates object â†’ byte stream.
    â¤ ObjectOutputStream is used to perform serialization.

âš¡Code Example:
import java.io.*;

class Student implements Serializable {
    int id;
    String name;

    Student(int id, String name) {
        this.id = id;
        this.name = name;
    }
}

public class SerializationDemo {
    public static void main(String[] args) throws Exception {
        Student s = new Student(1, "Ankur");

        FileOutputStream fos = new FileOutputStream("student.txt");
        ObjectOutputStream oos = new ObjectOutputStream(fos);

        oos.writeObject(s); // Serialization
        oos.close();
        System.out.println("Object Serialized");
    }
}

Deserialization is the reverse process of serialization where the byte stream is converted back into the original object.

Key Points:
    â¤ Performed using ObjectInputStream.
    â¤ Object is restored with its state.

âš¡Code Example:
import java.io.*;

public class DeserializationDemo {
    public static void main(String[] args) throws Exception {
        FileInputStream fis = new FileInputStream("student.txt");
        ObjectInputStream ois = new ObjectInputStream(fis);

        Student s = (Student) ois.readObject(); // Deserialization
        ois.close();

        System.out.println("Object Deserialized: " + s.id + " " + s.name);
    }
}

âš¡Key Points:
âœ”ï¸ Transient keyword: Used to skip some fields from serialization.
âœ”ï¸ Static fields: Not serialized because they belong to class, not object.
âœ”ï¸ serialVersionUID:
    â¤ Unique ID used during deserialization to verify sender and receiver are compatible.
    â¤ If not declared explicitly, JVM generates one.
    â¤ Best practice: always declare private static final long serialVersionUID = 1L;.


â“Use of super and this keywords in Java
âœ”ï¸ Answer:
ğŸ“Use of this Keyword in Java
Refers to the current object of the class.

ğŸ”„ Uses:
    â¤ To differentiate instance variables from local variables (when same name).
    â¤ To invoke current class methods.
    â¤ To call one constructor from another in the same class (this() â†’ constructor chaining).
    â¤ To return current class object.

âš¡Code Example:
class Student {
    int id;
    String name;

    Student(int id, String name) {
        this.id = id;       // differentiate instance and local
        this.name = name;
    }

    void print() {
        System.out.println(this.name); // current object reference
    }
}

ğŸ“ Use of super keyword in Java
Refers to the immediate parent class object.

ğŸ”„ Uses:
    â¤ To access parent class variables (when hidden by child class variables).
    â¤ To invoke parent class methods (when overridden).
    â¤ To invoke parent class constructor (super() â†’ must be first statement in constructor).

âš¡Code Example:
class Person {
    String name = "Parent";

    void display() {
        System.out.println("Person Display");
    }
}

class Student extends Person {
    String name = "Child";

    Student() {
        super(); // call parent constructor
    }

    void display() {
        super.display(); // call parent method
        System.out.println(super.name); // access parent variable
    }
}

