â“ Define JDK, JRE, and JVM
ğŸ”¹ 1. JVM (Java Virtual Machine)
â¤ JVM is an abstract machine that provides a runtime environment to execute Java bytecode.

âš¡Responsibilities:
âœ”ï¸ Converts bytecode â†’ machine code using JIT (Just-In-Time compiler).
âœ”ï¸ Provides platform independence (â€œWrite Once, Run Anywhereâ€).
âœ”ï¸ Manages memory (heap, stack, method area, GC).
âœ”ï¸ Ensures security via bytecode verification.
ğŸ”§ Key Point: JVM is platform-dependent (different implementations for Windows/Linux/Mac), but bytecode is platform-independent.

â¡ï¸ Interview Insight:
Many confuse JVM = Java compiler â†’ Wrong! Compiler (javac) converts Java code â†’ bytecode; JVM executes that bytecode.

ğŸ”¹ 2. JRE (Java Runtime Environment)
â¤ JRE provides libraries, JVM, and other components to run Java applications.

Includes:
âœ”ï¸ JVM
âœ”ï¸ Core libraries (like java.lang, java.util, java.io)
âœ”ï¸ Supporting files
ğŸ”§ Key Point: JRE does not include development tools (compiler, debugger). Itâ€™s only for running Java programs.

â¡ï¸ Interview Trap:
If asked, â€œCan you run Java code with just JRE?â€ â†’ Yes, if you already have compiled bytecode. But you cannot compile .java files with JRE.

ğŸ”¹ 3. JDK (Java Development Kit)
â¤ JDK is the full package required for Java development.

Includes:
âœ”ï¸ JRE (which has JVM + libraries)
âœ”ï¸ Development tools â†’ javac (compiler), jdb (debugger), javadoc, jar, etc.
ğŸ”§ Key Point: JDK is for developers; JRE is for users.

â¡ï¸ Interview Trap:
Some interviewers ask: â€œIf JDK contains JRE, and JRE contains JVM, can we say JDK = JVM?â€
Answer: No. JDK = JRE + Development Tools. JVM is just part of JRE.

ğŸ”¹ Hierarchy Diagram
JDK 
 â””â”€â”€ JRE 
      â””â”€â”€ JVM

ğŸ”¹ One-Liner for Revision
â¤ JVM â†’ Runs bytecode.
â¤ JRE â†’ JVM + Libraries (to run Java apps).
â¤ JDK â†’ JRE + Tools (to develop Java apps).

â“ Significance of public static void main(String[] args)
The main() method is the entry point of every Java program. The JVM calls it to start execution. Each keyword has a special meaning:

ğŸ”¹ 1. public
â¤ Reason: Must be accessible to JVM outside the class.
â¤ JVM looks for main() from anywhere, so it cannot be private or default.
â¤ If not public â†’ main method not found error.

â¡ï¸ Interview Trap:
Q: â€œWhat if I make main() private or protected?â€
A: JVM wonâ€™t be able to access it â†’ runtime error.

ğŸ”¹ 2. static
â¤ Reason: JVM doesnâ€™t need to create an object of the class to call main().
â¤ Being static, it belongs to the class rather than an object.
â¤ Ensures execution starts immediately when the class is loaded.

â¡ï¸ Interview Trap:
Q: â€œCan main() be non-static?â€
A: Yes, it compiles, but JVM wonâ€™t recognize it as a valid entry point.

ğŸ”¹ 3. void
â¤ Reason: main() doesnâ€™t return any value to JVM.
â¤ JVM doesnâ€™t expect a return type.
â¤ If you try to return something, compilation error occurs.

ğŸ”¹ 4. main
â¤ Reason: Name is predefined and reserved by JVM as the entry point.
â¤ If you change it, JVM wonâ€™t start execution.

ğŸ”¹ 5. (String[] args)
â¤ Reason: Accepts command-line arguments when program is executed.
âœ… Example:
class Demo {
    public static void main(String[] args) {
        System.out.println(args[0]); // prints first command line argument
    }
}
Run: java Demo Hello â†’ Output: Hello

â¡ï¸ Alternate forms accepted by JVM:
âœ”ï¸ public static void main(String args[])
âœ”ï¸ public static void main(String... args) (var-args since Java 5)

ğŸ”¹ One-Liner for Quick Revision
âœ”ï¸ public â†’ JVM can access.
âœ”ï¸ static â†’ No object needed.
âœ”ï¸ void â†’ No return value.
âœ”ï¸ main â†’ JVMâ€™s entry point.
âœ”ï¸ String[] args â†’ Command-line inputs.

ğŸ”¹ Interview Insights
â¤ â€œWhat if signature is public static int main()?â€ â†’ Compilation error.
â¤ â€œWhat if I overload main()?â€ â†’ Allowed, but JVM only calls the public static void main(String[] args).
â¤ â€œWhat if args is changed to String... args?â€ â†’ Still valid.


â“ Why does the main method support String[] args?
ğŸ”¹ 1. Command-Line Arguments Support
String[] args lets us pass data from outside (command line) to the program at runtime.
âœ… Example:

class Demo {
    public static void main(String[] args) {
        System.out.println("First argument: " + args[0]);
    }
}
âš¡ Run: java Demo Hello
Output: First argument: Hello

â¡ï¸ Without String[] args, the JVM couldnâ€™t pass inputs from command line.

ğŸ”¹ 2. Why Specifically String?
â¤ Every input from command line is text-based.
â¤ JVM collects arguments as strings (e.g., "123" not number 123).

â¤ If you need another type (int, double), you must parse it manually:
int num = Integer.parseInt(args[0]); // converts "123" â†’ 123

ğŸ”¹ 3. Why Array []?
â¤ Because we may pass multiple arguments separated by space.

âœ… Example:
java Demo Alice Bob Charlie

Then:
args[0] = "Alice"
args[1] = "Bob"
args[2] = "Charlie"
â¡ï¸ An array is the best way to store variable-length inputs.

ğŸ”¹ 4. Alternative Forms Accepted by JVM
â¤ JVM doesnâ€™t strictly enforce String[] args.
â¤ The following are also valid:
    âœ”ï¸ String args[]
    âœ”ï¸ String... args (var-args since Java 5).

ğŸ”¹ 5. What if we remove it?
If you write: public static void main()
â— Compiles fine, but JVM wonâ€™t recognize it as a valid entry point â†’ Runtime error:
âŒ Error: Main method not found in class Demo

ğŸ”¹ One-Liner for Quick Revisio
ğŸ‘‰ String[] args is used because JVM needs a standard way to pass runtime command-line arguments, and all inputs are strings by default.

ğŸ”¹ Interview Insights
ğŸ§  Trick Q: â€œWhy not int[] args or Object[] args?â€
â¤ Because JVM can only guarantee that inputs will be Strings from command line.
ğŸ§  Trick Q: â€œCan we overload main() with different parameters?â€
â¤ Yes, but JVM only calls public static void main(String[] args). Others can only be called manually inside code.

â“ Constructor Chaining in Java
Constructor Chaining means calling one constructor from another constructor (in the same class or parent class) to reuse initialization code and avoid duplication.

ğŸ”¹ Types of Constructor Chaining

ğŸ”„ Within the same class â†’ using this()
    âœ”ï¸ Calls another constructor of the same class.
    âœ”ï¸ Must be the first statement in the constructor.

ğŸ”„ Between parent and child class â†’ using super()
    âœ”ï¸ Calls the parent class constructor.
    âœ”ï¸ Must be the first statement in the constructor.

âœ… Example 1: Same Class (this())
class Student {
    private String name;
    private int age;

    // Constructor 1
    Student() {
        this("Unknown", 18);  // calling parameterized constructor
    }

    // Constructor 2
    Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    void display() {
        System.out.println(name + " - " + age);
    }
}

public class Demo {
    public static void main(String[] args) {
        Student s1 = new Student();
        Student s2 = new Student("Alice", 22);
        s1.display(); // Unknown - 18
        s2.display(); // Alice - 22
    }
}
â¡ï¸ Here, default constructor calls the parameterized constructor to avoid duplicate code.

âœ… Example 2: Parent â†’ Child (super())
class Person {
    Person() {
        System.out.println("Person constructor");
    }
}

class Employee extends Person {
    Employee() {
        super();  // calls parent constructor
        System.out.println("Employee constructor");
    }
}

public class Demo {
    public static void main(String[] args) {
        new Employee();
    }
}
âœ… Output:
Person constructor
Employee constructor
â¡ï¸ Here, super() ensures parent class initialization happens first.

ğŸ”¹ Rules of Constructor Chaining
â¤ Either this() or super() must be the first statement.
â¤ Circular calls (like a constructor calling itself) â†’ compile-time error.
â¤ If you donâ€™t write super(), the compiler automatically inserts super() (default constructor).
â¤ Cannot use both this() and super() in the same constructor â†’ only one allowed.

ğŸ”¹ Why is it Important?
â¤ Code Reusability â†’ No duplication of initialization logic.
â¤ Readability â†’ Clear execution order.
â¤ Mandatory for Inheritance â†’ Parent must always be initialized before child.

ğŸ”¹ One-Liner for Quick Revision
ğŸ‘‰ Constructor Chaining = Calling one constructor from another (same class via this(), parent class via super()) to reuse initialization logic.

ğŸ”¹ Interview Insights
ğŸ§  Q: â€œWhat happens if parent has only parameterized constructor and child does not call it?â€
â¤ Compilation error (because compiler inserts super() but no default constructor exists).
ğŸ§  Q: â€œCan this() and super() be used together?â€
â¤ No, only one can be the first line.
ğŸ§  Q: â€œWhat if I call a method before super() inside a constructor?â€
â¤ Compilation error: Constructor call must be the first statement.


â“ OOPs Concepts(Inheritance, Polymorphism, Encapsulation, Abstraction)
ğŸ”¹ 1. Encapsulation â†’ Data Hiding + Binding
â¤ Wrapping variables (data) and methods (logic) into a single unit (class). Provides controlled access via getters/setters.

âœ… Daily Life Example:
A bank account: Your balance is hidden (private), but you can access it using deposit/withdraw methods.
â¤ One-liner: â€œEncapsulation = data hiding using access modifiers + methods.â€

ğŸ”¹ 2. Abstraction â†’ Hiding Implementation
â¤ Showing only essential details, hiding internal complexity. Achieved using abstract classes / interfaces.

âœ… Daily Life Example:
Car driving: You use the steering wheel, accelerator, brakes without knowing how the engine, gears, and sensors work internally.
â¤ One-liner: â€œAbstraction = show what it does, hide how it does.â€

ğŸ”¹ 3. Inheritance â†’ Reusability
â¤ One class acquires properties and methods of another (parent â†’ child). Promotes code reuse.

âœ… Daily Life Example:
    âœ”ï¸ Father â†’ Son: A child inherits properties (like eye color) and behaviors (like habits) from parents.
    âœ”ï¸ In software: class Dog extends Animal.
â¤ One-liner: â€œInheritance = child gets features from parent.â€

ğŸ”¹ 4. Polymorphism â†’ Many Forms
â¤ Same method/operation behaves differently in different contexts.
    âœ”ï¸ Compile-time polymorphism â†’ Method overloading.
    âœ”ï¸ Runtime polymorphism â†’ Method overriding.

âœ… Daily Life Example:
Mobile Phone Button:
    âœ”ï¸ Single button = different actions (tap â†’ open app, double tap â†’ camera, long press â†’ assistant).
â¤ One-liner: â€œPolymorphism = same name, different behavior.â€

ğŸ”¹ Interview-Ready Summary (One Sentence)
ğŸ‘‰ OOPs = Encapsulation (data hiding), Abstraction (hiding implementation), Inheritance (reusability), and Polymorphism (same method different forms) â€” just like real-world objects such as cars, bank accounts, or family inheritance.

â“ Difference between Interface and Abstract Class
â¤ Interface: A contract that specifies what a class must do, but not how.
â¤ Abstract Class: A class that may have partial implementation (some abstract methods + some concrete methods).

ğŸ”¹ 2. Method Implementation
â¤ Interface:
    âœ”ï¸ Before Java 8 â†’ only abstract methods (implicitly public abstract).
    âœ”ï¸ Java 8 â†’ allowed default & static methods.
    âœ”ï¸ Java 9 â†’ allowed private methods.

â¤ Abstract Class:
    âœ”ï¸ Can have both abstract and concrete methods.
    âœ”ï¸ Can provide partial implementation.

ğŸ”¹ 3. Variables
â¤ Interface:
    âœ”ï¸ Variables are always public static final (constants).
    âœ”ï¸ Must be initialized at declaration.

â¤ Abstract Class:
    âœ”ï¸ Can have instance variables.
    âœ”ï¸ Can use any access modifier (private, protected, etc.).

ğŸ”¹ 4. Inheritance & Multiple Inheritance
Interface: Supports multiple inheritance (a class can implement multiple interfaces).
Abstract Class: Supports single inheritance only (a class can extend only one abstract class).

ğŸ”¹ 5. Constructors
Interface: âŒ Cannot have constructors (cannot be instantiated).
Abstract Class: âœ… Can have constructors (called when subclass object is created).

ğŸ”¹ 6. Use Cases
â¤ Interface:
    âœ”ï¸ Used to define a contract/blueprint for unrelated classes.
    âœ… Example: Comparable, Runnable, Serializable.

â¤ Abstract Class:
    âœ”ï¸ Used when classes share common behavior + state but still have some abstract methods.

âœ… Example: AbstractList in Java Collections.

ğŸ”¹ 7. Code Example
// Interface example
interface Vehicle {
    void start(); // abstract method
}

class Car implements Vehicle {
    public void start() {
        System.out.println("Car starts with key");
    }
}

// Abstract class example
abstract class Animal {
    abstract void sound();   // abstract method
    void sleep() {           // concrete method
        System.out.println("Sleeping...");
    }
}

class Dog extends Animal {
    void sound() {
        System.out.println("Bark");
    }
}

ğŸ”¹ 8. One-Liner for Interview
â¤ Interface â†’ â€œDefines what to do, no state.â€
â¤ Abstract Class â†’ â€œDefines what to do + partial how to do, can have state.â€

ğŸ”¹ 9. Interview Traps & Insights
ğŸ§  Q: â€œCan an interface extend another interface?â€ â†’ âœ… Yes (multiple inheritance of interfaces allowed).
ğŸ§  Q: â€œCan an abstract class implement an interface?â€ â†’ âœ… Yes, but must provide implementation for methods or remain abstract.
ğŸ§  Q: â€œWhich is faster, abstract class or interface?â€ â†’ Abstract class is slightly faster (direct method call vs dynamic dispatch in interfaces).
ğŸ§  Q: â€œWhen to prefer interface over abstract class?â€ â†’ Use interface when unrelated classes need common behavior (e.g., Flyable, Drivable). Use abstract class when related classes share state/logic (e.g., Shape).