â“ Define JDK, JRE, and JVM
ğŸ”¹ 1. JVM (Java Virtual Machine)
â¤ JVM is an abstract machine that provides a runtime environment to execute Java bytecode.

âš¡Responsibilities:
âœ”ï¸ Converts bytecode â†’ machine code using JIT (Just-In-Time compiler).
âœ”ï¸ Provides platform independence (â€œWrite Once, Run Anywhereâ€).
âœ”ï¸ Manages memory (heap, stack, method area, GC).
âœ”ï¸ Ensures security via bytecode verification.
ğŸ”§ Key Point: JVM is platform-dependent (different implementations for Windows/Linux/Mac), but bytecode is platform-independent.

â¡ï¸ Interview Insight:
Many confuse JVM = Java compiler â†’ Wrong! Compiler (javac) converts Java code â†’ bytecode; JVM executes that bytecode.

ğŸ”¹ 2. JRE (Java Runtime Environment)
â¤ JRE provides libraries, JVM, and other components to run Java applications.

Includes:
âœ”ï¸ JVM
âœ”ï¸ Core libraries (like java.lang, java.util, java.io)
âœ”ï¸ Supporting files
ğŸ”§ Key Point: JRE does not include development tools (compiler, debugger). Itâ€™s only for running Java programs.

â¡ï¸ Interview Trap:
If asked, â€œCan you run Java code with just JRE?â€ â†’ Yes, if you already have compiled bytecode. But you cannot compile .java files with JRE.

ğŸ”¹ 3. JDK (Java Development Kit)
â¤ JDK is the full package required for Java development.

Includes:
âœ”ï¸ JRE (which has JVM + libraries)
âœ”ï¸ Development tools â†’ javac (compiler), jdb (debugger), javadoc, jar, etc.
ğŸ”§ Key Point: JDK is for developers; JRE is for users.

â¡ï¸ Interview Trap:
Some interviewers ask: â€œIf JDK contains JRE, and JRE contains JVM, can we say JDK = JVM?â€
Answer: No. JDK = JRE + Development Tools. JVM is just part of JRE.

ğŸ”¹ Hierarchy Diagram
JDK 
 â””â”€â”€ JRE 
      â””â”€â”€ JVM

ğŸ”¹ One-Liner for Revision
â¤ JVM â†’ Runs bytecode.
â¤ JRE â†’ JVM + Libraries (to run Java apps).
â¤ JDK â†’ JRE + Tools (to develop Java apps).

â“ Significance of public static void main(String[] args)
The main() method is the entry point of every Java program. The JVM calls it to start execution. Each keyword has a special meaning:

ğŸ”¹ 1. public
â¤ Reason: Must be accessible to JVM outside the class.
â¤ JVM looks for main() from anywhere, so it cannot be private or default.
â¤ If not public â†’ main method not found error.

â¡ï¸ Interview Trap:
Q: â€œWhat if I make main() private or protected?â€
A: JVM wonâ€™t be able to access it â†’ runtime error.

ğŸ”¹ 2. static
â¤ Reason: JVM doesnâ€™t need to create an object of the class to call main().
â¤ Being static, it belongs to the class rather than an object.
â¤ Ensures execution starts immediately when the class is loaded.

â¡ï¸ Interview Trap:
Q: â€œCan main() be non-static?â€
A: Yes, it compiles, but JVM wonâ€™t recognize it as a valid entry point.

ğŸ”¹ 3. void
â¤ Reason: main() doesnâ€™t return any value to JVM.
â¤ JVM doesnâ€™t expect a return type.
â¤ If you try to return something, compilation error occurs.

ğŸ”¹ 4. main
â¤ Reason: Name is predefined and reserved by JVM as the entry point.
â¤ If you change it, JVM wonâ€™t start execution.

ğŸ”¹ 5. (String[] args)
â¤ Reason: Accepts command-line arguments when program is executed.
âœ… Example:
class Demo {
    public static void main(String[] args) {
        System.out.println(args[0]); // prints first command line argument
    }
}
Run: java Demo Hello â†’ Output: Hello

â¡ï¸ Alternate forms accepted by JVM:
âœ”ï¸ public static void main(String args[])
âœ”ï¸ public static void main(String... args) (var-args since Java 5)

ğŸ”¹ One-Liner for Quick Revision
âœ”ï¸ public â†’ JVM can access.
âœ”ï¸ static â†’ No object needed.
âœ”ï¸ void â†’ No return value.
âœ”ï¸ main â†’ JVMâ€™s entry point.
âœ”ï¸ String[] args â†’ Command-line inputs.

ğŸ”¹ Interview Insights
â¤ â€œWhat if signature is public static int main()?â€ â†’ Compilation error.
â¤ â€œWhat if I overload main()?â€ â†’ Allowed, but JVM only calls the public static void main(String[] args).
â¤ â€œWhat if args is changed to String... args?â€ â†’ Still valid.


â“ Why does the main method support String[] args?
ğŸ”¹ 1. Command-Line Arguments Support
String[] args lets us pass data from outside (command line) to the program at runtime.
âœ… Example:

class Demo {
    public static void main(String[] args) {
        System.out.println("First argument: " + args[0]);
    }
}
âš¡ Run: java Demo Hello
Output: First argument: Hello

â¡ï¸ Without String[] args, the JVM couldnâ€™t pass inputs from command line.

ğŸ”¹ 2. Why Specifically String?
â¤ Every input from command line is text-based.
â¤ JVM collects arguments as strings (e.g., "123" not number 123).

â¤ If you need another type (int, double), you must parse it manually:
int num = Integer.parseInt(args[0]); // converts "123" â†’ 123

ğŸ”¹ 3. Why Array []?
â¤ Because we may pass multiple arguments separated by space.

âœ… Example:
java Demo Alice Bob Charlie

Then:
args[0] = "Alice"
args[1] = "Bob"
args[2] = "Charlie"
â¡ï¸ An array is the best way to store variable-length inputs.

ğŸ”¹ 4. Alternative Forms Accepted by JVM
â¤ JVM doesnâ€™t strictly enforce String[] args.
â¤ The following are also valid:
    âœ”ï¸ String args[]
    âœ”ï¸ String... args (var-args since Java 5).

ğŸ”¹ 5. What if we remove it?
If you write: public static void main()
â— Compiles fine, but JVM wonâ€™t recognize it as a valid entry point â†’ Runtime error:
âŒ Error: Main method not found in class Demo

ğŸ”¹ One-Liner for Quick Revisio
ğŸ‘‰ String[] args is used because JVM needs a standard way to pass runtime command-line arguments, and all inputs are strings by default.

ğŸ”¹ Interview Insights
ğŸ§  Trick Q: â€œWhy not int[] args or Object[] args?â€
â¤ Because JVM can only guarantee that inputs will be Strings from command line.
ğŸ§  Trick Q: â€œCan we overload main() with different parameters?â€
â¤ Yes, but JVM only calls public static void main(String[] args). Others can only be called manually inside code.

â“ Constructor Chaining in Java
Constructor Chaining means calling one constructor from another constructor (in the same class or parent class) to reuse initialization code and avoid duplication.

ğŸ”¹ Types of Constructor Chaining

ğŸ”„ Within the same class â†’ using this()
    âœ”ï¸ Calls another constructor of the same class.
    âœ”ï¸ Must be the first statement in the constructor.

ğŸ”„ Between parent and child class â†’ using super()
    âœ”ï¸ Calls the parent class constructor.
    âœ”ï¸ Must be the first statement in the constructor.

âœ… Example 1: Same Class (this())
class Student {
    private String name;
    private int age;

    // Constructor 1
    Student() {
        this("Unknown", 18);  // calling parameterized constructor
    }

    // Constructor 2
    Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    void display() {
        System.out.println(name + " - " + age);
    }
}

public class Demo {
    public static void main(String[] args) {
        Student s1 = new Student();
        Student s2 = new Student("Alice", 22);
        s1.display(); // Unknown - 18
        s2.display(); // Alice - 22
    }
}
â¡ï¸ Here, default constructor calls the parameterized constructor to avoid duplicate code.

âœ… Example 2: Parent â†’ Child (super())
class Person {
    Person() {
        System.out.println("Person constructor");
    }
}

class Employee extends Person {
    Employee() {
        super();  // calls parent constructor
        System.out.println("Employee constructor");
    }
}

public class Demo {
    public static void main(String[] args) {
        new Employee();
    }
}
âœ… Output:
Person constructor
Employee constructor
â¡ï¸ Here, super() ensures parent class initialization happens first.

ğŸ”¹ Rules of Constructor Chaining
â¤ Either this() or super() must be the first statement.
â¤ Circular calls (like a constructor calling itself) â†’ compile-time error.
â¤ If you donâ€™t write super(), the compiler automatically inserts super() (default constructor).
â¤ Cannot use both this() and super() in the same constructor â†’ only one allowed.

ğŸ”¹ Why is it Important?
â¤ Code Reusability â†’ No duplication of initialization logic.
â¤ Readability â†’ Clear execution order.
â¤ Mandatory for Inheritance â†’ Parent must always be initialized before child.

ğŸ”¹ One-Liner for Quick Revision
ğŸ‘‰ Constructor Chaining = Calling one constructor from another (same class via this(), parent class via super()) to reuse initialization logic.

ğŸ”¹ Interview Insights
ğŸ§  Q: â€œWhat happens if parent has only parameterized constructor and child does not call it?â€
â¤ Compilation error (because compiler inserts super() but no default constructor exists).
ğŸ§  Q: â€œCan this() and super() be used together?â€
â¤ No, only one can be the first line.
ğŸ§  Q: â€œWhat if I call a method before super() inside a constructor?â€
â¤ Compilation error: Constructor call must be the first statement.


â“ OOPs Concepts(Inheritance, Polymorphism, Encapsulation, Abstraction)
ğŸ”¹ 1. Encapsulation â†’ Data Hiding + Binding
â¤ Wrapping variables (data) and methods (logic) into a single unit (class). Provides controlled access via getters/setters.

âœ… Daily Life Example:
A bank account: Your balance is hidden (private), but you can access it using deposit/withdraw methods.
â¤ One-liner: â€œEncapsulation = data hiding using access modifiers + methods.â€

ğŸ”¹ 2. Abstraction â†’ Hiding Implementation
â¤ Showing only essential details, hiding internal complexity. Achieved using abstract classes / interfaces.

âœ… Daily Life Example:
Car driving: You use the steering wheel, accelerator, brakes without knowing how the engine, gears, and sensors work internally.
â¤ One-liner: â€œAbstraction = show what it does, hide how it does.â€

ğŸ”¹ 3. Inheritance â†’ Reusability
â¤ One class acquires properties and methods of another (parent â†’ child). Promotes code reuse.

âœ… Daily Life Example:
    âœ”ï¸ Father â†’ Son: A child inherits properties (like eye color) and behaviors (like habits) from parents.
    âœ”ï¸ In software: class Dog extends Animal.
â¤ One-liner: â€œInheritance = child gets features from parent.â€

ğŸ”¹ 4. Polymorphism â†’ Many Forms
â¤ Same method/operation behaves differently in different contexts.
    âœ”ï¸ Compile-time polymorphism â†’ Method overloading.
    âœ”ï¸ Runtime polymorphism â†’ Method overriding.

âœ… Daily Life Example:
Mobile Phone Button:
    âœ”ï¸ Single button = different actions (tap â†’ open app, double tap â†’ camera, long press â†’ assistant).
â¤ One-liner: â€œPolymorphism = same name, different behavior.â€

ğŸ”¹ Interview-Ready Summary (One Sentence)
ğŸ‘‰ OOPs = Encapsulation (data hiding), Abstraction (hiding implementation), Inheritance (reusability), and Polymorphism (same method different forms) â€” just like real-world objects such as cars, bank accounts, or family inheritance.

â“ Difference between Interface and Abstract Class
â¤ Interface: A contract that specifies what a class must do, but not how.
â¤ Abstract Class: A class that may have partial implementation (some abstract methods + some concrete methods).

ğŸ”¹ 2. Method Implementation
â¤ Interface:
    âœ”ï¸ Before Java 8 â†’ only abstract methods (implicitly public abstract).
    âœ”ï¸ Java 8 â†’ allowed default & static methods.
    âœ”ï¸ Java 9 â†’ allowed private methods.

â¤ Abstract Class:
    âœ”ï¸ Can have both abstract and concrete methods.
    âœ”ï¸ Can provide partial implementation.

ğŸ”¹ 3. Variables
â¤ Interface:
    âœ”ï¸ Variables are always public static final (constants).
    âœ”ï¸ Must be initialized at declaration.

â¤ Abstract Class:
    âœ”ï¸ Can have instance variables.
    âœ”ï¸ Can use any access modifier (private, protected, etc.).

ğŸ”¹ 4. Inheritance & Multiple Inheritance
Interface: Supports multiple inheritance (a class can implement multiple interfaces).
Abstract Class: Supports single inheritance only (a class can extend only one abstract class).

ğŸ”¹ 5. Constructors
Interface: âŒ Cannot have constructors (cannot be instantiated).
Abstract Class: âœ… Can have constructors (called when subclass object is created).

ğŸ”¹ 6. Use Cases
â¤ Interface:
    âœ”ï¸ Used to define a contract/blueprint for unrelated classes.
    âœ… Example: Comparable, Runnable, Serializable.

â¤ Abstract Class:
    âœ”ï¸ Used when classes share common behavior + state but still have some abstract methods.

âœ… Example: AbstractList in Java Collections.

ğŸ”¹ 7. Code Example
// Interface example
interface Vehicle {
    void start(); // abstract method
}

class Car implements Vehicle {
    public void start() {
        System.out.println("Car starts with key");
    }
}

// Abstract class example
abstract class Animal {
    abstract void sound();   // abstract method
    void sleep() {           // concrete method
        System.out.println("Sleeping...");
    }
}

class Dog extends Animal {
    void sound() {
        System.out.println("Bark");
    }
}

ğŸ”¹ 8. One-Liner for Interview
â¤ Interface â†’ â€œDefines what to do, no state.â€
â¤ Abstract Class â†’ â€œDefines what to do + partial how to do, can have state.â€

ğŸ”¹ 9. Interview Traps & Insights
ğŸ§  Q: â€œCan an interface extend another interface?â€ â†’ âœ… Yes (multiple inheritance of interfaces allowed).
ğŸ§  Q: â€œCan an abstract class implement an interface?â€ â†’ âœ… Yes, but must provide implementation for methods or remain abstract.
ğŸ§  Q: â€œWhich is faster, abstract class or interface?â€ â†’ Abstract class is slightly faster (direct method call vs dynamic dispatch in interfaces).
ğŸ§  Q: â€œWhen to prefer interface over abstract class?â€ â†’ Use interface when unrelated classes need common behavior (e.g., Flyable, Drivable). Use abstract class when related classes share state/logic (e.g., Shape).

â“ Multi-catch Block in Java
â¤ A multi-catch block allows you to handle multiple exceptions in a single catch block using the | (pipe) operator.
â¤ Introduced in Java 7 to reduce code duplication.

âœ… Example (Before Java 7 â†’ Repetitive Code)
try {
    int arr[] = new int[5];
    arr[5] = 10 / 0;
} catch (ArithmeticException e) {
    System.out.println("Arithmetic Exception: " + e.getMessage());
} catch (ArrayIndexOutOfBoundsException e) {
    System.out.println("Array Index Exception: " + e.getMessage());
}
âŒ Problem: Code is repetitive; two separate blocks with same logic.

âœ… Example (After Java 7 â†’ Multi-Catch)
try {
    int arr[] = new int[5];
    arr[5] = 10 / 0;
} catch (ArithmeticException | ArrayIndexOutOfBoundsException e) {
    System.out.println("Exception: " + e.getMessage());
}
â¡ï¸ Same result with cleaner code.

ğŸ”¹ Rules of Multi-catch
â¤ Use | (pipe) to separate multiple exception types.
â¤ Exceptions must be unrelated (not parent-child).

âœ… Allowed: IOException | SQLException
âŒ Not Allowed: IOException | FileNotFoundException (because FileNotFoundException is a subclass of IOException).

âš¡ The exception variable (e) is final implicitly â†’ You cannot reassign it inside the block.

ğŸ”¹ Why Multi-catch is Useful?
â¤ Reduces boilerplate code (no duplicate catch blocks).
â¤ Improves readability.
â¤ Optimizes bytecode (compiler generates smaller, efficient bytecode).

ğŸ”¹ One-Liner for Quick Revision
ğŸ‘‰ Multi-catch block = Handle multiple exceptions in one catch block using | operator (Java 7+), avoiding code duplication.

ğŸ”¹ Interview Insights
ğŸ§  Q: â€œCan we catch exceptions in order?â€
In multi-catch, order doesnâ€™t matter because itâ€™s a single block.
ğŸ§  Q: â€œWhat if exceptions have parent-child relation?â€
Compile-time error. Use separate catch blocks instead.
ğŸ§  Q: â€œIs the exception object final in multi-catch?â€
Yes, you cannot assign e = new Exception() inside.


â“ Difference between final, finally, and finalize()
ğŸ”¹ 1. final (Keyword)
â¤ Usage: Restrict modification.
â¤ Applied to: Variable â†’ makes it a constant (cannot be reassigned).

final int x = 10;
// x = 20; âŒ Compile-time error

â¤ Method â†’ prevents overriding in child class.
class A {
    final void show() { System.out.println("A"); }
}
class B extends A {
    // void show() {} âŒ Not allowed
}

â¤ Class â†’ prevents inheritance.
final class A {}
// class B extends A {} âŒ Not allowed
â¡ï¸ One-liner: final = constant / no overriding / no inheritance.

ğŸ”¹ 2. finally (Block)
â¤ Usage: Used in exception handling.
â¤ Purpose: Ensures a block of code always executes, regardless of exception occurrence.
â¤ Commonly used for resource cleanup (closing files, DB connections).

âœ… Example:
try {
    int x = 10 / 0;
} catch (ArithmeticException e) {
    System.out.println("Exception: " + e);
} finally {
    System.out.println("Finally block always executes");
}

âœ… Output:
Exception: java.lang.ArithmeticException: / by zero
Finally block always executes

â¡ï¸ Special case: If you call System.exit(0), the finally block wonâ€™t execute.
â¡ï¸ One-liner: finally = block that always executes (for cleanup).

ğŸ”¹ 3. finalize() (Method)
A method in Object class called by Garbage Collector (GC) before destroying an object.
Usage: To release resources (like closing file handles, DB connections) before object is removed.

âœ… Example:
class Demo {
    protected void finalize() {
        System.out.println("Finalize method called before GC");
    }
    public static void main(String[] args) {
        Demo d = new Demo();
        d = null;
        System.gc(); // Suggests JVM to call GC
    }
}
âœ… Output: Finalize method called before GC


â¡ï¸ Important Notes:
â¤ finalize() execution is not guaranteed. GC may or may not run.
â¤ From Java 9, finalize() is deprecated (use try-with-resources instead).
â¡ï¸ One-liner: finalize() = method called by GC before object destruction (deprecated).

ğŸ”¹ Interview-Ready Comparison
| Feature           | `final` (Keyword)                        | `finally` (Block)            | `finalize()` (Method)                 |
| ----------------- | ---------------------------------------- | ---------------------------- | ------------------------------------- |
| **Category**      | Modifier                                 | Block                        | Method in `Object` class              |
| **Used For**      | Constants, no overriding, no inheritance | Cleanup code after try-catch | Cleanup before object destruction     |
| **When Executes** | At compile-time restriction              | Always after try-catch       | Called by GC before destroying object |
| **Control**       | Programmer                               | Programmer                   | JVM/GC decides                        |
| **Deprecation**   | âŒ Not deprecated                         | âŒ Not deprecated             | âœ… Deprecated in Java 9+               |


â“ Why is String inheritable? (or is it?)
ğŸ”¹ Truth about String class
The String class in Java is declared as:
âœ… Code Structure:
public final class String implements Serializable, Comparable<String>, CharSequence
Notice the final keyword â†’ this means:
    âœ”ï¸ String cannot be inherited (cannot have a subclass).
    âœ”ï¸ This is done to ensure immutability and security.
â¡ï¸ So, String is NOT inheritable. If you try to extend it:
class MyString extends String {} // âŒ Compile-time error

ğŸ”¹ Why did Java make String final?
â¤ Immutability: Prevents someone from extending String and overriding methods to break immutability.
â¤ Security: Strings are used in sensitive areas (file paths, DB URLs, network connections). If String could be inherited and tampered, it would be a major security risk.
â¤ Performance: String pool (interning) relies on immutability. If strings were mutable or extendable, pooling would fail.

â“ How can we create our own inheritance class?
If you want a custom class that supports inheritance, donâ€™t mark it as final. Example:

// Parent class
class Vehicle {
    String brand = "Generic";

    void start() {
        System.out.println("Vehicle starting...");
    }
}

// Child class
class Car extends Vehicle {
    int wheels = 4;

    @Override
    void start() {
        System.out.println(brand + " Car starting with " + wheels + " wheels!");
    }
}

public class Demo {
    public static void main(String[] args) {
        Car c = new Car();
        c.brand = "Tesla";
        c.start(); // Tesla Car starting with 4 wheels!
    }
}

ğŸ”¹ Rules for creating an inheritance class
â¤ Use extends keyword for class inheritance.
â¤ Use implements for interface implementation.
â¤ Methods in parent can be overridden in child (unless final/static/private).
â¤ Parentâ€™s constructor is always called first (via super()).
â¤ Multiple inheritance of classes is not allowed in Java â†’ solve via interfaces.

â“What is Runtime Polymorphism?
Runtime polymorphism in Java is method overriding â€” when a method call is resolved at runtime (not compile-time).
Itâ€™s also called Dynamic Method Dispatch.

âœ… Example: Method Overriding
class Animal {
    void sound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("Dog barks");
    }
}

class Cat extends Animal {
    @Override
    void sound() {
        System.out.println("Cat meows");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal a1 = new Dog();  // reference is Animal, object is Dog
        Animal a2 = new Cat();  // reference is Animal, object is Cat

        a1.sound();   // Dog barks  (resolved at runtime)
        a2.sound();   // Cat meows  (resolved at runtime)
    }
}

ğŸ”¹ Key Points
â¤ Happens via method overriding.
â¤ The objectâ€™s actual type (Dog, Cat) decides which method gets executed.
â¤ The reference type (Animal) only decides which methods are accessible.
â¤ Achieved only with non-static, non-final, non-private methods.

ğŸ”¸ Static vs Runtime Polymorphism
âœ”ï¸ Compile-time (Static) Polymorphism â†’ Method Overloading.
(Resolved during compilation).
âœ”ï¸ Runtime Polymorphism â†’ Method Overriding.
(Resolved during execution using Dynamic Method Dispatch).

ğŸ“Œ Interview Insights
â¤ If a superclass reference points to a subclass object, and an overridden method is called â†’ subclass version runs (not superclass).
â¤ Constructors cannot be overridden, so runtime polymorphism does not apply to them.
â¤ Helps in loose coupling â†’ code works on interface/superclass reference, actual object can vary.


â“ What is the need of creating incomplete methods in Interface?
Interfaces define a contract/blueprint for classes.
They say â€œthese methods must existâ€ but do not dictate how they should be implemented.

âœ… Needs & Advantages:
âš¡ Achieve Abstraction
    âœ”ï¸ Interface methods are incomplete because the how depends on the class.

âœ… Example:
interface Vehicle {
    void start();  // every vehicle must start, but differently
}

class Car implements Vehicle {
    public void start() { 
        System.out.println("Car starts with a key"); 
    }
}

class Bike implements Vehicle {
    public void start() { 
        System.out.println("Bike starts with a self-start button"); 
    }
}


âš¡ Multiple Implementations (Polymorphism)
    âœ”ï¸ Same method, different behavior â†’ achieved by leaving method incomplete in the interface.

Car.start() â‰  Bike.start(), but both guarantee they implement start().

âš¡ Standardization / Contract
    âœ”ï¸ Interfaces ensure all implementing classes must follow a standard contract.

âœ… Example: Comparable interface â†’ any class implementing it must define compareTo().

âš¡Loose Coupling
    âœ”ï¸ Code depends on interface (contract) and not on concrete classes.
This allows swapping implementations easily.

âœ… Example:
List<String> list = new ArrayList<>();
list = new LinkedList<>();  // works fine, same interface


Future Extensibility
    âœ”ï¸ Library/framework writers define interfaces â†’ application developers provide their own implementations.
âœ… Example: JDBC â†’ Connection, Statement, ResultSet are interfaces.

Oracle, MySQL, PostgreSQL â†’ provide their own implementations.

ğŸ”¸ Why not give default method bodies?
â¤ Before Java 8, interfaces could only have incomplete methods â†’ pure abstraction.
â¤ Since Java 8 â†’ default and static methods allowed in interfaces (to provide common behavior if needed).
â¤ But abstract (incomplete) methods are still necessary â†’ to enforce implementation.

â“ Difference between this and super keyword?
| Feature                   | this                                                           | super                                                          |
| Refers to                 | Current class object                                           | Immediate parent class object                                      |
| Usage in constructor      | Calls another constructor in the same class â†’ `this()`         | Calls parent class constructor â†’ `super()`                         |
| Access                    | Access current class fields, methods, and constructors         | Access parent class fields, methods, and constructors              |
| Variable access           | Resolves name conflict between instance variable and local variable  | Resolves name conflict between child and parent class variable |
| Method access             | Calls current class method (can be used explicitly,usually implicit)| Calls parent class method (useful in overriding)                   |
| Constructor call position | `this()` must be the first statement in a constructor                | `super()` must also be the first statement in a constructor    |
| Inheritance               | Does not involve inheritance (refers to same object)                 | Used in inheritance (refers to parent part of the object)          |

âœ… Examples
1. Variable Shadowing
class A {
    int x = 10;
}

class B extends A {
    int x = 20;

    void show() {
        System.out.println(x);        // 20 â†’ childâ€™s variable
        System.out.println(this.x);   // 20 â†’ childâ€™s variable explicitly
        System.out.println(super.x);  // 10 â†’ parentâ€™s variable
    }
}

2. Constructor Chaining
class A {
    A() {
        System.out.println("Parent constructor");
    }
}

class B extends A {
    B() {
        super(); // calls parent constructor
        System.out.println("Child constructor");
    }
}

3. Method Overriding
class A {
    void display() {
        System.out.println("Parent display");
    }
}

class B extends A {
    void display() {
        System.out.println("Child display");
    }

    void test() {
        this.display();   // Child display
        super.display();  // Parent display
    }
}

â“ What is a ClassLoader in Java?
â¤ A ClassLoader is a part of JVM responsible for loading classes into memory (RAM) when they are first referenced in a Java program.
â¤ It loads .class bytecode files from file system, network, or other sources into JVMâ€™s method area.
â¤ Without ClassLoader, JVM wouldnâ€™t know how to find and use your classes.

âœ… Types of ClassLoaders (Hierarchy)

â¤ Bootstrap ClassLoader
    âœ”ï¸ Loads core Java classes (rt.jar, java.lang, java.util, etc.).
    âœ”ï¸ Part of native JVM code (not a Java class).
âœ… Example: String, Integer.

â¤ Extension (Platform) ClassLoader
    âœ”ï¸ Loads classes from JDK extensions (jre/lib/ext or modules).
âœ… Example: javax.* packages.

â¤ Application (System) ClassLoader
    âœ”ï¸ Loads classes from the classpath (-cp or CLASSPATH env var).
    âœ”ï¸ This is the default loader for your project classes.
âœ… Example: your com.myapp.Student class.

âœ… ClassLoader Hierarchy (Parent Delegation Model)
Bootstrap ClassLoader
        â†“
Extension (Platform) ClassLoader
        â†“
Application (System) ClassLoader
        â†“
Your Custom ClassLoader (optional)

ğŸ‘‰ Whenever a class is needed:
â¤ Application loader asks parent first.
â¤ If parent doesnâ€™t find it, the current loader loads it.
(This avoids multiple loaders loading the same core classes.)

âœ… Example
public class ClassLoaderDemo {
    public static void main(String[] args) {
        // String class â†’ core class â†’ loaded by Bootstrap
        System.out.println(String.class.getClassLoader()); 
        // null (Bootstrap is written in native code)

        // This class â†’ loaded by Application ClassLoader
        System.out.println(ClassLoaderDemo.class.getClassLoader()); 
    }
}

ğŸ“Œ Key Interview Insights
ğŸ§  Why parent delegation model?
To prevent security issues (e.g., custom malicious java.lang.String class).
ğŸ§  Can we write a custom ClassLoader?
Yes, by extending ClassLoader and overriding findClass() (used in frameworks like Spring, Tomcat, Hibernate).

ğŸ§  Tricky point:
Bootstrap loader returns null in getClassLoader() because itâ€™s implemented in native code.

â“ What are access specifiers in Java?
Access Specifiers (or Modifiers) control the visibility/scope of classes, methods, constructors, and variables in Java.

There are 4 main access specifiers:

âœ… 1. public
â¤ Visible everywhere (inside same class, package, subclass, outside package).
â¤ Can be accessed from anywhere in the project.

public class Student {
    public String name;
    public void display() {
        System.out.println("Name: " + name);
    }
}

âœ… 2. protected
Accessible:
    âœ”ï¸ Inside the same package
    âœ”ï¸ In subclasses (even if in different package)
    âœ”ï¸ Not visible to non-subclasses outside the package.

class Person {
    protected int age;
}
class Student extends Person {
    void showAge() {
        System.out.println(age); // âœ… allowed (in subclass)
    }
}

âœ… 3. default (package-private â†’ when no specifier is written)
â¤ Accessible only within the same package.
â¤ Cannot be accessed outside the package, even in subclasses.

class Teacher {  // default access
    String subject;
    void printSubject() {
        System.out.println(subject);
    }
}

âœ… 4. private
â¤ Accessible only within the same class.
â¤ Not visible to subclass or other classes.

class Account {
    private double balance;
    private void displayBalance() {
        System.out.println(balance);
    }
}

| Specifier     | Same Class | Same Package | Subclass (diff pkg) | Outside Package |
| ------------- | ---------- | ------------ | ------------------- | --------------- |
| **public**    | âœ…         | âœ…          | âœ…                  | âœ…             |
| **protected** | âœ…         | âœ…          | âœ…                  | âŒ             |
| **default**   | âœ…         | âœ…          | âŒ                  | âŒ             |
| **private**   | âœ…         | âŒ          | âŒ                  | âŒ             |

ğŸ“Œ Interview Insights
â¤ default keyword does not exist â€” it just means no specifier is written.
â¤ protected is commonly misunderstood â€” it allows subclass access even outside package.
â¤ private â†’ best practice for encapsulation (fields should be private + exposed via getters/setters).
â¤ Classes can only be public or default (not protected or private).