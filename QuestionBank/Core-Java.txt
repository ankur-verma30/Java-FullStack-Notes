❓ Define JDK, JRE, and JVM
🔹 1. JVM (Java Virtual Machine)
➤ JVM is an abstract machine that provides a runtime environment to execute Java bytecode.

⚡Responsibilities:
✔️ Converts bytecode → machine code using JIT (Just-In-Time compiler).
✔️ Provides platform independence (“Write Once, Run Anywhere”).
✔️ Manages memory (heap, stack, method area, GC).
✔️ Ensures security via bytecode verification.
🔧 Key Point: JVM is platform-dependent (different implementations for Windows/Linux/Mac), but bytecode is platform-independent.

➡️ Interview Insight:
Many confuse JVM = Java compiler → Wrong! Compiler (javac) converts Java code → bytecode; JVM executes that bytecode.

🔹 2. JRE (Java Runtime Environment)
➤ JRE provides libraries, JVM, and other components to run Java applications.

Includes:
✔️ JVM
✔️ Core libraries (like java.lang, java.util, java.io)
✔️ Supporting files
🔧 Key Point: JRE does not include development tools (compiler, debugger). It’s only for running Java programs.

➡️ Interview Trap:
If asked, “Can you run Java code with just JRE?” → Yes, if you already have compiled bytecode. But you cannot compile .java files with JRE.

🔹 3. JDK (Java Development Kit)
➤ JDK is the full package required for Java development.

Includes:
✔️ JRE (which has JVM + libraries)
✔️ Development tools → javac (compiler), jdb (debugger), javadoc, jar, etc.
🔧 Key Point: JDK is for developers; JRE is for users.

➡️ Interview Trap:
Some interviewers ask: “If JDK contains JRE, and JRE contains JVM, can we say JDK = JVM?”
Answer: No. JDK = JRE + Development Tools. JVM is just part of JRE.

🔹 Hierarchy Diagram
JDK 
 └── JRE 
      └── JVM

🔹 One-Liner for Revision
➤ JVM → Runs bytecode.
➤ JRE → JVM + Libraries (to run Java apps).
➤ JDK → JRE + Tools (to develop Java apps).

❓ Significance of public static void main(String[] args)
The main() method is the entry point of every Java program. The JVM calls it to start execution. Each keyword has a special meaning:

🔹 1. public
➤ Reason: Must be accessible to JVM outside the class.
➤ JVM looks for main() from anywhere, so it cannot be private or default.
➤ If not public → main method not found error.

➡️ Interview Trap:
Q: “What if I make main() private or protected?”
A: JVM won’t be able to access it → runtime error.

🔹 2. static
➤ Reason: JVM doesn’t need to create an object of the class to call main().
➤ Being static, it belongs to the class rather than an object.
➤ Ensures execution starts immediately when the class is loaded.

➡️ Interview Trap:
Q: “Can main() be non-static?”
A: Yes, it compiles, but JVM won’t recognize it as a valid entry point.

🔹 3. void
➤ Reason: main() doesn’t return any value to JVM.
➤ JVM doesn’t expect a return type.
➤ If you try to return something, compilation error occurs.

🔹 4. main
➤ Reason: Name is predefined and reserved by JVM as the entry point.
➤ If you change it, JVM won’t start execution.

🔹 5. (String[] args)
➤ Reason: Accepts command-line arguments when program is executed.
✅ Example:
class Demo {
    public static void main(String[] args) {
        System.out.println(args[0]); // prints first command line argument
    }
}
Run: java Demo Hello → Output: Hello

➡️ Alternate forms accepted by JVM:
✔️ public static void main(String args[])
✔️ public static void main(String... args) (var-args since Java 5)

🔹 One-Liner for Quick Revision
✔️ public → JVM can access.
✔️ static → No object needed.
✔️ void → No return value.
✔️ main → JVM’s entry point.
✔️ String[] args → Command-line inputs.

🔹 Interview Insights
➤ “What if signature is public static int main()?” → Compilation error.
➤ “What if I overload main()?” → Allowed, but JVM only calls the public static void main(String[] args).
➤ “What if args is changed to String... args?” → Still valid.


❓ Why does the main method support String[] args?
🔹 1. Command-Line Arguments Support
String[] args lets us pass data from outside (command line) to the program at runtime.
✅ Example:

class Demo {
    public static void main(String[] args) {
        System.out.println("First argument: " + args[0]);
    }
}
⚡ Run: java Demo Hello
Output: First argument: Hello

➡️ Without String[] args, the JVM couldn’t pass inputs from command line.

🔹 2. Why Specifically String?
➤ Every input from command line is text-based.
➤ JVM collects arguments as strings (e.g., "123" not number 123).

➤ If you need another type (int, double), you must parse it manually:
int num = Integer.parseInt(args[0]); // converts "123" → 123

🔹 3. Why Array []?
➤ Because we may pass multiple arguments separated by space.

✅ Example:
java Demo Alice Bob Charlie

Then:
args[0] = "Alice"
args[1] = "Bob"
args[2] = "Charlie"
➡️ An array is the best way to store variable-length inputs.

🔹 4. Alternative Forms Accepted by JVM
➤ JVM doesn’t strictly enforce String[] args.
➤ The following are also valid:
    ✔️ String args[]
    ✔️ String... args (var-args since Java 5).

🔹 5. What if we remove it?
If you write: public static void main()
❗ Compiles fine, but JVM won’t recognize it as a valid entry point → Runtime error:
❌ Error: Main method not found in class Demo

🔹 One-Liner for Quick Revisio
👉 String[] args is used because JVM needs a standard way to pass runtime command-line arguments, and all inputs are strings by default.

🔹 Interview Insights
🧠 Trick Q: “Why not int[] args or Object[] args?”
➤ Because JVM can only guarantee that inputs will be Strings from command line.
🧠 Trick Q: “Can we overload main() with different parameters?”
➤ Yes, but JVM only calls public static void main(String[] args). Others can only be called manually inside code.

❓ Constructor Chaining in Java
Constructor Chaining means calling one constructor from another constructor (in the same class or parent class) to reuse initialization code and avoid duplication.

🔹 Types of Constructor Chaining

🔄 Within the same class → using this()
    ✔️ Calls another constructor of the same class.
    ✔️ Must be the first statement in the constructor.

🔄 Between parent and child class → using super()
    ✔️ Calls the parent class constructor.
    ✔️ Must be the first statement in the constructor.

✅ Example 1: Same Class (this())
class Student {
    private String name;
    private int age;

    // Constructor 1
    Student() {
        this("Unknown", 18);  // calling parameterized constructor
    }

    // Constructor 2
    Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    void display() {
        System.out.println(name + " - " + age);
    }
}

public class Demo {
    public static void main(String[] args) {
        Student s1 = new Student();
        Student s2 = new Student("Alice", 22);
        s1.display(); // Unknown - 18
        s2.display(); // Alice - 22
    }
}
➡️ Here, default constructor calls the parameterized constructor to avoid duplicate code.

✅ Example 2: Parent → Child (super())
class Person {
    Person() {
        System.out.println("Person constructor");
    }
}

class Employee extends Person {
    Employee() {
        super();  // calls parent constructor
        System.out.println("Employee constructor");
    }
}

public class Demo {
    public static void main(String[] args) {
        new Employee();
    }
}
✅ Output:
Person constructor
Employee constructor
➡️ Here, super() ensures parent class initialization happens first.

🔹 Rules of Constructor Chaining
➤ Either this() or super() must be the first statement.
➤ Circular calls (like a constructor calling itself) → compile-time error.
➤ If you don’t write super(), the compiler automatically inserts super() (default constructor).
➤ Cannot use both this() and super() in the same constructor → only one allowed.

🔹 Why is it Important?
➤ Code Reusability → No duplication of initialization logic.
➤ Readability → Clear execution order.
➤ Mandatory for Inheritance → Parent must always be initialized before child.

🔹 One-Liner for Quick Revision
👉 Constructor Chaining = Calling one constructor from another (same class via this(), parent class via super()) to reuse initialization logic.

🔹 Interview Insights
🧠 Q: “What happens if parent has only parameterized constructor and child does not call it?”
➤ Compilation error (because compiler inserts super() but no default constructor exists).
🧠 Q: “Can this() and super() be used together?”
➤ No, only one can be the first line.
🧠 Q: “What if I call a method before super() inside a constructor?”
➤ Compilation error: Constructor call must be the first statement.


❓ OOPs Concepts(Inheritance, Polymorphism, Encapsulation, Abstraction)
🔹 1. Encapsulation → Data Hiding + Binding
➤ Wrapping variables (data) and methods (logic) into a single unit (class). Provides controlled access via getters/setters.

✅ Daily Life Example:
A bank account: Your balance is hidden (private), but you can access it using deposit/withdraw methods.
➤ One-liner: “Encapsulation = data hiding using access modifiers + methods.”

🔹 2. Abstraction → Hiding Implementation
➤ Showing only essential details, hiding internal complexity. Achieved using abstract classes / interfaces.

✅ Daily Life Example:
Car driving: You use the steering wheel, accelerator, brakes without knowing how the engine, gears, and sensors work internally.
➤ One-liner: “Abstraction = show what it does, hide how it does.”

🔹 3. Inheritance → Reusability
➤ One class acquires properties and methods of another (parent → child). Promotes code reuse.

✅ Daily Life Example:
    ✔️ Father → Son: A child inherits properties (like eye color) and behaviors (like habits) from parents.
    ✔️ In software: class Dog extends Animal.
➤ One-liner: “Inheritance = child gets features from parent.”

🔹 4. Polymorphism → Many Forms
➤ Same method/operation behaves differently in different contexts.
    ✔️ Compile-time polymorphism → Method overloading.
    ✔️ Runtime polymorphism → Method overriding.

✅ Daily Life Example:
Mobile Phone Button:
    ✔️ Single button = different actions (tap → open app, double tap → camera, long press → assistant).
➤ One-liner: “Polymorphism = same name, different behavior.”

🔹 Interview-Ready Summary (One Sentence)
👉 OOPs = Encapsulation (data hiding), Abstraction (hiding implementation), Inheritance (reusability), and Polymorphism (same method different forms) — just like real-world objects such as cars, bank accounts, or family inheritance.

❓ Difference between Interface and Abstract Class
➤ Interface: A contract that specifies what a class must do, but not how.
➤ Abstract Class: A class that may have partial implementation (some abstract methods + some concrete methods).

🔹 2. Method Implementation
➤ Interface:
    ✔️ Before Java 8 → only abstract methods (implicitly public abstract).
    ✔️ Java 8 → allowed default & static methods.
    ✔️ Java 9 → allowed private methods.

➤ Abstract Class:
    ✔️ Can have both abstract and concrete methods.
    ✔️ Can provide partial implementation.

🔹 3. Variables
➤ Interface:
    ✔️ Variables are always public static final (constants).
    ✔️ Must be initialized at declaration.

➤ Abstract Class:
    ✔️ Can have instance variables.
    ✔️ Can use any access modifier (private, protected, etc.).

🔹 4. Inheritance & Multiple Inheritance
Interface: Supports multiple inheritance (a class can implement multiple interfaces).
Abstract Class: Supports single inheritance only (a class can extend only one abstract class).

🔹 5. Constructors
Interface: ❌ Cannot have constructors (cannot be instantiated).
Abstract Class: ✅ Can have constructors (called when subclass object is created).

🔹 6. Use Cases
➤ Interface:
    ✔️ Used to define a contract/blueprint for unrelated classes.
    ✅ Example: Comparable, Runnable, Serializable.

➤ Abstract Class:
    ✔️ Used when classes share common behavior + state but still have some abstract methods.

✅ Example: AbstractList in Java Collections.

🔹 7. Code Example
// Interface example
interface Vehicle {
    void start(); // abstract method
}

class Car implements Vehicle {
    public void start() {
        System.out.println("Car starts with key");
    }
}

// Abstract class example
abstract class Animal {
    abstract void sound();   // abstract method
    void sleep() {           // concrete method
        System.out.println("Sleeping...");
    }
}

class Dog extends Animal {
    void sound() {
        System.out.println("Bark");
    }
}

🔹 8. One-Liner for Interview
➤ Interface → “Defines what to do, no state.”
➤ Abstract Class → “Defines what to do + partial how to do, can have state.”

🔹 9. Interview Traps & Insights
🧠 Q: “Can an interface extend another interface?” → ✅ Yes (multiple inheritance of interfaces allowed).
🧠 Q: “Can an abstract class implement an interface?” → ✅ Yes, but must provide implementation for methods or remain abstract.
🧠 Q: “Which is faster, abstract class or interface?” → Abstract class is slightly faster (direct method call vs dynamic dispatch in interfaces).
🧠 Q: “When to prefer interface over abstract class?” → Use interface when unrelated classes need common behavior (e.g., Flyable, Drivable). Use abstract class when related classes share state/logic (e.g., Shape).

❓ Multi-catch Block in Java
➤ A multi-catch block allows you to handle multiple exceptions in a single catch block using the | (pipe) operator.
➤ Introduced in Java 7 to reduce code duplication.

✅ Example (Before Java 7 → Repetitive Code)
try {
    int arr[] = new int[5];
    arr[5] = 10 / 0;
} catch (ArithmeticException e) {
    System.out.println("Arithmetic Exception: " + e.getMessage());
} catch (ArrayIndexOutOfBoundsException e) {
    System.out.println("Array Index Exception: " + e.getMessage());
}
❌ Problem: Code is repetitive; two separate blocks with same logic.

✅ Example (After Java 7 → Multi-Catch)
try {
    int arr[] = new int[5];
    arr[5] = 10 / 0;
} catch (ArithmeticException | ArrayIndexOutOfBoundsException e) {
    System.out.println("Exception: " + e.getMessage());
}
➡️ Same result with cleaner code.

🔹 Rules of Multi-catch
➤ Use | (pipe) to separate multiple exception types.
➤ Exceptions must be unrelated (not parent-child).

✅ Allowed: IOException | SQLException
❌ Not Allowed: IOException | FileNotFoundException (because FileNotFoundException is a subclass of IOException).

⚡ The exception variable (e) is final implicitly → You cannot reassign it inside the block.

🔹 Why Multi-catch is Useful?
➤ Reduces boilerplate code (no duplicate catch blocks).
➤ Improves readability.
➤ Optimizes bytecode (compiler generates smaller, efficient bytecode).

🔹 One-Liner for Quick Revision
👉 Multi-catch block = Handle multiple exceptions in one catch block using | operator (Java 7+), avoiding code duplication.

🔹 Interview Insights
🧠 Q: “Can we catch exceptions in order?”
In multi-catch, order doesn’t matter because it’s a single block.
🧠 Q: “What if exceptions have parent-child relation?”
Compile-time error. Use separate catch blocks instead.
🧠 Q: “Is the exception object final in multi-catch?”
Yes, you cannot assign e = new Exception() inside.


❓ Difference between final, finally, and finalize()
🔹 1. final (Keyword)
➤ Usage: Restrict modification.
➤ Applied to: Variable → makes it a constant (cannot be reassigned).

final int x = 10;
// x = 20; ❌ Compile-time error

➤ Method → prevents overriding in child class.
class A {
    final void show() { System.out.println("A"); }
}
class B extends A {
    // void show() {} ❌ Not allowed
}

➤ Class → prevents inheritance.
final class A {}
// class B extends A {} ❌ Not allowed
➡️ One-liner: final = constant / no overriding / no inheritance.

🔹 2. finally (Block)
➤ Usage: Used in exception handling.
➤ Purpose: Ensures a block of code always executes, regardless of exception occurrence.
➤ Commonly used for resource cleanup (closing files, DB connections).

✅ Example:
try {
    int x = 10 / 0;
} catch (ArithmeticException e) {
    System.out.println("Exception: " + e);
} finally {
    System.out.println("Finally block always executes");
}

✅ Output:
Exception: java.lang.ArithmeticException: / by zero
Finally block always executes

➡️ Special case: If you call System.exit(0), the finally block won’t execute.
➡️ One-liner: finally = block that always executes (for cleanup).

🔹 3. finalize() (Method)
A method in Object class called by Garbage Collector (GC) before destroying an object.
Usage: To release resources (like closing file handles, DB connections) before object is removed.

✅ Example:
class Demo {
    protected void finalize() {
        System.out.println("Finalize method called before GC");
    }
    public static void main(String[] args) {
        Demo d = new Demo();
        d = null;
        System.gc(); // Suggests JVM to call GC
    }
}
✅ Output: Finalize method called before GC


➡️ Important Notes:
➤ finalize() execution is not guaranteed. GC may or may not run.
➤ From Java 9, finalize() is deprecated (use try-with-resources instead).
➡️ One-liner: finalize() = method called by GC before object destruction (deprecated).

🔹 Interview-Ready Comparison
| Feature           | `final` (Keyword)                        | `finally` (Block)            | `finalize()` (Method)                 |
| ----------------- | ---------------------------------------- | ---------------------------- | ------------------------------------- |
| **Category**      | Modifier                                 | Block                        | Method in `Object` class              |
| **Used For**      | Constants, no overriding, no inheritance | Cleanup code after try-catch | Cleanup before object destruction     |
| **When Executes** | At compile-time restriction              | Always after try-catch       | Called by GC before destroying object |
| **Control**       | Programmer                               | Programmer                   | JVM/GC decides                        |
| **Deprecation**   | ❌ Not deprecated                         | ❌ Not deprecated             | ✅ Deprecated in Java 9+               |


❓ Why is String inheritable? (or is it?)
🔹 Truth about String class
The String class in Java is declared as:
✅ Code Structure:
public final class String implements Serializable, Comparable<String>, CharSequence
Notice the final keyword → this means:
    ✔️ String cannot be inherited (cannot have a subclass).
    ✔️ This is done to ensure immutability and security.
➡️ So, String is NOT inheritable. If you try to extend it:
class MyString extends String {} // ❌ Compile-time error

🔹 Why did Java make String final?
➤ Immutability: Prevents someone from extending String and overriding methods to break immutability.
➤ Security: Strings are used in sensitive areas (file paths, DB URLs, network connections). If String could be inherited and tampered, it would be a major security risk.
➤ Performance: String pool (interning) relies on immutability. If strings were mutable or extendable, pooling would fail.

❓ How can we create our own inheritance class?
If you want a custom class that supports inheritance, don’t mark it as final. Example:

// Parent class
class Vehicle {
    String brand = "Generic";

    void start() {
        System.out.println("Vehicle starting...");
    }
}

// Child class
class Car extends Vehicle {
    int wheels = 4;

    @Override
    void start() {
        System.out.println(brand + " Car starting with " + wheels + " wheels!");
    }
}

public class Demo {
    public static void main(String[] args) {
        Car c = new Car();
        c.brand = "Tesla";
        c.start(); // Tesla Car starting with 4 wheels!
    }
}

🔹 Rules for creating an inheritance class
➤ Use extends keyword for class inheritance.
➤ Use implements for interface implementation.
➤ Methods in parent can be overridden in child (unless final/static/private).
➤ Parent’s constructor is always called first (via super()).
➤ Multiple inheritance of classes is not allowed in Java → solve via interfaces.

❓What is Runtime Polymorphism?
Runtime polymorphism in Java is method overriding — when a method call is resolved at runtime (not compile-time).
It’s also called Dynamic Method Dispatch.

✅ Example: Method Overriding
class Animal {
    void sound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("Dog barks");
    }
}

class Cat extends Animal {
    @Override
    void sound() {
        System.out.println("Cat meows");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal a1 = new Dog();  // reference is Animal, object is Dog
        Animal a2 = new Cat();  // reference is Animal, object is Cat

        a1.sound();   // Dog barks  (resolved at runtime)
        a2.sound();   // Cat meows  (resolved at runtime)
    }
}

🔹 Key Points
➤ Happens via method overriding.
➤ The object’s actual type (Dog, Cat) decides which method gets executed.
➤ The reference type (Animal) only decides which methods are accessible.
➤ Achieved only with non-static, non-final, non-private methods.

🔸 Static vs Runtime Polymorphism
✔️ Compile-time (Static) Polymorphism → Method Overloading.
(Resolved during compilation).
✔️ Runtime Polymorphism → Method Overriding.
(Resolved during execution using Dynamic Method Dispatch).

📌 Interview Insights
➤ If a superclass reference points to a subclass object, and an overridden method is called → subclass version runs (not superclass).
➤ Constructors cannot be overridden, so runtime polymorphism does not apply to them.
➤ Helps in loose coupling → code works on interface/superclass reference, actual object can vary.


❓ What is the need of creating incomplete methods in Interface?
Interfaces define a contract/blueprint for classes.
They say “these methods must exist” but do not dictate how they should be implemented.

✅ Needs & Advantages:
⚡ Achieve Abstraction
    ✔️ Interface methods are incomplete because the how depends on the class.

✅ Example:
interface Vehicle {
    void start();  // every vehicle must start, but differently
}

class Car implements Vehicle {
    public void start() { 
        System.out.println("Car starts with a key"); 
    }
}

class Bike implements Vehicle {
    public void start() { 
        System.out.println("Bike starts with a self-start button"); 
    }
}


⚡ Multiple Implementations (Polymorphism)
    ✔️ Same method, different behavior → achieved by leaving method incomplete in the interface.

Car.start() ≠ Bike.start(), but both guarantee they implement start().

⚡ Standardization / Contract
    ✔️ Interfaces ensure all implementing classes must follow a standard contract.

✅ Example: Comparable interface → any class implementing it must define compareTo().

⚡Loose Coupling
    ✔️ Code depends on interface (contract) and not on concrete classes.
This allows swapping implementations easily.

✅ Example:
List<String> list = new ArrayList<>();
list = new LinkedList<>();  // works fine, same interface


Future Extensibility
    ✔️ Library/framework writers define interfaces → application developers provide their own implementations.
✅ Example: JDBC → Connection, Statement, ResultSet are interfaces.

Oracle, MySQL, PostgreSQL → provide their own implementations.

🔸 Why not give default method bodies?
➤ Before Java 8, interfaces could only have incomplete methods → pure abstraction.
➤ Since Java 8 → default and static methods allowed in interfaces (to provide common behavior if needed).
➤ But abstract (incomplete) methods are still necessary → to enforce implementation.

❓ Difference between this and super keyword?
| Feature                   | this                                                           | super                                                          |
| Refers to                 | Current class object                                           | Immediate parent class object                                      |
| Usage in constructor      | Calls another constructor in the same class → `this()`         | Calls parent class constructor → `super()`                         |
| Access                    | Access current class fields, methods, and constructors         | Access parent class fields, methods, and constructors              |
| Variable access           | Resolves name conflict between instance variable and local variable  | Resolves name conflict between child and parent class variable |
| Method access             | Calls current class method (can be used explicitly,usually implicit)| Calls parent class method (useful in overriding)                   |
| Constructor call position | `this()` must be the first statement in a constructor                | `super()` must also be the first statement in a constructor    |
| Inheritance               | Does not involve inheritance (refers to same object)                 | Used in inheritance (refers to parent part of the object)          |

✅ Examples
1. Variable Shadowing
class A {
    int x = 10;
}

class B extends A {
    int x = 20;

    void show() {
        System.out.println(x);        // 20 → child’s variable
        System.out.println(this.x);   // 20 → child’s variable explicitly
        System.out.println(super.x);  // 10 → parent’s variable
    }
}

2. Constructor Chaining
class A {
    A() {
        System.out.println("Parent constructor");
    }
}

class B extends A {
    B() {
        super(); // calls parent constructor
        System.out.println("Child constructor");
    }
}

3. Method Overriding
class A {
    void display() {
        System.out.println("Parent display");
    }
}

class B extends A {
    void display() {
        System.out.println("Child display");
    }

    void test() {
        this.display();   // Child display
        super.display();  // Parent display
    }
}

❓ What is a ClassLoader in Java?
➤ A ClassLoader is a part of JVM responsible for loading classes into memory (RAM) when they are first referenced in a Java program.
➤ It loads .class bytecode files from file system, network, or other sources into JVM’s method area.
➤ Without ClassLoader, JVM wouldn’t know how to find and use your classes.

✅ Types of ClassLoaders (Hierarchy)

➤ Bootstrap ClassLoader
    ✔️ Loads core Java classes (rt.jar, java.lang, java.util, etc.).
    ✔️ Part of native JVM code (not a Java class).
✅ Example: String, Integer.

➤ Extension (Platform) ClassLoader
    ✔️ Loads classes from JDK extensions (jre/lib/ext or modules).
✅ Example: javax.* packages.

➤ Application (System) ClassLoader
    ✔️ Loads classes from the classpath (-cp or CLASSPATH env var).
    ✔️ This is the default loader for your project classes.
✅ Example: your com.myapp.Student class.

✅ ClassLoader Hierarchy (Parent Delegation Model)
Bootstrap ClassLoader
        ↓
Extension (Platform) ClassLoader
        ↓
Application (System) ClassLoader
        ↓
Your Custom ClassLoader (optional)

👉 Whenever a class is needed:
➤ Application loader asks parent first.
➤ If parent doesn’t find it, the current loader loads it.
(This avoids multiple loaders loading the same core classes.)

✅ Example
public class ClassLoaderDemo {
    public static void main(String[] args) {
        // String class → core class → loaded by Bootstrap
        System.out.println(String.class.getClassLoader()); 
        // null (Bootstrap is written in native code)

        // This class → loaded by Application ClassLoader
        System.out.println(ClassLoaderDemo.class.getClassLoader()); 
    }
}

📌 Key Interview Insights
🧠 Why parent delegation model?
To prevent security issues (e.g., custom malicious java.lang.String class).
🧠 Can we write a custom ClassLoader?
Yes, by extending ClassLoader and overriding findClass() (used in frameworks like Spring, Tomcat, Hibernate).

🧠 Tricky point:
Bootstrap loader returns null in getClassLoader() because it’s implemented in native code.

❓ What are access specifiers in Java?
Access Specifiers (or Modifiers) control the visibility/scope of classes, methods, constructors, and variables in Java.

There are 4 main access specifiers:

✅ 1. public
➤ Visible everywhere (inside same class, package, subclass, outside package).
➤ Can be accessed from anywhere in the project.

public class Student {
    public String name;
    public void display() {
        System.out.println("Name: " + name);
    }
}

✅ 2. protected
Accessible:
    ✔️ Inside the same package
    ✔️ In subclasses (even if in different package)
    ✔️ Not visible to non-subclasses outside the package.

class Person {
    protected int age;
}
class Student extends Person {
    void showAge() {
        System.out.println(age); // ✅ allowed (in subclass)
    }
}

✅ 3. default (package-private → when no specifier is written)
➤ Accessible only within the same package.
➤ Cannot be accessed outside the package, even in subclasses.

class Teacher {  // default access
    String subject;
    void printSubject() {
        System.out.println(subject);
    }
}

✅ 4. private
➤ Accessible only within the same class.
➤ Not visible to subclass or other classes.

class Account {
    private double balance;
    private void displayBalance() {
        System.out.println(balance);
    }
}

| Specifier     | Same Class | Same Package | Subclass (diff pkg) | Outside Package |
| ------------- | ---------- | ------------ | ------------------- | --------------- |
| **public**    | ✅         | ✅          | ✅                  | ✅             |
| **protected** | ✅         | ✅          | ✅                  | ❌             |
| **default**   | ✅         | ✅          | ❌                  | ❌             |
| **private**   | ✅         | ❌          | ❌                  | ❌             |

📌 Interview Insights
➤ default keyword does not exist — it just means no specifier is written.
➤ protected is commonly misunderstood — it allows subclass access even outside package.
➤ private → best practice for encapsulation (fields should be private + exposed via getters/setters).
➤ Classes can only be public or default (not protected or private).

❓Difference between Object Oriented Programming (OOP) and Procedure Oriented Programming (POP)?
| Feature                | Procedure-Oriented Programming (POP)                              | Object-Oriented Programming (OOP)
| Approach           | Focuses on functions (procedures) that operate on data.           | Focuses on objects that encapsulate both data & behavior.                    |
| Data Security      | Data is global and can be accessed by any function → less secure. | Data is encapsulated inside objects → more secure.                           |
| Modularity         | Functions are the building blocks.                                | Classes & objects are the building blocks.                                   |
| Reusability        | Limited reusability, functions need rewriting for new requirements.   | High reusability via inheritance & polymorphism.                       |
| Example Language   | C, Pascal                                                             | Java, C++,Python                                                         |
| Scalability        | Harder to manage large codebases → less scalable.                    | Easier to manage large projects → more scalable.                          |
| Data Handling      | Data moves **freely between functions**.                              | Data is hidden & accessed via methods (getters/setters).                 |
| Abstraction        | No direct support, manual handling.                                   | Strong support with **abstract classes & interfaces.                     |
| Real-World Mapping | Poor real-world representation.                                      | Maps naturally to real-world entities (Car, Employee, BankAccount, etc.). |

Interview One-Liners
➤ POP = "Functions-first, Data-second"
➤ OOP = "Data-first, Functions bound to Data"
➤ POP is like writing a recipe step by step, OOP is like designing a kitchen with appliances (objects).


❓Is Java 100% Object-Oriented?
➤ No, Java is not 100% Object-Oriented.
➤ Even though Java follows Object-Oriented Programming principles (Encapsulation, Inheritance, Polymorphism, Abstraction), it is not purely OOP.

Reasons Why Java is NOT 100% OOP:
🔄 Primitive Data Types
    ✔️ Java has 8 primitive types (int, char, byte, short, long, float, double, boolean).
    ✔️ These are not objects; they are stored directly in memory for performance.
    ✔️ If Java was 100% OOP, even these would be objects.
(Wrapper classes like Integer, Double, etc., were later introduced to wrap primitives.)

🔄 Static Members
    ✔️ static keyword allows access without creating an object.
    ✔️ This violates the “everything should be an object” rule.

🔄 main() Method
    ✔️ public static void main(String[] args) is static, so JVM can call it without creating an object.

🔄 Other Non-OOP Features
    ✔️ Use of operator overloading is not allowed (only + for String is overloaded).
    ✔️ Supports procedural code inside static methods.

✅ Conclusion
    ✔️ Java is Object-Oriented, but not 100% OOP.
    ✔️ The major reason: primitives + static context.


❓Why Pointers in not used in Java?
Java does not support explicit pointers (like in C/C++) because of security, simplicity, and memory management reasons. Instead, Java uses references to access objects.

Detailed Reasons

🔄 Security
    ✔️ Pointers allow direct memory access.
    ✔️ This can lead to:
        👉 Unauthorized access to memory (hacking, buffer overflow).
        👉 Modification of critical JVM memory areas.
    ✔️ By removing pointers, Java prevents such security vulnerabilities.

🔄 Simplicity & Readability
    ✔️ Pointers make code complex (pointer arithmetic, dangling pointers, memory leaks).
    ✔️ Java was designed to be beginner-friendly, so pointers were avoided.
    ✔️ Instead, Java developers work with references (safe pointers handled internally by JVM).

🔄 Automatic Memory Management (Garbage Collection)
    ✔️ In C/C++, developers must manually allocate (malloc) and free (free) memory.
    ✔️ Pointers complicate memory management, leading to memory leaks.
    ✔️ Java uses Garbage Collector (GC) to manage memory automatically, and explicit pointers would interfere with GC.

🔄 Platform Independence
    ✔️ Pointers are machine-dependent (addressing varies across architectures).
Java’s motto is “Write Once, Run Anywhere”.
    ✔️ By avoiding pointers, Java programs remain portable across different systems.

🔄 Use of References Instead
    ✔️ In Java, when you create an object:
String s = new String("Hello");

    ✔️ s is a reference, not a pointer.
    ✔️ You can use it to access the object, but you cannot perform pointer arithmetic (like s+1).

One-Liner
👉 "Java does not support explicit pointers to ensure security, simplicity, automatic memory management, and platform independence. Instead, Java uses references, which are safe and managed by JVM."

✅ Common Trap in Interviews:
🧠If asked "But aren’t references in Java like pointers?" 
✅ Answer:
"Yes, references are somewhat like pointers, but they don’t allow pointer arithmetic or direct memory access, making them safer and JVM-controlled."


❓Functional Interface and Lambda Expression. How these two are related to each other?
✔️Answer:
➤ Functional interface that has exactly one abstract method.
➤ Can have:
    👉One abstract method
    👉Any number of default and static methods
➤ Annotated with @FunctionalInterface (optional, but good practice).

✅ Examples from JDK:
1. Runnable (run())
2. Callable (call())
3. Comparator (compare())
4. Predicate<T> (test())
5. Function<T, R> (apply())

⚡ Code Example:
@FunctionalInterface
interface MyFunctionalInterface {
    void sayHello();
}

✅ Lambda Expression
short-cut way of writing an anonymous implementation of a functional interface.
❗ Syntax: (parameters) -> expression_or_block

⚡Code Example:
public class Test {
    public static void main(String[] args) {
        // Traditional Anonymous Class
        MyFunctionalInterface obj1 = new MyFunctionalInterface() {
            public void sayHello() {
                System.out.println("Hello World");
            }
        };

        // Using Lambda Expression
        MyFunctionalInterface obj2 = () -> System.out.println("Hello World");

        obj1.sayHello();
        obj2.sayHello();
    }
}

✅ Output:
Hello World
Hello World

✅ Relationship Between Them
➤ Lambda expressions can only be used with functional interfaces.
➤ The functional interface provides the target type for the lambda.
➤ ompiler maps the lambda expression → single abstract method of the functional interface.

👉 Example:
Runnable r = () -> System.out.println("Running...");  
// Here Runnable is functional interface, lambda implements run()

🔄 Why Introduced?
To support functional programming style in Java 8.
Makes code shorter, cleaner, and more readable (especially in Streams API).


❓Use of Marker Interfaces?
✔️ Answer: 
A Marker Interface is an interface with no methods or fields.
Also called tagging interfaces.
Purpose: to mark/tag a class so that JVM or frameworks can give it special behavior.

👉 Examples in JDK:
1. Serializable
2. Cloneable
3. Remote

🔄 Use of Marker Interfaces
✔️ Provide Metadata to JVM / Compiler
    ➤ Marker interfaces act as tags for classes.
    ✅ Example: If a class implements Serializable, JVM knows objects of this class can be serialized.

✔️ Enable Special Behavior at Runtime
JVM / frameworks check with instanceof to see if a class is marked.
✅ Example:
if(obj instanceof Serializable) {
    // JVM will allow serialization
}

✔️ Provide Strong Type Checking
    ➤ Marker interface is part of type system.
    ➤ Compiler ensures only tagged classes are passed where required.

✔️ Used in Frameworks / Libraries
Many frameworks (Hibernate, Spring, etc.) use marker interfaces for configuration and behavior control.

✅ Code Example:
import java.io.*;

class Student implements Serializable {   // Marker interface
    int id;
    String name;
    Student(int id, String name) {
        this.id = id;
        this.name = name;
    }
}

public class MarkerDemo {
    public static void main(String[] args) throws Exception {
        Student s = new Student(1, "Ankur");

        // Serialize object
        FileOutputStream fos = new FileOutputStream("data.ser");
        ObjectOutputStream oos = new ObjectOutputStream(fos);
        oos.writeObject(s);  // Works only because Student implements Serializable
        oos.close();

        System.out.println("Object serialized successfully!");
    }
}

✅ Output:
Object serialized successfully!

❗ If Student did not implement Serializable, above code would throw NotSerializableException.

⚡ Follow-up Trap Question:
👉 “Since Java 5 introduced annotations, are Marker Interfaces still useful?”
Answer: “Annotations are now preferred for metadata, but marker interfaces still provide type safety and are widely used in legacy code.”


❓What is object class and which methods are present in the object class.
✔️ Answer:
➤ Object is the parent/base class of all classes in Java.
➤ Every class in Java directly or indirectly inherits from Object.
➤ It is present in java.lang package.
➤ Provides common methods that every Java class gets by default.

👉 Example:
class Student {
    int id;
    String name;
}

➤ Even though we didn’t extend anything, Student extends Object internally.

✅ Methods Present in Object Class
| **Method**                                     | **Description / Use**                                                        |
| ---------------------------------------------- | ---------------------------------------------------------------------------- |
| `public String toString()`                     | Returns string representation of object (default: className\@hashCode).      |
| `public boolean equals(Object obj)`            | Compares two objects for equality (default: reference equality).             |
| `public int hashCode()`                        | Returns hash code of object (used in HashMap, HashSet, etc.).                |
| `protected Object clone()`                     | Creates and returns a copy of the object (class must implement `Cloneable`). |
| `protected void finalize()`                    | Called by GC before object is destroyed (deprecated in Java 9).              |
| `public final Class<?> getClass()`             | Returns runtime class (reflection).                                          |
| `protected void wait()`                        | Causes current thread to wait until notified.                                |
| `protected void wait(long timeout)`            | Wait with timeout.                                                           |
| `protected void wait(long timeout, int nanos)` | Wait with timeout + nanos.                                                   |
| `public final void notify()`                   | Wakes up one waiting thread on object’s monitor.                             |
| `public final void notifyAll()`                | Wakes up all waiting threads on object’s monitor.                            |


✅ Example Usage
class Student {
    int id;
    String name;

    Student(int id, String name) {
        this.id = id;
        this.name = name;
    }

    // Override toString()
    public String toString() {
        return "Student[id=" + id + ", name=" + name + "]";
    }
}

public class ObjectDemo {
    public static void main(String[] args) {
        Student s1 = new Student(1, "Ankur");
        Student s2 = new Student(1, "Ankur");

        // toString()
        System.out.println(s1);  // Student[id=1, name=Ankur]

        // equals()
        System.out.println(s1.equals(s2));  // false (unless overridden)

        // hashCode()
        System.out.println(s1.hashCode());
    }
}

⚡ Follow-up (commonly asked):
👉 “Why should we override equals() and hashCode() together?”


❓What is Exception Handling and Explain Exception handling hierarchy.
✔️ Answer:
Exception Handling in Java is a mechanism to handle runtime errors (like divide by zero, null pointer, array index out of bound, etc.) so the program continues execution without crashing.

🔄 Purpose:
    ➤ Ensure normal flow of the application.
    ➤ Provide meaningful messages instead of abrupt termination.
    ➤ Makes code robust and maintainable.

🔄 Key keywords used in Java Exception Handling:
    ➤ try → Code that might throw an exception.
    ➤ catch → Block to handle the exception.
    ➤ finally → Always executed (cleanup code).
    ➤ throw → Used to throw an exception.
    ➤ throws → Declares exceptions a method might throw.

👉 Example:
public class ExceptionDemo {
    public static void main(String[] args) {
        try {
            int a = 10 / 0; // ArithmeticException
        } catch (ArithmeticException e) {
            System.out.println("Can't divide by zero!");
        } finally {
            System.out.println("Finally block always executes.");
        }
    }
}


✅ Exception Handling Hierarchy

Java divides exceptions into Checked and Unchecked.
Here’s the hierarchy (interviewers love this diagram 👇):
                Throwable
                   |
     --------------------------------
     |                              |
  Exception                      Error
     |
  ----------------------------
  |                          |
Checked Exception       Unchecked Exception
(IOException,           (RuntimeException,
SQLException, etc.)     NullPointerException,
                        ArithmeticException,
                        ArrayIndexOutOfBounds, etc.)


🔹 Explanation of Hierarchy
🔄 Throwable
    ➤ The root class for all errors and exceptions.
    ➤ Has two main subclasses: Exception and Error.

🔄 Error
    ➤ Represents serious issues that are beyond the control of the program.
    ➤ Example: OutOfMemoryError, StackOverflowError.
    ➤ Should NOT be handled in normal application flow.

🔄 Exception
Represents conditions the program can catch and handle.

👉 Types:
🔄 Checked Exceptions (Compile-time exceptions)
    ➤ Checked by the compiler.
    ➤ Must be either caught or declared with throws.
    ➤ Examples: IOException, SQLException, ClassNotFoundException.

🔄 Unchecked Exceptions (Runtime exceptions)
    ➤ Occur at runtime. Compiler does not force handling.
    ➤ Subclasses of RuntimeException.
    ➤ Examples: NullPointerException, ArithmeticException, ArrayIndexOutOfBoundsException.

⚡ Common Interview Follow-up:
👉 “Can we catch Error in Java?”
✔️ Answer: Yes, Error is a subclass of Throwable, so we can catch it in the same way we catch Exception.


❓Difference between throw and throws keywords in Java
Difference between throw and throws in Java

Aspect                 throw                                  throws
-----------------------------------------------------------------------------------------
Definition             Used to explicitly throw an            Used in method declaration 
                       exception object.                      to declare exceptions.

Usage Place            Inside a method or block.              In method signature.

Number of Exceptions   Can throw only one exception           Can declare multiple 
                       at a time.                             exceptions separated by commas.

Execution Time         Actually throws the exception          Just declares that the method 
                       object at runtime.                     might throw exceptions.

Checked/Unchecked      Can throw both checked and             Generally used for checked 
                       unchecked exceptions.                  exceptions.

Syntax                 throw new ExceptionType("msg");        returnType methodName() 
                                                              throws Exception1, Exception2

Example                void demo() {                          void readFile() throws IOException {
                       throw new ArithmeticException(); }     FileReader fr = new FileReader("abc.txt"); }

✅ Example with Both
import java.io.*;

class ThrowThrowsDemo {

    // using throws
    void readFile() throws IOException {
        FileReader fr = new FileReader("abc.txt"); // may throw IOException
    }

    // using throw
    void divide() {
        throw new ArithmeticException("Divide by zero not allowed!");
    }

    public static void main(String[] args) {
        ThrowThrowsDemo obj = new ThrowThrowsDemo();

        try {
            obj.readFile();
        } catch (IOException e) {
            System.out.println("Handled IOException: " + e);
        }

        obj.divide(); // will throw ArithmeticException
    }
}


❓What is serialization and deserialization in Java?
✔️ Answer:
Serialization is the process of converting an object into a byte stream so that it can be saved to a file, sent over a network, or stored in a database.

Key Points:
    ➤ Implemented using java.io.Serializable interface (marker interface).
    ➤ Translates object → byte stream.
    ➤ ObjectOutputStream is used to perform serialization.

⚡Code Example:
import java.io.*;

class Student implements Serializable {
    int id;
    String name;

    Student(int id, String name) {
        this.id = id;
        this.name = name;
    }
}

public class SerializationDemo {
    public static void main(String[] args) throws Exception {
        Student s = new Student(1, "Ankur");

        FileOutputStream fos = new FileOutputStream("student.txt");
        ObjectOutputStream oos = new ObjectOutputStream(fos);

        oos.writeObject(s); // Serialization
        oos.close();
        System.out.println("Object Serialized");
    }
}

Deserialization is the reverse process of serialization where the byte stream is converted back into the original object.

Key Points:
    ➤ Performed using ObjectInputStream.
    ➤ Object is restored with its state.

⚡Code Example:
import java.io.*;

public class DeserializationDemo {
    public static void main(String[] args) throws Exception {
        FileInputStream fis = new FileInputStream("student.txt");
        ObjectInputStream ois = new ObjectInputStream(fis);

        Student s = (Student) ois.readObject(); // Deserialization
        ois.close();

        System.out.println("Object Deserialized: " + s.id + " " + s.name);
    }
}

⚡Key Points:
✔️ Transient keyword: Used to skip some fields from serialization.
✔️ Static fields: Not serialized because they belong to class, not object.
✔️ serialVersionUID:
    ➤ Unique ID used during deserialization to verify sender and receiver are compatible.
    ➤ If not declared explicitly, JVM generates one.
    ➤ Best practice: always declare private static final long serialVersionUID = 1L;.


❓Use of super and this keywords in Java
✔️ Answer:
📝Use of this Keyword in Java
Refers to the current object of the class.

🔄 Uses:
    ➤ To differentiate instance variables from local variables (when same name).
    ➤ To invoke current class methods.
    ➤ To call one constructor from another in the same class (this() → constructor chaining).
    ➤ To return current class object.

⚡Code Example:
class Student {
    int id;
    String name;

    Student(int id, String name) {
        this.id = id;       // differentiate instance and local
        this.name = name;
    }

    void print() {
        System.out.println(this.name); // current object reference
    }
}

📝 Use of super keyword in Java
Refers to the immediate parent class object.

🔄 Uses:
    ➤ To access parent class variables (when hidden by child class variables).
    ➤ To invoke parent class methods (when overridden).
    ➤ To invoke parent class constructor (super() → must be first statement in constructor).

⚡Code Example:
class Person {
    String name = "Parent";

    void display() {
        System.out.println("Person Display");
    }
}

class Student extends Person {
    String name = "Child";

    Student() {
        super(); // call parent constructor
    }

    void display() {
        super.display(); // call parent method
        System.out.println(super.name); // access parent variable
    }
}

