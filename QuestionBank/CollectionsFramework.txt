â“ Internal Working of HashMap in Java
â¤ HashMap = key-value data structure based on hashing.
â¤ Stores entries in buckets using an array of nodes (Node<K,V>).
â¤ Each Node stores:

static class Node<K,V> implements Map.Entry<K,V> {
    final int hash;
    final K key;
    V value;
    Node<K,V> next; // for handling collisions (linked list / tree)
}

ğŸ”¹ 2. Steps of put(K key, V value)
âš¡ Compute Ha
    âœ”ï¸ HashMap calls hashCode() of key â†’ integer has
    âœ”ï¸ Then applies hash function ((hash) ^ (hash >>> 16)) to spread bits â†’ reduces collisions.

âš¡ Find Bucket Inde
    âœ”ï¸ Index = (n - 1) & hash where n = table size (power of 2)
    âœ”ï¸ Example: Table size = 16 â†’ index between 0â€“15.

âš¡ Insert Entry
    âœ”ï¸ If bucket empty â†’ new node stored.
    âœ”ï¸ If bucket occupied â†’ collision handled:
        ğŸ”— Java 7 â†’ Linked List.
        ğŸ”— Java 8+ â†’ If >8 entries in same bucket & table size >= 64 â†’ bucket becomes Balanced Tree (Red-Black Tree) for faster O(log n) lookup.

âš¡ Check Duplicates
If same key exists (checked using equals()), old value is replaced.

âš¡ Rehashing / Resize
    âœ”ï¸ HashMap default capacity = 16, load factor = 0.75.
    âœ”ï¸ If size exceeds capacity Ã— loadFactor â†’ table doubles in size, and entries are rehashed.

ğŸ”¹ 3. Steps of get(K key)
â¤ Compute hash of key.
â¤ Find bucket index.
â¤ Traverse bucket:
    âœ”ï¸ If only one node â†’ return value.
    âœ”ï¸ If multiple â†’ check equals() to match correct key.
    âœ”ï¸ If tree bucket â†’ search in Red-Black Tree.

ğŸ”¹ 4. Collision Handling
â¤ Hash collisions occur when two keys map to same bucket index.
â¤ Handled via:
    âœ”ï¸ Linked List (Chaining) â†’ nodes linked in list.
    âœ”ï¸ Tree (Java 8+) â†’ if list too long â†’ converted to balanced tree.

ğŸ”¹ 5. Important Features
âš¡ Time Complexity:
    âœ”ï¸ Average â†’ O(1) (constant time for put/get).
    âœ”ï¸ Worst â†’ O(log n) (tree) or O(n) (linked list).

âš¡ Null keys/values:
    âœ”ï¸ Allows 1 null key and multiple null values.

âš¡ Thread-safety:
    âœ”ï¸ Not synchronized â†’ use ConcurrentHashMap for thread-safe operations.

âœ… 6. Example Walkthrough
import java.util.*;

public class Demo {
    public static void main(String[] args) {
        HashMap<String, Integer> map = new HashMap<>();
        
        map.put("A", 1);  // hash("A") â†’ index â†’ store
        map.put("B", 2);  // hash("B") â†’ different index
        map.put("C", 3);  // hash("C") â†’ may collide with "A" â†’ linked list/tree
       
        System.out.println(map.get("B")); // Recomputes index, finds value = 2
    }
}

ğŸ”¹ 7. One-Liner for Quick Revision
ğŸ‘‰ HashMap = Array of buckets + Linked List / Tree for collisions, uses hashCode() + equals() to store & retrieve key-value pairs efficiently.

ğŸ”¹ 8. Interview Insights & Common Traps
ğŸ§  Q: â€œWhat if two keys have same hashCode() but different equals()?â€
They go to same bucket, then resolved via equals().
ğŸ§  Q: â€œWhat if two keys have same hashCode() and same equals()?â€
Considered same key â†’ value is replaced.
ğŸ§  Q: â€œWhy default load factor is 0.75?â€
Good tradeoff between time (collisions) and space (memory).
ğŸ§  Q: â€œWhy power of 2 size for table?â€
(n-1) & hash works faster than % operator, improves performance.
ğŸ§  Q: â€œWhy use both hashCode() and equals()?â€
hashCode() â†’ narrow down bucket.
equals() â†’ confirm exact key match.

â“What is String.intern() in Java?
â¤ intern() is a method of the String class (public String intern()).
â¤ It ensures that all identical string literals share the same reference â¤ from the String Pool (a special memory area in the heap).
â¤ When you call s.intern(), JVM:
    âœ”ï¸ Checks if the string already exists in the String Pool.
    âœ”ï¸ If yes â†’ returns the reference from the pool.
    âœ”ï¸ If no â†’ adds the string to the pool and then returns the pooled reference.

âœ… Example
public class InternDemo {
    public static void main(String[] args) {
        String s1 = new String("hello");   // stored in heap (outside pool)
        String s2 = "hello";              // stored in String pool

        System.out.println(s1 == s2);     // false (different references)

        String s3 = s1.intern();          // moves "hello" to pool
        System.out.println(s3 == s2);     // true (same reference from pool)
    }
}

ğŸ”¹ Key Points
â¤ Without intern: new String("abc") â†’ creates a new object in heap, even if "abc" already exists in the pool.
â¤ With intern: It ensures "abc" is taken from the pool (no duplicates).
â¤ Helps in memory optimization (all identical string literals share one instance).
â¤ Mostly useful when you have many duplicate strings (like parsing XML/JSON, DB rows, etc.).

ğŸ”¸ Interview Insights
â¤ intern() is about reference equality (==), not content equality.
â¤ String literals are automatically interned by the compiler.
â¤ intern() is explicit, used for dynamically created strings.
â¤ Overusing intern() may increase String Pool size â†’ can cause memory overhead in very large applications.


â“What is Collection?
A Collection in Java is a framework that provides classes and interfaces to store, manipulate, and retrieve groups of objects efficiently.

Instead of writing data structures (like arrays, linked lists, stacks, queues) manually, Java provides them as ready-made implementations in the Collections Framework (java.util package).

Hierarchy
â¤ Collection Framework = Interfaces + Implementations + Algorithms
â¤ Interfaces (contract) â†’ Collection, List, Set, Queue, Map (Map is separate but part of framework).
â¤ Classes (implementations) â†’ ArrayList, HashSet, LinkedList, PriorityQueue, HashMap, etc.
â¤ Algorithms â†’ Utility methods in Collections class (sort(), binarySearch(), shuffle(), etc.).

Key Features of Collection Framework
âœ”ï¸ Dynamic size â†’ Unlike arrays, collections can grow/shrink dynamically.
âœ”ï¸ Built-in Data Structures â†’ List, Set, Queue, Map implementations ready to use.
âœ”ï¸ Polymorphic Algorithms â†’ Sorting, searching, etc., are already implemented.
âœ”ï¸ Reduces Coding Effort â†’ No need to manually implement DS logic.
âœ”ï¸ Consistency â†’ All classes follow a unified architecture.


â“Difference between List and Map?
| Feature           |                               List                                        |                  Map
| Definition        | Ordered collection of elements (values).                                  | Collection of keyâ€“value pairs.                                       |
| Interface         | `List` (extends `Collection`).                                            | `Map` (separate from `Collection`).                                  |
| Storage           | Stores only values.                                                       | Stores keys and values together.                                     |
| Order             | Maintains **insertion order (index-based).                                | No guaranteed order (except `LinkedHashMap` / `TreeMap`).            |
| Indexing / Access | Access elements by index (e.g., `list.get(0)`).                           | Access values by key (e.g., `map.get(key)`).                         |
| Duplicates        | Allows duplicate elements.                                                | Keys must be unique, values can be duplicate.                        |
| Null Handling     | Allows multiple `null` values, one `null` element.                        | Allows one null key (in HashMap) and multiple null values.           |
| Use Case          | When you need an ordered list of items (like shopping cart).              | When you need lookup by key (like dictionary, ID â†’ StudentName).     |
| Example Classes   | `ArrayList`, `LinkedList`, `Vector`                                       | `HashMap`, `LinkedHashMap`, `TreeMap`, `Hashtable`                   |

List is an ordered collection of elements (allows duplicates, accessed by index), while Map is a collection of keyâ€“value pairs (keys unique, values accessed by key).

â“Difference between ArrayList and LinkedList?
| Feature                   |      ArrayList                                              |                   LinkedList                                                |
| Underlying Data Structure | Dynamic array.                                              | Doubly linked list.                                                         |
| Access (get/set by index) | Fast (O(1)) â†’ direct index-based access.                    | Slow (O(n)) â†’ traversal needed from head/tail.                              |
| Insertion / Deletion      | Slow (O(n)) â†’ shifting required if not at the end.          | Fast (O(1)) if adding/removing from start/middle (just pointer change).     |
| Memory Usage              | Less memory â†’ only stores values.                           | More memory â†’ stores values + two extra references (prev, next).            |
| Iteration Performance     | Better cache locality â†’ generally faster iteration.         | Slower iteration due to scattered memory locations.                         |
| When to Use               | When frequent access/read operations.                       | When frequent insert/delete operations (especially in middle).              |
| Null Handling             | Allows multiple `null` values.                              | Allows multiple `null` values.                                              |
| Thread-Safety             | Not synchronized (use `Collections.synchronizedList()`   ). | Not synchronized (same handling needed).                                    |
| Example Use Cases         | Lookup-heavy apps, reading config data.                     | Real-time queues, frequently modified lists.                                |

â¤ ArrayList is better for searching/access, LinkedList is better for insertion/deletion.
â¤ ArrayList uses dynamic arrays, LinkedList uses doubly linked nodes.


â“Difference between List and Set?
Feature                                 List                                                                Set
----------------------------------------------------------------------------------------------------------------
Order                                   Maintains insertion order                               Does not guarantee order
                                                                                                (LinkedHashSet keeps insertion order,
                                                                                                TreeSet keeps sorted order)

Duplicates                              Allows duplicates                                        Does not allow duplicates

Indexing                                Supports index-based access                              No indexing (access via iterator)
                                        (get(int index))                   

Null Values                             Can have multiple nulls                                  Allows only one null (HashSet, LinkedHashSet)
                                                                                                 TreeSet does not allow null

Common Implementations                  ArrayList, LinkedList, Vector                             HashSet, LinkedHashSet, TreeSet

Performance                             ArrayList â†’ O(1) get (random)                            HashSet â†’ O(1) add/search
                                        LinkedList â†’ O(n) get                                    TreeSet â†’ O(log n) add/search (sorted)

Use Cases                               When order & duplicates matter                            When uniqueness is required
                                        (e.g., shopping cart, marks)                              (e.g., user IDs, emails)

Example Classes                         ArrayList, LinkedList, Vector                             HashSet, LinkedHashSet, TreeSet


â“Difference between Arrays and ArrayList?
Feature                 Arrays                              ArrayList
-----------------------------------------------------------------------------------
Size                    Fixed (cannot be changed once set)  Dynamic (can grow/shrink at runtime)

Storage Type            Stores both primitives and objects  Stores only objects (wrapper classes
                                                            for primitives, e.g., Integer for int)

Performance             Faster (less overhead)              Slightly slower (due to dynamic resizing)

Memory Usage            Less memory (continuous allocation) More memory (stores extra info)

Length/Size Access      length (property)                   size() (method)

Type Safety             Can be multi-dimensional            Single dimensional (for multi-dim,
                                                            use List of Lists)

Generics                Not supported directly              Supports Generics (e.g., ArrayList<String>)

Iteration               for loop, for-each loop             for loop, for-each loop, Iterator

Utility Methods         No built-in methods (manual ops)    Rich methods (add, remove, contains, etc.)

Use Cases               When size is fixed and performance  When size is dynamic and need
                        is critical                         collection methods

â¤ Array is fixed-size and can store primitives, ArrayList is dynamic and only stores objects.
â¤ Use Array when performance and memory are key; use ArrayList when flexibility is needed.


â“Difference between Vector and ArrayList?
Feature                 Vector                             ArrayList
-----------------------------------------------------------------------------------
Thread-Safety           Synchronized (thread-safe)          Not synchronized (not thread-safe)

Performance             Slower (due to synchronization)     Faster (no synchronization overhead)

Default Capacity        10 elements                         10 elements

Growth Rate             Doubles its size when full          Increases by 50% of current size when full

Legacy Status           Legacy class (from JDK 1.0)         Part of Collections Framework (from JDK 1.2)

Traversal               Supports Iterator + Enumeration     Supports Iterator only

Use Cases               When thread safety is required       When single-threaded & performance is key

â¤ Vector is synchronized and legacy, ArrayList is unsynchronized and modern.
â¤ ArrayList is preferred unless thread safety is explicitly needed.


âš¡Follow-up trap questions:
ğŸ‘‰ â€œIf ArrayList is not synchronized, how can you make it thread-safe?â€
Answer:
â¤ Use Collections.synchronizedList(new ArrayList<>())
â¤ Or use CopyOnWriteArrayList from java.util.concurrent


â“Difference between Vector and Queue?
Feature                 Vector                             Queue
-----------------------------------------------------------------------------------
Definition              Legacy class in Java that           Interface in Java representing
                        implements List, grows              FIFO (First In First Out) data structure
                        dynamically

Underlying DS           Dynamic array                       Varies by implementation:
                                                            LinkedList, PriorityQueue, ArrayDeque

Order                   Maintains insertion order           Follows FIFO (some impl. like PriorityQueue
                                                            use priority-based ordering)

Thread-Safety           Synchronized (thread-safe)          Not synchronized (must use
                                                            ConcurrentLinkedQueue for thread-safety)

Duplicates              Allows duplicates                   Allows duplicates

Access Type             Random access via index (get/set)   No index access, only head/tail operations
                                                            (offer, poll, peek)

Traversal               Iterator + Enumeration              Iterator

Performance             Slower (sync overhead,              Generally faster (non-sync), optimized for
                        resizing cost)                      add/remove at ends

Use Cases               When dynamic array with             For scheduling, task processing,
                        thread-safety is needed             producer-consumer, queuing systems

â¤ Vector is a legacy synchronized List, Queue is a FIFO interface for element processing.
â¤ Vector supports random access by index, Queue works with head/tail operations.

âš¡Follow-up trap questions:
ğŸ‘‰ â€œIf Vector is synchronized and Queue is not, how can we make Queue thread-safe?â€
Answer: Use ConcurrentLinkedQueue or wrap with Collections.synchronizedCollection().


â“Difference between hashset and LinkedHashSet?
Feature                 HashSet                           LinkedHashSet
-----------------------------------------------------------------------------------
Order                   Does not maintain order             Maintains insertion order

Underlying DS           Hash table                         Hash table + Doubly Linked List

Performance             Faster (slightly better             Slightly slower due to maintaining
                        since no ordering)                  insertion order

Duplicates              Not allowed                        Not allowed

Null Values             Allows only one null               Allows only one null

Iteration Order         Unpredictable                      Predictable (in insertion order)

Use Cases               When order of elements              When you need both uniqueness
                        does not matter                     and predictable iteration order

â¤ HashSet is unordered, LinkedHashSet maintains insertion order.
â¤ Both prevent duplicates, but LinkedHashSet is order-preserving.


â“Difference between HashMap and HashTable?
Feature                 HashMap                           Hashtable
-----------------------------------------------------------------------------------
Thread-Safety           Not synchronized (not thread-safe) Synchronized (thread-safe)

Performance             Faster (no sync overhead)          Slower (sync overhead)

Null Keys/Values        Allows one null key and            Does not allow null key,
                        multiple null values               does not allow null values

Introduced In           JDK 1.2 (part of Collections)      JDK 1.0 (legacy class)

Iteration Order         Unordered, unpredictable           Unordered, unpredictable

Iterator Type           Iterator (fail-fast)               Enumerator + Iterator (fail-fast)

Legacy Status           Modern, preferred choice           Legacy, mostly replaced by ConcurrentHashMap

Use Cases               Best for single-threaded           Rarely used today, sometimes in
                        applications requiring speed       legacy systems with multi-threaded needs

â¤ HashMap is unsynchronized and allows one null key, Hashtable is synchronized and doesnâ€™t allow nulls.
â¤ Hashtable is legacy, HashMap is modern and preferred.

âš¡Follow-up trap questions:
ğŸ‘‰ â€œIf HashMap is not thread-safe, how can you make it thread-safe?â€
Answer:
Use Collections.synchronizedMap(new HashMap<>())
Or use ConcurrentHashMap


â“Difference between HashMap and LinkedHashMap?
Feature                 HashMap                           LinkedHashMap
-----------------------------------------------------------------------------------
Order                   Does not maintain any order        Maintains insertion order
                                                            (or access order if specified)

Underlying DS           Hash table                         Hash table + Doubly Linked List

Iteration Order         Unpredictable                      Predictable (in insertion order)

Performance             Slightly faster (no order          Slightly slower (due to maintaining
                        maintenance overhead)               linked list for order)

Null Keys/Values        Allows one null key and            Allows one null key and
                        multiple null values               multiple null values

Introduced In           JDK 1.2                            JDK 1.4

Use Cases               Best when order does not matter    Best when predictable iteration order
                                                            is required (e.g., caches, LRU)


â¤ HashMap is unordered, LinkedHashMap maintains insertion order.
â¤ LinkedHashMap is slightly slower but useful for predictable iteration and cache design.

âš¡Pro Tip:
ğŸ‘‰ â€œHow would you implement an LRU Cache in Java?
Answer: Using LinkedHashMap with access-order set to true.


â“Difference between Comparable and Comparator?
Feature                 Comparable                        Comparator
-----------------------------------------------------------------------------------
Package                 java.lang                         java.util

Interface Method        compareTo(Object o)               compare(Object o1, Object o2)

Sorting Logic           Defines natural ordering          Defines custom ordering
                        (only one sort sequence)          (multiple sort sequences possible)

Implementation          Class implements Comparable        Separate class implements Comparator

Modification            Sorting logic must be changed      No need to modify original class,
                        inside the class                   can define multiple comparators externally

Usage                   Used when default/natural          Used when we need different ways
                        ordering is required               of sorting a class objects

Null Handling           compareTo() may throw NPE          compare() must handle nulls explicitly

Example (Use Case)      Sorting students by roll number    Sorting students by name, marks, age

â¤ Comparable provides natural order, Comparator provides custom order.
â¤ Comparable is in java.lang, Comparator is in java.util.

âœ… Code Example:
import java.util.*;

// Using Comparable (Natural order: Roll Number)
class Student implements Comparable<Student> {
    int roll;
    String name;

    Student(int roll, String name) {
        this.roll = roll;
        this.name = name;
    }

    @Override
    public int compareTo(Student s) {
        return this.roll - s.roll; // natural order
    }
}

// Using Comparator (Custom order: Name)
class NameComparator implements Comparator<Student> {
    @Override
    public int compare(Student s1, Student s2) {
        return s1.name.compareTo(s2.name);
    }
}

public class CompareDemo {
    public static void main(String[] args) {
        List<Student> list = new ArrayList<>();
        list.add(new Student(3, "Charlie"));
        list.add(new Student(1, "Alice"));
        list.add(new Student(2, "Bob"));

        // Using Comparable (Roll no)
        Collections.sort(list);
        System.out.println("Sorted by roll (Comparable):");
        list.forEach(s -> System.out.println(s.roll + " " + s.name));

        // Using Comparator (Name)
        Collections.sort(list, new NameComparator());
        System.out.println("\nSorted by name (Comparator):");
        list.forEach(s -> System.out.println(s.roll + " " + s.name));
    }
}

âœ… Output:
Sorted by roll (Comparable):
1 Alice
2 Bob
3 Charlie

Sorted by name (Comparator):
1 Alice
2 Bob
3 Charlie

âš¡Pro Tip: In Java 8+, you can replace Comparator with lambda expressions:
list.sort((s1, s2) -> s1.name.compareTo(s2.name));


â“Difference between Iterator and Iterable?
Feature                 Iterator                          Iterable
-----------------------------------------------------------------------------------
Definition              An object used to iterate          An interface that represents
                        over a collection                  a collection that can be iterated

Package                 java.util                          java.lang

Interface / Class       Interface                         Interface

Key Methods             hasNext(), next(), remove()        iterator() â†’ returns an Iterator

Usage                   Used to traverse elements          Any class implementing Iterable
                        of a collection                    can be used in for-each loop

for-each Support        Cannot be directly used in         Enables use of "for-each" loop
                        for-each loop                      (because it provides iterator())

Multiple Iterators      Represents one iteration           Can return multiple Iterator
                        process only                       objects over the same collection

Example Classes         Obtained from List, Set, Map       Collection framework classes
                        (via iterator() method)            like List, Set, Queue implement Iterable

â¤ Iterable is the root interface for collections that can be iterated, Iterator is used to actually perform the iteration.
â¤ Iterable provides iterator(), Iterator provides traversal methods like hasNext() and next().

âœ… Code Example:
import java.util.*;

public class IteratorVsIterable {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("A");
        list.add("B");
        list.add("C");

        // Iterable example: enables for-each loop
        for (String s : list) {
            System.out.println("For-each: " + s);
        }

        // Iterator example: manual traversal
        Iterator<String> it = list.iterator();
        while (it.hasNext()) {
            System.out.println("Iterator: " + it.next());
        }
    }
}

âœ… Output:
For-each: A
For-each: B
For-each: C
Iterator: A
Iterator: B
Iterator: C


â“Difference between Collection and Collections?
Feature                 Collection                        Collections
-----------------------------------------------------------------------------------
Definition              Root interface of Collection       Utility/helper class with
                        Framework (represents a group      static methods for collection
                        of objects)                        operations

Type                    Interface                         Class (final)

Package                 java.util                         java.util

Contains                Abstract methods (like add,        Only static utility methods
                        remove, size, iterator)            (like sort(), reverse(), min(), max())

Implementation          Extended by List, Set, Queue       Works on objects of
                        interfaces                        Collection classes (List, Set, Map, etc.)

Object Creation         You cannot create object           You cannot create object
                        of Collection (itâ€™s an interface)  of Collections (constructor is private)

Use Cases               Represents group of objects        Provides utility methods to
                                                            operate on collections

â¤ Collection is an interface, Collections is a utility class.
â¤ Collection defines behavior of data structures, Collections provides helper methods like sort, reverse, etc

âœ… Code Example:
import java.util.*;

public class CollectionVsCollections {
    public static void main(String[] args) {
        // Collection example
        Collection<String> collection = new ArrayList<>();
        collection.add("C");
        collection.add("A");
        collection.add("B");
        System.out.println("Collection: " + collection);

        // Collections example (utility class)
        List<String> list = new ArrayList<>(collection);
        Collections.sort(list); // sorting using Collections class
        System.out.println("Sorted using Collections: " + list);
    }
}

âœ… Output:
Collection: [C, A, B]
Sorted using Collections: [A, B, C]


â“What is Collision?
Collision occurs when two different keys generate the same hash code
(or are mapped to the same bucket index) in a hash-based data structure
like HashMap or HashSet.

ğŸ§ Why Collisions Happen?
â¤ Hash function converts a key â†’ integer (hash code).
â¤ Then hash % capacity decides the bucket index.
â¤ Different keys may result in the same bucket index.
âœ… Example:
    âœ”ï¸ Suppose a HashMap has 10 buckets.
    âœ”ï¸ Keys "CAT" and "DOG" may produce different hash codes but map to the same bucket (e.g., index 3).
    âœ”ï¸ â†’ This situation is a collision.

ğŸ§  How Java Handles Collisions?
ğŸŒŸ Chaining (Linked List / Tree)
âœ”ï¸ Each bucket stores multiple entries in a linked list (JDK 7 and earlier).
âœ”ï¸ In JDK 8+, if collisions in a bucket exceed a threshold (TREEIFY_THRESHOLD = 8),
the linked list is converted to a balanced Red-Black Tree â†’ improves performance from O(n) to O(log n).

ğŸŒŸ Open Addressing (not used in HashMap, but in general hashing)
âœ”ï¸ Finds another empty slot for the collided entry (like Linear Probing, Quadratic Probing).    

âš¡ Impact of Collision
â¤ Increases lookup time (from O(1) average to O(n) worst case in a bucket).
â¤ Too many collisions â†’ performance degradation.

â¤ Collision occurs when multiple keys are mapped to the same bucket in a hash-based DS.
â¤ Java handles collisions using chaining (LinkedList or Red-Black Tree).


â“How to iterate over a list?
import java.util.*;

public class IterateList {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("A");
        list.add("B");
        list.add("C");

        // 1. Using for loop (index-based)
        for (int i = 0; i < list.size(); i++) {
            System.out.println("For loop: " + list.get(i));
        }

        // 2. Using enhanced for loop
        for (String s : list) {
            System.out.println("For-each: " + s);
        }

        // 3. Using Iterator
        Iterator<String> it = list.iterator();
        while (it.hasNext()) {
            System.out.println("Iterator: " + it.next());
        }

        // 4. Using ListIterator (can go both directions)
        ListIterator<String> lit = list.listIterator();
        while (lit.hasNext()) {
            System.out.println("ListIterator forward: " + lit.next());
        }

        // 5. Using forEach with Lambda (Java 8+)
        list.forEach(s -> System.out.println("Lambda: " + s));

        // 6. Using Stream API (Java 8+)
        list.stream().forEach(s -> System.out.println("Stream: " + s));
    }
}


â“How to iterate over Map?
import java.util.*;

public class IterateMap {
    public static void main(String[] args) {
        Map<Integer, String> map = new HashMap<>();
        map.put(1, "A");
        map.put(2, "B");
        map.put(3, "C");

        // 1. Iterating over keys
        for (Integer key : map.keySet()) {
            System.out.println("Key: " + key + ", Value: " + map.get(key));
        }

        // 2. Iterating over values
        for (String value : map.values()) {
            System.out.println("Value: " + value);
        }

        // 3. Iterating over entrySet
        for (Map.Entry<Integer, String> entry : map.entrySet()) {
            System.out.println("Entry: " + entry.getKey() + " -> " + entry.getValue());
        }

        // 4. Using Iterator with entrySet
        Iterator<Map.Entry<Integer, String>> it = map.entrySet().iterator();
        while (it.hasNext()) {
            Map.Entry<Integer, String> entry = it.next();
            System.out.println("Iterator: " + entry.getKey() + " -> " + entry.getValue());
        }

        // 5. Using forEach with Lambda (Java 8+)
        map.forEach((key, value) -> System.out.println("Lambda: " + key + " -> " + value));

        // 6. Using Stream API (Java 8+)
        map.entrySet().stream().forEach(e ->
                System.out.println("Stream: " + e.getKey() + " -> " + e.getValue()));
    }
}
âš¡Follow-up trap questions:
ğŸ§  Which is the fastest way to iterate a Map?
Answer: â€œIterating via entrySet() is the fastest because it avoids multiple lookups (get() calls).


â“How to add only unique records in ArrayList?
âœ… 1. Using contains() check (simple way)
import java.util.*;

public class UniqueArrayList {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();

        // Adding unique elements
        addUnique(list, "A");
        addUnique(list, "B");
        addUnique(list, "A"); // Duplicate, will not be added

        System.out.println(list); // [A, B]
    }

    public static void addUnique(List<String> list, String element) {
        if (!list.contains(element)) {
            list.add(element);
        }
    }
}
ğŸ‘‰ Downside: contains() is O(n), so performance is poor for large lists.

âœ… 2. Using HashSet along with ArrayList
import java.util.*;

public class UniqueArrayList {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        Set<String> set = new HashSet<>();

        // Adding unique elements
        if (set.add("A")) list.add("A");  // true â†’ added
        if (set.add("B")) list.add("B");  // true â†’ added
        if (set.add("A")) list.add("A");  // false â†’ not added

        System.out.println(list); // [A, B]
    }
}
ğŸ‘‰ This is efficient because HashSet provides O(1) lookup.

âœ… 3. Using Java 8 stream().distinct()
import java.util.*;
import java.util.stream.Collectors;

public class UniqueArrayList {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>(Arrays.asList("A", "B", "A", "C", "B"));

        // Remove duplicates
        List<String> uniqueList = list.stream()
                                      .distinct()
                                      .collect(Collectors.toList());

        System.out.println(uniqueList); // [A, B, C]
    }
}
ğŸ‘‰ Very clean & concise, but creates a new list (not in-place).

âœ… 4. Using LinkedHashSet (Preserves Insertion Order + Unique)
import java.util.*;

public class UniqueArrayList {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>(Arrays.asList("A", "B", "A", "C", "B"));

        // Convert to LinkedHashSet (removes duplicates + keeps order)
        List<String> uniqueList = new ArrayList<>(new LinkedHashSet<>(list));

        System.out.println(uniqueList); // [A, B, C]
    }
}

âš¡ Insights:
â¤ ArrayList itself allows duplicates. To enforce uniqueness, we combine it with Set.
â¤ Best approaches:
    âœ”ï¸ Small data â†’ contains() check.
    âœ”ï¸ Large data â†’ use a HashSet or LinkedHashSet.
    âœ”ï¸ Clean Java 8 code â†’ stream().distinct().


â“What will happen if you don't override the hashCode() and equals() method?
âœ… Default Behavior (from Object class)
â¤ equals() (default in Object) â†’ compares memory reference (i.e., two objects are equal only if they are the same instance).
â¤ hashCode() (default in Object) â†’ generates a hash value based on the objectâ€™s memory address.    

âœ… Consequences if NOT overridden
â¤ Collections like HashMap, HashSet, HashTable wonâ€™t work as expected
    âœ”ï¸ Even if two objects have the same data, theyâ€™ll be treated as different keys or different set elements.
    âœ”ï¸ Because default equals() compares memory references, not object content.
    âœ”ï¸ Default hashCode() will also be different for different objects.

â¤ Duplicates not handled correctly in Sets   
import java.util.*;

class Student {
    int id;
    String name;
    Student(int id, String name) {
        this.id = id; this.name = name;
    }
}

public class Test {
    public static void main(String[] args) {
        Set<Student> set = new HashSet<>();
        set.add(new Student(1, "A"));
        set.add(new Student(1, "A"));

        System.out.println(set.size()); // âŒ Output: 2 (Expected: 1)
    }
}
ğŸ‘‰ Because equals() + hashCode() are not overridden, HashSet treats them as different objects.

â¤ HashMap keys wonâ€™t behave properly
import java.util.*;

class Student {
    int id;
    Student(int id) { this.id = id; }
}

public class Test {
    public static void main(String[] args) {
        Map<Student, String> map = new HashMap<>();
        Student s1 = new Student(1);
        Student s2 = new Student(1);

        map.put(s1, "First");
        map.put(s2, "Second");

        System.out.println(map.size()); // âŒ Output: 2 (Expected: 1)
    }
}
ğŸ‘‰ Without overriding, two logically same students (id=1) are stored as different keys.

âœ… Correct Way â†’ Override Both
class Student {
    int id;
    String name;

    Student(int id, String name) {
        this.id = id; this.name = name;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Student)) return false;
        Student s = (Student) o;
        return this.id == s.id && this.name.equals(s.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, name);
    }
}

â¤ HashSet / HashMap treat logically equal objects as duplicates.
â¤ Correct output for previous examples: set.size() = 1 and map.size() = 1.

âš¡ Follow-up trap question:
ğŸ§  What happens if you override only equals() but not hashCode()?
Answer: â€œHashSet/HashMap may still allow duplicates, because equal objects may return different hash codes and end up in different buckets.


â“How to sort a collection? How many ways to sort a collection?
1. Using Collections.sort() (Natural Order)
    âœ”ï¸ Works on List (like ArrayList, LinkedList).
    âœ”ï¸ Elements must implement Comparable (e.g., String, Integer).

import java.util.*;
public class SortExample1 {
    public static void main(String[] args) {
        List<Integer> list = new ArrayList<>(Arrays.asList(5, 1, 4, 2, 3));

        Collections.sort(list); // Natural ordering (Ascending)
        System.out.println(list); // [1, 2, 3, 4, 5]
    }
}

2. Using Collections.sort() with Comparator (Custom Order)
    âœ”ï¸ Pass a custom Comparator for sorting logic.

import java.util.*;
public class SortExample2 {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>(Arrays.asList("Banana", "Apple", "Cherry"));

        Collections.sort(list, (a, b) -> b.compareTo(a)); // Descending order
        System.out.println(list); // [Cherry, Banana, Apple]
    }
}

3. Using List.sort() (Java 8+)

Cleaner alternative to Collections.sort().
list.sort(Comparator.naturalOrder());      // Ascending
list.sort(Comparator.reverseOrder());      // Descending

4. Using Stream.sorted() (Java 8+)
Sorting while streaming.

list.stream()
    .sorted()
    .forEach(System.out::println); // Ascending

list.stream()
    .sorted(Comparator.reverseOrder())
    .forEach(System.out::println); // Descending

5. Using TreeSet or TreeMap
Automatically sorts elements in natural order (or custom Comparator).

import java.util.*;
public class SortExample5 {
    public static void main(String[] args) {
        Set<String> set = new TreeSet<>(Arrays.asList("Banana", "Apple", "Cherry"));
        System.out.println(set); // [Apple, Banana, Cherry]
    }
}    

6. Sorting Custom Objects (using Comparable or Comparator)

(a) Implement Comparable (Natural Order by class field)

class Student implements Comparable<Student> {
    int id;
    Student(int id) { this.id = id; }

    public int compareTo(Student s) {
        return this.id - s.id; // Ascending by id
    }
}

public class Test {
    public static void main(String[] args) {
        List<Student> list = new ArrayList<>();
        list.add(new Student(3));
        list.add(new Student(1));
        list.add(new Student(2));

        Collections.sort(list);
        list.forEach(s -> System.out.println(s.id)); // 1, 2, 3
    }
}


(b) Use Comparator (Custom Order by class field)
Collections.sort(list, (s1, s2) -> s2.id - s1.id); // Descending by id

âš¡ Ways to Sort a Collection
1. Collections.sort(list)  â†’ Natural order (Comparable)
2. Collections.sort(list, Comparator) â†’ Custom order
3. list.sort(Comparator)   â†’ Java 8+ method
4. Stream API (sorted())   â†’ Java 8+ streams
5. TreeSet / TreeMap       â†’ Sorted collections
6. Comparable / Comparator â†’ Sorting custom objects


â“How to add a collection in another collection particular index?
âœ… Using addAll(int index, Collection c) (List Only)
Works with List (ArrayList, LinkedList), because List supports indexing.

Syntax:
boolean addAll(int index, Collection<? extends E> c)

âœ… Example:
import java.util.*;

public class AddCollectionExample {
    public static void main(String[] args) {
        List<String> list1 = new ArrayList<>(Arrays.asList("A", "B", "C"));
        List<String> list2 = new ArrayList<>(Arrays.asList("X", "Y", "Z"));

        // Insert list2 into list1 at index 1
        list1.addAll(1, list2);

        System.out.println(list1); // [A, X, Y, Z, B, C]
    }
}
ğŸ‘‰ Here, "X", "Y", "Z" from list2 are inserted into list1 starting at index 1.

âœ… Important Notes:
â¤ addAll(int index, c) â†’ Shifts existing elements to the right.
â¤ Works only for List (not for Set/Map because they donâ€™t have index positions).
â¤ Returns true if collection was added.


â“How to compare two collections?
âœ… 1. Using equals() (Exact Match)
Checks if two collections have the same elements in the same order.

import java.util.*;

public class CompareCollections {
    public static void main(String[] args) {
        List<String> list1 = Arrays.asList("A", "B", "C");
        List<String> list2 = Arrays.asList("A", "B", "C");
        List<String> list3 = Arrays.asList("C", "B", "A");

        System.out.println(list1.equals(list2)); // true
        System.out.println(list1.equals(list3)); // false (order different)
    }
}
ğŸ‘‰ Works for List, Set, Map (Map uses equals() on key-value pairs).

âœ… 2. Using containsAll() (Subset / Ignoring Order)
Checks if one collection contains all elements of another.

List<String> list1 = Arrays.asList("A", "B", "C");
List<String> list2 = Arrays.asList("C", "B", "A");

System.out.println(list1.containsAll(list2)); // true
System.out.println(list2.containsAll(list1)); // true


âœ… 3. Using Collections.sort() + equals() (Compare ignoring order)
List<String> list1 = new ArrayList<>(Arrays.asList("A", "C", "B"));
List<String> list2 = new ArrayList<>(Arrays.asList("B", "A", "C"));

Collections.sort(list1);
Collections.sort(list2);

System.out.println(list1.equals(list2)); // true
ğŸ‘‰ Good for comparing Lists ignoring order.

âœ… 4. Using Set (Ignore Order + Remove Duplicates)
List<String> list1 = Arrays.asList("A", "B", "C", "A");
List<String> list2 = Arrays.asList("C", "B", "A");

System.out.println(new HashSet<>(list1).equals(new HashSet<>(list2))); // true
ğŸ‘‰ Ignores order and duplicates.

âœ… 5. Using Collections.disjoint() (Check if they share nothing in common)
List<String> list1 = Arrays.asList("A", "B", "C");
List<String> list2 = Arrays.asList("X", "Y", "Z");

System.out.println(Collections.disjoint(list1, list2)); // true (no common element)

âœ… 6. Using Java 8 Streams
List<String> list1 = Arrays.asList("A", "B", "C");
List<String> list2 = Arrays.asList("C", "B", "A");

boolean isEqual = list1.size() == list2.size() &&
                  list1.containsAll(list2);

System.out.println(isEqual); // true

Method                       Checks
---------------------------------------------------------------
equals()                     Same elements in same order
containsAll()                All elements present (ignores order)
sort + equals()              Same elements ignoring order
Convert to Set                Same unique elements ignoring order
Collections.disjoint()        Check if two collections share nothing
Streams (Java 8)              Custom comparisons

âœ”ï¸ Two collections can be compared using equals() for exact match, containsAll() for subset check, or by converting to Set/sorting for ignoring order. Use Collections.disjoint() to check if they have nothing in common