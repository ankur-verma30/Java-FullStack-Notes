â“ Internal Working of HashMap in Java
â¤ HashMap = key-value data structure based on hashing.
â¤ Stores entries in buckets using an array of nodes (Node<K,V>).
â¤ Each Node stores:

static class Node<K,V> implements Map.Entry<K,V> {
    final int hash;
    final K key;
    V value;
    Node<K,V> next; // for handling collisions (linked list / tree)
}

ğŸ”¹ 2. Steps of put(K key, V value)
âš¡ Compute Ha
    âœ”ï¸ HashMap calls hashCode() of key â†’ integer has
    âœ”ï¸ Then applies hash function ((hash) ^ (hash >>> 16)) to spread bits â†’ reduces collisions.

âš¡ Find Bucket Inde
    âœ”ï¸ Index = (n - 1) & hash where n = table size (power of 2)
    âœ”ï¸ Example: Table size = 16 â†’ index between 0â€“15.

âš¡ Insert Entry
    âœ”ï¸ If bucket empty â†’ new node stored.
    âœ”ï¸ If bucket occupied â†’ collision handled:
        ğŸ”— Java 7 â†’ Linked List.
        ğŸ”— Java 8+ â†’ If >8 entries in same bucket & table size >= 64 â†’ bucket becomes Balanced Tree (Red-Black Tree) for faster O(log n) lookup.

âš¡ Check Duplicates
If same key exists (checked using equals()), old value is replaced.

âš¡ Rehashing / Resize
    âœ”ï¸ HashMap default capacity = 16, load factor = 0.75.
    âœ”ï¸ If size exceeds capacity Ã— loadFactor â†’ table doubles in size, and entries are rehashed.

ğŸ”¹ 3. Steps of get(K key)
â¤ Compute hash of key.
â¤ Find bucket index.
â¤ Traverse bucket:
    âœ”ï¸ If only one node â†’ return value.
    âœ”ï¸ If multiple â†’ check equals() to match correct key.
    âœ”ï¸ If tree bucket â†’ search in Red-Black Tree.

ğŸ”¹ 4. Collision Handling
â¤ Hash collisions occur when two keys map to same bucket index.
â¤ Handled via:
    âœ”ï¸ Linked List (Chaining) â†’ nodes linked in list.
    âœ”ï¸ Tree (Java 8+) â†’ if list too long â†’ converted to balanced tree.

ğŸ”¹ 5. Important Features
âš¡ Time Complexity:
    âœ”ï¸ Average â†’ O(1) (constant time for put/get).
    âœ”ï¸ Worst â†’ O(log n) (tree) or O(n) (linked list).

âš¡ Null keys/values:
    âœ”ï¸ Allows 1 null key and multiple null values.

âš¡ Thread-safety:
    âœ”ï¸ Not synchronized â†’ use ConcurrentHashMap for thread-safe operations.

âœ… 6. Example Walkthrough
import java.util.*;

public class Demo {
    public static void main(String[] args) {
        HashMap<String, Integer> map = new HashMap<>();
        
        map.put("A", 1);  // hash("A") â†’ index â†’ store
        map.put("B", 2);  // hash("B") â†’ different index
        map.put("C", 3);  // hash("C") â†’ may collide with "A" â†’ linked list/tree
       
        System.out.println(map.get("B")); // Recomputes index, finds value = 2
    }
}

ğŸ”¹ 7. One-Liner for Quick Revision
ğŸ‘‰ HashMap = Array of buckets + Linked List / Tree for collisions, uses hashCode() + equals() to store & retrieve key-value pairs efficiently.

ğŸ”¹ 8. Interview Insights & Common Traps
ğŸ§  Q: â€œWhat if two keys have same hashCode() but different equals()?â€
They go to same bucket, then resolved via equals().
ğŸ§  Q: â€œWhat if two keys have same hashCode() and same equals()?â€
Considered same key â†’ value is replaced.
ğŸ§  Q: â€œWhy default load factor is 0.75?â€
Good tradeoff between time (collisions) and space (memory).
ğŸ§  Q: â€œWhy power of 2 size for table?â€
(n-1) & hash works faster than % operator, improves performance.
ğŸ§  Q: â€œWhy use both hashCode() and equals()?â€
hashCode() â†’ narrow down bucket.
equals() â†’ confirm exact key match.

â“What is String.intern() in Java?
â¤ intern() is a method of the String class (public String intern()).
â¤ It ensures that all identical string literals share the same reference â¤ from the String Pool (a special memory area in the heap).
â¤ When you call s.intern(), JVM:
    âœ”ï¸ Checks if the string already exists in the String Pool.
    âœ”ï¸ If yes â†’ returns the reference from the pool.
    âœ”ï¸ If no â†’ adds the string to the pool and then returns the pooled reference.

âœ… Example
public class InternDemo {
    public static void main(String[] args) {
        String s1 = new String("hello");   // stored in heap (outside pool)
        String s2 = "hello";              // stored in String pool

        System.out.println(s1 == s2);     // false (different references)

        String s3 = s1.intern();          // moves "hello" to pool
        System.out.println(s3 == s2);     // true (same reference from pool)
    }
}

ğŸ”¹ Key Points
â¤ Without intern: new String("abc") â†’ creates a new object in heap, even if "abc" already exists in the pool.
â¤ With intern: It ensures "abc" is taken from the pool (no duplicates).
â¤ Helps in memory optimization (all identical string literals share one instance).
â¤ Mostly useful when you have many duplicate strings (like parsing XML/JSON, DB rows, etc.).

ğŸ”¸ Interview Insights
â¤ intern() is about reference equality (==), not content equality.
â¤ String literals are automatically interned by the compiler.
â¤ intern() is explicit, used for dynamically created strings.
â¤ Overusing intern() may increase String Pool size â†’ can cause memory overhead in very large applications.