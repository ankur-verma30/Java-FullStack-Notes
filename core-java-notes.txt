üß† What is OOP in Java?
Object-Oriented Programming (OOP) is a programming paradigm that organizes code using objects, which are instances of classes.
Java is a pure object-oriented language (except for primitive types). To overcome the lack of object orientation in primitives, Java provides Wrapper Classes.
Properties (State) ‚Äì Data/attributes
Methods (Behavior) ‚Äì Functions/actions

üéØ Key Goals of OOPs:
‚û§Code reusability
‚û§Modularity
‚û§Data hiding and security
‚û§Scalability and maintainability

What is a class?
‚û§ A class in Java is a blueprint or template for creating objects.
‚û§ It defines the data (fields/attributes) and the behavior (methods/functions) that the objects created from the class will have.
‚û§ Class helps us to create objects in Java.

Class Naming Convention
#######################
‚û§ In Java, we use the class keyword to create a class, and the class keyword should be in lowercase. The class name should start with an uppercase letter only.
‚û§ If more than one word is used, then we should use camel casing.

Note: Class names cannot start with a number, but they can begin with a dollar sign ($) or an underscore (_), although this is not recommended.

Example :
class A {}
‚û§ We define the boundary of a class using curly brackets.
  
Example :
‚û§ Will execute without any error
public class Bank_Account_Number {}// Snake Casing-->Should not use for Java

Note:
1. Do not use specials characters like #,@ % & etc while creating class.
2. $Class name will execute. However, never create a class with a special character.

Breakdown of PSVM
###################
public static void main(String[] args)
It‚Äôs the starting point of any Java program, and each keyword has a specific purpose.
1Ô∏è‚É£ public
‚û§It's an access modifier.
‚û§Makes the main method accessible by the JVM from outside the class.
‚û§If you make it private, JVM won‚Äôt be able to access it, and the program won‚Äôt run.

2Ô∏è‚É£ static
‚û§Means it belongs to the class, not the object.
‚û§JVM doesn‚Äôt create an object of the class to call main() ‚Äî it just calls it via the class name directly.
‚û§That‚Äôs why it must be static.

3Ô∏è‚É£ void
‚û§Specifies that the method does not return any value.
‚û§You can‚Äôt return anything from main() in standard Java execution.

4Ô∏è‚É£ main
‚û§This is the method name.
‚û§JVM looks specifically for a method with this name as the entry point to start program execution.

5Ô∏è‚É£ String[] args
Represents command-line arguments.
It is an array of Strings, which means you can pass values when running the program:

java MyProgram Hello World
Then args[0] = "Hello", args[1] = "World"  

üî∑ Why Use Command-Line Arguments? (Use Cases)
‚û§ Dynamic input without Scanner or BufferedReader
‚û§ Script automation (e.g., batch processing, config values)
‚û§ File input/output paths
‚û§ Running test cases with different inputs
‚û§ Avoid hardcoding data into programs

üî∑ Real-Time Use Case: Calculator Program

‚úÖ Example: Add two numbers using command-line arguments
public class CommandLineCalculator {
    public static void main(String[] args) {
        if(args.length < 2) {
            System.out.println("Please provide two numbers.");
            return;
        }

        // Convert strings to integers
        int num1 = Integer.parseInt(args[0]);
        int num2 = Integer.parseInt(args[1]);

        int sum = num1 + num2;
        System.out.println("Sum = " + sum);
    }
}

üî∑ How to Run This Program?
Step 1: Compile
javac CommandLineCalculator.java

Step 2: Run with arguments
java CommandLineCalculator 10 20

Output:
Sum = 30

üî∑ Interview Trap ‚ùó
Q: Can we pass primitive values as command-line arguments?
A: No, command-line arguments are always String types. You need to manually parse them using Integer.parseInt(), Double.parseDouble(), etc.

üîÅ JVM Looks for This Exact Signature:
public static void main(String[] args)
‚ö†Ô∏è If the signature is different (e.g., not public, not static, or missing parameters), the program will compile but not run, and you‚Äôll get a "Main method not found" error.

new keyword:
##############
The new keyword in Java is used to create objects (instances) of a class. 
‚û§ Using the new keyword, we send a request to the class to create an object
Once the object is created, the new keyword will retrieve the object's address and store it in a reference variable.

Syntax to create an object:
ClassName variableName = new ClassName();

Two types of camel casing:
‚û§ UpperCase Camel Casing: Used for naming class, interface, abstract class, etc
‚û§ lowerCase Camel Casing: Used for creating methods, variables, etc

Non-static Variable/ Instance Variable /Object Variables
#########################################################
It is a variable declared inside a class, but outside any method, and without the static keyword.
üìå It belongs to:
‚û§ An instance of the class (not the class itself)
‚û§ Every object has its copy
‚û§ Without creating an object, we cannot access non-static variables.

Example :
public class A {
	int x = 10;
	int y = 20;
 	int z;
	public static void main(String[] args) {
		A a1 = new A();
		System.out.println(a1.x); // Output :10
		System.out.println(a1.y); // Output :20

    		A a2 = new A();
		System.out.println(a2.x); // Output :10
    		System.out.println(a2.z); // Output :0 //default value of int is 0
	}
}
‚û§ Every time we create an object non-static variable copy is loaded into that object.
‚û§ A copy of the variable in this object is different. That is, if you change the value of a variable in one object, those changes cannot be seen in another object.
‚û§ It is not mandatory to initialize a non-static variable. Depending on the data type, the default value will be automatically stored in it.

Static variables:
#################
A static variable is a class-level variable, meaning:
‚û§ It belongs to the class, not the object.
‚û§ It is shared among all instances of the class.
‚û§ Only one copy exists in memory, regardless of how many objects are created.

1. We should create static variables inside a class but outside a method with the static keyword
2. To access a static variable, we will use the following options:
a. üîßClassName.variableName
public class Main {
    static int x = 10;
    public static void main(String[] args) {
        System.out.println(Main.x);  // ‚úÖ Recommended Output: 10
    }
}

b. Accessing via variableName directly (With Constraints)
class A {
    static int x = 10;
    void show() {
        System.out.println(x); 
    }
}
You can directly use x without the class name only when:
‚û§You're inside the same class where the static variable is declared.
‚û§OR the static variable is imported statically (in some special cases).

This is allowed because the compiler understands the scope.

‚ùó Constraints:
‚û§This only works within the same class unless,
‚û§You use import static (less common).

üìå Example Without import static:
public class MyClass {
    public static int count = 42;
}

public class Test {
    public static void main(String[] args) {
        System.out.println(MyClass.count); // üëà Must use class name
    }
}

üìå Example with import static:
import static java.lang.Math.*;

public class Demo {
    public static void main(String[] args) {
        System.out.println(sqrt(16)); // instead of Math.sqrt(16)
        System.out.println(PI);       // instead of Math.PI
    }
}

Outside the class, you need to use either:
‚û§ClassName.x (best), or
‚û§object.x (works but discouraged).

c. objectAddress.variableName (Wrong Approach, but will work)
‚û§This works because the object refers to the class, and the static variable belongs to the class.
‚û§When you do a1.x, Java still resolves it as A.x internally.
‚û§But it's misleading because it looks like x is instance-specific when it's shared across all instances.

üîÅ Bonus Tip:
A a1 = null;
System.out.println(a1.x); // Still works!

‚úÖExample:
public class A {
	static int x=10 ;
	public static void main(String[] args) {
		System.out.println(A.x);// Output :10
		System.out.println(x);// Output :10
    
		//Wrong
		A a1 = new A();
		System.out.println(a1.x);//A.x, but will give the Output:10
                A.x = 30;
		System.out.println(A.x); //Ouput :30 
  }
}

Types of variables in Java
############################
1. Local Variable
‚û§ Local variables should be created inside methods
‚û§ We should use local variables within the created method only
‚û§ Without initialization, if you are using a local variable, you will get an error.
  
‚úÖExample:
public class A {
	static int y=10;
	public static void main(String[] args) {
		int x = 100;
		System.out.println(x);
    		System.out.println(A.y);// Output :10
		A a1 = new A();
         	a1.test();
    		System.out.println(y);//Output: 10
	}
	public void test() {
        int z=100;
	System.out.println(x);//Error because it is not present in this method
        System.out.println(z); //Correct
        System.out.println(A.y);//Correct because y is a static variable
	}
}

‚úÖ Interview question based on Local Variable
public class Test {
    public static void main(String[] args) {
        int x = 100;
        {
            int x = 200;
            System.out.println(x);
        }
    }
}

‚û§The code will give a compile-time error, but not because of creating a new scope ‚Äî that is allowed in Java.
The actual issue is:
‚û§You are declaring two local variables with the same name, x, in overlapping scopes.
‚û§Even though you're trying to redeclare int x = 200; in an inner block, Java does not allow hiding a local variable in an inner block with the same name.

Also:
Each method has its stack frame, and local variables are stored there, so naming conflicts like this are not allowed even in nested blocks.

2. Static variable
üìå Where are static variables stored in Java?
‚û§ In Java, memory is divided into different areas managed by the JVM (Java Virtual Machine):
‚û§ Heap ‚Üí For objects.
‚û§ Stack ‚Üí For local variables and method calls.
‚û§ Method Area / Metaspace (Java 8+) ‚Üí For class-level data like:
	‚úîÔ∏è Class metadata (name, methods, fields)
	‚úîÔ∏è Static variables
	‚úîÔ∏è Constant pool
‚û§ PC Register ‚Üí Keeps track of execution in threads.
‚û§ Native Method Stack ‚Üí For native (C/C++) calls.

3. Non-static variable/instance variable

4. Reference Variable
A reference variable in Java is a variable that stores the memory address (reference) of an object, not the actual object itself.
a. Can hold either an Object address or a null value.
b. The datatype of the reference variable is the class. 

In the example below, "a1" is created inside main, hence it is a local variable. We cannot access that outside the main method
If we do not initialize a static reference variable, then by default null value will be stored in it.
‚úÖExample : 
public class A {
	static A a4;  //null
	public static void main(String[] args) {
		A a1 = null;
		A a2 = new A();
    		A a3; // Reference Local Variable
    		System.out.println(a3);// Error because "a3" is local variable and not initialized   
	}
  	public void test() {
		System.out.println(a1);//Error
	}
}

üß± Stack Memory ‚Äì LIFO (Last In First Out)
Stores:
‚û§ Method calls,
‚û§ local variables,
‚û§ reference variables (not actual objects).

‚û§ Memory is automatically managed (pushed and popped as methods are called or returned).
‚û§ Operates in LIFO (Last-In, First-Out) order, where the last is the first one to return.
‚û§ Faster but limited in size.

üß† Example:
When a method is called, its variables go on the stack. When it returns, they‚Äôre removed.

üóÉÔ∏è Heap Memory
################
‚û§Used to store objects/instance variables.
‚û§Every time you do new ClassName(), it creates an object in the heap.
‚û§Objects stay in memory until they're no longer referenced.

üìç Note: All reference variables (in the stack) point to objects in the heap.

üß† What is Garbage Collection in Java?
Garbage Collection is a process by which the Java Virtual Machine (JVM) automatically removes unused objects (objects that are no longer reachable) from memory to free up space and avoid memory leaks.

Java developers don‚Äôt manually free memory (unlike in C/C++). Instead, the Garbage Collector (GC) handles it.

üß© Key Goals of GC:
‚û§ Reclaim memory used by unreachable objects
‚û§ Prevent memory leaks
‚û§ Keep the heap memory clean and efficient

üîÑ When Does GC Run?
‚û§ GC runs automatically in the background.
‚û§ It is non-deterministic ‚Äî you can't predict exactly when it will run.
‚û§ You can suggest GC using System.gc(), but the JVM may ignore it.
‚û§ Only Heap memory is subject to GC.

üîç Object Lifecycle in Java
1. The object is created using new
2. The reference variable holds the object
3. Once the reference is lost or goes out of scope, the object becomes unreachable
4. JVM marks it as garbage
5. GC reclaims that memory

Methods in Java
###############
1. void keyword: A void method cannot return any value

Example :
----------
public class C {
	public static void main(String[] args) {
		C c1 = new C();
		int x = c1.test1(); //Error
    		int y= c1.test2();
		System.out.println(y);// Output :100
	}
	public void test1() {
		return 100;//Error
 	 }
	public int test2() {
		return 100;
  	}
}

Return without value vs Return value in Java
#############################################
The difference between return and return value lies in what you're returning and why.

return without value keyword:
‚û§ A method has to be void
‚û§ It is optional
‚û§ It will return control to the method calling statement

Note: If we write code after the return keyword, then that code will 100% not run. This error is called an unreachable code error

Example:
public class C {
	public static void main(String[] args) {
	  C c1 = new C();
	  c1.test();
	}	
	public void test() {
	      System.out.println(100);
	      return;
	      System.out.println(200);
	}
}
Output: unreachable code error

Returning "value"
-----------------
‚û§ The method has to be non-void.
‚û§ It is mandatory to use a return "value" statement inside a non-void method
‚û§ It will return control and value to the method calling statement

public class C {
	public static void main(String[] args) {}
	public int test1() {}// Error
  	public int test2() {
		return 100; 
		System.out.println(300);// Unreachable code error
	}
}

Method Arguments
##################
‚û§ Using method arguments, we supply values to the method when we call it
‚û§ The method argument is a local variable
‚û§ Arguments inside the method values that you supply to the method should match

Example:
public class C {
	public static void main(String[] args) {
	 C c1 = new C();
    	 C c2 = new C();
	 c1.test1(100);
    	 c2.test2(100,"mike");
	}
	public void test1(int x) {
	  System.out.println(x);
	}
  public void test2(int x,String y) {
	  System.out.println(x);
	}
}

Note: When the method argument type is Object, then we can supply any value to it.

Example
public class C {
	public static void main(String[] args) {
	  C c1 = new C();
	  c1.test('a');
	}
	public void test(Object x) {
	   System.out.println(x);
	}
}

Using Varargs (Variable Arguments)
##################################

Example:
public class C {
	public static void main(String[] args) {
	  C c1 = new C();
	  c1.test("mike",100,200,300);
	}
	public void test(String y,int... x) { 
		System.out.println(x[0]);// Output :100
		System.out.println(x[1]);// Output :200
		System.out.println(x[2]);// Output :300
		System.out.println(y);// Output :mike
	}
}

Static Methods in Java
######################
A static method belongs to the class, not to instances (objects) of the class.
This means you can call a static method without creating an object of that class.
public class C {
	public static void main(String[] args) {
	    C.test1();// Output :599
    	    int x =  C.test2();
	    System.out.println(x);// Output :100  
	}
	public static void test1() {
		System.out.println(599);
	}
 	public static int test2() {
		return 100;
	}
}  

Java Data Types 
################
Java data types are divided into 2 main categories:

üîπ 1. Primitive Data Types (8 types)
Built-in, fixed-size types that store actual values directly.

üî∏ Integer Types (for whole numbers)
Type	       Size     	Default Value	      Range
byte	       1 byte	            0	              -128 to 127
short	       2 bytes	   	    0	              -32,768 to 32,767
int	       4 bytes	            0	              -2,147,483,648 to 2,147,483,647
long           8 bytes	            0	              -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807

üî∏ Floating Point Types (for decimals)
Type	    Size	      Default Value	        Range
float	    4 bytes	      0.0f	              ¬±3.40282347E+38F (single-precision)
double	    8 bytes	      0.0d	              ¬±1.79769313486231570E+308 (double-precision)

Find the size of the datatype
#########################
Example:
public class Main {
    public static void main(String[] args) {
        System.out.println("Size of int in bytes: " + Integer.BYTES);//4 INTEGER is a wrapper class of int (discussed later)
        System.out.println("Size of int in bits: " + Integer.SIZE);//32
    }
}

üî∏ Other Primitive Types
-----------------------------
Type	    Size	            Default Value	          Description
boolean	    (JVM dependent)	    false                   Only true or false
char	    2 bytes	            ' ' (blank)	            0 to 65,535 (Unicode characters)

üîπ 2. Non-Primitive / Reference Data Types
---------------------------------------------
Type	               Description	                        Default Value
String	        A class (sequence of characters)	          null
Array	        Object that holds multiple values	          null
Custom Classes	User-defined types	                          null

üìå Notes:
String is not a primitive type, but a class in java.lang package.
All reference types default to null.
‚û§Use long literals with L or l: long x = 123456789L;
‚û§Use float literals with F or f: float y = 3.14F;

A new type was introduced in Java version 10
---------------------------------------------
var type
#########
‚û§This was introduced in Java version 10
‚û§It is a dynamic datatype concept. Depending on the value stored inside the variable, the datatype is allocated to it internally.

Example:
public class C {
	public static void main(String[] args) {
		var x1 =100;
		var x2 =100.3;
		var x3 ="mike";
		var x4 =new C();
		System.out.println(x1);
		System.out.println(x2);
		System.out.println(x3);
		System.out.println(x4);
	}
  public var test(var x3) {}//Error
}

Properties and Constraints on the var keyword
--------------------------------------------
‚û§The var type can only be a local variable
‚û§It cannot be a static / non-static variable
‚û§It cannot be a method argument
‚û§It cannot be a method return type

‚úÖ Wrapper Classes
###################
‚û§ Java is object-oriented, but primitive types (int, float, char, etc.) are not objects.
‚û§ To treat them as objects, Java provides Wrapper Classes in the java.lang package.
‚û§ A wrapper class wraps (encloses) a primitive type inside an object.

üîπ List of Primitive Types and Their Wrapper Classes:
| Primitive Type | Wrapper Class |
| -------------- | ------------- |
| byte           | Byte          |
| short          | Short         |
| int            | Integer       |
| long           | Long          |
| float          | Float         |
| double         | Double        |
| char           | Character     |
| boolean        | Boolean       |

üîπ Why Do We Need Wrapper Classes?
‚û§ To store primitives in collections like ArrayList, which accept only objects.
‚û§ For object manipulation (e.g., in multithreading, generics, reflection).
‚û§ Useful in parsing strings into numeric values.
‚û§ Enable the use of utility methods like Integer.parseInt(), Double.compare(), etc.

‚ùì Are wrapper classes immutable?
‚úÖ Yes, all wrapper classes are immutable.

üîπ Key Concepts
1. Boxing (Manual Conversion) Depreciated
Converting primitive ‚Üí object
int a = 10;
Integer i = new Integer(a); // Boxing

2. Unboxing (Manual Conversion)
Converting object ‚Üí primitive
Integer i = new Integer(10);
int a = i.intValue(); // Unboxing

3. Autoboxing- Mostly Used
The compiler automatically converts a primitive ‚Üí wrapper object
int x = 5;
Integer obj = x;  // Autoboxing

4. Auto-unboxing
The compiler automatically converts wrapper ‚Üí primitive
Integer y = 100;
int value = y;  // Auto-unboxing

üîπ Commonly Used Wrapper Class Methods
Integer.parseInt(String) ‚Üí Converts string to int
Double.parseDouble(String) ‚Üí Converts string to double
Character.isDigit(char) ‚Üí Checks if the char is a digit
Boolean.valueOf(String) ‚Üí Converts string to Boolean object

‚úÖ Code Examples
public class WrapperExample1 {
    public static void main(String[] args) {
        int a = 100;
        Integer obj = new Integer(a); // Boxing
        int b = obj.intValue();       // Unboxing
        System.out.println("Boxed: " + obj + ", Unboxed: " + b);
		Integer num = 50;     // Autoboxing
        int val = num + 20;   // Auto-unboxing
        System.out.println("Value: " + val);
    }
}

üî∏ Conceptual Trick Questions
‚ùì What will happen here?
Integer a = 128;
Integer b = 128;
System.out.println(a == b); ‚ùå Output: false compare refrences
System.out.println(a.equals(b)); // true ‚úÖ compare actual values.

üîç What's happening step-by-step
Autoboxing
Integer a = 128;
Integer b = 128;
‚û§ Here, 128 (a primitive int) is automatically boxed into an Integer object by Java.

üîßInteger Cache
‚û§ Java maintains an internal Integer cache for values from -128 to 127.
‚û§ When you assign a value in this range to an Integer, Java reuses the same object from the cache.
‚û§ For values outside this range (like 128), new Integer objects are created.
So here:
a ‚Üí new Integer(128)  
b ‚Üí new Integer(128)  
(two different objects in memory)

üîÑ.equals() üÜö ==
== ‚Üí compares references (memory addresses) for objects.
‚û§ Since a and b are different objects, a == b ‚Üí false.
‚û§ .equals() ‚Üí in the Integer class is overridden to compare the actual int values.
‚û§ Both a and b hold the same value (128), so a.equals(b) ‚Üí true.

üî∏ Deep Understanding
‚ùì Difference between parseInt() and valueOf()?
 parseInt() returns a primitive int
 valueOf() returns an Integer object

‚ùì Can you override methods in wrapper classes?
‚ùå No, they are final classes

‚ùì What is the default value of Integer vs int?
 int ‚Üí 0, Integer ‚Üí null

Constructors in Java
####################
Constructors are special methods used to initialize objects when they are created.

üîπ Basic Rules:
‚û§ The constructor name must match the class name
‚û§ Constructors do not have a return type, not even void
‚û§If you write void before a constructor, it becomes a method, not a constructor

Example 1:
public class C {
	C(){
		System.out.println(100);//will execute successfully Output :100
		return 100;//Error
	}
	public static void main(String[] args) {
		C c1 = new C();
	}	
}

Note: Method, Variable name can be the same as the class name

üîÅ Constructor Overloading in Java
Constructor overloading refers to having more than one constructor in the same class, but with different parameter lists.

‚úÖ Why Use Constructor Overloading?
To create objects with different levels of information or default values, depending on what‚Äôs available.

Example:
public class A {
	A(){//NoofArgs=0
		System.out.println("A");
	}
	A(int x){//NoofArgs=1
		System.out.println(x);
	}
	A(int x,int y){//NoofArgs=2
		System.out.println(x);
		System.out.println(y);
	}
	public static void main(String[] args) {
		A a1 = new A();
		A a2  = new A(100);
		A a3 = new A(200,300);
	}
}

üî∑ This keyword in Java
This keyword in Java is a reference variable that refers to the current object ‚Äî the object whose method or constructor is being executed.

‚úÖ Uses of this Keyword
1. Differentiate Between Instance and Local Variables
When local variable names are the same as instance variables, use this to refer to the instance variable.
Example:
class Student {
    String name;
    Student(String name) {
        this.name = name;  // 'this.name' is the instance variable, 'name' is the parameter
    }
}

2. Call One Constructor from Another (Constructor Chaining)
Use this() to call another constructor within the same class.
Example:
class Student {
    String name;
    int age;
    Student(String name) {
        this(name, 18);  // calls the second constructor
    }
    Student(String name, int age) {
        this.name = name;
        this.age = age;
    }
}

3. Pass the Current Object as an Argument
Example
class Student {
    void display() {
        Helper.printStudent(this);  // pass current object
    }
}
class Helper {
    static void printStudent(Student s) {
        System.out.println("Student object: " + s);
    }
}

4. Return Current Object
Useful in method chaining.

class Person {
    private String name;
    private int age;

    Person setName(String name) {
        this.name = name; // Set name and return current object
        return this;
    }

    Person setAge(int age) {
        this.age = age; // Set age and return current object
        return this;
    }

    public static void main(String[] args) {
        Person p1 = new Person();
        
        // Method chaining in action
        p1.setName("Ankur").setAge(22).show();
    }
}

5. Access Instance Methods and Variables
You can use this to call other instance methods or access fields within the class explicitly.

void print() {
    this.show();  // same as just calling show()
}

void show() {
    System.out.println("Hello");
}

‚û§ This keyword is a special reference variable that holds the current object's address.
Example:
public class A {
	public static void main(String[] args) {
		A a1 = new A();
		System.out.println(a1);
		a1.test();
	}
	public void test() {
		System.out.println(this);
	}
}

‚û§Using this keyword, we can access non-static members of the class
Example:
public class A {
	int x = 10;
	public static void main(String[] args) {
		A a1 = new A();
		System.out.println(a1.x);
		a1.test();
	}
	public void test() {
		System.out.println(this.x);
	}
}

‚û§We cannot use this keyword inside a "static method"
public class A {
	int x=10;
	public static void main(String[] args) {
		A a1 = new A();
		System.out.println(this);//Error
	}
	public static void test() {
		System.out.println(this);// Error
		System.out.println(this.x);// Error 
	}
}

this()- This syntax is used to call the constructor
‚û§ Using this() keyword, we can call a constructor
Example:
public class A {
	A(){
		System.out.println("A");
	}
	A(int x){
		this();
	}
	public static void main(String[] args) {
	   A a1 = new A(100);
	}	
}

‚û§ While calling a constructor using this() keyword, ensure calling is done from another constructor
Example 1:
public class A {
	A(){
		System.out.println("A");
	}
	A(int x){
		this();
	}
	public static void main(String[] args) {
	   A a1 = new A(100);
	}
	public void test() {
		this();//Error, we cannot call the constructor from a method
	}	
}

Example 2:
public class A {
	A(int x){
		System.out.println(x);
	}
	A(){
		this(100);
	}
	public static void main(String[] args) {
	   A a1 = new A();
	}	
}

‚û§ While calling a constructor using this() keyword, ensure it is always the first statement inside another constructor
Example 1:
public class A {
	A(int x){
		System.out.println(x);
	}
	A(){
		System.out.println(200);
		this(100);//Error because it cannot be the second statement while calling the constructor	
	}
	public static void main(String[] args) {
	   A a1 = new A();
	}	
}

Example 2:
public class A {
	int x;//-->0
	A(int x){////Step 4-->x=100
		this.x=x;//Step 5
		System.out.println(this.x);//Step 6===>100
	}
	A(){//Step 2
		this(100);//Step 3
	}
	public static void main(String[] args) {
	   A a1 = new A();//Step 1
	}	
}

‚úÖ Types of Constructor Chaining
‚û§ When we call one constructor from another constructor, it will form a chain-like flow structure. This is called constructor chaining.

üî∏ 1. Within the Same Class ‚Üí Use this().
You can use this() to call another constructor in the same class.
‚úÖ Example:
class Student {
    String name;
    int age;
    Student() {
        this("Unknown", 18);  // calls 2-arg constructor
        System.out.println("Default constructor called");
    }

    Student(String name) {
        this(name, 18);  // calls 2-arg constructor
    }

    Student(String name, int age) {
        this.name = name;
        this.age = age;
        System.out.println("Parameterized constructor called");
    }

    void display() {
        System.out.println("Name: " + name + ", Age: " + age);
    }
}
‚ñ∂Ô∏è Output:
The parameterized constructor called  
The default constructor is called 

üî∏ 2. From Subclass to Superclass ‚Üí Use super()
You can call a constructor from the parent class using super().
‚úÖ Example:
class Person {
    Person() {
        System.out.println("Person constructor");
    }
}

class Student extends Person {
    Student() {
        super(); // calls Person constructor
        System.out.println("Student constructor");
    }
}

‚ö†Ô∏è Rules of Constructor Chaining
‚úÖ Only one constructor can be called using this() or super()	
‚úÖ Must be the first statement in the constructor	
‚ùå Cannot mix this() and super() in the same constructor

üî∑ Important Shortcuts in Eclipse
1. Ctrl + Space:‚ö° Content Assist ‚Äî suggests code completions.
2. Ctrl + 1: üí° Quick fix ‚Äî suggests solutions for errors or warnings.
3. Ctrl + O: üß≠ Quick outline ‚Äî shows methods/fields of the current class.
4. F3: üîÑ Go to the declaration of a variable, method, or class.
5. Ctrl + . : ‚û°Ô∏è Jump to the next error or warning in the file.

üì¶ Packages in Java
A package in Java is a namespace that organizes classes and interfaces into a structured folder system, making code modular, reusable, and easy to manage.

üî∑ Naming Convention for packages
‚û§ Package name cannot be a keyword like - new, static, public, etc...
‚û§ Do not start the package name with capital letters
‚û§ Package name not to be given as java
‚û§ When you create a class inside a package, you have to define the package keyword in your program as shown below:

Example:
package p1;
public class A {}

‚û§ Create 2 classes in the same package and perform inheritance. Import is not required.
Example 1:
package p1;
public class A {}

package p1;
public class B extends A {}

‚û§ Create 2 classes in different packages and perform inheritance. "Import required".
Example 2:
package p1;
public class A {}

package p2;
import p1.A;
public class C extends A{}

Example 3:
package p1;
public class A {}

package p2;
public class C {}

package p1;
import p2.C;
public class B {
	public static void main(String[] args) {
		A a1 = new A();
		C c1 = new C();
	}
}

Example 4:
package p1;
public class A {}

package p1;
public class B {}

package p2;
import p1.*;
public class C {
	public static void main(String[] args) {
		A a1 = new A();
		B b1 = new B();
	}
}

Example 5:
package p1;
public class A {}

package p2;
public class A {}

package p3;
public class B {
	public static void main(String[] args) {
		p1.A a1 = new p1.A();//---> p1
		p2.A a2 = new p2.A();//---> p2
	}
}

üî∑ Object-Oriented Programming 
a. Inheritance
b. Polymorphism
c. Encapsulation
d. Abstraction

üåü Inheritance
Inheritance is one of the core pillars of Object-Oriented Programming (OOP).
It allows a class (subclass) to inherit fields and methods from another class (superclass).

‚úÖ Why Use Inheritance?
‚û§ Code reusability
‚û§ Improves maintainability
‚û§ Supports method overriding & polymorphism

Example :
package app_java_1;
public class Animal {
	public void eat() {
		System.out.println("Eating");
	}
	public void sleep() {
		System.out.println("sleeping");
	}
}

package app_java_1;
public class Dog extends Animal{
	//eat(),sleep()--->Animal
}

package app_java_1;
public class Cow extends Animal{
	//eat(),sleep()--->Animal
}

package app_java_1;
public class Root {
	public static void main(String[] args) {
		Dog d = new Dog();
		d.eat();
		d.sleep();
		System.out.println("_______");
		Cow cow = new Cow();
		cow.eat();
		cow.sleep();
	}
}

 üîÑ Multilevel inheritance
Example:
package app_java_1;
public class A {
	public void test1() {
		System.out.println(1);
	}
}
package app_java_1;
public class B extends A{
	public void test2() {
		System.out.println(2);
	}
}
package app_java_1;
public class C extends B{
	public static void main(String[] args) {
		C c1 = new C();
		c1.test1();//Output :1
		c1.test2();//Output :2
	}
}

üîÑ Multiple inheritance
When a child class has more than one parent class, it is called multiple inheritance
‚û§ Java classes do not support multiple inheritance because of the diamond problem.

‚ùóDiamond Problem in Java (Multiple Inheritance Problem)
‚û§ The Diamond Problem occurs in multiple inheritance when a class inherits from two classes that have a common superclass, leading to ambiguity about which method to inherit.
‚û§ Suppose we inherit a method from A->B->D,  and the same method is inherited from A->C->D, then confusion arises from which parent class method is inherited by the child class D. This is called as DIAMOND PROBLEM. Hence, in Java, classes do not support multiple inheritance.

Note: We can do multiple inheritance on an interface.

Example: Multiple inheritance error‚ùå
package app_java_1;
public class A {}

package app_java_1;
public class B{}

package app_java_1;
public class C extends A, B{ ‚ùåError	
}

üî∑ Access Specifiers in Java
| Access Context                | `public` |         `protected`          | `default` (no modifier)   | `private`  |
| ------------------------------| :------: | :------------------------:   | :---------------------:   | :-------:  |
| Same Class                    |     ‚úÖ   |              ‚úÖ             |            ‚úÖ            |     ‚úÖ     |
| Same Package                  |     ‚úÖ   |              ‚úÖ             |            ‚úÖ            |     ‚ùå     |
| Subclass in Same Package      |     ‚úÖ   |              ‚úÖ             |            ‚úÖ            |     ‚ùå     |
| Non-Subclass in Same Package  |     ‚úÖ   |              ‚úÖ             |            ‚úÖ            |     ‚ùå     |
| Subclass in Other Package     |     ‚úÖ   | ‚úÖ (via inheritance only)   |            ‚ùå            |     ‚ùå     |
| Non-Subclass in Other Package |     ‚úÖ   |              ‚ùå             |            ‚ùå            |     ‚ùå     |

a. private: When a variable/method is made private, then we can access it in the same class but not outside the class
b. default: A variable/method with a default access specifier can work only inside the same class or the same package, but cannot be accessed in a different package
c. protected: We can access variables/methods in the same class/same package, and inside different packages only when inheritance is done
d. public: When we make a variable/method public, then we can access that in the same class/the same package/different package

üî∑ Access Specifier on Constructors
‚ùóCan we inherit the Constructor?
No, constructors cannot be inherited in Java.
Even though a subclass gets access to all public and protected members of the superclass, constructors are not part of inheritance.

üîç Why Are Constructors Not Inherited?
‚úÖ 1. Constructors are not members
Constructors are not inherited because they are not class members, such as methods or fields.

‚úÖ 2. Constructors are class-specific
A constructor is tightly bound to its class name.

‚úÖ 3. Subclass should define how it initializes its members
A subclass may have new fields or different logic for initialization.
Therefore, it requires a constructor to control its initialization.

‚úÖ 4. Java automatically provides a default constructor
If you don't define any constructors, Java will insert a default no-arg constructor.
But this doesn't mean the superclass constructor is inherited ‚Äî it's just that Java calls the superclass constructor from the subclass constructor.
They are special blocks used to initialize objects of a specific class.

üîê Private Constructor in Java
A private constructor is a constructor that cannot be accessed outside its class.

‚úÖ Why Use a Private Constructor?
‚ùå Prevent object creation	        for utility or helper classes
‚úÖ Implement Singleton Pattern		Ensure only one instance is created
üîê Hide object instantiation		Force object creation through factory methods
‚û§ If a constructor is made private, then its object cannot be created outside the class.

Example 1:
package p1;
public class A {
	private A() {}
	public static void main(String[] args) {
		A a1 = new A();
	}
}
package p1;
public class B {
	public static void main(String[] args) {
		A a1 = new A();//--->Error
	}
}
package p2;
import p1.A;
public class C {
	public static void main(String[] args) {
		A a1 = new A();//-->Error
	}
}

‚û§ When a constructor is made private, then inheritance of that class is not allowed

Example 2:
package p1;
public class A {
	private A() {}	
}

package p1;
public class B extends A{//-->Error	
}

package p2;
import p1.A;
public class C extends A{//-->Error	
}

üèóÔ∏è Default Constructor in Java
A default constructor is a no-argument constructor that the Java compiler automatically provides if you do not define any constructors in your class.

‚úÖ Key Features:
Feature							Description
No parameters. 					Takes zero arguments
Provided automatically			Only if no constructor is defined by the user
Initializes variables,			sets fields to default values (e.g., 0, null)
Used for object creation		Allows creation of objects without parameters
‚û§ If a constructor is made default, then its object can be created in the same class/same package, but not outside the package.

Example 1:
package p1;
public class A {
	A() {}
	public static void main(String[] args) {
		A a1 = new A();
	}
}
package p1;
public class B {
	public static void main(String[] args) {
		A a1 = new A();
	}
}
package p2;
import p1.A;
public class C{
	public static void main(String[] args) {
		A a1 = new A();//-->Error
	}
}

Example 2:
package p1;
public class A {
	A() {}
}
package p1;
public class B extends A {}

package p2;
import p1.A;
public class C extends A{//-->Error	
}

üîê Protected Constructor in Java
A protected constructor means the constructor can only be accessed:
‚úÖ Within the same package
‚úÖ From subclasses (even in other packages)

‚úÖ Why Use a Protected Constructor?
‚û§ To restrict object creation outside the package
‚û§ To allow subclassing but prevent direct instantiation from unrelated classes
‚û§ Often used in inheritance-based designs, frameworks, or abstract factories

Example 1:
package p1;
public class A {
	protected A() {}
	public static void main(String[] args) {
		A a1 = new A();
	}
}

package p1;
public class B  {
	public static void main(String[] args) {
		A a1 = new A();
	}
}

package p2;
import p1.A;
public class C {
	public static void main(String[] args) {
		A a1 = new A();//-->Error
	}
}
‚û§ When a constructor is made protected, then inheritance of that class is allowed in the same package / outside the package (both).

Example 2:
package p1;
public class A {
	protected A() {}
}

package p1;
public class B extends A {}

package p2;
import p1.A;
public class C extends A {}

üåüPublic Constructor
‚û§ If a constructor is made public, then its object can be created in the same class/same package, and outside the package also

Example 1:
package p1;
public class A {
	public A() {}
	public static void main(String[] args) {
		 A a1 = new A();
	}
}

package p1;
public class B  {
	public static void main(String[] args) {
		 A a1 = new A();
	}
}

package p2;
import p1.A;
public class C  {
	public static void main(String[] args) {
		 A a1 = new A();
	}
}

‚û§ When a constructor is made public, then inheritance of that class is allowed in the same package / outside the package (both)

Example 2:
package p1;
public class A {
	public A() {}
}

package p1;
public class B extends A {}

package p2;
import p1.A;
public class C extends A {}

‚úÖ Access Specifiers on Top-Level Classes:
Access Specifier				Usage							Visibility
public							public class ClassName {}		Visible to all classes everywhere (within the same package or other packages).
Default (no modifier)			class ClassName {}				Visible to classes within the same package only.

‚ùå Not allowed on top-level classes:
private
protected

üîç Reason: Java's Design Philosophy
‚úÖ 1. Top-level classes must be accessible to the JVM & compiler

‚û§ If you declare a class as private or protected, no other class can access it, not even the class loader or main method (in another file).
‚û§ That breaks the point of having it at the top level ‚Äî it becomes useless.

‚úÖ 2. Protected and private only make sense in class hierarchies

‚û§ Protected is meaningful only within inheritance (i.e., subclass access).
‚û§ Private is meaningful only within the enclosing class.
‚û§ For a top-level class, there is no enclosing class, so these modifiers make no logical sense.

Example 1:
package p1;
class A {}

package p1;
public class B extends A{} //Because A is default and inherited in B

package p2;
import p1.A;//-->Error
public class C extends A{//-->Error	
}

Example 2:
package p1;
class A {
	public static void main(String[] args) {
		A a1 = new A();
	}
}

package p1;
public class B {
	public static void main(String[] args) {
		A a1 = new A();
	}
}

package p2;
import p1.A;//--->Error because A is default and cannot be inherited in another package
public class C {
	public static void main(String[] args) {
		A a1 = new A();//--->Error
	}
}

What happens when a class is made public?
‚û§ Its object can be created in the same class/same package & inside a different package
‚û§ Inheritance is allowed in the same package & inside different packages

Example :
package p1;
public class A {}

package p1;
public class B extends A{}

package p2;
import p1.A;
public class C extends A{}

üîó Compile Time
‚û§ This is the phase where source code is checked and translated into bytecode.
‚û§ Java source files (.java) are compiled by the Java Compiler (javac).
‚û§ The compiler checks for syntax errors and converts the code into bytecode (platform-independent code).

[Source Code (.java file)]
             |
             v
[JDK - javac Compiler]
   (Compiles to Bytecode)
             |
             v
[.class File (Bytecode)]
             |
             v
[JVM Class Loader]
   (Loads class into memory)
             |
             v
[Bytecode Verifier]
   (Validates bytecode)
             |
             v
[Execution by JVM]
     /           \
    v             v
[Interpreter]   [JIT Compiler]
 (line-by-line)   (compiles hot code to native)
             |
             v
[Native Machine Code]
             |
             v
[CPU Executes Code ‚Üí Output]

The JVM uses both an interpreter and a JIT (Just-In-Time) compiler because it‚Äôs designed to balance fast startup with high runtime performance.

1Ô∏è‚É£ Roles of Each
Interpreter
‚û§ Reads bytecode line by line and executes it directly.
‚û§ Advantage: Immediate execution ‚Üí fast startup.
‚û§ Disadvantage: Slower in the long run because every instruction has to be interpreted again and again.

JIT Compiler
‚û§ Detects ‚Äúhot code‚Äù (frequently executed methods/loops).
‚û§ Translates those bytecode parts into native machine code.
‚û§ Advantage: Native code runs much faster (close to C/C++ speeds).
‚û§ Disadvantage: Compilation takes time and memory.

2Ô∏è‚É£ Why JVM Combines Them
If the JVM only used:
‚û§ Interpreter only ‚Üí Quick startup but poor long-term performance.
‚û§ JIT only ‚Üí Very slow startup (needs to compile everything first).

By combining:
‚û§ Start with the interpreter ‚Üí get the program running instantly.
‚û§ Monitor execution ‚Üí detect methods/loops used often.
‚û§ Switch to JIT for those hot parts ‚Üí gain native-speed execution.

This is called adaptive optimization.

3Ô∏è‚É£ Real-Life Analogy
‚û§ Interpreter = You read a speech word-by-word from paper ‚Üí you can start immediately, but it‚Äôs slow if you have to repeat it.
‚û§ JIT = You memorize the speech (compile to native) ‚Üí takes time initially, but then you can say it much faster.
‚û§ JVM = First read it from the paper, and for parts you repeat often, memorize them.

4Ô∏è‚É£ Execution Flow in JVM
‚û§ Bytecode Verifier checks safety.
‚û§ Interpreter starts running bytecode.
‚û§ JVM profiling detects ‚Äúhot‚Äù methods.
‚û§ JIT compiles those into native code.
‚û§ Native code replaces the interpreted version for future calls.

Command: javac MyProgram.java
Result: Creates MyProgram.class file.

üîó Run Time
‚û§ This is the phase where the compiled bytecode is executed by the Java Virtual Machine (JVM).
‚û§ The JVM loads the .class file and executes the bytecode.
‚û§ Any exceptions or logical errors may occur during this phase.

Command: java MyProgram
Result: Runs the program using the bytecode inside MyProgram.class.

‚úÖ What Makes Java Platform Independent?
Java is platform-independent because of its "Write Once, Run Anywhere" capability.
This is mainly due to:
üîë 1. Bytecode
When you compile a Java program (.java file), the Java compiler (javac) doesn't generate platform-specific machine code.
It generates bytecode (.class file) ‚Äî an intermediate, platform-neutral code.

// You write this
HelloWorld.java
‚Üì
// Compiled by javac to
HelloWorld.class (bytecode)

Bytecode is the key to platform independence ‚Äî it's the same for all operating systems.

üîë 2. Java Virtual Machine (JVM)
JVM is platform-dependent (a different version exists for Windows, Linux, Mac, etc.).
It executes the bytecode by converting it into native machine code at runtime.
Since every OS has its own JVM, the same bytecode can run on any system with a compatible JVM.

üîÑ Polymorphism
Two types of polymorphism:

a. Overriding (Run-time polymorphism):
‚û§ Overriding occurs when a subclass provides a specific implementation of a method that is already defined in its superclass.
‚û§ It is used to achieve Run-time Polymorphism.
‚û§ The method signature (name + parameters) must be the same in both parent and child classes.
‚û§ The decision of which method to call is made at run-time, not compile-time.

üî∏ Key Rules of Method Overriding:
Rule													Description
Same method signature									Method name, return type, and parameters must be the same.
Access modifier											Child method must have the same or more accessible modifier (e.g., can‚Äôt override public with private).
Can't override final, static, or private methods		These are either not inherited or cannot be changed.
Return type												should be the same or covariant (child class return type).
Use @Override											Optional, but recommended to catch errors at compile time.

Example:
package p1;
public class GoldAccount {
	public void onlineBanking() {
		System.out.println("yes");
	}
	public void rateOfInterest() {
		System.out.println("nill");
	}
}

package p1;
public class PlatinumAccount extends GoldAccount {
	public void rateOfInterest() {
		System.out.println("6% PA");
	}
	public static void main(String[] args) {
		PlatinumAccount p = new PlatinumAccount();
		p.onlineBanking();
		p.rateOfInterest()// Output: 6% PA
		GoldAccount g = new GoldAccount();
		g.onlineBanking();
		g.rateOfInterest();//-->Output: nill
	}
}

 What are Annotations?
‚û§ Introduced in Java 5, annotations are metadata that provide information to the compiler or runtime environment.
‚û§ They do not directly affect program logic but can instruct the compiler or tools to perform specific actions.

 Common Use: @Override
‚û§ @Override is used to indicate that a method is intended to override a method in the superclass.
‚û§ It helps the compiler catch errors if the method does not override anything (e.g., due to a typo or mismatch in method signature).

package p1;
	public class GoldAccount {	
		public void rateOfInterest() {
			System.out.println("nill");
		}
	}

package p1;
public class PlatinumAccount extends GoldAccount {
	@Override
	public void rateOfInterests() {//-->Error because method name mismatch
		System.out.println("6% PA");
	}	
}

‚ùóAccess Specifier should be the same, or can it be different during Overriding?
 During overriding, we can increase the scope of the access specifier, but we cannot reduce the scope of the access specifier

Example 1:
package p1;
public class GoldAccount {
	void rateOfInterest() {
		System.out.println("nill");
	}
}

package p1;
public class PlatinumAccount extends GoldAccount {
//No Error Because the default scope is increased to public	
	@Override
	public void rateOfInterest() {
		System.out.println("6% PA");
	}
}

Example 2:
package p1;
public class GoldAccount {
	public void rateOfInterest() {
		System.out.println("nill");
	}
}

package p1;
public class PlatinumAccount extends GoldAccount {
	@Override
	void rateOfInterest() { //‚ùåError: Because the public scope is reduced to the default
		System.out.println("6% PA");
	}
}

Order of Access Specifiers
Private -> Default -> Proctected -> Public

Example 3:
package p1;
public class GoldAccount {
	private void rateOfInterest() {
		System.out.println("nill");
	}
}

package p1;
public class PlatinumAccount extends GoldAccount {
	@Override
	protected void rateOfInterest()  //‚ùåError: Because private methods cannot be inherited, without inheritance, overriding cannot be done
		System.out.println("6% PA");
	}
}

‚ùì Are Static Members Inherited in Java?
‚úÖ Technically, static members are inherited ‚Äî but they are not polymorphic, and they do not behave like instance members in inheritance.

üî• Common Misconception:
‚ùå "Static members cannot be inherited." But that's not entirely accurate.

‚úÖ What Happens:
1. Static members belong to the class, not to objects.
They are class-level members, not instance-level.
So they are shared across the inheritance hierarchy.
So yes, static members are accessible in the subclass, but they are not inherited in the object-oriented sense (no polymorphism).

‚ö†Ô∏è Why Static Members Are Not "Truly" Inherited:
‚úÖ 1. They don‚Äôt participate in runtime polymorphism

class A {
    static void show() {
        System.out.println("A");
    }
}

class B extends A {
    static void show() {
        System.out.println("B");
    }
}

public class Main {
    public static void main(String[] args) {
        A obj = new B();// Upcasting 
        obj.show(); // Output: A (not B)
    }
}

Is this overriding?
‚ùå No. This is method hiding, not method overriding, because the methods are static
‚û§ Even though obj is of type B, A.show() gets called because static methods are resolved at compile time, based on the reference type, not the object.

Imagine static methods are like TV channels fixed on the remote brand, not on who's holding the remote.

A obj = new B();
‚û§ Here, you're using a remote (reference) of brand A, so Java checks what methods belong to A, not B.
‚û§ Even though you created a B object, the method called depends on what reference type you're using.
static = class-based decision (compile-time)
non-static = object-based decision (run-time)

‚úÖ 2. They're not part of the instance, so ‚Äúinheritance‚Äù isn‚Äôt meaningful
Since they don‚Äôt get copied to each object or act differently per subclass instance, calling it "inheritance" is misleading.

Example:
A parent class: GoldAccount (in package p1)
A child class: PlatinumAccount extends GoldAccount

package p1;
public class GoldAccount {
    static int x = 100;
    public static void rateOfInterest() {
        System.out.println("nill");
    }
}

package p1;
public class PlatinumAccount extends GoldAccount {
    public static void main(String[] args) {
        PlatinumAccount.rateOfInterest();      // Output:  nill
        System.out.println(PlatinumAccount.x); // Outuput: 100
    }
}

üîç What Is This Program Teaching?
‚úÖ 1. Static Methods and Variables Are Not Polymorphic. Even though PlatinumAccount inherits from GoldAccount, calling PlatinumAccount.rateOfInterest();
It is resolved at compile time based on the class name, not the object type.

Since PlatinumAccount does not override the method (it doesn‚Äôt define its rateOfInterest()), calling: PlatinumAccount.rateOfInterest(); 
is effectively the same as: GoldAccount.rateOfInterest();

The same logic applies to the static variable x:
PlatinumAccount.x; // resolves to GoldAccount.x (100)

‚úÖ Overloading in Java (Compile-Time Polymorphism)
üîπ What is Method Overloading?
‚û§Method Overloading means defining multiple methods with the same name in a class but with different parameter lists (type, number, or order of parameters).
‚û§It allows compile-time polymorphism, where the method to be called is determined at compile time based on the method signature.

| Feature                     | Allowed in Overloading? | Explanation                             |
| --------------------------- | ----------------------- | --------------------------------------- |
| Change number of parameters | ‚úÖ Yes                   | Different arity                         |
| Change type of parameters   | ‚úÖ Yes                   | Different signatures                    |
| Change order of parameters  | ‚úÖ Yes                   | Only if types are different             |
| Change return type only     | ‚ùå No                    | Causes compile-time error               |
| Change access modifier only | ‚ùå No                    | Doesn't affect method signature         |
| Change method name          | ‚ùå No                    | It's not overloading, it's a new method |

üî∏ Characteristics of Overloading:
Feature						Description
Method name					must be the same
Parameter list				must be different (type, number, or order)
Return type					can be the same or different, but doesn't affect overloading
Access modifier				can be the same or different
Inheritance					is not required for overloading
Polymorphism type			Compile-time polymorphism

Example:
package p1;

public class EmailService {
	public void sendEmail(String to, String subject, String message) {
		System.out.println("Email sending....");
	}
	public void sendEmail(String to, String subject, String message, String filePath) {
		System.out.println("Email sending with attachment.....");
	}
	public static void main(String[] args) {
		EmailService service = new EmailService();
		service.sendEmail("mike@gmail.com", "Welcome", "Some Message","G:\\image.png");
	}
}

Final Keyword
‚û§ If you make a variable final, then we cannot change its value(Just like constant variables).
‚û§ If you make a static/non-static variable final, then initialization is mandatory.

Example:
package p1;
public interface A {
	int MAX_VAL=100;
	static final int MIN_VAL=0;
}

package p1;
public class B {
	public static void main(String[] args) {
		System.out.println(A.MAX_VAL);//Output: 100
		System.out.println(A.MIN_VAL);//Output: 0
	}
}

‚û§ If you make a method final, then overriding is not allowed, but inheritance is allowed
üîí Why Use final on a Method?
1. You want to prevent subclassing from changing the logic of a method.
2. You're building secure or stable base classes (e.g., Java API classes like String, Integer, etc.)

‚û§ If you make a class final, then inheritance is not allowed
A final class:
‚ùå Cannot be extended/inherited.
‚úÖ Can have regular (non-final) methods.
‚úÖ Can have final methods too.

But since the class itself cannot be inherited:
üîí No methods inside it ‚Äî final or not ‚Äî can ever be overridden.

Example 1: 
package p1;

public class A {
	public static void main(String[] args) {
		final int x = 10;
		x=20;//-->Cannot change the value of a final variable
		final int y;//->final mandatory to be initialized
	        final static int z;//->final mandatory to be initialized
	        //‚ùåThe above errors are called blank field errors
		System.out.println(y);
	}
}

Example 2:
package p1;

public class A {
	final public void test() {
		System.out.println(100);
	}
}
package p1;

public class B extends A{
	@Override
	public void test() {//‚ùå Error because we cannot override final methods
		System.out.println(100);
	}
}

Example 3:
package p1;
final public class A {}

package p1;
public class B extends A{//‚ùå Error because we cannot inherit final class	
}

‚úÖ What Happens When a Reference Variable is marked final?
final Student s = new Student();
‚û§ You can't reassign s to point to another object.
‚û§ But you can still modify the object that refers to(if it is mutable). unless the class itself is immutable(like String).

‚úÖ Example:
class Student {
    int marks = 80;
}

public class Test {
    public static void main(String[] args) {
        final Student s = new Student();
        s.marks = 90;         // ‚úÖ Allowed
        // s = new Student(); // ‚ùå Not allowed (Compile-time error)
        System.out.println(s.marks); // 90
    }
}

Why do you use the final for references?
To prevent reassignment, ensure safe dependency injection, and make code more thread-safe and readable. It‚Äôs also a key part of writing immutable classes and predictable lambdas.

Interfaces in Java - Abstraction
Interfaces are a fundamental feature in Java used to achieve abstraction and enforce design contracts between classes.

üîπ Key Points:
Complete Abstraction (Java 7)
‚û§ In Java 7 and earlier, interfaces could only have abstract methods (no method bodies).
‚û§ They define what should be done, not how.

‚û§ All Variables are public static final.
‚û§ No need to specify these modifiers‚Äîthey are applied by default.
‚û§ No Object creation

‚ùó Drawback of Inheritance ‚Äì Tightly Coupled Programming
‚û§ When two or more classes are highly dependent on each other's implementation, they are said to be tightly coupled.
‚û§ In such a setup, changing one class often requires changes in the other, reducing flexibility, maintainability, and scalability.

üî∏ How Inheritance Causes Tight Coupling:
Child class depends heavily on the parent class:
‚û§ In inheritance, the child class inherits both behavior and structure from the parent.
‚û§ If the parent class changes, it can break or affect the behavior of all child classes.

Strong binding:
‚û§ The child class is strongly bound to the specific parent class.
‚û§ You cannot easily switch to a different parent or change the inheritance hierarchy without impacting the child classes.

Hard to maintain and extend:
‚û§ Over time, inherited code becomes fragile.
‚û§ Multiple levels of inheritance (deep hierarchy) make debugging and updates difficult.

Example 1:
package p1;

public interface A {
	public void test1() {}//‚ùå Error because complete methods are not allowed in an interface	
	public void test2(); //Correct version
	}
}

Example 2:
package p1;

public interface NotificationService {
	public void emailService();
	public void whatsAppService();
	public void smsService();
}

package p1;

public class NotificationServiceImpl implements NotificationService {
	@Override
	public void emailService() {
		System.out.println("Email Sending");
	}
	@Override
	public void whatsAppService() {
		System.out.println("Whats app Sending");
	}
	@Override
	public void smsService() {
		System.out.println("SMS Sending");
	}
	public static void main(String[] args) {
		NotificationServiceImpl impl = new NotificationServiceImpl();
		impl.emailService();
		impl.smsService();
		impl.whatsAppService();
	}
}

Example:
package p1;

public interface Calculator {
	public void add(int x, int y);
	public void mul(int x, int y);
}

package p1;
public class OrdinaryCalc implements Calculator{
	@Override
	public void add(int x, int y) {
		System.out.println(x+y);
	}
	@Override
	public void mul(int x, int y) {
		System.out.println(x*y);
	}
}

package p1;

public class SciCalc implements Calculator{
	@Override
	public void add(int x, int y) {
		System.out.println(x*x+y*y);
	}
	@Override
	public void mul(int x, int y) {
		int num1 = x*x;
		int num2 = y*y;
		System.out.println(num1*num2);
	}
}
package p1;

public class MainCalc {
	public static void main(String[] args) {
		OrdinaryCalc oc = new OrdinaryCalc();
		oc.add(10, 20);
		oc.mul(10, 20);
		SciCalc sc = new SciCalc();
		sc.add(10, 20);
		sc.mul(10, 20);
	}
}

üß† Interview Questions:
Question 1. Could this have been done with an abstract class?
‚úÖ Yes ‚Äî abstract classes allow incomplete methods and inheritance.
But the real reason for using an interface here is that you're defining pure behavior (what calculators must do), not common implementation logic.
So:
Interface ‚Üí for capabilities
Abstract class ‚Üí for partial implementation + common state

Question 2. Biggest advantage of using an interface instead of an Abstract Class?
‚úÖ Loose coupling and flexibility.
Interfaces let you add new types of calculators later without changing the existing hierarchy.
Also, Java allows multiple interfaces, but only single inheritance with abstract classes.

‚úÖ Advantages of Interfaces in Java
1. Abstraction
‚û§ Interfaces facilitate complete abstraction.
‚û§ They allow you to hide implementation details and only expose what needs to be done, not how.

Example: A Database interface may define connect(), disconnect(), but not how these are implemented.

2. Contract Enforcement
‚û§ When a class implements an interface, it must implement all its methods.
‚û§ This imposes a strict contract on the class, ensuring consistency in structure and behavior across multiple classes.

3. Good Design Practices
‚û§ Interfaces promote clear separation of responsibilities.
‚û§ They lead to clean, modular, and testable code.
‚û§ Developers can work independently on the interface and its implementations.

4. Loose Coupling
‚û§ Classes that use interfaces depend only on method signatures, not on concrete implementations.
‚û§ This allows changes in implementations without affecting dependent classes.
‚û§ Enhances flexibility, extensibility, and maintainability of the system.

5. Multiple Inheritance
‚û§ Java doesn‚Äôt support multiple inheritance with classes, but a class can implement multiple interfaces.
‚û§ This allows a class to inherit behavioral capabilities from multiple sources.

6. Supports Plug-and-Play Architecture
‚û§ Interface-based design makes it easy to swap implementations (e.g., using different payment gateways, databases, or services) without changing the dependent code.

Note:
‚û§Class to Class Inheritance --> extends
‚û§Interface to Interface Inheritance --> extends
‚û§Interface to Class Inheritance --> implements

Example :
package p1;
public interface A {
	public void test1();
}

package p1;
public interface B extends A{
	public void test2();
}

public interface D{
	public void test3();
}

package p1;
public class C implements B, D { //If you do multiple inheritance on a class, then its parent should be interfaces only

	@Override
	public void test1() {
		System.out.println("From test1");
	}
	@Override
	public void test2() {
		System.out.println("From test2");
	}

	public static void main(String[] args) {
		C c1 = new C();
		c1.test1();
		c1.test2();
	}
}

Example 4:
‚û§ In class, can we perform extends and implements together
‚û§ But ensure the extends is used first and then implementes

package p1;
public interface A {
	public void test2();
}

package p1;
public class B {
	public void test1() {
		System.out.println("From test1");
	}
}

package p1;
public class C extends B implements A {
	@Override
	public void test2() {
		System.out.println("From test2");		
	}
	public static void main(String[] args) {
		C c1 = new C();
		c1.test1();
		c1.test2();
	}
}

‚úÖExample:
interface A {
    default void show() {
        System.out.println("A");
    }
}

interface B {
    default void show() {
        System.out.println("B");
    }
}

class C implements A, B {
    // ??----------------->// It does not compile
}
üß†Interview Question on the above example
‚ùì Will this compile?
‚ùì If not, what do you do in class C to fix it?
‚ùì Why does Java force you to resolve this?

üß†It will not compile. Why ??
‚úîÔ∏è Because both interfaces A and B define a default void show() method.
‚úîÔ∏è When C implements both, Java doesn‚Äôt know which one to inherit ‚Üí üî∫ Diamond Problem (method ambiguity).

‚úÖ Fix in Class C:
class C implements A, B {
    public void show() {
        A.super.show();  // or B.super.show();
    }
}

‚úîÔ∏è You resolve the conflict by explicitly choosing which interface‚Äôs show() to call.
üìå Why Java Forces This?
Because, unlike classes (which can‚Äôt be inherited from more than one), interfaces can be ‚Äî so Java must protect against silent conflicts, especially now that interfaces can have default (concrete) methods since Java 8.

Java‚Äôs philosophy:
‚ú≥Ô∏è ‚ÄúExplicit is better than implicit in cases of ambiguity.‚Äù

‚ùóCan I develop an incomplete static method in an interface?
We cannot inherit static methods & override, hence incomplete static methods are not allowed in an interface.

Example:
package p1;
public interface A {
	public static void test2();//‚ùå Error
}

Java 8 Features
1. default keyword:
‚û§ We can create complete methods inside an interface. This was introduced in Java version 8.

Example:
package javaconcepts.p3;
public interface A {
	default public void test1() {
		System.out.println("From test1");
	}
	public void test2();
}

package javaconcepts.p3;
public class B implements A {
	public static void main(String[] args) {
		B b1 = new B();
		b1.test1();
		b1.test2();
	}
	@Override
	public void test2() {
		System.out.println("From Overrided test2");
	}	
	@Override
	public void test1() { //we can override the method
		System.out.println("From Overrided Test1");
	}
}
Output
From Overrided Test1
From Overrided test2

Before Java 8:
‚û§ Interfaces could only contain abstract methods (no body).
‚û§ If you added a new method to an interface, all implementing classes would break unless they implemented the new method.

‚úÖ Benefits of default Methods in Interfaces
1. Backward Compatibility
‚û§ You can add new methods to interfaces without breaking existing implementations.
‚û§ Existing classes don‚Äôt need to override the new default method.

interface A {
    void m1();  // originally
    default void m2() { // added later
        System.out.println("Default m2");
    }
}

‚û§ Even if old classes only implement m1(), they won‚Äôt break because m2() has a default body.

interface A {
    default void greet() {
        System.out.println("Hello from A");
    }
}
interface B {
    default void greet() {
        System.out.println("Hello from B");
    }
}
class C implements A, B {
    public void greet() {
        A.super.greet();  // resolve conflict
    }
}
This allows controlled multiple behavior inheritance.

‚úÖ 2. Functional Interface
üîπ Definition:
‚û§ A Functional Interface is an interface that has exactly one abstract (incomplete) method.
‚û§ Can have multiple default or static methods (complete methods).
‚û§ It enables lambda expressions and functional programming in Java.

üî∏ Key Points:
‚û§ A functional interface must contain only one abstract method.
‚û§ You can add any number of default or static methods (they're considered complete methods).
‚û§ If the interface inherits more than one abstract method (from multiple interfaces), it no longer remains a functional interface, and the compiler throws an error.
‚û§ Use @FunctionalInterface annotation to enforce the rule at compile-time.

Example 1:
@FunctionalInterface
public interface A {//‚ùå Error Because it cannot have a ZERO incomplete method
}

Example 2:
@FunctionalInterface
public interface A {
	public void test1();
}
Output:  No Error because it has exactly one incomplete method

Example 3:
@FunctionalInterface
public interface A {//‚ùå Error->A functional interface should consist of exactly one //incomplete method inside it
	public void test1();
	public void test2();
}

Example 4:
package p1;
@FunctionalInterface
public interface A {
	public void test1();
	default public void test2() {
		System.out.println("From Test 2");
	}
	default public void test3() {
		System.out.println("From Test 3");
	}
}
package p1;
public class B implements A {
	public static void main(String[] args) {
		B b1 = new B();
		b1.test1();
		b1.test2();
		b1.test3();
	}
	@Override
	public void test1() {
		System.out.println("From test 1");
	}
		
}
Output:
From test 1
From Test 2
From Test 3

Example 5:
package p1;
public interface A {
	public void test1();
}

package p1;
@FunctionalInterface
public interface B extends A{}
Output: No Error

Example 6:
package p1;
public interface A {
	public void test1();
	public void test2();
}

package p1;
@FunctionalInterface
public interface B extends A{}

Output:‚ùå Error because we are inheriting 2 methods to a functional interface

Example 7:
package p1;
public interface A {
	public void test1();	
}

package p1;
@FunctionalInterface
public interface B extends A{
	public void test2();
}
Output:‚ùå Error because we are inheriting 1 method from a functional interface, and a functional interface has 1 method, which totals to 2 methods in an interface

üîπLambda Expression:
A Lambda Expression is a short block of code that:
‚û§ Takes in parameters
‚û§ Executes a body
‚û§ Can be used in place of anonymous classes
‚û§ Requires a functional interface to work

üî∏ Key Points:
‚úÖ Introduced in Java 8
Part of Java‚Äôs functional programming enhancements.

‚úÖ Reduces Code Length
Allows writing concise code by eliminating boilerplate like anonymous class syntax.

‚úÖ Works With Functional Interfaces
Lambda expressions can only be used where a functional interface (i.e., one abstract method) is expected.

‚úÖ Commonly Used in Stream API
Lambdas  are widely used in filtering, mapping, sorting, and reducing data in the Java Stream API.

üîπ Syntax of Lambda Expression:
(parameters) -> { body }

Examples:
(x, y) -> x + y
name -> System.out.println("Hello " + name)
() -> System.out.println("No parameters")

‚úÖ How Lambda Expressions Work in Java?
‚û§ It creates an anonymous class behind the scenes. A class without any name is called Anonymous.
‚û§ Then the lambda expression creates an object and loads the method by implementing it inside the object.
‚û§ Then we use an object reference to call that implemented method
‚û§ Replacing instances of anonymous classes that implement functional interfaces with a concise, inline function-like syntax.

Example:
@FunctionalInterface
interface MyOperation {
    void perform(int x);
}

‚úÖ Lambda Expression
MyOperation op = () -> System.out.println("Hello");
op.perform();

Question 1. Why does this work without new?
‚úîÔ∏è Yes ‚Äî a lambda expression automatically creates an instance of the functional interface.
üîß But technically: It‚Äôs not creating an anonymous class; it creates a synthetic implementation of the interface using invokedynamic bytecode ‚Äî more lightweight and efficient than anonymous inner classes.

So: MyOperation op = (int x) -> { ... };

is syntactic sugar for:
MyOperation op = new MyOperation() {
    public void perform(int x) {
        // your lambda logic
    }
};

But the lambda version is shorter, cleaner, and faster.
Note: Functional Programming defines you to say "what you want, not how to do it step-by-step"

Example 1:
package p1;
@FunctionalInterface
public interface A {
	public void test1();	
}
package p1;
public class B{
	public static void main(String[] args) {
		A a1 = ()->{
			System.out.println(100);
		};
		a1.test1();//Output: 100
	}
}

Example 2:
package p1;
@FunctionalInterface
public interface A {
	public void test1(int x);
	default public void test2() {
		System.out.println("test2");
	}
}
package p1;
public class B{
	public static void main(String[] args) {
		A a1 = (int y) -> {
			System.out.println(y);
		};
		a1.test1(100);// Output: 100
		a1.test2();// Output: test2
	}
}

‚úÖ Why were private methods added to interfaces in Java 9?
üîê Types of Private Interface Methods (Java 9)
| Modifier         | Can Call From         | Description                         |
| ---------------- | --------------------- | ----------------------------------- |
| `private`        | Other default methods | Helps share common logic internally |
| `private static` | Other static methods  | Helps static methods reuse logic    |

üß™ Example: Private Methods in Interface
interface MyInterface {
    default void greet() {
        log("Hello from default method");
    }
    static void staticGreet() {
        logStatic("Hello from static method");
    }
    // ‚úÖ Private instance method
    private void log(String message) {
        System.out.println("LOG: " + message);
    }
    // ‚úÖ Private static method
    private static void logStatic(String message) {
        System.out.println("STATIC LOG: " + message);
    }
}

Usage:
public class Test implements MyInterface {
    public static void main(String[] args) {
        Test t = new Test();
        t.greet();
        MyInterface.staticGreet();
    }
}

‚úÖ Output:
LOG: Hello from the default method
STATIC LOG: Hello from static method

üéØ Key Benefits
‚û§ Code reusability: Avoids repeating logic in multiple default/static methods.
‚û§ Encapsulation: Keeps helper methods hidden from implementing classes.
‚û§ Cleaner design: Interfaces can now follow DRY (Don't Repeat Yourself) more cleanly.

Can private interface methods be accessed outside the interface?
‚ùå No, only accessible within the interface for reuse by default/static methods.

Can we override private interface methods?
‚ùå No, private methods cannot be inherited or overridden.

Are private methods mandatory in interfaces?
‚ùå No, they are optional‚Äîuse them to clean up repeated logic.

4. Stream API
Note: to learn Stream API, complete the following first
a. Collection (Data Structure)
b. Functional Programming

5. Optional class - We have to learn the exception concept in Java first


üî∑ Marker interface 
‚û§ An empty interface is called a marker interface
‚û§ Purpose: To mark a class as having a specific property so that JVM or frameworks can handle it differently at runtime.
Example:
1. java.io.Serializable
2. java.lang.Cloneable
3. java.util.RandomAccess

‚úÖ Abstract Class in Java
An abstract class in Java is a class that is declared with the abstract keyword. It cannot be instantiated directly and is typically used to provide a partial implementation that its subclasses must complete.

üîπ Key Features of Abstract Class
1. ‚úÖ Can Have Both Complete and Incomplete Methods
An abstract class can contain:
‚û§ Complete methods (methods with body)
‚û§ Incomplete methods (methods without a body)
‚û§ To declare an incomplete method, the abstract keyword is mandatory.

abstract class Shape {
    abstract void draw();        // Incomplete method
    void color() {               // Complete method
        System.out.println("Coloring shape");
    }
}

2. ‚úÖ Can Have Both Static and Non-Static Members
You can define:
‚û§ Static variables and methods
‚û§ Non-static variables and methods

abstract class Demo {
    static int count = 0;
    int id;
    static void showCount() {
        System.out.println("Count = " + count);
    }
}

3. ‚úÖ Static Methods Must Be Complete
You cannot define abstract static methods.
‚û§Because static methods belong to the class, and abstract methods must be overridden, this contradicts the purpose.

abstract class Test {
    // abstract static void display(); ‚ùå Not allowed
    static void show() {         // ‚úÖ Allowed
        System.out.println("Static method");
    }
}

4. ‚úÖ Can Have main() Method
‚û§An abstract class can contain the main() method and be used as the entry point of a Java program.

abstract class Launcher {
    public static void main(String[] args) {
        System.out.println("Main inside abstract class");
    }
}

5. ‚ùå Cannot Instantiate an Abstract Class
‚û§ You cannot create an object of an abstract class directly.
It may contain incomplete methods, so Java doesn‚Äôt allow creating an object of something that‚Äôs not fully defined.

abstract class Animal {
    abstract void makeSound();
}

// Animal a = new Animal(); // ‚ùå Compile-time error

6. ‚ùå Does Not Support Multiple Inheritance with Classes
‚û§ Java does not allow multiple inheritance with classes (i.e., a class cannot extend more than one class, abstract or not).
‚û§ This is to avoid ambiguity and diamond problems.

abstract class A {
    abstract void show();
}

abstract class B {
    abstract void show();
}

// class C extends A, B { } // ‚ùå Not allowed
Java solves this limitation using interfaces, which do support multiple inheritance.

Example 1:
package p1;
abstract public class A {
	public void test1() {}
	abstract public void test2();
	public static void test3() {}
	public static void test4();//‚ùå Error
	public static void main(String[] args) {
		A a1 = new A();//‚ùå Error
	}
}

Example 2: Error because multiple inheritance cannot be done
package p1;
abstract public class A {}
package p1;
abstract public class B{}

package p1;
public abstract class C extends A,B{//‚ùå Error
}

üß† So, Why Use an Interface if an Abstract Class Can Have Abstract Methods?
‚û§ Java doesn't support multiple inheritance for classes; interfaces allow it.
‚û§ Interfaces are ideal for defining APIs and contracts, not implementations.
‚û§ Use abstract classes when you want to provide a common base with shared code.
‚û§ Use interfaces when you want to enforce a common behavior across unrelated classes.
‚û§ All variables in an interface by default are final & static, whereas inside an abstract class, we can create static/non-static/final variables

‚úÖ Real-World Analogy:
| Concept        | Example                                                                     |
| -------------- | --------------------------------------------------------------------------- |
| Interface      | RemoteControl: defines buttons (on/off) ‚Äî any brand can follow              |
| Abstract class | SamsungRemote: provides partial button logic, common to all Samsung remotes |

Example 1:
package p1;
abstract public class A {
	static int x = 10;
	public static void test() {
		System.out.println(100);
	}
	public static void main(String[] args) {
		System.out.println(A.x);//Output :10
		A.test();// Output: 100
	}
}

Example 2:
package p1;
abstract public class A {
	int x = 10;
	public void test() {
		System.out.println(100);
	}
}
package p1;
public class B extends A {
	public static void main(String[] args) {
		B b1 = new B();
		System.out.println(b1.x);// Outupt: 10
		b1.test();// Output: 100
	}
}

Example: Inheritance from interface-->abstract class-->class
package p1;
public interface A {
	public void test1();
}

package p1;
abstract public class B implements A {
	abstract public void test2();
}

package p1;
public class C extends B{
	@Override
	public void test1() {
		System.out.println("From test1");
	}
	@Override
	public void test2() {
		System.out.println("From test2");
	}
	public static void main(String[] args) {
		C c1 = new C();
		c1.test1();
		c1.test2();
	}
}

Note: In Java 8, we can develop complete static methods & main method in an interface

Example:
package p1;
public interface A {
	static int x = 100;
	public static void test1() {
		System.out.println("From test1");
	}
	public static void main(String[] args) {
		System.out.println(A.x);// Output :100
		A.test1();// Output: From test1
	}
}

‚úÖ Exception and Exception Handling in Java
üîπ What is an Exception?
‚û§ An exception is an unexpected event that occurs during the execution of a program.
‚û§ It disrupts the normal flow of the program and may cause it to terminate abruptly if not handled properly.

üîπ Why Do Exceptions Occur?
They occur due to unforeseen errors like:
‚û§ Invalid user input (e.g., dividing by zero)
‚û§ Trying to access a null object
‚û§ File not found
‚û§ Network failure
‚û§ They can happen at runtime, even if the code compiles successfully.

Example 1:
package p1;
public class A {
	public static void main(String[] args) {
		int x = 10;
		int y = 0;
		int z = x / y;//Stop Program Here
		System.out.println(z);
		System.out.println("Welcome");
	}
}
Output:
Exception in thread "main" java.lang.ArithmeticException: / by zero

üî∑ Exception handling
‚û§ To handle exceptions, we will use a "try & catch" block in Java
‚û§ When an exception occurs in the try block, it will create an exception object, and that object's address is given to the catch block. The catch block will suppress that exception, and further code will continue to execute

Example:
package p1;
public class A {
	public static void main(String[] args) {
		try {
			int x = 10;
			int y = 0;
			int z = x/y;
			System.out.println(z);
		} catch (Exception e) {
			e.printStackTrace();
		}
		System.out.println("Welcome");
	}
}

üîÑ Types of Exception in Java
There are two types of exceptions in Java:
‚û§ Compile Time / Checked Exception - These exceptions will occur when a .java file is compiled to a .class file. That is, during compilation, we will get this exception.
‚û§ Runtime / Unchecked Exception - These exceptions will occur when we run a .class file. That is during runtime

üî∑ Runtime / unchecked Exceptions
1. ArithmeticException: This exception will occur when invalid mathematical operations are performed

Example:
package p1;
public class A {
	public static void main(String[] args) {
		try {
			int x = 10;
			int y = 0;
			int z = x/y;// same for modulus %0
			System.out.println(z);
		} catch (ArithmeticException a) {
			a.printStackTrace();
		}
		System.out.println("Welcome");
	}
}
Output:
java.lang.ArithmeticException: / by zero
Welcome

2. Null Pointer Exception: This exception will occur when with null reference variable we try to access non-static members of the class
Example 1:
package p1;
public class A {
	int x = 10;
	public static void main(String[] args) {
		try {
			A a1 = null;
			System.out.println(a1.x);
		} catch (NullPointerException e) {
			e.printStackTrace();
		}
		System.out.println("Welcome");
	}
}
Output:
java.lang.NullPointerException: Cannot read field "x" because "a1" is null
Welcome

Example 2: Can access static members without the object creation
package p1;
public class A {
	static int x = 10;
	public static void main(String[] args) {
		try {
			A a1 = null;
			System.out.println(a1.x);//A.x  Output: 10
		} catch (NullPointerException e) {
			e.printStackTrace();
		}
		System.out.println("Welcome");//Output: Welcome
	}
}



Unary Operators in Java
##############################

1. Increment Operator
   1.1 Post-Increment: Increment the value of the variable next time you see the same variable
Example 1:
----------
package p1;

public class A {
	public static void main(String[] args) {
		int i=0;
		int j = i++;
		int k=10;
		int l=k++ + k++ + k++;
		System.out.println(i);//Output: 1
		System.out.println(j);// Output: 0
		System.out.println(k);//Output: 13
		System.out.println(l);// Output: 33
	} 
}
   1.2 Pre-Increment: Increment the value of the variable in the same step
Example 1:
-----------
package p1;

public class A {
	public static void main(String[] args) {
		int i=10;		
		int j = ++i;
		int k=10;
		int l=++k + ++k + ++k;
		System.out.println(i);// Output: 11
		System.out.println(j);// Output: 11
		System.out.println(k);// Output: 13
		System.out.println(l);// Output: 36
	} 	
}
2. Decrement Operator
   2.1 Post Decrement: Here we decrement the value of i by 1 when we next time see the same variable:

Example:
package p1;

public class A {
    public static void main(String[] args) {
        int a = 10;
        int b = a-- + a--; 
	int x = 10;
        int y = x-- + x++ + x-- + x--; 
        System.out.println(a); //Output: 8
        System.out.println(b); //Output: 19
        System.out.println(x); //Output: 8
        System.out.println(y); //Output: 38
    }
}
   2.2 Pre Decrement: Here we decrement the value of the variable in the same step by 1

Example 1:
----------
package p1;

public class A {
	public static void main(String[] args) {
		int i=10;		
		int j = --i + --i;
		System.out.println(i);
		System.out.println(j);
	} 
}

‚úÖ Type Casting of Data Types in Java
In Java, type casting is used to convert a variable of one data type into another. This is commonly done between primitive types or object references (in case of inheritance).

üîÑ 1. Type Casting Between Primitive Data Types
There are two types:

‚úÖ a) Widening Casting (Implicit & Upcasting)
‚û§Smaller type ‚Üí Larger type
‚û§Safe, automatic, without any loss of data

byte ‚Üí short ‚Üí int ‚Üí long ‚Üí float ‚Üí double

üß™ Example:
int a = 10;
double b = a;  // int to double (widening)
double x=10.3d;
long y=x; // Larger -> Smaller, there is a loss of data so it will give an error.

‚úÖ b) Narrowing Casting (Explicit & Downcasting)
 ‚û§Larger type ‚Üí Smaller type
‚û§Risky, must be done manually using cast () 
‚û§Loss of data can take place

double ‚Üí float ‚Üí long ‚Üí int ‚Üí short ‚Üí byte

üß™ Example:
double x = 10.99;
long i=10;
int y = (int) x;  //output: 10 double to int (narrowing)
byte j=i; // ----------> Throws error

üß™ Example:
long i=100;
byte j=(byte)(int)i; //multiple downcasting is possible

üß™ Example:
int i=100;
long j=(long)i; // No error

üîç Why is float ‚Üí long considered downcasting, even though size increases?
Because type casting in Java is not only about memory size, but also about type compatibility and precision:

‚ùó float ‚Üí long is narrowing because:
‚û§You are going from floating-point to integer, which involves:
‚û§Loss of precision (decimal part is truncated)
‚û§Potential data loss if the value is too large
‚û§Even if you're increasing memory size, you're going from a more complex representation (float) to a simpler one (integer).

Primitive    Wrapper Class
byte		Byte
short		Short
int		Integer
long		Long
float		Float
double		Double
char		Character

Example 1: I want to convert a String to an Integer

public class A {
	public static void main(String[] args) {
		String x = "100";
		int  y = Integer.parseInt(x);
		System.out.println(y);
	}
}

Example 2:I want to convert a String to a Float
float  y = Float.parseFloat(x);

Example 3:I want to convert a String to a Double
double  y = Double.parseDouble(x);

Example 4:
-----------
package p1;

public class A {
	public static void main(String[] args) {
		try {
			String x = "10.3dasdsd";
			double  y = Double.parseDouble(x);
			System.out.println(y);
		} catch (NumberFormatException e) {
			e.printStackTrace();
		}
		System.out.println("Welcome");
		
	}
}
Output:
java.lang.NumberFormatException: For input string: "10.3dasdsd"
Welcome

What is class upcasting?
########################
‚û§Here we store the child class object address into the parent class reference variable, so that the reference variable becomes reusable

Example: Reusing a reference variable

public class A {}

public class B extends A{}

public class C extends A{
	public static void main(String[] args) {
		A a1 = new B();
		System.out.println(a1);
		a1 = new C();
		System.out.println(a1);
	}
}

Example 2: How can we implement polymorphism for multiple child classes by using the same reference variable

public class A {
	void display() {
        System.out.println("Inside class A");
    }
}

public class B extends A{
	 @Override
	    void display() {
	        System.out.println("Inside class B");
	    }
}

public class C extends A{
	  @Override
	    void display() {
	        System.out.println("Inside class C");
	    }
	public static void main(String[] args) {
				
		A a1 = new B();
		a1.display();    // Calls B's version => "Inside class B"
		a1 = new C();
		a1.display();    // Calls C's version => "Inside class C"
	}
}

üß† Why do we do it?
1. To reuse the parent class reference for multiple child class objects.
2. To enable polymorphism on multiple child classes.
3. To write generic, flexible code that works with different subclasses.

Note:
instanceof - It will check which class object address is present inside the reference variable

Example:

public class A {}

public class B extends A{}

public class C extends A{	 
	public static void main(String[] args) {
				
	  A a1 = new B();
	  System.out.println(a1 instanceof B);// Output: true
	}
}

What is class downcasting?
##########################
-> Here we store the parent class object address into the child class reference variable
-> To perform downcasting, first do upcasting and then perform downcasting
Example:
---------
public class A {}
public class B extends A{}

public class C extends A{	 
	public static void main(String[] args) {
		A a1 = new B();
		if(a1 instanceof B) {
			B b1 = (B)a1;
			System.out.println("Downcasting successful!");
		}
	}
}

Example:
--------
public class A {
	public void display() {
		System.out.println("Inside class A");
	}
}
public class B extends A{
	public void showB() {
        System.out.println("Inside class B");
        }
}
public class C extends A {
	public void showC() {
		System.out.println("Inside class C");
	}
}
public class MainClass {
	public static void processObject(A obj) {
        if (obj instanceof B) {
            B b = (B) obj;  // Downcasting to B
            b.showB();
        } else if (obj instanceof C) {
            C c = (C) obj;  // Downcasting to C
            c.showC();
        } else {
            obj.display();
        }
    }
    public static void main(String[] args) {
    	processObject(new B());
	}
}

Note:
‚û§Using upcasting, we can access only parent class members, you cannot access child class members
‚û§After upcasting to access child class members, we have to perform downcasting

Example:
---------
package p1;

public class A {
	public void display() {
		System.out.println("Inside class A");
	}
}
public class B extends A{
	public void showB() {
       	 System.out.println("Inside class B");
        }
	public static void main(String[] args) {
		A a1 = new B();
		if(a1 instanceof B) {
			B b1 = (B)a1;
			b1.showB();
		}
	}
}

‚úÖ Arrays in Java
----------------------

üîπ 1. Arrays Hold a Collection of Values
‚û§An array is a container object that can hold a fixed number of elements of the same data type.
‚û§Instead of creating multiple individual variables for related values (like 10 integers), we can store all of them in one array.

üîπ 2. Anything That Holds a Collection of Values is Called a Data Structure
‚û§Arrays are one of the simplest and most fundamental data structures.
‚û§A data structure is a way to organize and store data efficiently for easy access and modification.
‚û§Arrays serve as the base for many advanced data structures (like lists, stacks, queues, etc.).

üîπ 3. An array in Java is Treated as an Object
‚û§In Java, arrays are not primitive types (like int, char, etc.)‚Äîthey are objects.
‚û§This means they are created using the new keyword internally.
Being objects, they:
Have a runtime class type
Inherit methods from the Object class
Have properties like .length to determine their size

üîπ 4. Arrays Start With Index Zero
‚û§Array indexing in Java is zero-based.
‚û§The first element is accessed with index 0, the second with 1, and so on.
‚û§So, for an array of size n, the last valid index is n-1.

üîπ 5. To Store and Read Values We Use: start_address + index √ó memory_size
‚û§Internally, the array elements are stored sequentially in memory.
‚û§The memory address of any element can be calculated using:

Address = Base¬†Address + (Index√óSize¬†of¬†Each¬†Element)
‚û§This allows direct access to any element using its index in constant time O(1), which makes arrays efficient for random access.

üîπ 6. Memory Allocation Happens in Sequence (Contiguous Allocation)
‚û§When an array is created, Java allocates a block of continuous memory locations to store its elements.
This contiguous allocation ensures that:
Each element is placed right after the previous one in memory.
Accessing any element is fast using index-based computation.
But the array size cannot change after creation (fixed size limitation).

Example 1:
----------
package p1;
public class A {
	public static void main(String[] args) {
		int[] age = new int[4];
		age[0] = 90;
		age[1] = 89;
		System.out.println(age[0]);
		System.out.println(age[1]);
	} 
}

‚û§To find the size of an array dynamically, we will use the  public final field "length". When the array is created this variable will get initialized

Example 2:
----------
package p1;

public class A {
	public static void main(String[] args) {
		int[] age = new int[40];
		System.out.println(age.length);// Output :40
	} 
}

Scanner class - Is used to provide user input
################

Example 1:
----------
package p1;
import java.util.Scanner;
public class A {
	public static void main(String[] args) {
		
		Scanner scan = new Scanner(System.in);
		System.out.println("Enter your name:");
		String name = scan.next();//Can read one String word only
		System.out.println("Your name is "+name);
		System.out.println("Enter your age:");
		int age = scan.nextInt();//Can read on Integer value only
		System.out.println("Your age is "+age);
		System.out.println("Enter your weight:");
		float weight = scan.nextFloat();//Can read on float values
		System.out.println("Your weight is "+weight);
		System.out.println("Enter your Answer:");
		boolean ans = scan.nextBoolean();//Can read on boolean values
		System.out.println("Your ans is "+ans);
		scan.close();
		
	} 
	
}
Output:
Enter your name:
mike
Your name is Mike
Enter your age:
100
Your age is 100
Enter your weight:
98.34
Your weight is 98.34
Enter your Answer:
true
Your ans is true

Example 2: How to read multiple String words using the nextLine() method
--------------------------------------------------------------------------
package p1;
import java.util.Scanner;
public class A {
	public static void main(String[] args) {	
		Scanner scan = new Scanner(System.in);
		System.out.println("Enter your name:");
		String name = scan.nextLine();//Can read Multiple String words
		System.out.println(name);
		scan.close();
	} 	
}
‚ö†Ô∏è Note:
‚û§Always close the scanner with sc.close() to free system resources.
‚û§Use nextLine() carefully after nextInt() or next() due to newline issues.

‚ö†Ô∏è Issue: nextLine() after nextInt() or next() doesn't behave as expected.
‚úÖ Root Cause:
‚û§Methods like nextInt(), nextDouble(), and next() do not consume the newline character (\n) at the end of user input.
‚û§But nextLine() does consume the full line, including the newline.

So, if you call nextLine() immediately after nextInt() or next(), it may read the leftover newline from the previous input, resulting in an empty string.

üîç Example:
Scanner sc = new Scanner(System.in);

System.out.print("Enter age: ");
int age = sc.nextInt();  // user enters: 25 + [Enter]

System.out.print("Enter name: ");
String name = sc.nextLine();  // reads leftover '\n' from above

System.out.println("Age: " + age);
System.out.println("Name: " + name);

üî¥ Output:
Enter age: 25
Enter name:
Age: 25
Name:
‚ùóOops! name is empty because nextLine() consumed the leftover newline from nextInt().

‚úÖ How to Fix It:
Solution: Add a sc.nextLine() dummy call after nextInt() or next() to consume the leftover newline.

System.out.print("Enter age: ");
int age = sc.nextInt();
sc.nextLine(); // ‚Üê eat the leftover newline

System.out.print("Enter name: ");
String name = sc.nextLine();

üî∑ IIB ‚Äî Instance Initialization Block
########################################
It runs every time an object is created, before the constructor, and is used to initialize instance (non-static) data.
You can think of an IIB as an anonymous constructor fragment that runs before the real constructor.

package p1;

public class iiBTutorial {
	int i;
	int j;
	static int k;
	static void test() {
		System.out.println("Test method called");
	}
	{
		i = 10;
		j = 20;
		System.out.println("Intance Initialization Block 1 called");
		System.out.println("The value of i: " + i);
		System.out.println("The value of j: " + j);
		System.out.println("The value of k: " + k);
		test();
		// new iiBTutorial();-----------> recursive calling of IIB stack overflow, cannot create object inside IIB
	}
	{
		System.out.println("Intance Initialization Block 2 called");
	}

	iiBTutorial() {
		System.out.println("B constructor called");
	}

	public static void main(String[] args) {
		iiBTutorial b1 = new iiBTutorial();
		test();
	}
}

When you create an object, Java executes:
1. Instance variable initializations
2. IIB block(s) (in the order they appear)
3. Constructor

‚û§Use Case: To initialize instance variables or logic common to all constructors.
‚û§Runs whenever an object creation takes place.
‚û§Every time a new object is created, IIB runs.

‚úÖ When to Use IIB?
‚û§When all constructors need to run some common code.
‚û§To reduce duplication across overloaded constructors.

Note: A Static variable/method can be accessed inside the IIB

üî∑ SIB ‚Äî Static Initialization Block
#######################################
It runs once when the class is loaded, before the main() method or any static method/variable is accessed.

package p1;
public class SIBTutorial {
	static int i;
	int j;
	static {
		System.out.println("Static Initialization Block-1 called");
		System.out.println("The value of i "+i);
		i=20;
		j=10;//cannot do that
		System.out.println("The value of i "+i);	
	}
	static {
		System.out.println("Static Initialization Block-2 called");
	}
	public static void main(String[] args) {}
}

Order of Execution:
‚û§Static variable initializations
‚û§SIB block(s) (in the order they appear)
‚û§Main method

üî• Use Case:
‚û§Initialize static variables
‚û§Load configuration, logging, or static resources
‚û§Run a one-time setup for the class

Example 2: We can create an object inside SIB through which IIB and the constructor can be called.
package p1;
public class A {
	{
		System.out.println("IIB");// Print 1
	}
	static {
		new A();
		System.out.println("SIB"); // Print 3
	}
	A(){
		System.out.println("Constructor of A called");// Print 2
	}
	public static void main(String[] args) {
		System.out.println("Entered Main");// Print 4
	}
}

Output 
IIB
Constructor of A called
SIB
Entered Main

Super in Java
###############
The super keyword is a reference variable used within a subclass to refer to its immediate parent class (superclass) members, including variables, methods, and constructors.
It helps achieve proper inheritance behavior and overriding control.

‚úÖ Uses of super in Java
1Ô∏è‚É£ Access Parent Class Fields (Variables)
When the subclass has a variable with the same name as the parent class, super helps distinguish the parent class version.
It cannot access the private members of the super class.

üéì Real-World Analogy
Imagine super as saying:
"Hey, I want the version of this thing that came from my parent class."
Just like a child might say:
"I want to use my dad‚Äôs phone, not mine ‚Äî because it's different."

class A {
    int num = 10;
}
class B extends A {
    int num = 20;
    void display() {
        System.out.println("Child num: " + num);       // 20
        System.out.println("Parent num: " + super.num); // 10
    }
}

2Ô∏è‚É£ Call Parent Class Methods
If the child class overrides a method, but you still want to call the parent version, use super.methodName().

public class A {
	 int x = 10;
	 static int y=20;
	  static void display() {
		  System.out.println("This is a static display method");
	  }
	    void show() {
	        System.out.println("In class A");
	    }
}

public class B extends A {

	public static void main(String[] args) {
		B b1=new B();
		b1.test();	
	}
	public void test() {
		super.display();
		System.out.println(super.x);
		System.out.println(super.y);	
	}
}

‚úÖ What This Means:
‚û§Super is meant to refer to instance (non-static) members of a superclass.
‚û§Even though it is technically possible to write super.staticMethod() in Java, it is discouraged, and Java treats it the same as ParentClass.staticMethod() internally.
‚û§So, it's not a compiler error, but a bad practice.

‚úÖ Best Practice:
Always access static members using the class name, not super or this.
// Good
ParentClass.staticMethod();

// Bad (misleading)
super.staticMethod();

3Ô∏è‚É£ Call Parent Class Constructor
‚û§super() is used to call the constructor of the parent class from the child class constructor only.
‚û§‚úÖ This must be the first statement in the subclass constructor; Hence, super and this keyword cannot be used at the same time.
‚û§If in the Child class constructor, this keyword is used, then in that constructor super keyword will not be automatically placed.
class A {
    A() {
        System.out.println("Constructor of A");
    }
}
class B extends A {
    B() {
        super();  // Must be first statement
        System.out.println("Constructor of B");
    }
}
üìå Output:
Constructor of A
Constructor of B

Even though you didn‚Äôt write super() in class B, Java internally adds it:
Even If we don't explicitly write the constructor, Java internally calls the constructor and add the super() keyword inside it(but only calls the default constructor of the parent class).
B() {
    super(); // inserted automatically by compiler
    System.out.println("Constructor of B");
}

üéØ Why use it?
‚û§To ensure proper construction of the inheritance chain
‚û§To pass values to a parameterized parent constructor

4Ô∏è‚É£ Use with Parameterized Constructors
class A {
    A(String msg) {
        System.out.println("Message from A: " + msg);
    }
}
class B extends A {
    B() {
        super("Hello"); // Pass value to superclass constructor
        System.out.println("Constructor of B");
    }
}

‚ùå super is not allowed in static methods
The super keyword refers to the current object‚Äôs superclass, but static methods belong to the class, not to any object.

üîç Why This Causes an Error:
‚û§Static methods do not have a this reference, because they can be called without creating an object.
‚û§Since super is used to refer to the parent of this object, and this doesn't exist in a static context, super becomes invalid there.

üß™ Example:
class A {
    int x = 10;
    static void staticShow() {
        System.out.println("Static method in A");
    }
}
class B extends A {
    static void staticTest() {
        // System.out.println(super.x); ‚ùå Compile-time error
        // super.staticShow();          ‚ùå Compile-time error
    }
}

üö´ Both lines give:
Cannot use 'super' in a static context

‚úÖ What You Can Do in Static Methods:
If you need to access static members of the parent class in a static method:
A.staticShow();  // ‚úÖ Correct
System.out.println(A.someStaticVariable);  // ‚úÖ Correct

Loops in Java
##############
1. for loop

Example 1;
---------
public class A {
	public static void main(String[] args) {
		for (int i = 0; i < 4; i++) { //0 to 3
			System.out.println(i);
		}
	} 
}
Example 2:
a. The user will enter the PIN 1234
b. If the entered PIN is valid, then the program should print Welcome and stop
c. If the PIN is invalid, the user can attempt to enter it a maximum of three times.
d. If all 3 times the PIN is invalid, then the card is blocked message we should get

Code:
package p1;
import java.util.Scanner;
//break
//1. Can be used only inside loops and switch case statements
//2. It stops the for loop execution
public class A {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		
		for(int i=0;i<3;i++) {//0 to 2
			System.out.println("Enter the pin number");
			int pinNumber = scan.nextInt();
			if(pinNumber==1234) {
				System.out.println("Welcome");
				break;
			}else {
				System.out.println("Invalid Pin number");
				if(i==2) {
					System.out.println("Card is blocked");
				}
			}
		}
		scan.close();
	} 
}

2. while loop
Example 1:
----------
package p1;
public class A {
	public static void main(String[] args) {
		int i=0;
		while(i<3) {//If condition true will enter while loop
			System.out.println(i);
			i++;
		}
	}	
}

Example 2:
--------
a. Enter the amount, and we should get a message, please collect cash
b. Then prompt a message: Do you want to continue(yes or no)
c. If yes, again enter the amount, and we should get a message, please collect cash
d. If no program is entered, it should stop

Code:
import java.util.Scanner;

public class A {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		String i="yes";
		while(i.equals("yes")) {//If condition true will enter while loop
			System.out.println("Enter the amount");
			int amount = scan.nextInt();
			System.out.println("Please collect the cash: rs. "+amount);
			System.out.println("Do you want to continue(yes/no)?");
			i = scan.next();
			
			if(i.equals("no")) {
				System.out.println("Thank you. Visit again");
			}
		}
	}
}

3. do while loop -  Will run first time without condition check. For the second iteration, the condition will be evaluated

Example 1:
---------
package p1;
public class A {
	public static void main(String[] args) {
		int i=100;
		do {
			System.out.println(i);
			i++;
		}while(i<3);
	}	
}

Example 2:
----------
package p1;
public class A {
	public static void main(String[] args) {
		int i=0;
		do {
			System.out.println(i);
			i++;
		}while(i<3);
	}	
}

4. for each loop - 
-> Works only with a data structure
-> Can only read the value of the data structure one by one
-> The loop will run until all values are read in the given data structure

Example:
package p1;
public class A {
	public static void main(String[] args) {
		int[] age = new int[3];
		age[0] = 100;
		age[1] = 101;
		age[2] = 120;
		
		for(int x:age) {
			System.out.println(x);
		}
	}
}

Continuation of Arrays using Loops:
######################

Example 1:
----------
package p1;
public class A {
	public static void main(String[] args) {
		int[] age = new int[3];
		age[0] = 100;
		age[1] = 101;
		age[2] = 120;
		
		for (int i = 0; i < age.length; i++) {//0 to 2
			System.out.println(age[i]);
		}
	}
}

ArrayIndexOutOfBoundsException
#####################################
‚û§When we exceed the array size, we get this exception

Example:
------
package p1;
public class A {
	public static void main(String[] args) {
		try {
			int[] age = new int[3];
			age[0] = 100;
			age[1] = 101;
			age[2] = 120;
			age[3] = 103;
		} catch (Exception e) {
			e.printStackTrace();
		}
		System.out.println("Welcome");
	}
}

Output:
java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3
Welcome

Continue Keyword in Java
#####################
The continue keyword is used inside loops (for, while, or do-while) to skip the current iteration and jump to the next one.

package p1;
public class A {
	public static void main(String[] args) {
		for (int i = 0; i < 5; i++) {
			
			if(i==3) {
				continue;
			}
			System.out.println(i);//0 1 2 4
		}
	}
}
Output:
0
1
2
4

else-if ladder statement
######################
-> If the user enters yes, it should print pass
-> If the user enters no, it should print fail
-> If the user enters something else, it should print invalid input

Example:
-------------
package p1;

import java.util.Scanner;

public class A {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		System.out.println("Enter the input(yes/no)");
		String value = scan.next();
		if(value.equals("yes")) {
			System.out.println("Pass");
		} else if(value.equals("no")) {
			System.out.println("Fail");
		} else {
			System.out.println("Invalid Input");
		}
	}	
}

Switch Case
############################

package p1;

import java.util.Scanner;

public class A {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		System.out.println("Enter the floor number");
		int key=scan.nextInt();
		switch (key) {
		case 1:
			System.out.println("1st Floor");
			break;
		case 2:
			System.out.println("2nd Floor");
			break;
		case 3:
			System.out.println("3rd Floor");
			break;
		default:
			System.out.println("Invalid input");
			break;
		}
	}	
}

Removing Duplicate elements from an array
###########################################
‚û§For the below logic array should be sorted

Steps:
1. Create a temp array which same size as that of x
int[] x = {3,3,4,5,6,6,7};
int[] temp = new int[x.length];

2. Compare i with i+1 of array x, if not equal copy the value from x[i] to temp[j] and increment j by 1

3. When you reach last index of array x, copy that value directly to temp[j];

package p1;
public class A {
	public static void main(String[] args) {
		int[] x = {3,3,4,5,6,6};
		int[] temp = new int[x.length];
		int j=0;
		for(int i=0;i<x.length-1;i++) {//i=5
			if(x[i]!=x[i+1]) {//with index 5 to 6
				temp[j] = x[i];
				j++;
			}
		}
		temp[j] = x[x.length-1];
		
		for(int arr:temp) {
			System.out.println(arr);
		}
	}
}

Logic For Swapping
##########################
package p1;
public class A {
	public static void main(String[] args) {
		int x = 10;
		int y = 20;
		int temp;
		temp=y;
		y=x;
		x=temp;
		System.out.println(x);
		System.out.println(y);
	}
}

File Handling in Java
#######################
File handling allows Java programs to create, read, write, and delete files or directories stored on disk.
‚û§Java uses the java.io, java.nio.file, and java.util packages for file operations.

Example:

package p1;
import java.io.File;
public class A {
	public static void main(String[] args) {
		File f = new File("E:\\april\\t1.txt");
		System.out.println(f);
	}
}

File f = new File("E:\\april\\t1.txt");
‚û§ This line does not check whether the file exists.
‚û§ It simply creates a File object representing the given path.
‚û§ That means you're just wrapping a file path inside a File object.

System.out.println(f);
‚û§ This prints the path stored in the object ‚Äî it does not interact with the actual file.

‚úÖ exists() Method in Java
‚û§ It is a non-static method present inside the File class
‚û§ The return type of this method is boolean
‚û§ It checks whether the file exists in the given path.

üí° Interview Insights
Question: Does it check only files or also directories?
‚û§ It checks both files and directories.
‚û§ exists() does not distinguish between files and directories.
‚û§ Use isFile() or isDirectory() to differentiate.

üß† Code:
if (f.exists()) {
    if (f.isFile()) System.out.println("It's a file.");
    if (f.isDirectory()) System.out.println("It's a directory.");
}

‚û§ If the file exists, it will return true, else false.

üîç Syntax
File f = new File("path_to_file");
boolean result = f.exists(); //if exist then true otherwise than false

Example:
---------
package p1;
import java.io.File;
public class A {
	public static void main(String[] args) {
		File f = new File("G:\\april\\t100.txt");
		boolean val = f.exists();
		System.out.println(val); // true or false based on file existence
	}
}

‚úÖ delete() Method in Java
‚û§ It is a non-static method present inside the File class
‚û§ The return type of this method is boolean
‚û§ It deletes the file that exists in the given path.
‚û§ If the file is deleted, it will return true, else false

üîç Syntax
File f = new File("path_to_file");
boolean result = f.delete();

üí° Interview Insights
Question: How can you delete a directory with files in it?
You must recursively delete all contents before deleting the directory.

Example:
--------
package p1;
import java.io.File;
public class A {
	public static void main(String[] args) {
		File f = new File("G:\\april\\t1.txt");
		boolean val = f.delete();
		System.out.println(val);
	}
}

‚öôÔ∏è Interview Exercise
How would you delete a non-empty folder in Java?

public static void deleteDirectory(File dir) {
    if (dir.isDirectory()) {
        for (File file : dir.listFiles()) {
            deleteDirectory(file);
        }
    }
    dir.delete(); // delete files/subdirs and finally the directory itself
}

‚úÖ mkdir() Method in Java

‚û§ It is a non-static method present inside the File class
‚û§ The return type of this method is boolean
‚û§ It creates a folder  in the given path.
‚û§ If a folder is created, it will return true, else false
‚û§ It will neither replace the existing folder nor overwrite it.

üîç Syntax
File f = new File("path_to_directory");
boolean created = f.mkdir();

üí° Interview Insights
Will mkdir() create parent folders if they don‚Äôt exist?
‚ùå No. It will return false if the parent directory is missing.

What‚Äôs the difference between mkdir() and mkdirs()?
mkdir() ‚Üí Creates only the last directory if the parent exists
mkdirs() ‚Üí Creates entire directory hierarchy if needed

üß† Bonus Tip for Interviews
If you want to create nested directories like G:\\april\\p2\\test\\demo, use:

File f = new File("G:\\april\\p2\\test\\demo");
f.mkdirs();  // creates all non-existing parent directories

Example:
-------
package p1;
import java.io.File;
public class A {
	public static void main(String[] args) {
		File f = new File("G:\\april\\p2");
		boolean val = f.mkdir(); // true if created, false if already exists or parent missing
		System.out.println(val);
	}
}

‚úÖ Deleting Folders Using delete() in Java

üîç Syntax
File f = new File("path_to_folder");
boolean result = f.delete();

üí° Interview Insights
Q: What happens if the folder contains files/subfolders?
‚ùå delete() will fail and return false.
We have to use the recursive deletion method to delete a non-empty directory.

public class A {
	public static void main(String[] args) {
		File f = new File("G:\\april\\p2"); // p2 must be empty
		boolean val = f.delete();
		System.out.println(val);
	}
}

Note: The delete() method can delete both folders/files

‚úÖ length() Method in Java
‚û§ It is a non-static method present inside the File class
‚û§ The return type of this method is long
‚û§ length() returns size in bytes, not characters.
1 character ‚â† 1 byte always (especially in UTF-8 or Unicode encoding)
‚û§ White spaces and new lines are also counted as bytes.
‚û§ Not valid for directories ‚Üí returns 0 if used on a directory.

üîç Syntax
File f = new File("path_to_file");
long size = f.length();

üí° Interview Insights
Q: What if the file doesn't exist?
‚û§ Returns 0, doesn't throw an exception.

Q: Can length() be used to measure file upload size?
‚û§ Yes, if used carefully. But beware of file encoding differences.

Q: Is length() affected by file encoding?
‚û§ Yes ‚Äî different encodings may change the byte count.

Example:
--------
package p1;
import java.io.File;
public class A {
	public static void main(String[] args) {
		File f = new File("G:\\april\\t1.txt");
		long val = f.length();
		System.out.println(val);
	}
}

üß™ Bonus Tip: For Directory Size (Advanced)

public static long folderSize(File folder) {
    long total = 0;
    for (File f: folder.listFiles()) {
        if (f.isFile())
            total += f.length();
        else
            total += folderSize(f);
    }
    return total;
}

Compile-time Exception/Checked Exception
_____________________________________________

‚û§ Checked Exceptions are exceptions that are checked at compile time.
‚û§ The Java compiler forces you to either handle them using try-catch or declare them using throws.
‚û§ These exceptions must be addressed in code; otherwise, the code will not compile.

‚úÖ createNewFile()

‚û§ createNewFile() is a non-static method in the java.io.File class.
‚û§ It attempts to create a new file in the specified path.
‚û§ If the file already exists, it does not replace it ‚Äî instead, it returns false.

Example:
------
package p1;
import java.io.File;
import java.io.IOException;
public class A {
	public static void main(String[] args) {
		try {
			File f = new File("G:\\april\\t1.txt");
			boolean val = f.createNewFile();
			System.out.println(val);
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}


üß† Interview Insights
Q: Will the file be created if the path doesn't exist?
‚ùå No, intermediate folders must already exist. Otherwise, it throws an exception.

Q: Can createNewFile() create folders?
‚ùå No, it is only for creating files, not directories. Use mkdir() for folders.

IOException in Java
‚û§ IOException is a checked exception in Java.
‚û§ It is part of the java.io package.
‚û§ It is thrown when an Input/Output operation fails or is interrupted.

üìå Class Signature
public class IOException extends Exception

üìÇ Common Scenarios Where IOException Occurs
| üîç Scenario            | üí° Example                                            |
| ---------------------- | ----------------------------------------------------- |
| üìÅ File not found      | Reading a file that doesn't exist (`FileInputStream`) |
| üîí File not readable   | Accessing a file without permission                   |
| üåê Network I/O failure | Socket gets disconnected during data transfer         |
| ‚ùå Stream closed        | Reading from or writing to a closed stream            |
| üíæ Full disk           | Writing to disk when no space is available            |



6. list()-
-------------------
‚û§ list() is a non-static method present in the java.io.File class.
‚û§ It returns a String[] array containing the names of files and directories in the current directory.
‚û§ It does not include absolute or full paths‚Äîjust the names.
‚û§ To get the full path use listFiles() instead of list().

üìå Syntax
public String[] list()

Example:
-------
package p1;
import java.io.File;
public class A {
	public static void main(String[] args) {
			File f = new File("G:\\april\\");
			String[] val = f.list();
			for(String x: val) {
				System.out.println(x);
			}
			System.out.println(val.length);
	}
}

üß† Interview Insights
Q: What is returned if the file object is not a directory?
‚ùå null is returned, not an empty array ‚Äî interview trap

üß™ Common Mistakes (Interview Traps)
| ‚ùå Mistake                                                 | ‚úÖ Correct Understanding                                                 |
| --------------------------------------------------------- | ----------------------------------------------------------------------- |
| Assuming `list()` works on files                          | `list()` **only works on directories**                                  |
| Expecting full paths                                      | It returns **only names**, not full paths                               |
| Not checking for `null`                                   | Always check if `list()` returns `null` to avoid `NullPointerException` |
| Not handling security exceptions (e.g., read permissions) | `SecurityException` may occur ‚Äî though it‚Äôs **unchecked**               |


2. FileReader:
‚û§ FileReader is a class in the java.io package used to read character-based files.
‚û§ It is typically used for reading text files (e.g., .txt, .csv).
‚û§ Return type is int, but it returns Unicode/ASCII value, so we often cast it to char.
‚û§ It return -1(indicates EOF- End of file) when the file ends.
‚û§ Not efficient for large files because it reads one character at a time. Prefer BufferReader.

üß± Constructor Signature
FileReader fr = new FileReader(String filePath);

Example 1:
-----------
package app_java_3;
import java.io.FileReader;

public class A {
	public static void main(String[] args) {
		try {
			FileReader fr = new FileReader("G:\\april\\t1.txt");
			System.out.println((char)fr.read());  // Reads only 1 character
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

Example 2:
----------
package app_java_3;
import java.io.File;
import java.io.FileReader;
public class A {
	public static void main(String[] args) {
		try {
			FileReader fr = new FileReader("file.txt");
			int c;
			while ((c = fr.read()) != -1) {
   			 System.out.print((char)c);
			}
			fr.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

‚ö†Ô∏è Interview Trap ‚Äì Don‚Äôt Use f.length() with Unicode Files
‚úÖ It works for simple English text files (ASCII), where 1 byte = 1 character
‚ùå NOT SAFE for files with Unicode (multi-byte) characters like Hindi, Chinese, or emojis ‚Äî f.length() returns byte size, not character count.

File f = new File("file_with_‡§π‡§ø‡§Ç‡§¶‡•Ä.txt");
System.out.println(f.length());  // May return 18 bytes
// But the actual number of characters could be < 18

‚úÖ Better alternative:
int c;
while ((c = fr.read()) != -1) {
    System.out.print((char)c);
}

üìå 2. Is FileReader character-based or byte-based?
‚úÖ FileReader is character-based
‚ö†Ô∏è It automatically converts bytes to characters using the platform's default charset

‚úÖ FileReader read(char[] ch)

char[] ch = new char[(int)f.length()];//type case to int because f.length returns long and array index only takes int values.

‚û§ Allocates a character array whose size is equal to the file size in bytes.
‚û§ (int)f.length() returns the size in bytes, not characters.
‚û§ Risk: Unicode/multibyte characters can break this logic.

fr.read(ch);
‚û°Ô∏è It reads all the characters from the file into a character array and then prints them one by one.

‚ö†Ô∏è Common Mistakes in Interviews

‚ùå Assuming file length = number of characters
char[] ch = new char[(int)f.length()]; // Problematic for UTF-8

‚ùå Ignoring return value of read(ch)
fr.read(ch);  // BAD ‚Äî may not fill array completely

‚úÖ Better Practice:
int len = fr.read(ch);
for (int i = 0; i < len; i++) {
    System.out.print(ch[i]);
}

Example
-------
package app_java_3;
import java.io.File;
import java.io.FileReader;
public class A {
	public static void main(String[] args) {
		try {
			File f = new File("G:\\april\\t1.txt");
			FileReader fr = new FileReader(f);
			char[] ch = new char[(int)f.length()];
			fr.read(ch);
			
			for(char c:ch) {
				System.out.print(c);
			}
			fr.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

üìù FileWriter in Java
########################

üîπ FileWriter Class (java.io)
‚û§ Used to write character data to a file.
‚û§ Belongs to the java.io package.
‚û§ Can create a new file if it doesn‚Äôt exist.
‚û§ The default behavior is to replace (overwrite) the existing file content.
‚û§ You can append to existing content by passing true as a second parameter during object creation.

üî∏ Constructor Variants
1. FileWriter fw = new FileWriter("path")
Overwrites content if the file exists.
Creates the file if it doesn‚Äôt exist.

2. FileWriter fw = new FileWriter("path", false)
Same as above ‚Äî explicitly overwrites content.

3. FileWriter fw = new FileWriter("path", true)
Appends to the existing file content if present.
Creates a new file if it doesn‚Äôt exist.

üîπ Common Methods
1. write(int ch): Writes a single character (based on ASCII value).
2. write(String str): Writes an entire string.
3. write(char[] ch): Write a character array.

close()
‚û§ Saves written content and closes the stream.
‚û§ Must be called to avoid data loss or resource leakage.

‚ùìInterviewer Trick: "What happens if the file does not exist?" ‚Üí FileWriter will create it only if the directory structure already exists; otherwise, it will throw a FileNotFoundException.

‚úÖ Example 1 ‚Äì Overwriting a file
package app_java_3;

import java.io.FileWriter;

public class A {
	public static void main(String[] args) {
		try {
			FileWriter fw = new FileWriter("G:\\april\\t4.txt", false);
			fw.write(97);            // Writes: a
			fw.write("100");         // Writes: 100
			fw.write(new char[]{'a','b','c'}); // Writes: abc
			fw.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

‚úÖ Example 2 ‚Äì Writing multiple lines
package app_java_3;

import java.io.FileWriter;

public class A {
	public static void main(String[] args) {
		try {
			FileWriter fw = new FileWriter("G://april//t1.txt");
			fw.write("mike\n");
			fw.write("stallin\n");
			fw.write("adam\n");
			fw.close();//Save the file content and close the file
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

üìò BufferedReader in Java
#############################
‚û§ BufferedReader is used to read text from a character-input stream, buffering characters for efficient reading of characters, arrays, and lines.
‚û§ It significantly improves performance over using FileReader alone.
‚û§ Introduced in the java.io package.

1. Improved Performance
Uses a buffer (default size: 8192 characters) to read chunks of data at once, reducing disk I/O.

2. Works with FileReader
BufferedReader wraps FileReader. On its own, it cannot read files because it doesn‚Äôt handle files directly.

3. readLine() Method
Allows reading one full line (till \n) at a time. Returns null when EOF (End Of File) is reached.

4. Supports Other Input Types
Can wrap any Reader (e.g., InputStreamReader, StringReader), not just FileReader

üìå Commonly Used Constructors
BufferedReader br = new BufferedReader(new FileReader("path"));
BufferedReader br = new BufferedReader(new FileReader("path"), bufferSize); // optional buffer size

‚û§ Example 1: Reading one character

import java.io.BufferedReader;
import java.io.FileReader;

FileReader fr = new FileReader("G://april//t1.txt");
BufferedReader br = new BufferedReader(fr);
System.out.println((char)br.read());  // Reads one character
br.close();
fr.close();

‚û§ Example 2: Reading into a char array

FileReader fr = new FileReader("G://f1//t1.txt");
BufferedReader br = new BufferedReader(fr);
char[] ch = new char[4];
br.read(ch); // Reads 4 characters into the array
for(char c: ch) {
    System.out.print(c);
}
br.close();
fr.close();

‚û§ Example 3: Reading multiple lines using readLine()

package p1;

import java.io.BufferedReader;
import java.io.FileReader;

public class A{
	public static void main(String[] args) {
		try {
			FileReader fr = new FileReader("file_location");
			BufferedReader br= new BufferedReader(fr);
			String line;
			while ((line = br.readLine()) != null) {
			    System.out.println(line);
			}
			br.close();
		} catch (Exception e) {
			e.printStackTrace();
		}

	}
}

üî• Internal Working
‚û§ BufferedReader maintains an internal buffer (char[]).
‚û§ When read() or readLine() is called and the buffer is empty, it:
‚û§ Pulls a block of characters from the underlying Reader (FileReader)
‚û§ Stores them in the buffer
‚û§ Serves future reads from this buffer until it's empty again.
‚û§ This reduces the number of physical reads from disk, improving performance.

üéØ Advantages
‚û§ Reduces file reading time, especially for large files.
‚û§ readLine() makes line-by-line processing much easier.

üìò BufferedWriter in Java
###########################
‚û§ BufferedWriter is a part of the java.io package.
‚û§ It is used to write text efficiently to character output streams by buffering characters.
‚û§ Improves performance by minimizing disk interaction (reducing write operations).

üîç Core Features
Buffers characters before writing to the destination (default size: 8192 characters).
Can write:
1. Strings (write(String str))
2. Single characters (write(int c))
3. Character arrays (write(char[] cbuf))

Supports newLine() to write platform-dependent line separator (\n, \r\n, etc.)
Must be used with a Writer (e.g., FileWriter, OutputStreamWriter) ‚Äî cannot directly write to files.

üß™ Code Example:
FileWriter fw = new FileWriter("G://april//t1.txt", true); // true = append mode
BufferedWriter bw = new BufferedWriter(fw);
bw.write("mike");
bw.newLine(); //append new line
bw.write(97); // Writes the character with ASCII value 97 ('a')
char[] ch = {'b','c','d'}; //// Writes a char array {'b', 'c', 'd'}
bw.newLine();
bw.write(ch);

bw.close(); // Always close in reverse order of creation
fw.close();

Q. When is the data written to the file?
‚úÖ When the buffer is full, or flush() / close() is called.
Prefer flush() if writing in real-time or inside loops.

üíæ Serialization & Deserialization in Java
############################################

Serialization is the process of converting a Java object into a byte stream.
This byte stream can be:
1. Written to a file
2. Transmitted over a network
3. Saved to a database

Deserialization is the reverse process: Converting a byte stream back into a Java object.

üîÑ Real-World Use Cases
1. Saving the state of an object to a file (e.g., session persistence)
2. Sending objects over a network (e.g., in RMI, sockets)
3. Caching objects in memory/disk
4. Java Messaging Service (JMS)

üìò Key Concepts
| Concept             | Details                                                             |
| ------------------- | ------------------------------------------------------------------- |
| `Serializable`      | Marker interface (`java.io.Serializable`) that must be implemented  |
| `transient` keyword | Used to skip fields from serialization                              |
| `serialVersionUID`  | Version control for the class ‚Äî helps avoid `InvalidClassException` |

Example:
--------
package p1;
import java.io.Serializable;

public class User implements Serializable {
    private static final long serialVersionUID = 1L;  // Version control ID
    String username = "mike";
    transient String password = "secret123"; // Will not be serialized
}


‚û§ transient: tells JVM to skip this field during serialization
‚û§ The password field will be null when deserialized

üîê transient Keyword ‚Äì In Detail
Prevents sensitive data (e.g., password, OTP) from being persisted
Prevents circular references or unnecessarily heavy objects from being serialized

Syntax:
transient DataType fieldName;

package p1;
import java.io.FileOutputStream;
import java.io.ObjectOutputStream;
public class B {
	public static void main(String[] args) {
		A a1 = new A();
		try {
			FileOutputStream fos = new FileOutputStream("G:\\april\\file.ser");
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			oos.writeObject(a1); // a1 is instance of A. The object a1 is converted to a byte stream and saved in a file.ser
			oos.close();
			fos.close();
		} catch (Exception e) {	
			e.printStackTrace();
		}
	}
}

‚ö†Ô∏è Bonus Trap: Changing Class After Serialization

If you serialize an object and later modify the class (add/remove fields), deserialization can fail unless:
serialVersionUID is unchanged
Compatible changes are made (adding optional fields is safe)

üîπ Can serialVersionUID be anything?
‚úÖ Yes, you can assign any long value as serialVersionUID.

üîπ Example
private static final long serialVersionUID = 42L;     // Valid
private static final long serialVersionUID = 1234567890123456789L;  // Also valid

üí° But Why Do We Use It?
serialVersionUID is used to verify that the sender and receiver of a serialized object have loaded classes for that object that are compatible concerning serialization.

üîê What happens without it?
If you don‚Äôt define serialVersionUID, the Java compiler automatically generates it based on class structure (fields, methods, modifiers, etc.).

But the auto-generated value is not consistent across:
Different compilers (javac vs Eclipse)
Even minor changes in the class (adding/removing a method or variable)

üö® Interview Trap
Q: Can I remove or skip defining serialVersionUID if my class implements Serializable?
‚ùå Wrong Answer: Yes, it's optional
‚úÖ Correct Answer: Technically optional, but highly recommended. Without it, even small changes in the class can cause InvalidClassException during deserialization.

üß† Best Practices
Always manually declare serialVersionUID for Serializable classes.
Choose any long value that‚Äôs meaningful to you (version number, timestamp, or arbitrary value).

üë®‚Äçüíª Example
package p1;
import java.io.FileInputStream;
import java.io.ObjectInputStream;
public class C {
	public static void main(String[] args) {
		try {
			FileInputStream fis = new FileInputStream("G:\\april\\file.ser");
			ObjectInputStream ois = new ObjectInputStream(fis);
			A a1 = (A)ois.readObject();
			System.out.println(a1.name);
			System.out.println(a1.password); // The object is restored, but password will be null because it was marked transient
			ois.close();	
		} catch (Exception e) {	
			e.printStackTrace();
		}
	}
}

If class doesn‚Äôt implement Serializable	‚ùå NotSerializableException will be thrown at runtime
Can static fields be serialized		‚ùå No. Static fields are class-level, not object-level, so not serialized.

JDBC - Java Database Connectivity
##########################################
-> Database: Here we store data in the form of tables permanently
-> Popular Databases: MySQL, PostgreSQL, Oracle, SQL Server, MongoDB, Derby, h2Database
-> Install MySQL Database
Download from here: https://dev.mysql.com/downloads/windows/installer/8.0.html
-> When you download MySQL Workbench, you will get the following
a. IDE - To Write SQL Query (Structured Query Language)
(SQL query is used to interact with the database)
b. MySQL Server

Installation Doc: https://www.prowesstics.com/blogs/mysql-workbench-installation/

-> Launch MySQL Workbench
-> Create psaDB connection
-> Crate Database: Create Database psaDB
-> Connect to Database: use psaDB
-> Create Table Student: 
Create table student(
	name varchar(45),
    email varchar(128),
    mobile varchar(10)
)
-> Read Table Content: Select * from student
-> Insert data to table: insert into student values('mike','mike@gmail.com','9632629033')
-> Read Table Content: Select * from student

Assignment: Complete SQL Recorded Classes. Access will be given in the PSA App. Nearly covered 250+ examples

After installing MySQL Workbench, we can now start with the JDBC Concept
------------------------------------------------------------------------
-> Interacting with the database using Java program
-> Download Connector File for MySQL: https://dev.mysql.com/downloads/file/?id=538917
-> Create a folder with the name lib inside the root path of your Java project & paste the connector jar file inside it
-> Right click on project>>Go to properties>>select java build path>> click on libraries tab>>Click on add jar>>navigate to lib folder and select mysql connector j jar>> click apply + close

Example 1: JDBC code to insert data
-----------------------------------
package jdbc_examples;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.Statement;

public class A {
	public static void main(String[] args) {
		try {
//Connect to database - use psaDB (SQL)
			
Connection con=DriverManager.getConnection("jdbc:mysql://localhost:3306/psadb1","root","test");

//Write & execute SQl query
Statement stmnt =  con.createStatement();
stmnt.executeUpdate("insert into student values('adam','adam@gmail.com','9632629555')");
			
//Close database connection
con.close();
} catch (Exception e) {
	e.printStackTrace();
}
}
}
 
Example 2: JDBC Code to delete a record
---------------------------------------
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.Statement;

public class B {
	public static void main(String[] args) {
		try {
			//Connect to database - use psaDB (SQL)
		Connection con = 
					DriverManager.
	getConnection("jdbc:mysql://localhost:3306/psadb1","root","test");
					
			//Write & execute SQl query
			
			Statement stmnt =  con.createStatement();
			stmnt.executeUpdate("Delete from student where email='adam@gmail.com'");
			//Close database connection
			con.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

Example 3: JDBC Code to update a Record
-------------------------------------
import java.sql.*;

public class C {
	public static void main(String[] args) {
		try {
			//Step Connect to Database
			Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/psadb1", "root", "test");
			
			//Step 2: Execute SQL Query
			Statement stmnt = con.createStatement();
			stmnt.executeUpdate("Update student set mobile='9632882052' where email='mike@gmail.com'");
			
			//Step 3: Close Database Connection
			con.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

Example 4: JDBC Code to read data from the database
-----------------------------------------------
package p1;

import java.sql.*;

public class D {
	public static void main(String[] args) {
		try {
			//Step Connect to Database
			Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/psadb1", "root", "test");
			
			//Step 2: Execute SQl Query
			Statement stmnt = con.createStatement();
			ResultSet result = stmnt.executeQuery("Select * from student");
			
			while(result.next()) {
				System.out.println(result.getString(1));
				System.out.println(result.getString(2));
				System.out.println(result.getString(3));
			}
			
			//Step 3: Close Database Connection
			con.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

‚úÖ Custom Exception in Java
##############################
Custom exceptions are user-defined exceptions that extend either the Exception class (for checked exceptions) or the RuntimeException class (for unchecked exceptions).

üîπ Syntax for Custom Exception
‚úÖ 1. Checked Exception (extends Exception)
// Custom checked exception
public class MyCheckedException extends Exception {
    public MyCheckedException(String message) {
        super(message);
    }
}

‚úÖ 2. Unchecked Exception (extends RuntimeException)
// Custom unchecked exception
public class MyUncheckedException extends RuntimeException {
    public MyUncheckedException(String message) {
        super(message);
    }
}

üîß Example with Usage
üìå Example: Creating and Using a Checked Exception
// Custom exception class
class AgeInvalidException extends Exception {
    public AgeInvalidException(String message) {
        super(message);
    }
}

// Business logic
public class CustomExceptionDemo {
    public static void validateAge(int age) throws AgeInvalidException {
        if (age < 18) {
            throw new AgeInvalidException("‚ùå Age is not valid for voting!");
        } else {
            System.out.println("‚úÖ You are eligible to vote.");
        }
    }

    public static void main(String[] args) {
        try {
            validateAge(15);
        } catch (AgeInvalidException e) {
            System.out.println("Caught Exception: " + e.getMessage());
        }
    }
}

üìò Best Practices for Custom Exceptions
‚û§ Always extend Exception or RuntimeException.
‚û§ Provide constructors for messages and causes.
‚û§ Use descriptive names (InvalidAgeException, UserNotFoundException).
‚û§ Don‚Äôt overuse ‚Äî prefer standard exceptions when they fit.

üß† Interview Tips & Traps
| ‚ùì Question                                             | ‚úÖ Good Answer                                                 |
| ------------------------------------------------------ | ------------------------------------------------------------- |
| Should I extend `Throwable` directly?                  | ‚ùå No, use `Exception` or `RuntimeException`.                  |
| Can I throw a custom exception without the `throws` keyword? | ‚úÖ Yes, but only if it extends `RuntimeException` (unchecked). |
| Why create custom exceptions?                          | To handle specific business logic and improve code clarity.   |
| Can custom exceptions have multiple constructors?      | ‚úÖ Yes, just like any class (with message, cause, etc.).       |

‚úÖ Difference between throw and throws in Java
##################################################
| Feature                  | `throw`                                       | `throws`                                                |
| ------------------------ | --------------------------------------------- | ------------------------------------------------------- |
| Purpose              | Used to explicitly throw an exception     | Used to declare exceptions a method might throw     |
| Location             | Inside method or block                        | In method signature                                     |
| Number of Exceptions | Can throw only one exception at a time    | Can declare multiple exceptions separated by commas |
| Type                 | Followed by an object of `Throwable` type | Followed by one or more **exception class names       |
| Usage                | Used for triggering exception                 | Used for declaring exception handling responsibility    |
| Syntax               | `throw new ExceptionType("msg");`             | `public void method() throws IOException`               |

‚úÖ Syntax and Example
üîπ throw keyword example (used inside method)
public class ThrowExample {
    public static void main(String[] args) {
        int age = 16;
        if (age < 18) {
            throw new ArithmeticException("‚ùå Age must be 18+ to vote");
        }
        System.out.println("‚úÖ You can vote");
    }
}

üîπ throws keyword example (used in method declaration)
import java.io.*;

public class ThrowsExample {
    // declaring that this method may throw IOException
    public static void readFile() throws IOException {
        FileReader fr = new FileReader("file.txt"); // may throw IOException
        BufferedReader br = new BufferedReader(fr);
        System.out.println(br.readLine());
    }

    public static void main(String[] args) {
        try {
            readFile(); // handle the exception
        } catch (IOException e) {
            System.out.println("Caught IOException: " + e.getMessage());
        }
    }
}

üîç Key Points
‚û§ throw is used within a method, while throws is used in the method declaration.
‚û§ throws a single instance of an exception.
‚û§ throws can declare multiple exceptions that a method might throw.
‚û§ Use throw to generate an exception during custom logic validation.
‚û§ Use throws to inform the caller method to handle the exception.

‚ö†Ô∏è Common Interview Traps
| ‚ùì Trap Question                                                        | ‚úÖ Correct Clarification                                                  |
| ---------------------------------------------------------------------- | ------------------------------------------------------------------------ |
| Can we use `throw` without creating exception object?                  | ‚ùå No, `throw` must be followed by a `Throwable` object.                  |
| Can we write `throws` inside method body?                              | ‚ùå No, `throws` is only used in **method signature**.                     |
| Can we throw multiple exceptions with `throw`?                         | ‚ùå No, only **one exception object** at a time.                           |
| What happens if a method declares `throws` but doesn't actually throw? | ‚úÖ That‚Äôs allowed ‚Äî declaration is just a **promise**, not a requirement. |

‚úÖ Best Practices
‚û§ Use throws for checked exceptions that you don‚Äôt want to handle in the method.
‚û§ Use throw for custom exception logic or early exits.
‚û§ Always handle checked exceptions using try-catch or declare them using throws.

Multi-catch blocks:
---------------------
‚û§We can create multiple catch blocks.
‚û§Always start with the  child exception class, followed by the parent exception class

Example:
---------
package p1;

public class E {
	int x = 10;
	public static void main(String[] args) {
		try {
			Integer.parseInt("ahsjkdhas687");
			E a1 = null;
			System.out.println(a1.x);
			int x = 10/0;
		}catch (ArithmeticException e) {
			System.out.println(1);
		}catch (NullPointerException e) {
			System.out.println(2);
		}catch (Exception e) {
			System.out.println(3);
		}
		
	}
}

Finally block in Java
###########################
‚û§ This isan  extension of try try-catch block
‚û§The code that we write in the finally block will run 100%, regardless of the exception

Example:
--------
public class E {
	int x = 10;
	public static void main(String[] args) {
		try {
			int x = 100/0;
		}catch (Exception e) {
			e.printStackTrace();
		}finally {
			System.out.println("Finally");//Output: Finally
		}	
	}
}

Example:
--------
public class E {
	int x = 10;
	public static void main(String[] args) {
		try {
			int x = 100/2;
		}catch (Exception e) {
			e.printStackTrace();
		}finally {
			System.out.println("Finally")//;Output: Finally
		}
		
	}
}

Example: Can we write only a try-catch block: yes
--------
public class E {
	int x = 10;
	public static void main(String[] args) {
		try {
			int x = 100/0;
		}finally {
			System.out.println("Finally");
		}
		System.out.println("Welcome");
	}
}
Output: Finally
Exception in thread "main" java.lang.ArithmeticException: / by zero
	at jdbc_examples.E.main(E.java:7)


Example where the finally block can be used?
a. We can perform a database closing operation
b. We can perform a file closing operation / Database closing Operation

Example :
package p1;

import java.sql.*;

public class A {
	public static void main(String[] args) {
		Connection con = null;
		try {
			//Step Connect to Database
			con = DriverManager.getConnection("jdbc:mysql://localhost:3306/psadb1", "root", "test");
			
			//Step 2: Execute SQl Query
			Statement stmnt = con.createStatement();
			stmnt.executeUpdate("insert into student values('adam','adam@gmail.com','9632629455')");
					
		} catch (Exception e) {
			e.printStackTrace();
		}finally {
			try {
				//Step 3: Close Database Connection
				con.close();
			} catch (Exception e2) {
				e2.printStackTrace();
			}
		}
	}
}

public class Test {
    public static void main(String[] args) {
        System.out.println(test());
    }

    static int test() {
        try {
            return 1;
        } catch (Exception e) {
            return 2;
        } finally {
            return 3;
        }
    }
}
1. What is the output?
‚úÖ Output is: 3

2. Why does finally override the return in try?
‚û§Because the finally block is always executed, and if it contains a return, it overrides any previous return values, even from try or catch.
‚û§So even though try says return 1, and there's no exception, the finally block's return 3 overrides it.
üß® This is often called "return suppression".

3. What if finally didn‚Äôt have a return?
Then the return from try (or catch, if an exception occurs) would go through as normal.

So if finally it is:
finally {
    System.out.println("Cleaning up");
}

Then the output would be:
Cleaning up ---> Output from finally  
1 ----> returned output from try-catch block

Code Example 2:
public class Main {
    public static void main(String[] args) {
        try {
            int a = 5 / 0;
        } catch (ArithmeticException e) {
            System.out.println("A");
        } finally {
            System.out.println("B");
        }
    }
}
And what if you remove the catch block ‚Äî will it still print B? Why or why not?
‚úÖ Output:B  
Exception in thread "main" java.lang.ArithmeticException: / by zero.
‚úîÔ∏è Finally runs.
Even when there's no catch, the finally block executes before the exception is thrown back to the JVM.

final:
-> final makes variable constant
-> final prevents overriding
-> final on class stops inheritance

finally:
‚û§ This is an extension of a try-catch block.
‚û§ The code that we write in the finally block will run 100%, regardless of the exception.

finalize():
‚û§ This is a method inside the Object class, and here, the Garbage collection logic is implemented.
‚û§ We can try calling the garbage collector using System.gc(). But it will not guarantee 100% execution.

Multithreading in Java
‚úÖ Multitasking vs Multiprocessing 
| Feature            | Multitasking                                          | Multiprocessing                                      |
| ------------------ | ----------------------------------------------------- | ---------------------------------------------------- |
| Definition     | Running multiple tasks simultaneously on a single CPU | Running multiple processes on multiple CPUs or cores |
| Type           | Software-level (tasks share same CPU)                 | Hardware-level (tasks run on separate processors)    |
| Performance    | Slower compared to multiprocessing                    | Faster execution due to multiple processors          |
| Cost           | Cost-effective (uses single processor)                | Expensive (requires multiple processors/cores)       |
| Resource Usage | Shares resources, hence limited                       | Dedicated resources per process                      |
| Risk           | Can affect performance due to context switching       | More stable and isolated                             |
| Example        | Multiple threads in a browser                         | OS running browser, editor, and games separately     |

üß† Interview Trap:
Q: Which is better, multitasking or multiprocessing?
‚úÖ Answer: Depends on context.

For lightweight tasks, multitasking via threads is better.
For CPU-bound tasks, multiprocessing gives better performance.

üîπ 2. Threads in Java
A thread is a lightweight sub-process.
It is the smallest unit of execution in a program.
Java uses threads to perform multitasking at the program level.

üîπ Main thread: Default thread started by JVM.
üîπ User-defined thread: Thread created by programmer.

Methods to Create Threads
‚úÖ Method 1: Extending the Thread class
üîß Steps:
Create a class that extends Thread
Override the run() method
Create an object and call the start() method to begin execution

‚úÖExample:
public class A extends Thread {
    public void run() {
        for (int i = 0; i <= 1000; i++) {
            System.out.println("Task 1");
        }
    }

    public static void main(String[] args) {
        A a1 = new A(); // Create thread object
        a1.start();     // Start new thread

        for (int i = 0; i < 1000; i++) {
            System.out.println("Task 2");
        }
    }
}

‚òëÔ∏è start() ‚Üí starts a new thread and invokes run() internally.
‚ùå Calling run() directly doesn‚Äôt create a new thread; it runs on the main thread.

‚úÖ Method 2: Implementing Runnable interface
üîß Steps:
Create a class implementing Runnable
Override the run() method
Pass object to Thread constructor
Call start() on Thread object

‚úÖExample:
public class A implements Runnable {
    public void run() {
        for (int i = 0; i <= 1000; i++) {
            System.out.println("Task 1");
        }
    }

    public static void main(String[] args) {
        A a1 = new A();             // Runnable object
        Thread t1 = new Thread(a1); // Thread object
        t1.start();                 // Start new thread

        for (int i = 0; i < 1000; i++) {
            System.out.println("Task 2");
        }
    }
}

üß† Runnable is preferred in real-world Java apps because:
Java supports single inheritance ‚Üí extending Thread restricts class hierarchy
Runnable makes a class more flexible and reusable

üìå Key Differences: Thread vs Runnable
| Aspect           | `Thread` Class                          | `Runnable` Interface                       |
| ---------------- | --------------------------------------- | ------------------------------------------ |
| Inheritance      | Extends Thread                          | Implements Runnable                        |
| Flexibility      | Less flexible (no multiple inheritance) | More flexible (can extend other classes)   |
| Resource Usage   | More memory usage                       | Lightweight, better for large applications |
| Real-world usage | Less preferred                          | More commonly used in production           |

‚ö†Ô∏è Interview Traps & Questions:
Q: What if we call run() instead of start()?
It will not create a new thread ‚Äì the task runs on the main thread, defeating the purpose of threading.

Q: Why use Runnable over extending Thread?
Because Java does not support multiple inheritance, implementing Runnable allows extending another class.

Q: What is the difference between process and thread?
A process is an independent program with its own memory space; a thread is a unit of execution within a process.

Q: Is start() synchronous or asynchronous?
It is asynchronous ‚Äì after calling start(), JVM schedules thread to run separately from main thread.

‚úÖ Thread Synchronization in Java
‚û§Synchronization is the process of controlling access to shared resources by multiple threads in a multithreaded environment.
‚û§It ensures that only one thread can access the critical section (shared resource) at a time, preventing data inconsistency.

üîπ Why Synchronization is Needed?
In Java, threads run asynchronously (independently).

If two or more threads access the same data or object simultaneously, it can lead to race conditions and data corruption.

üî• Example Scenario:
balance = 0;

Thread 1 ‚Üí balance -= i;  (deducting)
Thread 2 ‚Üí balance += i;  (adding)
If both threads execute without coordination, the final balance will be incorrect.

üîπ Thread join() Method
join() is used to pause the current thread (main thread) until the target thread finishes execution.

This ensures that the main thread waits for the child threads to complete before proceeding.

‚úÖ Use Case:
t1.join(); // Main thread waits until t1 finishes
t2.join(); // Main thread waits until t2 finishes

üîπ Real-World Example:
‚ö†Ô∏è Without Synchronization

class A {
    int balance;

    public void add() {
        for (int i = 0; i <= 10000; i++) {
            balance -= i;
        }
    }

    public void sub() {
        for (int i = 0; i <= 10000; i++) {
            balance += i;
        }
    }

    public void account() {
        Thread t1 = new Thread(() -> add());
        Thread t2 = new Thread(() -> sub());

        t1.start();
        t2.start();

        try {
            t1.join();
            t2.join();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        A a1 = new A();
        a1.account();
        System.out.println(a1.balance);  // May print incorrect result due to race condition
    }
}

‚úÖ With Synchronization
class A {
    int balance;

    public synchronized void add() {
        for (int i = 0; i <= 10000; i++) {
            balance -= i;
        }
    }

    public synchronized void sub() {
        for (int i = 0; i <= 10000; i++) {
            balance += i;
        }
    }

    public void account() {
        Thread t1 = new Thread(() -> add());
        Thread t2 = new Thread(() -> sub());

        t1.start();
        t2.start();

        try {
            t1.join();
            t2.join();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        A a1 = new A();
        a1.account();
        System.out.println(a1.balance); // Always 0 if synchronized correctly
    }
}

üîπ Meaning of synchronized Keyword
‚û§ The synchronized keyword tells the JVM to acquire a lock on the current object before entering the method.
‚û§ Only one thread can hold the lock at a time ‚Üí other threads are blocked until the lock is released.

üîê How Lock Works:
1. Every object in Java has an intrinsic lock (monitor).
2. When a thread enters a synchronized method, it acquires the lock for that object.
3. After the method is complete, the lock is released.

üîπ Interview-Level Questions
Can two threads execute two different synchronized methods of the same object at the same time?
No. If both methods are synchronized and belong to the same object, one thread must wait.

What happens if you don‚Äôt use synchronization in shared data scenarios?
Unpredictable results ‚Äì race conditions, incorrect values, or crashes.

Can synchronization be done on a block instead of a method?
Yes! Use synchronized block to lock only the critical part of the method (better performance):
synchronized(this) {
   // critical section
}

Is join() used for synchronization?
Not directly. join() is for waiting, not for data safety.
Use join() to make sure threads finish before the main thread proceeds.

‚úÖ wait(), notify(), notifyAll() in Java
##########################################
These are methods of the Object class, not the Thread class.

Why? Because every object in Java has a monitor (lock), and these methods are used to control thread communication on an object's lock.

| Method        | Purpose                                                                                      |
| ------------- | -------------------------------------------------------------------------------------------- |
| `wait()`      | Causes the **current thread** to wait until another thread calls `notify()` or `notifyAll()` |
| `notify()`    | Wakes up **one waiting thread** (chosen arbitrarily) on the object's monitor                 |
| `notifyAll()` | Wakes up **all waiting threads** on the object's monitor                                     |

üîπ Why Use wait() / notify()?
Used when:
Threads need to communicate or coordinate their execution
For example, producer-consumer problems, or when a thread must pause until another completes

üîπ ‚ö†Ô∏è Important Rules for Using wait() / notify()
| Rule                                                                | Description                                          |
| ------------------------------------------------------------------- | ---------------------------------------------------- |
| Must be called inside `synchronized` block/method                   | Otherwise, you'll get `IllegalMonitorStateException` |
| Must be called on the **object** whose monitor you're synchronizing |                                                      |
| `wait()` releases the lock temporarily, `notify()` does not         |                                                      |
üîπ üîç Wrong Example (Race Condition)
class A {
    public static void main(String[] args) {
        B b1 = new B();
        b1.start();
        System.out.println(b1.balance); // ‚ùå Likely prints 0 ‚Äî race condition!
    }
}

class B extends Thread {
    int balance;
    public void run() {
        for (int i = 0; i <= 10000; i++) {
            balance += i;
        }
    }
}
‚ùå Problem:
main() prints balance before run() finishes.
No synchronization or communication between threads.

‚úÖ Correct Way with wait() and notify()
class A {
    public static void main(String[] args) {
        B b1 = new B();
        b1.start();

        synchronized (b1) {
            try {
                b1.wait();  // Main thread waits for notification from b1
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        System.out.println("Final balance: " + b1.balance);  // ‚úÖ Correct value
    }
}

class B extends Thread {
    int balance;

    public void run() {
        synchronized (this) {
            for (int i = 0; i <= 10000; i++) {
                balance += i;
            }
            this.notify(); // Wakes up the main thread waiting on this object
        }
    }
}

üîπ When to Use notifyAll() Instead of notify()?
Use notifyAll() when:
Multiple threads are waiting for different conditions
You‚Äôre not sure which thread should continue ‚Äî let the scheduler decide

‚úÖ wait() + notifyAll() Example:
class Shared {
    void printMessage() {
        synchronized (this) {
            System.out.println(Thread.currentThread().getName() + " is waiting...");
            try {
                wait(); // thread goes into waiting state
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + " is resumed.");
        }
    }
}

class MyThread extends Thread {
    Shared shared;

    MyThread(Shared shared, String name) {
        super(name);
        this.shared = shared;
    }

    public void run() {
        shared.printMessage();
    }
}

public class NotifyAllSimple {
    public static void main(String[] args) throws InterruptedException {
        Shared shared = new Shared();

        MyThread t1 = new MyThread(shared, "Thread-1");
        MyThread t2 = new MyThread(shared, "Thread-2");

        t1.start();
        t2.start();

        Thread.sleep(1000); // Allow both threads to call wait()

        synchronized (shared) {
            System.out.println("Main thread is calling notifyAll...");
            shared.notifyAll(); // wake up both t1 and t2
        }
    }
}

üü¢ Output:
Thread-1 is waiting...
Thread-2 is waiting...
Main thread is calling notifyAll...
Thread-2 is resumed.
Thread-1 is resumed.

Note: The order in which resumed threads are executed may change depending on the JVM.

üü¢ Thread Life Cycle
######################



