What is a class?
-> A class in Java is a blueprint or template for creating objects.
-> It defines the data (fields/attributes) and the behavior (methods/functions) that the objects created from the class will have.
-> Class helps us to create objects in Java.

Class Naming Convention
#######################
-> In Java, we use the class keyword to create a class, and the class keyword should be in lowercase. The class name should start with an uppercase letter only.
-> If more than one word is used, then we should use camel casing.

Note: class name cannot start with a number but can begin with $ or underscore(_), but it is not recommended.

Example :
class A {}
-> We define the boundary of a class using curly brackets.
  
Example :
-> Will execute without any error
public class Bank_Account_Number {}  // Snake Casing-->Should not use for Java

Note:
1. Do not use specials characters like #,@ % & etc while creating class.
2. $Class name will execute. But never create a class with a special character $.

new keyword:
##############
The new keyword in Java is used to create objects (instances) of a class. 
-> Using the new keyword, we send a request to the class to create an object
-> Once the object is created new keyword will get the object's address and store that in a reference variable.

Syntax to create an object:
-------------------------
ClassName variableName = new ClassName();

Note:
Two types of camel casing:
a. Upper Case Camel Casing: Used for naming class, interface, abstract class, etc
b. Lower Case Camel Casing: Used for creating methods, variables, etc
_______________________________________________________________________ 

Non-static Variable/ Instance Variable /Object Variables
#########################################################
It is a variable declared inside a class, but outside any method, and without the static keyword.
ðŸ“Œ It belongs to:
An instance of the class (not the class itself)
Every object has its copy

1. We should create non non-static variable inside a class outside a method without using the static keyword.
2. Without creating an object, we cannot access non non-static variable.

Example :
public class A {
	int x = 10;
	int y = 20;
  int z;
	public static void main(String[] args) {
		A a1 = new A();
		System.out.println(a1.x); // Output :10
		System.out.println(a1.y); // Output :20

    A a2 = new A();
		System.out.println(a2.x); // Output :10
    System.out.println(a2.z); // Output :0 //default value of int is 0
	}
}
3. Every time we create an object non-static variable copy is loaded into that object.
4. A copy of the variable in this object is different. That is, if you change the value of a variable in one object, those changes cannot be seen in another object.
5. It is mandatory to initialize a non-static variable. Depending on the data type, automatically default value will be automatically stored in it.

Static variables:
#################
->A static variable is a class-level variable, meaning:
->It belongs to the class, not the object.
->It is shared among all instances of the class.
->Only one copy exists in memory, regardless of how many objects are created.

1. We should create static variables inside a class but outside a method with the static keyword
2. To access a static variable, we will use below options:
a. ClassName.variableName
b. variableName (Constraints)
c. objectAddress.variableName (Wrong Approach, but will work)

Example:
---------------
public class A {
	static int x=10 ;
	public static void main(String[] args) {
		System.out.println(A.x);// Output :10
		System.out.println(x);// Output :10
    
		//Wrong
		A a1 = new A();
		System.out.println(a1.x);//A.x, but will give the Output:10
                A.x = 30;
		System.out.println(A.x); //Ouput :30 
  }
}

Types of variables in Java
############################

1. Local Variable
######################
a. Local variables should be created inside methods
b. We should use local variables within the created method only
c. Without initialization, if you are using a local variable, you will get an error.
  
Example 1:
---------
public class A {
	static int y=10;
	public static void main(String[] args) {
		int x = 100;
		System.out.println(x);
    		System.out.println(A.y);// Output :10
		A a1 = new A();
         	a1.test();
    		System.out.println(y);//Error
	}
	public void test() {
        int z=100;
	System.out.println(x);//Error because it is not present in this method
        System.out.println(z); //Correct
        System.out.println(A.y);
	}
}

2. Static variable
3. Non-static variable/instance variable

4. Reference Variable
#####################
A reference variable in Java is a variable that stores the memory address (reference) of an object, not the actual object itself.
a. Can hold either an Object address or a null value
b. The datatype of the reference variable is the class 

Example :
----------
In the below example, "a1" is created inside main, and hence it is a local variable. We cannot access that outside the main method

Note: If we do not initialize a static reference variable, then by default null value will be stored in it.
  
public class A {
	static A a4;  //null
	public static void main(String[] args) {
		A a1 = null;
		A a2 = new A();
    		A a3;
    		System.out.println(a3);// Error because "a3" is local variable and not initialized   
	}
  	public void test() {
		System.out.println(a1);//Error
	}
}

ðŸ§± Stack Memory â€“ LIFO (Last In First Out)
###########################################
Stores:
Method calls,
local variables,
and reference variables (not actual objects).

->Memory is automatically managed (pushed and popped as methods are called or returned).
->Operates in LIFO (Last-In, First-Out) order, where the last is the first one to return.
->Faster but limited in size.

ðŸ§  Example:
When a method is called, its variables go on the stack. When it returns, theyâ€™re removed.

ðŸ—ƒï¸ Heap Memory
################
Used to store objects and instance variables.
Every time you do new ClassName(), it creates an object in the heap.
Objects stay in memory until they're no longer referenced.

ðŸ“ Note: All reference variables (in the stack) point to objects in the heap.

ðŸ—‘ï¸ Garbage Collector (GC)
##########################
Javaâ€™s automatic memory management tool.
Runs in the background and:
1. Detects objects in the heap no longer referenced
2. Removes them to free memory
3. Helps prevent memory leaks and overflow

ðŸ“Œ You donâ€™t have to manually delete objects â€” GC handles it.

methods in java
###############
1. void keyword: A void method cannot return any value

Example :
----------
public class C {
	public static void main(String[] args) {
		C c1 = new C();
		int x = c1.test1(); //Error
    		int y= c1.test2();
		System.out.println(y);// Output :100
	}
	public void test1() {
		return 100;//Error
 	 }
	public int test2() {
		return 100;
  	}
}

return without value vs return value in Java
#############################################
The difference between return and return value lies in what you're returning and why.

return without value keyword:
-----------------------------
-> A method has to be void
-> It is optional
-> It will return control to the method calling statement

Note: If we write code after the return keyword, then that code will 100% not run. This error is called an unreachable code error

Example:
public class C {
	public static void main(String[] args) {
	  C c1 = new C();
	  c1.test();
	}
	
	public void test() {
	      System.out.println(100);
	      return;
	      System.out.println(200);
	}
}
Output: unreachable code error

returning "value"
-----------------
-> The method has to be non-void
-> It is mandatory to use a return "value" statement inside a non-void method
-> It will return control and value to the method calling statement

public class C {
	public static void main(String[] args) {}
	public int test1() {}// Error
  	public int test2() {
		return 100; 
		System.out.println(300);// Unreachable code error
	}
}

Method Arguments
##################
-> Using method arguments, we supply values to the method when we call it
-> The method argument is a local variable
-> Arguments inside the method values that you supply to the method should match

Example:
-------
public class C {
	public static void main(String[] args) {
	 C c1 = new C();
    	 C c2 = new C();
	 c1.test1(100);
    	 c2.test2(100,"mike");
	}
	
	public void test1(int x) {
	  System.out.println(x);
	}
  public void test2(int x,String y) {
	  System.out.println(x);
	}
}

Note: When the method argument type is Object, then we can supply any kind of value to it

public class C {
	public static void main(String[] args) {
	  C c1 = new C();
	  c1.test('a');
	}
	public void test(Object x) {
	   System.out.println(x);
	}
}

Using Varargs (Variable Arguments)
##################################
Example 2:
public class C {
	public static void main(String[] args) {
	  C c1 = new C();
	  c1.test("mike",100,200,300,400);
	}
	
	public void test(String y, int... x) { 
		System.out.println(x[0]);// Output :100
		System.out.println(x[1]);// Output :200
		System.out.println(x[2]);// Output :300
		System.out.println(x[3]);// Output :400
		System.out.println(y);// Output :mike
	}
}

Static Methods in Java
######################
A static method belongs to the class, not to instances (objects) of the class.
This means you can call a static method without creating an object of that class.
public class C {
	public static void main(String[] args) {
	    C.test1();// Output :599
    	    int x =  C.test2();
	    System.out.println(x);// Output :100  
	}
	public static void test1() {
		System.out.println(599);
	}
  public static int test2() {
		return 100;
	}
}  

Java Data Types 
################
Java data types are divided into 2 main categories:

ðŸ”¹ 1. Primitive Data Types (8 types)
-------------------------------------
Built-in, fixed-size types that store actual values directly.

ðŸ”¸ Integer Types (for whole numbers)
--------------------------------------
Type	       Size     	Default Value	      Range
byte	       1 byte	            0	              -128 to 127
short	       2 bytes	   	    0	              -32,768 to 32,767
int	       4 bytes	            0	              -2,147,483,648 to 2,147,483,647
long           8 bytes	            0	              -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807

ðŸ”¸ Floating Point Types (for decimals)
----------------------------------------
Type	    Size	      Default Value	        Range
float	    4 bytes	      0.0f	              Â±3.40282347E+38F (single-precision)
double	  8 bytes	      0.0d	              Â±1.79769313486231570E+308 (double-precision)

Find the size of the datatype
#########################
Example:
public class Main {
    public static void main(String[] args) {
        System.out.println("Size of int in bytes: " + Integer.BYTES);
        System.out.println("Size of int in bits: " + Integer.SIZE);
    }
}

ðŸ”¸ Other Primitive Types
-----------------------------
Type	    Size	            Default Value	          Description
boolean	    (JVM dependent)	    false                   Only true or false
char	    2 bytes	            ' ' (blank)	            0 to 65,535 (Unicode characters)

ðŸ”¹ 2. Non-Primitive / Reference Data Types
---------------------------------------------
Type	               Description	                        Default Value
String	        A class (sequence of characters)	          null
Arrays	        Object that holds multiple values	          null
Custom Classes	User-defined types	                          null

ðŸ“Œ Notes:
String is not a primitive type, but a class in java.lang package.
All reference types default to null.
->Use long literals with L or l: long x = 123456789L;
->Use float literals with F or f: float y = 3.14F;

A new type was introduced in Java version 10
---------------------------------------
var type
#########
-> This was introduced in Java version 10
-> It gives a dynamic datatype concept. Depending on the value stored inside the variable, the datatype is allocated to it internally.

Example:
public class C {
	public static void main(String[] args) {
		var x1 =100;
		var x2 =100.3;
		var x3 ="mike";
		var x4 =new C();
		System.out.println(x1);
		System.out.println(x2);
		System.out.println(x3);
		System.out.println(x4);
	}
  public var test(var x3) {}//Error
}
-> var type can only be a local variable
-> It cannot be a static / non-static variable
-> It cannot be a method argument
-> It cannot be a method return type

Constructors in Java
Constructors are special methods used to initialize objects when they are created.

ðŸ”¹ Basic Rules:
âœ… Constructor name must match the class name
âŒ It is not void by default
Constructors do not have a return type, not even void
If you write void before a constructor, it becomes a method, not a constructor

Example 1:
----------
public class C {
	C(){
		System.out.println(100);//will execute successfully Output :100
		return 100;//Error
	}
	public static void main(String[] args) {
		C c1 = new C();
	}	
}

Note :
-> Method name can be the same as the class name
-> Variable name can be the same as the class name

ðŸ” Constructor Overloading in Java
####################################
Constructor Overloading means having more than one constructor in the same class, but with different parameter lists.

âœ… Why Use Constructor Overloading?
To create objects with different levels of information or default values, depending on whatâ€™s available.

Example:
--------
public class A {
	A(){//NoofArgs=0
		System.out.println("A");
	}
	A(int x){//NoofArgs=1
		System.out.println(x);
	}
	A(int x,int y){//NoofArgs=2
		System.out.println(x);
		System.out.println(y);
	}
	public static void main(String[] args) {
		A a1 = new A();
		A a2  = new A(100);
		A a3 = new A(200,300);
	}
}

ðŸ”· this keyword in Java
#############################
The this keyword in Java is a reference variable that refers to the current object â€” the object whose method or constructor is being executed.

âœ… Uses of this Keyword
1. Differentiate Between Instance and Local Variables
------------------------------------------------------
When local variable names are the same as instance variables, use this to refer to the instance variable.

class Student {
    String name;
    Student(String name) {
        this.name = name;  // 'this.name' is the instance variable, 'name' is the parameter
    }
}

2. Call One Constructor from Another (Constructor Chaining)
------------------------------------------------------------
Use this() to call another constructor within the same class.

class Student {
    String name;
    int age;

    Student(String name) {
        this(name, 18);  // calls the second constructor
    }

    Student(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
3. Pass Current Object as Argument
-----------------------------------
class Student {
    void display() {
        Helper.printStudent(this);  // pass current object
    }
}
class Helper {
    static void printStudent(Student s) {
        System.out.println("Student object: " + s);
    }
}

4. Return Current Object
---------------------------
Useful in method chaining.

class Person {
    Person setName(String name) {
        // set name
        return this;  // return current object
    }

    Person setAge(int age) {
        // set age
        return this;
    }
}

5. Access Instance Methods and Variables
-----------------------------------------
You can use this to call other instance methods or access fields within the class explicitly.

void print() {
    this.show();  // same as just calling show()
}

void show() {
    System.out.println("Hello");
}
-> this keyword is a special reference variable that hold's object's address
Example:
----------
public class A {
	public static void main(String[] args) {
		A a1 = new A();
		System.out.println(a1);
		a1.test();
	}
	public void test() {
		System.out.println(this);
	}
}

-> Using this keyword, we can access non-static members of the class
Example:
--------
public class A {
	int x = 10;
	public static void main(String[] args) {
		A a1 = new A();
		System.out.println(a1.x);
		a1.test();
	}
	public void test() {
		System.out.println(this.x);
	}
}

-> We cannot use this keyword inside a "static method"
public class A {
	public static void main(String[] args) {
		A a1 = new A();
		System.out.println(this);//Error
	}
	public static void test() {
		System.out.println(this);//Error
	}
}

Example:
-------
public class A {
	int x = 10;
	int y = 10;
	public static void main(String[] args) {
		A a1 = new A();
		a1.test();
	}
	public void test() {
		System.out.println(this.x);
		System.out.println(this.y);
	}
}

-> this keyword hold's current object address that is executing

Example:
--------
public class A {
	public static void main(String[] args) {
		A a1 = new A();
		a1.test();
		A a2 = new A();
		a2.test();
		a1.test();
		
	}
	public void test() {
		System.out.println(this);
	}
}

this()- This syntax is used to call the constructor
--------------------------------------------
-> Using this() keyword, we can call a constructor

Example:
-------
public class A {
	A(){
		System.out.println("A");
	}
	A(int x){
		this();
	}
	public static void main(String[] args) {
	   A a1 = new A(100);
	}	
}

-> While calling a constructor using this() keyword, ensure calling is done from another constructor
Example:
--------
public class A {
	A(){
		System.out.println("A");
	}
	A(int x){
		this();
	}
	public static void main(String[] args) {
	   A a1 = new A(100);
	}
	public void test() {
		this();//Error, we cannot call the constructor from a method
	}	
}

Example:
---------
public class A {
	A(int x){
		System.out.println(x);
	}
	A(){
		this(100);
	}
	public static void main(String[] args) {
	   A a1 = new A();
	}	
}

-> While calling a constructor using this() keyword, ensure it is alwaysthe  first statement inside another constructor

Example:
---------
public class A {
	A(int x){
		System.out.println(x);
	}
	A(){
		System.out.println(200);
		this(100);//Error because it cannot be the second statement while calling the constructor	
	}
	public static void main(String[] args) {
	   A a1 = new A();
	}	
}

Example:
---------
public class A {
	int x;//-->0
	A(int x){////Step 4-->x=100
		this.x=x;//Step 5
		System.out.println(this.x);//Step 6===>100
	}
	A(){//Step 2
		this(100);//Step 3
	}
	public static void main(String[] args) {
	   A a1 = new A();//Step 1
	}	
}

âœ… Types of Constructor Chaining
-> When we call one constructor from another constructor it will form chain like flow structure. This is called constructor chaining
ðŸ”¸ 1. Within the Same Class â†’ Use this()
You can use this() to call another constructor in the same class.

âœ… Example:
class Student {
    String name;
    int age;

    Student() {
        this("Unknown", 18);  // calls 2-arg constructor
        System.out.println("Default constructor called");
    }

    Student(String name) {
        this(name, 18);  // calls 2-arg constructor
    }

    Student(String name, int age) {
        this.name = name;
        this.age = age;
        System.out.println("Parameterized constructor called");
    }

    void display() {
        System.out.println("Name: " + name + ", Age: " + age);
    }
}
â–¶ï¸ Output:
The parameterized constructor called  
The default constructor is called  
ðŸ”¸ 2. From Subclass to Superclass â†’ Use super()
You can call a constructor from the parent class using super().

âœ… Example:
class Person {
    Person() {
        System.out.println("Person constructor");
    }
}

class Student extends Person {
    Student() {
        super(); // calls Person constructor
        System.out.println("Student constructor");
    }
}

âš ï¸ Rules of Constructor Chaining
Rule	Description
âœ… Only one constructor can be called using this() or super()	
âœ… Must be the first statement in the constructor	
âŒ Cannot mix this() and super() in the same constructor

###############################
Important Shortcuts in Eclipse
################################
1. Ctrl + Space:âš¡ Content Assist â€” suggests code completions.
2. Ctrl + 1: ðŸ’¡ Quick fix â€” suggests solutions for errors or warnings.
3. Ctrl + O: ðŸ§­ Quick outline â€” shows methods/fields of the current class.
4. F3: ðŸ”„ Go to the declaration of a variable, method, or class.
5. Ctrl + . : âž¡ï¸ Jump to the next error or warning in the file.

ðŸ“¦ Packages in Java
####################
A package in Java is a namespace that organizes classes and interfaces into a structured folder system, making code modular, reusable, and easy to manage.

c. Naming Convention for packages
----------------------------------
-> Package name cannot be ka eyword like - new, static, public, etc...
-> Do not start the package name with capital letters
-> Package name not to be given as java

d. When you create a class inside a package, you have to define the package keyword in your program as shown below:
Example:
package p1;
public class A {}

e. Create 2 classes in the same package and perform inheritance. Import is not required.
Example:
package p1;
public class A {}

package p1;
public class B extends A {}

f. Create 2 classes in different packages and perform inheritance. "Import required".
Example:
package p1;
public class A {}

package p2;
import p1.A;
public class C extends A{}

----------------------------------------------------------
Example:
package p1;
public class A {}

package p2;
public class C {}

package p1;
import p2.C;
public class B {
	public static void main(String[] args) {
		A a1 = new A();
		C c1 = new C();
	}
}
---------------------------------------
Example:
package p1;
public class A {}

package p1;
public class B {}

package p2;
import p1.*;
public class C {
	public static void main(String[] args) {
		A a1 = new A();
		B b1 = new B();
	}
}
--------------------------------
Example:
package p1;
public class A {}

package p2;
public class A {}

package p3;
public class B {
	public static void main(String[] args) {
		p1.A a1 = new p1.A();//---> p1
		p2.A a2 = new p2.A();//---> p2
	}
}
---------------------------------------
#######################################
Object Oriented Programming -  Pillars
########################################

a. inheritance
b. polymorphism
c. encapsulation
d. abstraction

a. inheritance
######################
Inheritance is one of the core pillars of Object-Oriented Programming (OOP).
It allows a class (subclass) to inherit fields and methods from another class (superclass).

âœ… Why Use Inheritance?
Code reusability
Improves maintainability
Supports method overriding & polymorphism

Example :
package app_java_1;
public class Animal {
	public void eat() {
		System.out.println("Eating");
	}
	public void sleep() {
		System.out.println("sleeping");
	}
}

package app_java_1;
public class Dog extends Animal{
	//eat(),sleep()--->Animal
}

package app_java_1;
public class Cow extends Animal{
	//eat(),sleep()--->Animal
}

package app_java_1;
public class Root {
	public static void main(String[] args) {
		Dog d = new Dog();
		d.eat();
		d.sleep();
		System.out.println("_______");
		Cow cow = new Cow();
		cow.eat();
		cow.sleep();
	}
}

Example 3: Multilevel inheritance
-----------------------------------

package app_java_1;
public class A {
	public void test1() {
		System.out.println(1);
	}
}
package app_java_1;
public class B extends A{
	public void test2() {
		System.out.println(2);
	}
}
package app_java_1;
public class C extends B{
	public static void main(String[] args) {
		C c1 = new C();
		c1.test1();//Output :1
		c1.test2();//Output :2
	}
}

------------------------------------------------------------------------------
################################################################################################
What is multiple inheritance?
Answer: When a child class has more than one parent class, it is called multiple inheritance
################################################################################################

Note: Java classes do not support multiple inheritance because of the diamond problem.

 Diamond Problem in Java (Multiple Inheritance Problem)
---------------------------------------------------------
The Diamond Problem occurs in multiple inheritance when a class inherits from two classes that have a common superclass, leading to ambiguity about which method to inherit.

Suppose we inherit a method from A->B->D,  and the Same method is inherited from A->C->D, then confusion arises from which parent class method is inherited by the child class D. This is called as DIAMOND PROBLEM. Hence in java classes does not support multiple inheritance.

Note: We can do mulitple inheritance on interface.

Example: Multiple inheritance error
------------------------------------------
package app_java_1;
public class A {}

package app_java_1;
public class B{}

package app_java_1;
public class C extends A, B{//Error
	
}

###############################
Access Specifiers in Java
###############################

| Access Context                | `public` |         `protected`          | `default` (no modifier)   | `private`  |
| ------------------------------| :------: | :------------------------:   | :---------------------:   | :-------:  |
| Same Class                    |     âœ…   |              âœ…             |            âœ…            |     âœ…     |
| Same Package                  |     âœ…   |              âœ…             |            âœ…            |     âŒ     |
| Subclass in Same Package      |     âœ…   |              âœ…             |            âœ…            |     âŒ     |
| Non-Subclass in Same Package  |     âœ…   |              âœ…             |            âœ…            |     âŒ     |
| Subclass in Other Package     |     âœ…   | âœ… *(via inheritance only)* |            âŒ            |     âŒ     |
| Non-Subclass in Other Package |     âœ…   |              âŒ             |            âŒ            |     âŒ     |

a. private: When a variable/method is made private, then we can access that in the same class but not outside the class

b. default: A variable/method with default access specifier can work only inside the same class or the same package, but cannot be accessed in a different package

c. protected: We can access variables/methods in the same class/same package, and inside different packages only when inheritance is done

d. public: When we make a variable/method public, then we can access that in the same class/the same package/different package

########################################################
Access Specifier on Constructors
#######################################################

Can we inherit the Constructor?
Answer: We cannot inherit the constructor

ðŸ” Private Constructor in Java
A private constructor is a constructor that cannot be accessed outside its class.

âœ… Why Use a Private Constructor?
âŒ Prevent object creation	        for utility or helper classes
âœ… Implement Singleton Pattern		Ensure only one instance is created
ðŸ” Hide object instantiation		Force object creation through factory methods
-> If a constructor is made private, then its object cannot be created outside the class.

Example :
package p1;
public class A {
	private A() {}
	public static void main(String[] args) {
		A a1 = new A();
	}
}
package p1;
public class B {
	public static void main(String[] args) {
		A a1 = new A();//--->Error
	}
}
package p2;
import p1.A;
public class C {
	public static void main(String[] args) {
		A a1 = new A();//-->Error
	}
}
-> When a constructor is made private, then inheritance of that class is not allowed
(Note: Constructs are not inherited)

Example 2:
----------
package p1;
public class A {
	private A() {}	
}

package p1;
public class B extends A{//-->Error	
}

package p2;
import p1.A;
public class C extends A{//-->Error	
}


ðŸ—ï¸ Default Constructor in Java
################################
A default constructor is a no-argument constructor that the Java compiler automatically provides if you do not define any constructors in your class.

âœ… Key Features:
Feature					Description
No parameters. 				Takes zero arguments
Provided automatically			Only if no constructor is defined by the user
Initializes variables,			sets fields to default values (e.g., 0, null)
Used for object creation		Allows creation of objects without parameters
-> If a constructor is made default, then its object can be created in the  same class/same package, but not outside the package.

Example 1:
----------
package p1;
public class A {
	A() {}
	public static void main(String[] args) {
		A a1 = new A();
	}
}
package p1;
public class B {
	public static void main(String[] args) {
		A a1 = new A();
	}
}
package p2;
import p1.A;
public class C{
	public static void main(String[] args) {
		A a1 = new A();//-->Error
	}
}

-> When a constructor is made default, then inheritance of that class is allowed only in the same package, but not outside the package

Example 2:
----------
package p1;
public class A {
	A() {}
}
package p1;
public class B extends A {}

package p2;
import p1.A;
public class C extends A{//-->Error	
}

ðŸ” Protected Constructor in Java
#################################
A protected constructor means the constructor can only be accessed:

âœ… Within the same package
âœ… From subclasses (even in other packages)

âœ… Why Use a Protected Constructor?
->To restrict object creation outside the package
->To allow subclassing but prevent direct instantiation from unrelated classes
->Often used in inheritance-based designs, frameworks, or abstract factories

Example 1:
---------
package p1;
public class A {
	protected A() {}
	public static void main(String[] args) {
		A a1 = new A();
	}
}

package p1;
public class B  {
	public static void main(String[] args) {
		A a1 = new A();
	}
}

package p2;
import p1.A;
public class C {
	public static void main(String[] args) {
		A a1 = new A();//-->Error
	}
}
-> When a constructor is made protected, then inheritance of that class is  allowed inthe  same package / outside the package (both)
(Note: Constructors are not inherited)

Example 2:
----------
package p1;
public class A {
	protected A() {}
}

package p1;
public class B extends A {}

package p2;
import p1.A;
public class C extends A {}

e. public Constructor
------------------------
-> If a constructor is made public, then its object can be created in the same class/same package and outside the package also

Example 1:
---------
package p1;
public class A {
	public A() {}
	public static void main(String[] args) {
		 A a1 = new A();
	}
}

package p1;
public class B  {
	public static void main(String[] args) {
		 A a1 = new A();
	}
}

package p2;
import p1.A;
public class C  {
	public static void main(String[] args) {
		 A a1 = new A();
	}
}

-> When a constructor is made public, then inheritance of that class is  allowed in the same package / outside the package (both)
(Note: Constructors are not inherited)

Example 2:
----------
package p1;
public class A {
	public A() {}
}

package p1;
public class B extends A {}

package p2;
import p1.A;
public class C extends A {}

########################################
Access Specifier on Class
########################################
-> A class can be only public / default
-> A class cannot be private / protected




