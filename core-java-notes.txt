üß† What is OOP in Java?
Object-Oriented Programming (OOP) is a programming paradigm that organizes code using objects, which are instances of classes.
Java is a pure object-oriented language (except for primitive types) and is built entirely around the concept.
Properties (State) ‚Äì Data/attributes
Methods (Behavior) ‚Äì Functions/actions

üéØ Key Goals of OOPs:
‚û§Code reusability
‚û§Modularity
‚û§Data hiding and security
‚û§Scalability and maintainability

What is a class?
-> A class in Java is a blueprint or template for creating objects.
-> It defines the data (fields/attributes) and the behavior (methods/functions) that the objects created from the class will have.
-> Class helps us to create objects in Java.

Class Naming Convention
#######################
-> In Java, we use the class keyword to create a class, and the class keyword should be in lowercase. The class name should start with an uppercase letter only.
-> If more than one word is used, then we should use camel casing.

Note: Class names cannot start with a number, but they can begin with $ or an underscore (_), although this is not recommended.

Example :
class A {}
-> We define the boundary of a class using curly brackets.
  
Example :
-> Will execute without any error
public class Bank_Account_Number {}// Snake Casing-->Should not use for Java

Note:
1. Do not use specials characters like #,@ % & etc while creating class.
2. $Class name will execute. However, never create a class with a special character ($).

Breakdown of PSVM
###################
public static void main(String[] args)
It‚Äôs the starting point of any Java program, and each keyword has a specific purpose. Here's the full form and meaning of each part:

‚úÖ Detailed Breakdown:

1Ô∏è‚É£ public
‚û§It's an access modifier.
‚û§Makes the main method accessible by the JVM from outside the class.
‚û§If you make it private, JVM won‚Äôt be able to access it, and the program won‚Äôt run.

2Ô∏è‚É£ static
‚û§Means it belongs to the class, not the object.
‚û§JVM doesn‚Äôt create an object of the class to call main() ‚Äî it just calls it via the class name directly.
‚û§That‚Äôs why it must be static.

3Ô∏è‚É£ void
‚û§Specifies that the method does not return any value.
‚û§You can‚Äôt return anything from main() in standard Java execution.

4Ô∏è‚É£ main
‚û§This is the method name.
‚û§JVM looks specifically for a method with this name as the entry point to start program execution.

5Ô∏è‚É£ String[] args
Represents command-line arguments.
It is an array of Strings, which means you can pass values when running the program:

java MyProgram Hello World
Then args[0] = "Hello", args[1] = "World"

üîÅ JVM Looks for This Exact Signature:
public static void main(String[] args)
‚ö†Ô∏è If the signature is different (e.g., not public, not static, or missing parameters), the program will compile but not run, and you‚Äôll get a "Main method not found" error.

new keyword:
##############
The new keyword in Java is used to create objects (instances) of a class. 
-> Using the new keyword, we send a request to the class to create an object
Once the object is created, the new keyword will retrieve the object's address and store it in a reference variable.

Syntax to create an object:
-------------------------
ClassName variableName = new ClassName();

Note:
Two types of camel casing:
a. Upper Case Camel Casing: Used for naming class, interface, abstract class, etc
b. Lower Case Camel Casing: Used for creating methods, variables, etc
_______________________________________________________________________ 

Non-static Variable/ Instance Variable /Object Variables
#########################################################
It is a variable declared inside a class, but outside any method, and without the static keyword.
üìå It belongs to:
An instance of the class (not the class itself)
Every object has its copy
Without creating an object, we cannot access non-static variables.

Example :
public class A {
	int x = 10;
	int y = 20;
 	int z;
	public static void main(String[] args) {
		A a1 = new A();
		System.out.println(a1.x); // Output :10
		System.out.println(a1.y); // Output :20

    		A a2 = new A();
		System.out.println(a2.x); // Output :10
    		System.out.println(a2.z); // Output :0 //default value of int is 0
	}
}
3. Every time we create an object non-static variable copy is loaded into that object.
4. A copy of the variable in this object is different. That is, if you change the value of a variable in one object, those changes cannot be seen in another object.
5. It is not mandatory to initialize a non-static variable. Depending on the data type, the default value will be automatically stored in it.

Static variables:
#################
->A static variable is a class-level variable, meaning:
->It belongs to the class, not the object.
->It is shared among all instances of the class.
->Only one copy exists in memory, regardless of how many objects are created.

1. We should create static variables inside a class but outside a method with the static keyword
2. To access a static variable, we will use the following options:
a. ClassName.variableName

Example
public class Main {
    static int x = 10;
    public static void main(String[] args) {
        System.out.println(Main.x);  // ‚úÖ Recommended Output: 10
    }
}

b. Accessing via variableName directly (With Constraints)
Example
class A {
    static int x = 10;
    void show() {
        System.out.println(x); // ‚úÖ Works inside the same class
    }
}
‚úÖ Explanation:
‚û§You can directly use x without the class name only when:
‚û§You're inside the same class where the static variable is declared.
‚û§OR the static variable is imported statically (in some special cases).

This is allowed because the compiler understands the scope.

‚ùó Constraints:
‚û§This only works within the same class unless,
‚û§You use import static (less common).

üìå Example Without import static:
Example:

public class MyClass {
    public static int count = 42;
}

public class Test {
    public static void main(String[] args) {
        System.out.println(MyClass.count); // üëà Must use class name
    }
}

üìå Example with import static:
Example:

import static java.lang.Math.*;

public class Demo {
    public static void main(String[] args) {
        System.out.println(sqrt(16)); // instead of Math.sqrt(16)
        System.out.println(PI);       // instead of Math.PI
    }
}

Outside the class, you need to use either:
‚û§ClassName.x (best), or
‚û§object.x (works but discouraged).

c. objectAddress.variableName (Wrong Approach, but will work)
‚úÖ Explanation:
‚û§This works because the object refers to the class, and the static variable belongs to the class.
‚û§When you do a1.x, Java still resolves it as A.x internally.
‚û§But it's misleading because it looks like x is instance-specific when it's shared across all instances.

üîÅ Bonus Tip:
You can even do:

A a1 = null;
System.out.println(a1.x); // Still works!

Example:
---------------
public class A {
	static int x=10 ;
	public static void main(String[] args) {
		System.out.println(A.x);// Output :10
		System.out.println(x);// Output :10
    
		//Wrong
		A a1 = new A();
		System.out.println(a1.x);//A.x, but will give the Output:10
                A.x = 30;
		System.out.println(A.x); //Ouput :30 
  }
}

Types of variables in Java
############################

1. Local Variable
######################
a. Local variables should be created inside methods
b. We should use local variables within the created method only
c. Without initialization, if you are using a local variable, you will get an error.
  
Example 1:
---------
public class A {
	static int y=10;
	public static void main(String[] args) {
		int x = 100;
		System.out.println(x);
    		System.out.println(A.y);// Output :10
		A a1 = new A();
         	a1.test();
    		System.out.println(y);//Output: 10
	}
	public void test() {
        int z=100;
	System.out.println(x);//Error because it is not present in this method
        System.out.println(z); //Correct
        System.out.println(A.y);
	}
}

‚úÖ Interview question based on Local Variable

public class Test {
    public static void main(String[] args) {
        int x = 100;
        {
            int x = 200;
            System.out.println(x);
        }
    }
}

‚û§The code will give a compile-time error, but not because of creating a new scope ‚Äî that is allowed in Java.
The actual issue is:
‚û§You are declaring two local variables with the same name, x, in overlapping scopes.
‚û§Even though you're trying to redeclare int x = 200; in an inner block, Java does not allow hiding a local variable in an inner block with the same name.

Also:
Each method has its stack frame, and local variables are stored there, so naming conflicts like this are not allowed even in nested blocks.

2. Static variable
3. Non-static variable/instance variable

4. Reference Variable
#####################
A reference variable in Java is a variable that stores the memory address (reference) of an object, not the actual object itself.
a. Can hold either an Object address or a null value.
b. The datatype of the reference variable is the class. 

Example :
----------
In the below example, "a1" is created inside main, and hence it is a local variable. We cannot access that outside the main method

Note: If we do not initialize a static reference variable, then by default null value will be stored in it.
  
public class A {
	static A a4;  //null
	public static void main(String[] args) {
		A a1 = null;
		A a2 = new A();
    		A a3; // Reference Local Variable
    		System.out.println(a3);// Error because "a3" is local variable and not initialized   
	}
  	public void test() {
		System.out.println(a1);//Error
	}
}

üß± Stack Memory ‚Äì LIFO (Last In First Out)
###########################################
Stores:
‚û§Method calls,
‚û§local variables,
‚û§reference variables (not actual objects).

‚û§Memory is automatically managed (pushed and popped as methods are called or returned).
‚û§Operates in LIFO (Last-In, First-Out) order, where the last is the first one to return.
‚û§Faster but limited in size.

üß† Example:
When a method is called, its variables go on the stack. When it returns, they‚Äôre removed.

üóÉÔ∏è Heap Memory
################
‚û§Used to store objects/instance variables.
‚û§Every time you do new ClassName(), it creates an object in the heap.
‚û§Objects stay in memory until they're no longer referenced.

üìç Note: All reference variables (in the stack) point to objects in the heap.

üß† What is Garbage Collection in Java?
Garbage Collection is a process by which the Java Virtual Machine (JVM) automatically removes unused objects (objects that are no longer reachable) from memory to free up space and avoid memory leaks.

Java developers don‚Äôt manually free memory (unlike in C/C++). Instead, the Garbage Collector (GC) handles it.

üß© Key Goals of GC:
‚û§Reclaim memory used by unreachable objects
‚û§Prevent memory leaks
‚û§Keep the heap memory clean and efficient

üîÑ When Does GC Run?
‚û§GC runs automatically in the background.
‚û§It is non-deterministic ‚Äî you can't predict exactly when it will run.
‚û§You can suggest GC using System.gc(), but the JVM may ignore it.
‚û§Only Heap memory is subject to GC.

üîç Object Lifecycle in Java
1. The object is created using new
2. The reference variable holds the object
3. Once the reference is lost or goes out of scope, the object becomes unreachable
4. JVM marks it as garbage
5. GC reclaims that memory

Methods in Java
###############
1. void keyword: A void method cannot return any value

Example :
----------
public class C {
	public static void main(String[] args) {
		C c1 = new C();
		int x = c1.test1(); //Error
    		int y= c1.test2();
		System.out.println(y);// Output :100
	}
	public void test1() {
		return 100;//Error
 	 }
	public int test2() {
		return 100;
  	}
}

Return without value vs Return value in Java
#############################################
The difference between return and return value lies in what you're returning and why.

return without value keyword:
-----------------------------
‚û§A method has to be void
‚û§It is optional
‚û§It will return control to the method calling statement

Note: If we write code after the return keyword, then that code will 100% not run. This error is called an unreachable code error

Example:
public class C {
	public static void main(String[] args) {
	  C c1 = new C();
	  c1.test();
	}	
	public void test() {
	      System.out.println(100);
	      return;
	      System.out.println(200);
	}
}
Output: unreachable code error

Returning "value"
-----------------
‚û§The method has to be non-void.
‚û§It is mandatory to use a return "value" statement inside a non-void method
‚û§It will return control and value to the method calling statement

public class C {
	public static void main(String[] args) {}
	public int test1() {}// Error
  	public int test2() {
		return 100; 
		System.out.println(300);// Unreachable code error
	}
}

Method Arguments
##################
‚û§Using method arguments, we supply values to the method when we call it
‚û§The method argument is a local variable
‚û§Arguments inside the method values that you supply to the method should match

Example:
public class C {
	public static void main(String[] args) {
	 C c1 = new C();
    	 C c2 = new C();
	 c1.test1(100);
    	 c2.test2(100,"mike");
	}
	public void test1(int x) {
	  System.out.println(x);
	}
  public void test2(int x,String y) {
	  System.out.println(x);
	}
}

Note: When the method argument type is Object, then we can supply any kind of value to it.

Example
public class C {
	public static void main(String[] args) {
	  C c1 = new C();
	  c1.test('a');
	}
	public void test(Object x) {
	   System.out.println(x);
	}
}

Using Varargs (Variable Arguments)
##################################

Example:
public class C {
	public static void main(String[] args) {
	  C c1 = new C();
	  c1.test("mike",100,200,300);
	}
	public void test(String y,int... x) { 
		System.out.println(x[0]);// Output :100
		System.out.println(x[1]);// Output :200
		System.out.println(x[2]);// Output :300
		System.out.println(y);// Output :mike
	}
}

Static Methods in Java
######################
A static method belongs to the class, not to instances (objects) of the class.
This means you can call a static method without creating an object of that class.
public class C {
	public static void main(String[] args) {
	    C.test1();// Output :599
    	    int x =  C.test2();
	    System.out.println(x);// Output :100  
	}
	public static void test1() {
		System.out.println(599);
	}
  public static int test2() {
		return 100;
	}
}  

Java Data Types 
################
Java data types are divided into 2 main categories:

üîπ 1. Primitive Data Types (8 types)
-------------------------------------
Built-in, fixed-size types that store actual values directly.

üî∏ Integer Types (for whole numbers)
--------------------------------------
Type	       Size     	Default Value	      Range
byte	       1 byte	            0	              -128 to 127
short	       2 bytes	   	    0	              -32,768 to 32,767
int	       4 bytes	            0	              -2,147,483,648 to 2,147,483,647
long           8 bytes	            0	              -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807

üî∏ Floating Point Types (for decimals)
----------------------------------------
Type	    Size	      Default Value	        Range
float	    4 bytes	      0.0f	              ¬±3.40282347E+38F (single-precision)
double	    8 bytes	      0.0d	              ¬±1.79769313486231570E+308 (double-precision)

Find the size of the datatype
#########################
Example:
public class Main {
    public static void main(String[] args) {
        System.out.println("Size of int in bytes: " + Integer.BYTES);//4 INTEGER is a wrapper class of int (discussed later)
        System.out.println("Size of int in bits: " + Integer.SIZE);//32
    }
}

üî∏ Other Primitive Types
-----------------------------
Type	    Size	            Default Value	          Description
boolean	    (JVM dependent)	    false                   Only true or false
char	    2 bytes	            ' ' (blank)	            0 to 65,535 (Unicode characters)

üîπ 2. Non-Primitive / Reference Data Types
---------------------------------------------
Type	               Description	                        Default Value
String	        A class (sequence of characters)	          null
Array	        Object that holds multiple values	          null
Custom Classes	User-defined types	                          null

üìå Notes:
String is not a primitive type, but a class in java.lang package.
All reference types default to null.
‚û§Use long literals with L or l: long x = 123456789L;
‚û§Use float literals with F or f: float y = 3.14F;

A new type was introduced in Java version 10
---------------------------------------------
var type
#########
‚û§This was introduced in Java version 10
‚û§It is a dynamic datatype concept. Depending on the value stored inside the variable, the datatype is allocated to it internally.

Example:
public class C {
	public static void main(String[] args) {
		var x1 =100;
		var x2 =100.3;
		var x3 ="mike";
		var x4 =new C();
		System.out.println(x1);
		System.out.println(x2);
		System.out.println(x3);
		System.out.println(x4);
	}
  public var test(var x3) {}//Error
}

Properties and Constraints on the var keyword
--------------------------------------------
‚û§The var type can only be a local variable
‚û§It cannot be a static / non-static variable
‚û§It cannot be a method argument
‚û§It cannot be a method return type

Constructors in Java
####################
Constructors are special methods used to initialize objects when they are created.

üîπ Basic Rules:
The constructor name must match the class name
Constructors do not have a return type, not even void
If you write void before a constructor, it becomes a method, not a constructor

Example 1:
----------
public class C {
	C(){
		System.out.println(100);//will execute successfully Output :100
		return 100;//Error
	}
	public static void main(String[] args) {
		C c1 = new C();
	}	
}

Note :
‚û§Method, Variable name can be the same as the class name

üîÅ Constructor Overloading in Java
####################################
Constructor Overloading means having more than one constructor in the same class, but with different parameter lists.

‚úÖ Why Use Constructor Overloading?
To create objects with different levels of information or default values, depending on what‚Äôs available.

Example:
--------
public class A {
	A(){//NoofArgs=0
		System.out.println("A");
	}
	A(int x){//NoofArgs=1
		System.out.println(x);
	}
	A(int x,int y){//NoofArgs=2
		System.out.println(x);
		System.out.println(y);
	}
	public static void main(String[] args) {
		A a1 = new A();
		A a2  = new A(100);
		A a3 = new A(200,300);
	}
}

üî∑ This keyword in Java
##########################
This keyword in Java is a reference variable that refers to the current object ‚Äî the object whose method or constructor is being executed.

‚úÖ Uses of this Keyword
1. Differentiate Between Instance and Local Variables
------------------------------------------------------
When local variable names are the same as instance variables, use this to refer to the instance variable.

Example:
class Student {
    String name;
    Student(String name) {
        this.name = name;  // 'this.name' is the instance variable, 'name' is the parameter
    }
}

2. Call One Constructor from Another (Constructor Chaining)
-----------------------------------------------------------
Use this() to call another constructor within the same class.

Example:
class Student {
    String name;
    int age;
    Student(String name) {
        this(name, 18);  // calls the second constructor
    }
    Student(String name, int age) {
        this.name = name;
        this.age = age;
    }
}

3. Pass the Current Object as an Argument
-----------------------------------------
class Student {
    void display() {
        Helper.printStudent(this);  // pass current object
    }
}
class Helper {
    static void printStudent(Student s) {
        System.out.println("Student object: " + s);
    }
}

4. Return Current Object
---------------------------
Useful in method chaining.

class Person {
    private String name;
    private int age;

    Person setName(String name) {
        this.name = name; // Set name and return current object
        return this;
    }

    Person setAge(int age) {
        this.age = age; // Set age and return current object
        return this;
    }

    public static void main(String[] args) {
        Person p1 = new Person();
        
        // Method chaining in action
        p1.setName("Ankur").setAge(22).show();
    }
}

5. Access Instance Methods and Variables
-----------------------------------------
You can use this to call other instance methods or access fields within the class explicitly.

void print() {
    this.show();  // same as just calling show()
}

void show() {
    System.out.println("Hello");
}
‚û§This keyword is a special reference variable that hold's object's address

Example:
----------
public class A {
	public static void main(String[] args) {
		A a1 = new A();
		System.out.println(a1);
		a1.test();
	}
	public void test() {
		System.out.println(this);
	}
}

‚û§Using this keyword, we can access non-static members of the class

Example:
--------
public class A {
	int x = 10;
	public static void main(String[] args) {
		A a1 = new A();
		System.out.println(a1.x);
		a1.test();
	}
	public void test() {
		System.out.println(this.x);
	}
}

‚û§We cannot use this keyword inside a "static method"
public class A {
	int x=10;
	public static void main(String[] args) {
		A a1 = new A();
		System.out.println(this);//Error
	}
	public static void test() {
		System.out.println(this);//Error
		System.out.println(this.x);// Output: 10
	}
}

‚û§This keyword hold's current object address that is executing

Example:
--------
public class A {
	public static void main(String[] args) {
		A a1 = new A();
		a1.test();
		A a2 = new A();
		a2.test();
		a1.test();	
	}
	public void test() {
		System.out.println(this);
	}
}

this()- This syntax is used to call the constructor
--------------------------------------------
‚û§Using this() keyword, we can call a constructor

Example:
-------
public class A {
	A(){
		System.out.println("A");
	}
	A(int x){
		this();
	}
	public static void main(String[] args) {
	   A a1 = new A(100);
	}	
}

‚û§While calling a constructor using this() keyword, ensure calling is done from another constructor
Example:
--------
public class A {
	A(){
		System.out.println("A");
	}
	A(int x){
		this();
	}
	public static void main(String[] args) {
	   A a1 = new A(100);
	}
	public void test() {
		this();//Error, we cannot call the constructor from a method
	}	
}

Example:
---------
public class A {
	A(int x){
		System.out.println(x);
	}
	A(){
		this(100);
	}
	public static void main(String[] args) {
	   A a1 = new A();
	}	
}

‚û§While calling a constructor using this() keyword, ensure it is always the  first statement inside another constructor

Example:
---------
public class A {
	A(int x){
		System.out.println(x);
	}
	A(){
		System.out.println(200);
		this(100);//Error because it cannot be the second statement while calling the constructor	
	}
	public static void main(String[] args) {
	   A a1 = new A();
	}	
}

Example:
---------
public class A {
	int x;//-->0
	A(int x){////Step 4-->x=100
		this.x=x;//Step 5
		System.out.println(this.x);//Step 6===>100
	}
	A(){//Step 2
		this(100);//Step 3
	}
	public static void main(String[] args) {
	   A a1 = new A();//Step 1
	}	
}

‚úÖ Types of Constructor Chaining
‚û§When we call one constructor from another constructor, it will form a chain-like flow structure. This is called constructor chaining.
üî∏ 1. Within the Same Class ‚Üí Use this().
You can use this() to call another constructor in the same class.

‚úÖ Example:
class Student {
    String name;
    int age;
    Student() {
        this("Unknown", 18);  // calls 2-arg constructor
        System.out.println("Default constructor called");
    }

    Student(String name) {
        this(name, 18);  // calls 2-arg constructor
    }

    Student(String name, int age) {
        this.name = name;
        this.age = age;
        System.out.println("Parameterized constructor called");
    }

    void display() {
        System.out.println("Name: " + name + ", Age: " + age);
    }
}
‚ñ∂Ô∏è Output:
The parameterized constructor called  
The default constructor is called 

üî∏ 2. From Subclass to Superclass ‚Üí Use super()
You can call a constructor from the parent class using super().

‚úÖ Example:
class Person {
    Person() {
        System.out.println("Person constructor");
    }
}

class Student extends Person {
    Student() {
        super(); // calls Person constructor
        System.out.println("Student constructor");
    }
}

‚ö†Ô∏è Rules of Constructor Chaining
‚úÖ Only one constructor can be called using this() or super()	
‚úÖ Must be the first statement in the constructor	
‚ùå Cannot mix this() and super() in the same constructor

###############################
Important Shortcuts in Eclipse
################################
1. Ctrl + Space:‚ö° Content Assist ‚Äî suggests code completions.
2. Ctrl + 1: üí° Quick fix ‚Äî suggests solutions for errors or warnings.
3. Ctrl + O: üß≠ Quick outline ‚Äî shows methods/fields of the current class.
4. F3: üîÑ Go to the declaration of a variable, method, or class.
5. Ctrl + . : ‚û°Ô∏è Jump to the next error or warning in the file.

üì¶ Packages in Java
####################
A package in Java is a namespace that organizes classes and interfaces into a structured folder system, making code modular, reusable, and easy to manage.

c. Naming Convention for packages
----------------------------------
‚û§Package name cannot be a keyword like - new, static, public, etc...
‚û§Do not start the package name with capital letters
‚û§Package name not to be given as java
‚û§When you create a class inside a package, you have to define the package keyword in your program as shown below:

Example:
package p1;
public class A {}

‚û§Create 2 classes in the same package and perform inheritance. Import is not required.
Example:
package p1;
public class A {}

package p1;
public class B extends A {}

‚û§Create 2 classes in different packages and perform inheritance. "Import required".
Example:
package p1;
public class A {}

package p2;
import p1.A;
public class C extends A{}

Example:
package p1;
public class A {}

package p2;
public class C {}

package p1;
import p2.C;
public class B {
	public static void main(String[] args) {
		A a1 = new A();
		C c1 = new C();
	}
}

Example:
package p1;
public class A {}

package p1;
public class B {}

package p2;
import p1.*;
public class C {
	public static void main(String[] args) {
		A a1 = new A();
		B b1 = new B();
	}
}

Example:
package p1;
public class A {}

package p2;
public class A {}

package p3;
public class B {
	public static void main(String[] args) {
		p1.A a1 = new p1.A();//---> p1
		p2.A a2 = new p2.A();//---> p2
	}
}

Object Oriented Programming -  Pillars
########################################
a. inheritance
b. polymorphism
c. encapsulation
d. abstraction

a. inheritance
###############
Inheritance is one of the core pillars of Object-Oriented Programming (OOP).
It allows a class (subclass) to inherit fields and methods from another class (superclass).

‚úÖ Why Use Inheritance?
‚û§Code reusability
‚û§Improves maintainability
‚û§Supports method overriding & polymorphism

Example :
package app_java_1;
public class Animal {
	public void eat() {
		System.out.println("Eating");
	}
	public void sleep() {
		System.out.println("sleeping");
	}
}

package app_java_1;
public class Dog extends Animal{
	//eat(),sleep()--->Animal
}

package app_java_1;
public class Cow extends Animal{
	//eat(),sleep()--->Animal
}

package app_java_1;
public class Root {
	public static void main(String[] args) {
		Dog d = new Dog();
		d.eat();
		d.sleep();
		System.out.println("_______");
		Cow cow = new Cow();
		cow.eat();
		cow.sleep();
	}
}

 Multilevel inheritance
#########################

Example:
package app_java_1;
public class A {
	public void test1() {
		System.out.println(1);
	}
}
package app_java_1;
public class B extends A{
	public void test2() {
		System.out.println(2);
	}
}
package app_java_1;
public class C extends B{
	public static void main(String[] args) {
		C c1 = new C();
		c1.test1();//Output :1
		c1.test2();//Output :2
	}
}

What is multiple inheritance?
Answer: When a child class has more than one parent class, it is called multiple inheritance

Note: Java classes do not support multiple inheritance because of the diamond problem.

 Diamond Problem in Java (Multiple Inheritance Problem)
---------------------------------------------------------
The Diamond Problem occurs in multiple inheritance when a class inherits from two classes that have a common superclass, leading to ambiguity about which method to inherit.

Suppose we inherit a method from A->B->D,  and the Same method is inherited from A->C->D, then confusion arises from which parent class method is inherited by the child class D. This is called as DIAMOND PROBLEM. Hence, in Java, classes do not support multiple inheritance.

Note: We can do multiple inheritance on an interface.

Example: Multiple inheritance error

package app_java_1;
public class A {}

package app_java_1;
public class B{}

package app_java_1;
public class C extends A, B{//Error	
}

Access Specifiers in Java
###############################

| Access Context                | `public` |         `protected`          | `default` (no modifier)   | `private`  |
| ------------------------------| :------: | :------------------------:   | :---------------------:   | :-------:  |
| Same Class                    |     ‚úÖ   |              ‚úÖ             |            ‚úÖ            |     ‚úÖ     |
| Same Package                  |     ‚úÖ   |              ‚úÖ             |            ‚úÖ            |     ‚ùå     |
| Subclass in Same Package      |     ‚úÖ   |              ‚úÖ             |            ‚úÖ            |     ‚ùå     |
| Non-Subclass in Same Package  |     ‚úÖ   |              ‚úÖ             |            ‚úÖ            |     ‚ùå     |
| Subclass in Other Package     |     ‚úÖ   | ‚úÖ *(via inheritance only)* |            ‚ùå            |     ‚ùå     |
| Non-Subclass in Other Package |     ‚úÖ   |              ‚ùå             |            ‚ùå            |     ‚ùå     |

a. private: When a variable/method is made private, then we can access that in the same class but not outside the class

b. default: A variable/method with default access specifier can work only inside the same class or the same package, but cannot be accessed in a different package

c. protected: We can access variables/methods in the same class/same package, and inside different packages only when inheritance is done

d. public: When we make a variable/method public, then we can access that in the same class/the same package/different package

Access Specifier on Constructors
#######################################################

Can we inherit the Constructor?
Answer: No, constructors cannot be inherited in Java.
Even though a subclass gets access to all public and protected members of the superclass, constructors are not part of inheritance.

üîç Why Are Constructors Not Inherited?
‚úÖ 1. Constructors are not members
Constructors are not inherited because they are not class members like methods or fields.

‚úÖ 2. Constructors are class-specific
A constructor is tightly bound to its class name.

‚úÖ 3. Subclass should define how it initializes its members
A subclass might have new fields or different logic to initialize.
So it needs its constructor to control initialization.

‚úÖ 4. Java automatically provides a default constructor
If you don't define any constructors, Java will insert a default no-arg constructor.
But this doesn't mean the superclass constructor is inherited ‚Äî it's just that Java calls the superclass constructor from the subclass constructor.
They are special blocks used to initialize objects of a specific class.

üîê Private Constructor in Java
A private constructor is a constructor that cannot be accessed outside its class.

‚úÖ Why Use a Private Constructor?
‚ùå Prevent object creation	        for utility or helper classes
‚úÖ Implement Singleton Pattern		Ensure only one instance is created
üîê Hide object instantiation		Force object creation through factory methods
‚û§If a constructor is made private, then its object cannot be created outside the class.

Example :
package p1;
public class A {
	private A() {}
	public static void main(String[] args) {
		A a1 = new A();
	}
}
package p1;
public class B {
	public static void main(String[] args) {
		A a1 = new A();//--->Error
	}
}
package p2;
import p1.A;
public class C {
	public static void main(String[] args) {
		A a1 = new A();//-->Error
	}
}

‚û§When a constructor is made private, then inheritance of that class is not allowed

Example 2:
----------
package p1;
public class A {
	private A() {}	
}

package p1;
public class B extends A{//-->Error	
}

package p2;
import p1.A;
public class C extends A{//-->Error	
}

üèóÔ∏è Default Constructor in Java
################################
A default constructor is a no-argument constructor that the Java compiler automatically provides if you do not define any constructors in your class.

‚úÖ Key Features:
Feature					Description
No parameters. 				Takes zero arguments
Provided automatically			Only if no constructor is defined by the user
Initializes variables,			sets fields to default values (e.g., 0, null)
Used for object creation		Allows creation of objects without parameters
‚û§If a constructor is made default, then its object can be created in the same class/same package, but not outside the package.

Example 1:

package p1;
public class A {
	A() {}
	public static void main(String[] args) {
		A a1 = new A();
	}
}
package p1;
public class B {
	public static void main(String[] args) {
		A a1 = new A();
	}
}
package p2;
import p1.A;
public class C{
	public static void main(String[] args) {
		A a1 = new A();//-->Error
	}
}

Example 2:

package p1;
public class A {
	A() {}
}
package p1;
public class B extends A {}

package p2;
import p1.A;
public class C extends A{//-->Error	
}

üîê Protected Constructor in Java
#################################
A protected constructor means the constructor can only be accessed:
‚úÖ Within the same package
‚úÖ From subclasses (even in other packages)

‚úÖ Why Use a Protected Constructor?
‚û§To restrict object creation outside the package
‚û§To allow subclassing but prevent direct instantiation from unrelated classes
‚û§Often used in inheritance-based designs, frameworks, or abstract factories

Example 1:

package p1;
public class A {
	protected A() {}
	public static void main(String[] args) {
		A a1 = new A();
	}
}

package p1;
public class B  {
	public static void main(String[] args) {
		A a1 = new A();
	}
}

package p2;
import p1.A;
public class C {
	public static void main(String[] args) {
		A a1 = new A();//-->Error
	}
}
‚û§When a constructor is made protected, then inheritance of that class is  allowed in the same package / outside the package (both).

Example 2:

package p1;
public class A {
	protected A() {}
}

package p1;
public class B extends A {}

package p2;
import p1.A;
public class C extends A {}

e. public Constructor

‚û§If a constructor is made public, then its object can be created in the same class/same package, and outside the package also

Example 1:

package p1;
public class A {
	public A() {}
	public static void main(String[] args) {
		 A a1 = new A();
	}
}

package p1;
public class B  {
	public static void main(String[] args) {
		 A a1 = new A();
	}
}

package p2;
import p1.A;
public class C  {
	public static void main(String[] args) {
		 A a1 = new A();
	}
}

‚û§When a constructor is made public, then inheritance of that class is  allowed in the same package / outside the package (both)

Example 2:

package p1;
public class A {
	public A() {}
}

package p1;
public class B extends A {}

package p2;
import p1.A;
public class C extends A {}


‚úÖ Access Specifiers on Top-Level Classes:
Access Specifier			Usage					Visibility
public					public class ClassName {}		Visible to all classes everywhere (within the same package or other packages).
Default (no modifier)			class ClassName {}			Visible to classes within the same package only.

‚ùå Not allowed on top-level classes:
private
protected

üîç Reason: Java's Design Philosophy
‚úÖ 1. Top-level classes must be accessible to the JVM & compiler

If you declare a class as private or protected, no other class can access it, not even the class loader or main method (in another file).

That breaks the point of having it at the top level ‚Äî it becomes useless.

‚úÖ 2. Protected and private only make sense in class hierarchies

Protected is meaningful only within inheritance (i.e., subclass access).
Private is meaningful only within the enclosing class.
For a top-level class, there is no enclosing class, so these modifiers make no logical sense.

These are invalid for top-level classes and will cause a compile-time error if used.

Example 1:
package p1;
class A {}

package p1;
public class B extends A{} //Because A is default and inherited in B

package p2;
import p1.A;//-->Error
public class C extends A{//-->Error	
}

Example 2:
package p1;
class A {
	public static void main(String[] args) {
		A a1 = new A();
	}
}

package p1;
public class B {
	public static void main(String[] args) {
		A a1 = new A();
	}
}

package p2;
import p1.A;//--->Error because A is default and cannot be inherited in another package
public class C {
	public static void main(String[] args) {
		A a1 = new A();//--->Error
	}
}

What happens when a class is made public?
Answer:
‚û§Its object can be created in the same class/same package & inside a different package
‚û§Inheritance is allowed in the same package & inside different packages

Example :

package p1;
public class A {}

package p1;
public class B extends A{}

package p2;
import p1.A;
public class C extends A{}

Note:
a. Compile Time
‚û§This is the phase where source code is checked and translated into bytecode.
‚û§Java source files (.java) are compiled by the Java Compiler (javac).
‚û§The compiler checks for syntax errors and converts the code into bytecode (platform-independent code).

[Source Code (.java file)]
             |
             v
[JDK - javac Compiler]
   (Compiles to Bytecode)
             |
             v
[.class File (Bytecode)]
             |
             v
[JVM Class Loader]
   (Loads class into memory)
             |
             v
[Bytecode Verifier]
   (Validates bytecode)
             |
             v
[Execution by JVM]
     /           \
    v             v
[Interpreter]   [JIT Compiler]
 (line-by-line)   (compiles hot code to native)
             |
             v
[Native Machine Code]
             |
             v
[CPU Executes Code ‚Üí Output]

Output: .class file containing bytecode.

Command: javac MyProgram.java
Result: Creates MyProgram.class file.

b. Run Time
‚û§This is the phase where the compiled bytecode is executed by the Java Virtual Machine (JVM).
‚û§The JVM loads the .class file and executes the bytecode.
‚û§Any exceptions or logical errors may occur during this phase.

Command: java MyProgram
Result: Runs the program using the bytecode inside MyProgram.class.

‚úÖ What Makes Java Platform Independent?
Java is platform-independent because of its "Write Once, Run Anywhere" capability.
This is mainly due to:
üîë 1. Bytecode
When you compile a Java program (.java file), the Java compiler (javac) doesn't generate platform-specific machine code.
It generates bytecode (.class file) ‚Äî an intermediate, platform-neutral code.

// You write this
HelloWorld.java
‚Üì
// Compiled by javac to
HelloWorld.class (bytecode)

Bytecode is the key to platform independence ‚Äî it's the same for all operating systems.

üîë 2. Java Virtual Machine (JVM)
JVM is platform-dependent (a different version exists for Windows, Linux, Mac, etc.).
It executes the bytecode by converting it into native machine code at runtime.
Since every OS has its own JVM, the same bytecode can run on any system with a compatible JVM.

b. Polymorphism
#################
Two types of polymorphism:

a. Overriding (Run-time polymorphism):
‚û§Overriding occurs when a subclass provides a specific implementation of a method that is already defined in its superclass.
‚û§It is used to achieve Run-time Polymorphism.
‚û§The method signature (name + parameters) must be the same in both parent and child classes.
‚û§The decision of which method to call is made at run-time, not compile-time.

üî∏ Key Rules of Method Overriding:
Rule							Description
Same method signature					Method name, return type, and parameters must be the same.
Access modifier						Child method must have the same or more accessible modifier (e.g., can‚Äôt override public with private).
Can't override final, static, or private methods	These are either not inherited or cannot be changed.
Return type						should be the same or covariant (child class return type).
Use @Override						Optional, but recommended to catch errors at compile time.

Example:
package p1;
public class GoldAccount {
	public void onlineBanking() {
		System.out.println("yes");
	}
	public void rateOfInterest() {
		System.out.println("nill");
	}
}

package p1;
public class PlatinumAccount extends GoldAccount {
	public void rateOfInterest() {
		System.out.println("6% PA");
	}
	public static void main(String[] args) {
		PlatinumAccount p = new PlatinumAccount();
		p.onlineBanking();
		p.rateOfInterest()// Output: 6% PA
		System.out.println("--------");
		GoldAccount g = new GoldAccount();
		g.onlineBanking();
		g.rateOfInterest();//-->Output: nill
	}
}

 What are Annotations?
‚û§Introduced in Java 5, annotations are metadata that provide information to the compiler or runtime environment.
‚û§They do not directly affect program logic but can instruct the compiler or tools to perform specific actions.

 Common Use: @Override
--------------------------
‚û§@Override is used to indicate that a method is intended to override a method in the superclass.
‚û§It helps the compiler catch errors if the method does not override anything (e.g., due to a typo or mismatch in method signature).

package p1;
	public class GoldAccount {	
		public void rateOfInterest() {
			System.out.println("nill");
		}
	}

package p1;
public class PlatinumAccount extends GoldAccount {
	@Override
	public void rateOfInterests() {//-->Error because method name mismatch
		System.out.println("6% PA");
	}	
}

Question: Access Specifier should be the same or can it be different during Overriding?
Answer: During overriding, we can increase the scope of the access specifier, but we cannot reduce the scope of the access specifier

Example 1:
package p1;
public class GoldAccount {
	void rateOfInterest() {
		System.out.println("nill");
	}
}

package p1;
public class PlatinumAccount extends GoldAccount {
//No Error Because the default scope is increased to public	
	@Override
	public void rateOfInterest() {
		System.out.println("6% PA");
	}
}

Example 2:

package p1;
public class GoldAccount {
	public void rateOfInterest() {
		System.out.println("nill");
	}
}

package p1;
public class PlatinumAccount extends GoldAccount {
//Error: Because the public scope is reduced to the default
	@Override
	void rateOfInterest() {
		System.out.println("6% PA");
	}
}

Order of Access Specifiers
Private -> Default -> Proctected -> Public

Example 3:

package p1;
public class GoldAccount {
	private void rateOfInterest() {
		System.out.println("nill");
	}
}

package p1;
public class PlatinumAccount extends GoldAccount {
//Error: Because private methods, we cannot inherit
//Without inheritance, overriding cannot be done
	@Override
	protected void rateOfInterest() {
		System.out.println("6% PA");
	}
}

Note: Static members cannot be inherited
‚ùì Are Static Members Inherited in Java?
‚úÖ Technically, static members are inherited ‚Äî but they are not polymorphic, and they do not behave like instance members in inheritance.

üî• Common Misconception:
People often say:
‚ùå "Static members cannot be inherited."
But that's not entirely accurate.

‚úÖ What Happens:
1. Static members belong to the class, not to objects.
They are class-level members, not instance-level.

So they are shared across the inheritance hierarchy.

‚úÖ Example:
class A {
    static int x = 10;
    static void greet() {
        System.out.println("Hello from A");
    }
}

class B extends A {}
Now in B, you can access x and greet():

System.out.println(B.x);     // ‚úÖ Allowed
B.greet();                   // ‚úÖ Allowed

So yes ‚Äî static members are accessible in the subclass, but they are not inherited in the object-oriented sense (no polymorphism).

‚ö†Ô∏è Why Static Members Are Not "Truly" Inherited:
‚úÖ 1. They don‚Äôt participate in runtime polymorphism

class A {
    static void show() {
        System.out.println("A");
    }
}

class B extends A {
    static void show() {
        System.out.println("B");
    }
}

public class Main {
    public static void main(String[] args) {
        A obj = new B();
        obj.show(); // Output: A (not B)
    }
}

Even though obj is of type B, A.show() gets called because static methods are resolved at compile time, based on the reference type, not the object.

‚úÖ 2. They're not part of the instance, so ‚Äúinheritance‚Äù isn‚Äôt meaningful
Since they don‚Äôt get copied to each object or act differently per subclass instance, calling it "inheritance" is misleading.

Example:
You have:
A parent class: GoldAccount (in package p1)
A child class: PlatinumAccount extends GoldAccount

// GoldAccount.java
package p1;
public class GoldAccount {
    static int x = 100;
    public static void rateOfInterest() {
        System.out.println("nill");
    }
}

// PlatinumAccount.java
package p1;

public class PlatinumAccount extends GoldAccount {
    public static void main(String[] args) {
        PlatinumAccount.rateOfInterest();      // Output:  nill
        System.out.println(PlatinumAccount.x); // Outuput: 100
    }
}

üîç What Is This Program Teaching?
‚úÖ 1. Static Methods and Variables Are Not Polymorphic
Even though PlatinumAccount inherits from GoldAccount, calling:
PlatinumAccount.rateOfInterest();
is resolved at compile time based on the class name, not the object type.

Since PlatinumAccount does not override the method (it doesn‚Äôt define its own rateOfInterest()), calling: PlatinumAccount.rateOfInterest(); 
is effectively the same as: GoldAccount.rateOfInterest();

The same logic applies to the static variable x:
PlatinumAccount.x; // resolves to GoldAccount.x (100)

üü® Important Point:
Static methods and variables are resolved based on class name, not overridden, and not polymorphic.

Note: During overriding, the method return type should match

‚úÖ Overloading in Java (Compile-Time Polymorphism)
üîπ What is Method Overloading?
‚û§Method Overloading means defining multiple methods with the same name in a class but with different parameter lists (type, number, or order of parameters).
‚û§It allows compile-time polymorphism, where the method to be called is determined at compile time based on the method signature.

| Feature                     | Allowed in Overloading? | Explanation                             |
| --------------------------- | ----------------------- | --------------------------------------- |
| Change number of parameters | ‚úÖ Yes                   | Different arity                         |
| Change type of parameters   | ‚úÖ Yes                   | Different signatures                    |
| Change order of parameters  | ‚úÖ Yes                   | Only if types are different             |
| Change return type only     | ‚ùå No                    | Causes compile-time error               |
| Change access modifier only | ‚ùå No                    | Doesn't affect method signature         |
| Change method name          | ‚ùå No                    | It's not overloading, it's a new method |

üî∏ Characteristics of Overloading:
Feature					Description
Method name				Must be the same
Parameter list				Must be different (type, number, or order)
Return type				Can be same or different, but doesn't affect overloading
Access modifier				Can be same or different
Inheritance				Not required for overloading
Polymorphism type			Compile-time polymorphism

Example:
package p1;

public class EmailService {
	public void sendEmail(String to, String subject, String message) {
		System.out.println("Email sending....");
	}
	public void sendEmail(String to, String subject, String message, String filePath) {
		System.out.println("Email sending with attachment.....");
	}
	public static void main(String[] args) {
		EmailService service = new EmailService();
		service.sendEmail("mike@gmail.com", "Welcome", "Some Message","G:\\image.png");
	}
}

Final Keyword
################################
‚û§If you make a variable final, then we cannot change its value(Just like constant variables)
‚û§If you make a static/non-static variable final, then initialization is mandatory

Example:  
---------
public interface A {
	int MAX_VAL=100;
	static final int MIN_VAL=0;
}
package p1;

public class B {
	public static void main(String[] args) {
		System.out.println(A.MAX_VAL);//Output: 100
		System.out.println(A.MIN_VAL);//Output: 0
	}
}

‚û§If you make a method final, then overriding is not allowed
‚û§If you make a class final, then inheritance is not allowed

Example 1: 
----------
package p1;

public class A {
	public static void main(String[] args) {
		final int x = 10;
		x=20;//-->Cannot change the value of final variable
		final int y;//->final mandatory to be initialized
	        final static int z;//->final mandatory to be initialized
	        //The above errors are called blank field errors
		System.out.println(y);
	}
}

Example 2:
----------
package p1;

public class A {
	final public void test() {
		System.out.println(100);
	}
}
package p1;

public class B extends A{
	@Override
	public void test() {//--> Error because we cannot override final methods
		System.out.println(100);
	}
}

Example 3:
----------
package p1;

final public class A {}
package p1;

public class B extends A{//---> Error because we cannot inherit final class	
}

Interfaces in Java - Abstraction
##################################
Interfaces are a fundamental feature in Java used to achieve abstraction and enforce design contracts between classes.

üîπ Key Points:
Complete Abstraction (Java 7)
‚û§ In Java 7 and earlier, interfaces could only have abstract methods (no method bodies).
‚û§ They define what should be done, not how.

All Variables are public static final.
‚û§ Any variable declared in an interface is implicit:
public static final (i.e., a constant).
‚û§ No need to specify these modifiers‚Äîthey are applied by default.
‚û§No Object creation

‚úÖ Note: Drawback of Inheritance ‚Äì Tightly Coupled Programming
üîπ What is Tightly Coupled Programming?
‚û§When two or more classes are highly dependent on each other's implementation, they are said to be tightly coupled.
‚û§In such a setup, changing one class often requires changes in the other, reducing flexibility, maintainability, and scalability.

üî∏ How Inheritance Causes Tight Coupling:
Child class depends heavily on the parent class:
‚û§In inheritance, the child class inherits both behavior and structure from the parent.
‚û§If the parent class changes, it can break or affect the behavior of all child classes.

Strong binding:
‚û§The child class is strongly bound to the specific parent class.
‚û§You cannot easily switch to a different parent or change the inheritance hierarchy without impacting the child classes.

Hard to maintain and extend:
‚û§Over time, inherited code becomes fragile.
‚û§Multiple levels of inheritance (deep hierarchy) make debugging and updates difficult.

Example 1:
---------
package p1;

public interface A {
	public void test1() {//-->Error because complete methods are not allowed in an interface	
	public void test2(); //Correct version
	}
}

Example 3:
----------
package p1;

public interface NotificationService {
	public void emailService();
	public void whatsAppService();
	public void smsService();
}

package p1;

public class NotificationServiceImpl implements NotificationService {
	@Override
	public void emailService() {
		System.out.println("Email Sending");
	}
	@Override
	public void whatsAppService() {
		System.out.println("Whats app Sending");
	}
	@Override
	public void smsService() {
		System.out.println("SMS Sending");
	}
	public static void main(String[] args) {
		NotificationServiceImpl impl = new NotificationServiceImpl();
		impl.emailService();
		impl.smsService();
		impl.whatsAppService();
	}
}

Example:
----------
package p1;

public interface Calculator {
	public void add(int x, int y);
	public void mul(int x, int y);
}

package p1;
public class OrdinaryCalc implements Calculator{
	@Override
	public void add(int x, int y) {
		System.out.println(x+y);
	}
	@Override
	public void mul(int x, int y) {
		System.out.println(x*y);
	}
}

package p1;

public class SciCalc implements Calculator{
	@Override
	public void add(int x, int y) {
		System.out.println(x*x+y*y);
	}
	@Override
	public void mul(int x, int y) {
		int num1 = x*x;
		int num2 = y*y;
		System.out.println(num1*num2);
	}
}
package p1;

public class MainCalc {
	public static void main(String[] args) {
		OrdinaryCalc oc = new OrdinaryCalc();
		oc.add(10, 20);
		oc.mul(10, 20);
		SciCalc sc = new SciCalc();
		sc.add(10, 20);
		sc.mul(10, 20);
	}
}

‚úÖ Advantages of Interfaces in Java
1. Abstraction
‚û§Interfaces facilitate complete abstraction.
‚û§They allow you to hide implementation details and only expose what needs to be done, not how.

Example: A Database interface may define connect(), disconnect(), but not how these are implemented.

2. Contract Enforcement
‚û§When a class implements an interface, it must implement all its methods.
‚û§This imposes a strict contract on the class, ensuring consistency in structure and behavior across multiple classes.

3. Good Design Practices
‚û§Interfaces promote clear separation of responsibilities.
‚û§They lead to clean, modular, and testable code.
‚û§Developers can work independently on the interface and its implementations.

4. Loose Coupling
‚û§Classes that use interfaces depend only on method signatures, not on concrete implementations.
‚û§This allows changes in implementations without affecting dependent classes.
‚û§Enhances flexibility, extensibility, and maintainability of the system.

5. Multiple Inheritance
‚û§Java doesn‚Äôt support multiple inheritance with classes, but a class can implement multiple interfaces.
‚û§This allows a class to inherit behavioral capabilities from multiple sources.

6. Supports Plug-and-Play Architecture
‚û§Interface-based design makes it easy to swap implementations (e.g., using different payment gateways, databases, or services) without changing the dependent code.

Note:
‚û§Class to Class Inheritance --> extends
‚û§Interface to Interface Inheritance --> extends
‚û§Interface to Class Inheritance --> implements

Example :
---------
package p1;

public interface A {
	public void test1();
}

package p1;

public interface B extends A{
	public void test2();
}

public interface D{
	public void test3();
}

package p1;

public class C implements B, D { //If you do multiple inheritance on a class, then its parent should be interfaces only

	@Override
	public void test1() {
		System.out.println("From test1");
	}
	@Override
	public void test2() {
		System.out.println("From test2");
	}

	public static void main(String[] args) {
		C c1 = new C();
		c1.test1();
		c1.test2();
	}
}

Example 4:
----------
‚û§ In class, can we perform extends and implements together
‚û§But ensure the extends is used first and then implementes

package p1;
public interface A {
	public void test2();
}

package p1;
public class B {
	public void test1() {
		System.out.println("From test1");
	}
}

package p1;
public class C extends B implements A {
	@Override
	public void test2() {
		System.out.println("From test2");		
	}
	public static void main(String[] args) {
		C c1 = new C();
		c1.test1();
		c1.test2();
	}
}

Question: Can I develop an incomplete static method in an interface?
Answer: We cannot inherit static methods & override, hence incomplete static methods are not allowed in an interface.

Example:
package p1;
public interface A {
	public static void test2();//-------> Error
}

Java 8 Features
###################
1. default keyword:
‚û§Using the default keyword, we can create complete methods inside an interface. This was introduced in Java version 8

Example :
package javaconcepts.p3;

public interface A {
	default public void test1() {
		System.out.println("From test1");
	}
	public void test2();
}

package javaconcepts.p3;

public class B implements A {

	public static void main(String[] args) {
		B b1 = new B();
		b1.test1();
		b1.test2();
	}
	@Override
	public void test2() {
		System.out.println("From Overrided test2");
	}	
	@Override
	public void test1() { //we can override the method
		System.out.println("From Overrided Test1");
	}
}
Output
From Overrided Test1
From Overrided test2

Before Java 8:
‚û§Interfaces could only contain abstract methods (no body).
‚û§If you added a new method to an interface, all implementing classes would break unless they implemented the new method.

‚úÖ Benefits of default Methods in Interfaces
1. Backward Compatibility
‚û§You can add new methods to interfaces without breaking existing implementations.
‚û§Existing classes don‚Äôt need to override the new default method.

interface A {
    void m1();  // originally
    default void m2() { // added later
        System.out.println("Default m2");
    }
}

‚û§Even if old classes only implement m1(), they won‚Äôt break because m2() has a default body.

interface A {
    default void greet() {
        System.out.println("Hello from A");
    }
}
interface B {
    default void greet() {
        System.out.println("Hello from B");
    }
}
class C implements A, B {
    public void greet() {
        A.super.greet();  // resolve conflict
    }
}
This allows controlled multiple behavior inheritance.

‚úÖ 2. Functional Interface
üîπ Definition:
‚û§A Functional Interface is an interface that has exactly one abstract (incomplete) method.
‚û§Can have multiple default or static methods (complete methods).
‚û§ It enables lambda expressions and functional programming in Java.

üî∏ Key Points:
‚û§A functional interface must contain only one abstract method.
‚û§You can add any number of default or static methods (they're considered complete methods).
‚û§If the interface inherits more than one abstract method (from multiple interfaces), it no longer remains a functional interface, and the compiler throws an error.
‚û§Use @FunctionalInterface annotation to enforce the rule at compile-time.

Example 1:
--------------------
@FunctionalInterface
public interface A {//Error-> Because cannot have ZERO incomplete method
}

Example 2:
----------
@FunctionalInterface
public interface A {
	public void test1();
}
Output:  No Error because it has exactly one incomplete method

Example 3:
----------
@FunctionalInterface
public interface A {//Error->A functional interface should consist of exactly one //incomplete method inside it
	public void test1();
	public void test2();
}

Example 4:
----------
package p1;
@FunctionalInterface
public interface A {
	public void test1();
	default public void test2() {
		System.out.println("From Test 2");
	}
	default public void test3() {
		System.out.println("From Test 3");
	}
}
package p1;
public class B implements A {
	public static void main(String[] args) {
		B b1 = new B();
		b1.test1();
		b1.test2();
		b1.test3();
	}
	@Override
	public void test1() {
		System.out.println("From test 1");
	}
		
}
Output:
---------
From test 1
From Test 2
From Test 3

Example 5:
-----------
package p1;
public interface A {
	public void test1();
}

package p1;
@FunctionalInterface
public interface B extends A{}
Output: No Error

Example 6:
----------
package p1;
public interface A {
	public void test1();
	public void test2();
}
package p1;
@FunctionalInterface
public interface B extends A{}
Output: Error because we are inheriting 2 methods to a functional interface

Example 6:
---------
package p1;
public interface A {
	public void test1();	
}

package p1;
@FunctionalInterface
public interface B extends A{
	public void test2();
}
Output: Error because we are inheriting 1 method from a functional interface, and a functional interface has 1 method, which totals to 2 methods in an interface

üîπLambda Expression:
A Lambda Expression is a short block of code that:
‚û§Takes in parameters
‚û§Executes a body
‚û§Can be used in place of anonymous classes
‚û§Requires a functional interface to work

üî∏ Key Points:
‚úÖ Introduced in Java 8
Part of Java‚Äôs functional programming enhancements.

‚úÖ Reduces Code Length
Allows writing concise code by eliminating boilerplate like anonymous class syntax.

‚úÖ Works With Functional Interfaces
Lambda expressions can only be used where a functional interface (i.e., one abstract method) is expected.

‚úÖ Commonly Used in Stream API
Lambdas  are widely used in filtering, mapping, sorting, and reducing data in the Java Stream API.

üîπ Syntax of Lambda Expression:
(parameters) -> { body }

Examples:
(x, y) -> x + y
name -> System.out.println("Hello " + name)
() -> System.out.println("No parameters")

‚úÖ How Lambda Expressions Work in Java?
‚û§ It creates an anonymous class behind the scenes. A class without any name is called Anonymous.
‚û§Then the lambda expression creates an object and loads the method by implementing it inside the object.
‚û§Then we use an object reference to call that implemented method
‚û§Replacing instances of anonymous classes that implement functional interfaces with a concise, inline function-like syntax.

üî∏ ‚úÖ Behind the Scenes:
When you write a lambda expression like: () -> System.out.println("Hello");

üîπ Step-by-step Breakdown:
‚úÖ Step 1: Functional Interface
@FunctionalInterface
interface Greet {
    void sayHello();
}

‚úÖ Step 2: Lambda Expression
Greet g = () -> System.out.println("Hello");
g.sayHello();

‚û° This is functionally equivalent to:
Greet g = new Greet() {
    public void sayHello() {
        System.out.println("Hello");
    }
};
But the lambda version is shorter, cleaner, and faster.

Note: Functional Programming defines you to say "what you want, not how to do it step-by-step"

Example 1:
-----------
package p1;
@FunctionalInterface
public interface A {
	public void test1();	
}
package p1;
public class B{
	public static void main(String[] args) {
		A a1 = ()->{
			System.out.println(100);
		};
		a1.test1();//Output: 100
	}
}

Example 2:
----------
package p1;
@FunctionalInterface
public interface A {
	public void test1(int x);
	default public void test2() {
		System.out.println("test2");
	}
}
package p1;
public class B{

	public static void main(String[] args) {
		A a1 = (int y) -> {
			System.out.println(y);
		};
		a1.test1(100);// Output: 100
		a1.test2();// Output: test2
	}
}

4. Stream API
---------------------
Note: to learn Stream API, complete the following first
a. Collection (Data Structure)
b. Functional Programming

5. Optional class - We have to learn the exception concept in Java first
-----------------------------------------------------------------------

Marker interface 
------------------
An empty interface is called a marker interface
package p1;
public interface A {}

‚úÖ Abstract Class in Java
An abstract class in Java is a class that is declared with the abstract keyword. It cannot be instantiated directly and is typically used to provide a partial implementation that its subclasses must complete.

üîπ Key Features of Abstract Class
1. ‚úÖ Can Have Both Complete and Incomplete Methods
An abstract class can contain:
‚û§Complete methods (methods with body)
‚û§Incomplete methods (methods without a body)
‚û§To declare an incomplete method, the abstract keyword is mandatory.

abstract class Shape {
    abstract void draw();        // Incomplete method
    void color() {               // Complete method
        System.out.println("Coloring shape");
    }
}

2. ‚úÖ Can Have Both Static and Non-Static Members
You can define:
‚û§Static variables and methods
‚û§Non-static variables and methods

abstract class Demo {
    static int count = 0;
    int id;
    static void showCount() {
        System.out.println("Count = " + count);
    }
}

3. ‚úÖ Static Methods Must Be Complete
You cannot define abstract static methods.
‚û§Because static methods belong to the class, and abstract methods must be overridden, which contradicts the purpose.

abstract class Test {
    // abstract static void display(); ‚ùå Not allowed
    static void show() {         // ‚úÖ Allowed
        System.out.println("Static method");
    }
}

4. ‚úÖ Can Have main() Method
‚û§An abstract class can contain the main() method and be used as the entry point of a Java program.

abstract class Launcher {
    public static void main(String[] args) {
        System.out.println("Main inside abstract class");
    }
}

5. ‚ùå Cannot Instantiate an Abstract Class
‚û§You cannot create an object of an abstract class directly.
Reason: It may contain incomplete methods, so Java doesn‚Äôt allow creating an object of something that‚Äôs not fully defined.

abstract class Animal {
    abstract void makeSound();
}

// Animal a = new Animal(); // ‚ùå Compile-time error

6. ‚ùå Does Not Support Multiple Inheritance with Classes
‚û§Java does not allow multiple inheritance with classes (i.e., a class cannot extend more than one class, abstract or not).
‚û§This is to avoid ambiguity and diamond problems.

abstract class A {
    abstract void show();
}

abstract class B {
    abstract void show();
}

// class C extends A, B { } // ‚ùå Not allowed
Java solves this limitation using interfaces, which do support multiple inheritance.

Example 1:
----------
package p1;
abstract public class A {
	public void test1() {}
	abstract public void test2();
	public static void test3() {}
	public static void test4();//Error
	public static void main(String[] args) {
		A a1 = new A();//Error
	}
}

Example 2: Error because multiple inheritance cannot be done
-------------------------------------------------------------
package p1;
abstract public class A {}
package p1;
abstract public class B{}

package p1;
public abstract class C extends A,B{//Error
}

üß† So, Why Use an Interface if an Abstract Class Can Have Abstract Methods?
‚û§Java doesn't support multiple inheritance for classes; interfaces allow it.
‚û§Interfaces are ideal for defining APIs and contracts, not implementations.
‚û§Use abstract classes when you want to provide a common base with shared code.
‚û§Use interfaces when you want to enforce a common behavior across unrelated classes.
‚û§All variables in an interface by default are final & static, whereas inside an abstract class, we can create static/non-static/final variables

‚úÖ Real-World Analogy:
| Concept        | Example                                                                     |
| -------------- | --------------------------------------------------------------------------- |
| Interface      | RemoteControl: defines buttons (on/off) ‚Äî any brand can follow              |
| Abstract class | SamsungRemote: provides partial button logic, common to all Samsung remotes |


Example:
-------
package p1;
abstract public class A {
	static int x = 10;
	public static void test() {
		System.out.println(100);
	}
	public static void main(String[] args) {
		System.out.println(A.x);//Output :10
		A.test();// Output: 100
	}
}

Example :
---------
package p1;
abstract public class A {
	int x = 10;
	public void test() {
		System.out.println(100);
	}
}
package p1;
public class B extends A {
	public static void main(String[] args) {
		B b1 = new B();
		System.out.println(b1.x);// Outupt: 10
		b1.test();// Output: 100
	}
}

Example: Inheritance from interface-->abstract class-->class
----------------------------------------------------------------
package p1;
public interface A {
	public void test1();
}

package p1;
abstract public class B implements A {
	abstract public void test2();
}

package p1;
public class C extends B{
	@Override
	public void test1() {
		System.out.println("From test1");
	}
	@Override
	public void test2() {
		System.out.println("From test2");
	}
	public static void main(String[] args) {
		C c1 = new C();
		c1.test1();
		c1.test2();
	}
}

#############################################################################
Note: In Java 8, we can develop complete static methods & main method in an interface
#################################################################################

Example:
package p1;
public interface A {
	static int x = 100;
	public static void test1() {
		System.out.println("From test1");
	}
	public static void main(String[] args) {
		System.out.println(A.x);// Output :100
		A.test1();// Output: From test1
	}
}

‚úÖ Exception and Exception Handling in Java
--------------------------------------------

üîπ What is an Exception?
‚û§An exception is an unexpected event that occurs during the execution of a program.
‚û§It disrupts the normal flow of the program and may cause it to terminate abruptly if not handled properly.

üîπ Why Do Exceptions Occur?
They occur due to unforeseen errors like:
‚û§Invalid user input (e.g., dividing by zero)
‚û§Trying to access a null object
‚û§File not found
‚û§Network failure
‚û§They can happen at runtime, even if the code compiles successfully.

Example 1:
package p1;

public class A {
	public static void main(String[] args) {
		int x = 10;
		int y = 0;
		int z = x / y;//Stop Program Here
		System.out.println(z);
		System.out.println("Welcome");
	}
}
Output:
Exception in thread "main" java.lang.ArithmeticException: / by zero

Exception handling
#######################
‚û§To handle exceptions, we will use a "try & catch" block in Java
‚û§When an exception occurs in the try block, it will create an exception object, and that object's address is given to the catch block. Catch block will suppress that exception, and further code will continue to execute

Example :
----------
package p1;
public class A {
	public static void main(String[] args) {
		try {
			int x = 10;
			int y = 0;
			int z = x/y;
			System.out.println(z);
		} catch (Exception e) {
			e.printStackTrace();
		}
		System.out.println("Welcome");
	}
}

Types of Exception in Java
##########################

There are two types of exceptions in Java:

‚û§ Compile Time / Checked Exception - These exceptions will occur when a .java file is compiled to a .class file. That is, during compilation, we will get this exception.
‚û§Runtime / Unchecked Exception - These exceptions will occur when we run a .class file. That is during runtime

Runtime / unchecked Exceptions
###############################

1. ArithmeticException: This exception will occur when invalid mathematical operations are performed

package p1;
public class A {
	public static void main(String[] args) {
		try {
			int x = 10;
			int y = 0;
			int z = x/y;// same for modulus %0
			System.out.println(z);
		} catch (ArithmeticException a) {
			a.printStackTrace();
		}
		System.out.println("Welcome");
	}
}
Output:
java.lang.ArithmeticException: / by zero
Welcome

2. Null Pointer Exception: This exception will occur when with null reference variable we try to access non-static members of the class
Example:
--------
package p1;
public class A {
	int x = 10;
	public static void main(String[] args) {
		try {
			A a1 = null;
			System.out.println(a1.x);
		} catch (NullPointerException e) {
			e.printStackTrace();
		}
		System.out.println("Welcome");
	}
}
Output:
java.lang.NullPointerException: Cannot read field "x" because "a1" is null
Welcome

Example 
----------
package p1;
public class A {
	static int x = 10;
	public static void main(String[] args) {
		try {
			A a1 = null;
			System.out.println(a1.x);//A.x  Output: 10
		} catch (NullPointerException e) {
			e.printStackTrace();
		}
		System.out.println("Welcome");//Output: Welcome
	}
}

Unary Operators in Java
##############################

1. Increment Operator
   1.1 Post-Increment: Increment the value of the variable next time you see the same variable
Example 1:
----------
package p1;

public class A {
	public static void main(String[] args) {
		int i=0;
		int j = i++;
		int k=10;
		int l=k++ + k++ + k++;
		System.out.println(i);//Output: 1
		System.out.println(j);// Output: 0
		System.out.println(k);//Output: 13
		System.out.println(l);// Output: 33
	} 
}
   1.2 Pre-Increment: Increment the value of the variable in the same step
Example 1:
-----------
package p1;

public class A {
	public static void main(String[] args) {
		int i=10;		
		int j = ++i;
		int k=10;
		int l=++k + ++k + ++k;
		System.out.println(i);// Output: 11
		System.out.println(j);// Output: 11
		System.out.println(k);// Output: 13
		System.out.println(l);// Output: 36
	} 	
}
2. Decrement Operator
   2.1 Post Decrement: Here we decrement the value of i by 1 when we next time see the same variable:

Example:
package p1;

public class A {
    public static void main(String[] args) {
        int a = 10;
        int b = a-- + a--; 
	int x = 10;
        int y = x-- + x++ + x-- + x--; 
        System.out.println(a); //Output: 8
        System.out.println(b); //Output: 19
        System.out.println(x); //Output: 8
        System.out.println(y); //Output: 38
    }
}
   2.2 Pre Decrement: Here we decrement the value of the variable in the same step by 1

Example 1:
----------
package p1;

public class A {
	public static void main(String[] args) {
		int i=10;		
		int j = --i + --i;
		System.out.println(i);
		System.out.println(j);
	} 
}

‚úÖ Type Casting of Data Types in Java
In Java, type casting is used to convert a variable of one data type into another. This is commonly done between primitive types or object references (in case of inheritance).

üîÑ 1. Type Casting Between Primitive Data Types
There are two types:

‚úÖ a) Widening Casting (Implicit & Upcasting)
‚û§Smaller type ‚Üí Larger type
‚û§Safe, automatic, without any loss of data

byte ‚Üí short ‚Üí int ‚Üí long ‚Üí float ‚Üí double

üß™ Example:
int a = 10;
double b = a;  // int to double (widening)
double x=10.3d;
long y=x; // Larger -> Smaller, there is a loss of data so it will give an error.

‚úÖ b) Narrowing Casting (Explicit & Downcasting)
 ‚û§Larger type ‚Üí Smaller type
‚û§Risky, must be done manually using cast () 
‚û§Loss of data can take place

double ‚Üí float ‚Üí long ‚Üí int ‚Üí short ‚Üí byte

üß™ Example:
double x = 10.99;
long i=10;
int y = (int) x;  //output: 10 double to int (narrowing)
byte j=i; // ----------> Throws error

üß™ Example:
long i=100;
byte j=(byte)(int)i; //multiple downcasting is possible

üß™ Example:
int i=100;
long j=(long)i; // No error

üîç Why is float ‚Üí long considered downcasting, even though size increases?
Because type casting in Java is not only about memory size, but also about type compatibility and precision:

‚ùó float ‚Üí long is narrowing because:
‚û§You are going from floating-point to integer, which involves:
‚û§Loss of precision (decimal part is truncated)
‚û§Potential data loss if the value is too large
‚û§Even if you're increasing memory size, you're going from a more complex representation (float) to a simpler one (integer).

Primitive    Wrapper Class
byte		Byte
short		Short
int		Integer
long		Long
float		Float
double		Double
char		Character

Example 1: I want to convert a String to an Integer

public class A {
	public static void main(String[] args) {
		String x = "100";
		int  y = Integer.parseInt(x);
		System.out.println(y);
	}
}

Example 2:I want to convert a String to a Float
float  y = Float.parseFloat(x);

Example 3:I want to convert a String to a Double
double  y = Double.parseDouble(x);

Example 4:
-----------
package p1;

public class A {
	public static void main(String[] args) {
		try {
			String x = "10.3dasdsd";
			double  y = Double.parseDouble(x);
			System.out.println(y);
		} catch (NumberFormatException e) {
			e.printStackTrace();
		}
		System.out.println("Welcome");
		
	}
}
Output:
java.lang.NumberFormatException: For input string: "10.3dasdsd"
Welcome

What is class upcasting?
########################
‚û§Here we store the child class object address into the parent class reference variable, so that the reference variable becomes reusable

Example: Reusing a reference variable

public class A {}

public class B extends A{}

public class C extends A{
	public static void main(String[] args) {
		A a1 = new B();
		System.out.println(a1);
		a1 = new C();
		System.out.println(a1);
	}
}

Example 2: How can we implement polymorphism for multiple child classes by using the same reference variable

public class A {
	void display() {
        System.out.println("Inside class A");
    }
}

public class B extends A{
	 @Override
	    void display() {
	        System.out.println("Inside class B");
	    }
}

public class C extends A{
	  @Override
	    void display() {
	        System.out.println("Inside class C");
	    }
	public static void main(String[] args) {
				
		A a1 = new B();
		a1.display();    // Calls B's version => "Inside class B"
		a1 = new C();
		a1.display();    // Calls C's version => "Inside class C"
	}
}

üß† Why do we do it?
1. To reuse the parent class reference for multiple child class objects.
2. To enable polymorphism on multiple child classes.
3. To write generic, flexible code that works with different subclasses.

Note:
instanceof - It will check which class object address is present inside the reference variable

Example:

public class A {}

public class B extends A{}

public class C extends A{	 
	public static void main(String[] args) {
				
	  A a1 = new B();
	  System.out.println(a1 instanceof B);// Output: true
	}
}

What is class downcasting?
##########################
-> Here we store the parent class object address into the child class reference variable
-> To perform downcasting, first do upcasting and then perform downcasting
Example:
---------
public class A {}
public class B extends A{}

public class C extends A{	 
	public static void main(String[] args) {
		A a1 = new B();
		if(a1 instanceof B) {
			B b1 = (B)a1;
			System.out.println("Downcasting successful!");
		}
	}
}

Example:
--------
public class A {
	public void display() {
		System.out.println("Inside class A");
	}
}
public class B extends A{
	public void showB() {
        System.out.println("Inside class B");
        }
}
public class C extends A {
	public void showC() {
		System.out.println("Inside class C");
	}
}
public class MainClass {
	public static void processObject(A obj) {
        if (obj instanceof B) {
            B b = (B) obj;  // Downcasting to B
            b.showB();
        } else if (obj instanceof C) {
            C c = (C) obj;  // Downcasting to C
            c.showC();
        } else {
            obj.display();
        }
    }
    public static void main(String[] args) {
    	processObject(new B());
	}
}

Note:
‚û§Using upcasting, we can access only parent class members, you cannot access child class members
‚û§After upcasting to access child class members, we have to perform downcasting

Example:
---------
package p1;

public class A {
	public void display() {
		System.out.println("Inside class A");
	}
}
public class B extends A{
	public void showB() {
       	 System.out.println("Inside class B");
        }
	public static void main(String[] args) {
		A a1 = new B();
		if(a1 instanceof B) {
			B b1 = (B)a1;
			b1.showB();
		}
	}
}

‚úÖ Arrays in Java
----------------------

üîπ 1. Arrays Hold a Collection of Values
‚û§An array is a container object that can hold a fixed number of elements of the same data type.
‚û§Instead of creating multiple individual variables for related values (like 10 integers), we can store all of them in one array.

üîπ 2. Anything That Holds a Collection of Values is Called a Data Structure
‚û§Arrays are one of the simplest and most fundamental data structures.
‚û§A data structure is a way to organize and store data efficiently for easy access and modification.
‚û§Arrays serve as the base for many advanced data structures (like lists, stacks, queues, etc.).

üîπ 3. An array in Java is Treated as an Object
‚û§In Java, arrays are not primitive types (like int, char, etc.)‚Äîthey are objects.
‚û§This means they are created using the new keyword internally.
Being objects, they:
Have a runtime class type
Inherit methods from the Object class
Have properties like .length to determine their size

üîπ 4. Arrays Start With Index Zero
‚û§Array indexing in Java is zero-based.
‚û§The first element is accessed with index 0, the second with 1, and so on.
‚û§So, for an array of size n, the last valid index is n-1.

üîπ 5. To Store and Read Values We Use: start_address + index √ó memory_size
‚û§Internally, the array elements are stored sequentially in memory.
‚û§The memory address of any element can be calculated using:

Address = Base¬†Address + (Index√óSize¬†of¬†Each¬†Element)
‚û§This allows direct access to any element using its index in constant time O(1), which makes arrays efficient for random access.

üîπ 6. Memory Allocation Happens in Sequence (Contiguous Allocation)
‚û§When an array is created, Java allocates a block of continuous memory locations to store its elements.
This contiguous allocation ensures that:
Each element is placed right after the previous one in memory.
Accessing any element is fast using index-based computation.
But the array size cannot change after creation (fixed size limitation).

Example 1:
----------
package p1;
public class A {
	public static void main(String[] args) {
		int[] age = new int[4];
		age[0] = 90;
		age[1] = 89;
		System.out.println(age[0]);
		System.out.println(age[1]);
	} 
}

‚û§To find the size of an array dynamically, we will use the  public final field "length". When the array is created this variable will get initialized

Example 2:
----------
package p1;

public class A {
	public static void main(String[] args) {
		int[] age = new int[40];
		System.out.println(age.length);// Output :40
	} 
}

Scanner class - Is used to provide user input
################

Example 1:
----------
package p1;
import java.util.Scanner;
public class A {
	public static void main(String[] args) {
		
		Scanner scan = new Scanner(System.in);
		System.out.println("Enter your name:");
		String name = scan.next();//Can read one String word only
		System.out.println("Your name is "+name);
		System.out.println("Enter your age:");
		int age = scan.nextInt();//Can read on Integer value only
		System.out.println("Your age is "+age);
		System.out.println("Enter your weight:");
		float weight = scan.nextFloat();//Can read on float values
		System.out.println("Your weight is "+weight);
		System.out.println("Enter your Answer:");
		boolean ans = scan.nextBoolean();//Can read on boolean values
		System.out.println("Your ans is "+ans);
		scan.close();
		
	} 
	
}
Output:
Enter your name:
mike
Your name is Mike
Enter your age:
100
Your age is 100
Enter your weight:
98.34
Your weight is 98.34
Enter your Answer:
true
Your ans is true

Example 2: How to read multiple String words using the nextLine() method
--------------------------------------------------------------------------
package p1;
import java.util.Scanner;
public class A {
	public static void main(String[] args) {	
		Scanner scan = new Scanner(System.in);
		System.out.println("Enter your name:");
		String name = scan.nextLine();//Can read Multiple String words
		System.out.println(name);
		scan.close();
	} 	
}
‚ö†Ô∏è Note:
‚û§Always close the scanner with sc.close() to free system resources.
‚û§Use nextLine() carefully after nextInt() or next() due to newline issues.

‚ö†Ô∏è Issue: nextLine() after nextInt() or next() doesn't behave as expected.
‚úÖ Root Cause:
‚û§Methods like nextInt(), nextDouble(), and next() do not consume the newline character (\n) at the end of user input.
‚û§But nextLine() does consume the full line, including the newline.

So, if you call nextLine() immediately after nextInt() or next(), it may read the leftover newline from the previous input, resulting in an empty string.

üîç Example:
Scanner sc = new Scanner(System.in);

System.out.print("Enter age: ");
int age = sc.nextInt();  // user enters: 25 + [Enter]

System.out.print("Enter name: ");
String name = sc.nextLine();  // reads leftover '\n' from above

System.out.println("Age: " + age);
System.out.println("Name: " + name);

üî¥ Output:
Enter age: 25
Enter name:
Age: 25
Name:
‚ùóOops! name is empty because nextLine() consumed the leftover newline from nextInt().

‚úÖ How to Fix It:
Solution: Add a sc.nextLine() dummy call after nextInt() or next() to consume the leftover newline.

System.out.print("Enter age: ");
int age = sc.nextInt();
sc.nextLine(); // ‚Üê eat the leftover newline

System.out.print("Enter name: ");
String name = sc.nextLine();

üî∑ IIB ‚Äî Instance Initialization Block
########################################
It runs every time an object is created, before the constructor, and is used to initialize instance (non-static) data.
You can think of an IIB as an anonymous constructor fragment that runs before the real constructor.

package p1;

public class iiBTutorial {
	int i;
	int j;
	static int k;
	static void test() {
		System.out.println("Test method called");
	}
	{
		i = 10;
		j = 20;
		System.out.println("Intance Initialization Block 1 called");
		System.out.println("The value of i: " + i);
		System.out.println("The value of j: " + j);
		System.out.println("The value of k: " + k);
		test();
		// new iiBTutorial();-----------> recursive calling of IIB stack overflow, cannot create object inside IIB
	}
	{
		System.out.println("Intance Initialization Block 2 called");
	}

	iiBTutorial() {
		System.out.println("B constructor called");
	}

	public static void main(String[] args) {
		iiBTutorial b1 = new iiBTutorial();
		test();
	}
}


When you create an object, Java executes:
1. Instance variable initializations
2. IIB block(s) (in the order they appear)
3. Constructor

‚û§Use Case: To initialize instance variables or logic common to all constructors.
‚û§Runs whenever an object creation takes place.
‚û§Every time a new object is created, IIB runs.

‚úÖ When to Use IIB?
‚û§When all constructors need to run some common code.
‚û§To reduce duplication across overloaded constructors.

Note: A Static variable/method can be accessed inside the IIB

üî∑ SIB ‚Äî Static Initialization Block
#######################################
It runs once when the class is loaded, before the main() method or any static method/variable is accessed.

package p1;

public class SIBTutorial {
	static int i;
	int j;
	static {
		System.out.println("Static Initialization Block-1 called");
		System.out.println("The value of i "+i);
		i=20;
		j=10;//cannot do that
		System.out.println("The value of i "+i);	
	}
	static {
		System.out.println("Static Initialization Block-2 called");
	}
	public static void main(String[] args) {}
}

Order of Execution:
‚û§Static variable initializations
‚û§SIB block(s) (in the order they appear)
‚û§Main method

üî• Use Case:
‚û§Initialize static variables
‚û§Load configuration, logging, or static resources
‚û§Run a one-time setup for the class

Example 2: We can create an object inside SIB through which IIB and the constructor can be called.
package p1;
public class A {
	{
		System.out.println("IIB");// Print 1
	}
	static {
		new A();
		System.out.println("SIB"); // Print 3
	}
	A(){
		System.out.println("Constructor of A called");// Print 2
	}
	public static void main(String[] args) {
		System.out.println("Entered Main");// Print 4
	}
}

Output 
IIB
Constructor of A called
SIB
Entered Main

Super in Java
###############
The super keyword is a reference variable used within a subclass to refer to its immediate parent class (superclass) members, including variables, methods, and constructors.
It helps achieve proper inheritance behavior and overriding control.

‚úÖ Uses of super in Java
1Ô∏è‚É£ Access Parent Class Fields (Variables)
When the subclass has a variable with the same name as the parent class, super helps distinguish the parent class version.
It cannot access the private members of the super class.

üéì Real-World Analogy
Imagine super as saying:
"Hey, I want the version of this thing that came from my parent class."
Just like a child might say:
"I want to use my dad‚Äôs phone, not mine ‚Äî because it's different."

class A {
    int num = 10;
}
class B extends A {
    int num = 20;
    void display() {
        System.out.println("Child num: " + num);       // 20
        System.out.println("Parent num: " + super.num); // 10
    }
}

2Ô∏è‚É£ Call Parent Class Methods
If the child class overrides a method, but you still want to call the parent version, use super.methodName().

public class A {
	 int x = 10;
	 static int y=20;
	  static void display() {
		  System.out.println("This is a static display method");
	  }
	    void show() {
	        System.out.println("In class A");
	    }
}

public class B extends A {

	public static void main(String[] args) {
		B b1=new B();
		b1.test();	
	}
	public void test() {
		super.display();
		System.out.println(super.x);
		System.out.println(super.y);	
	}
}

‚úÖ What This Means:
‚û§Super is meant to refer to instance (non-static) members of a superclass.
‚û§Even though it is technically possible to write super.staticMethod() in Java, it is discouraged, and Java treats it the same as ParentClass.staticMethod() internally.
‚û§So, it's not a compiler error, but a bad practice.

‚úÖ Best Practice:
Always access static members using the class name, not super or this.
// Good
ParentClass.staticMethod();

// Bad (misleading)
super.staticMethod();

3Ô∏è‚É£ Call Parent Class Constructor
‚û§super() is used to call the constructor of the parent class from the child class constructor only.
‚û§‚úÖ This must be the first statement in the subclass constructor; Hence, super and this keyword cannot be used at the same time.
‚û§If in the Child class constructor, this keyword is used, then in that constructor super keyword will not be automatically placed.
class A {
    A() {
        System.out.println("Constructor of A");
    }
}
class B extends A {
    B() {
        super();  // Must be first statement
        System.out.println("Constructor of B");
    }
}
üìå Output:
Constructor of A
Constructor of B

Even though you didn‚Äôt write super() in class B, Java internally adds it:
Even If we don't explicitly write the constructor, Java internally calls the constructor and add the super() keyword inside it(but only calls the default constructor of the parent class).
B() {
    super(); // inserted automatically by compiler
    System.out.println("Constructor of B");
}

üéØ Why use it?
‚û§To ensure proper construction of the inheritance chain
‚û§To pass values to a parameterized parent constructor

4Ô∏è‚É£ Use with Parameterized Constructors
class A {
    A(String msg) {
        System.out.println("Message from A: " + msg);
    }
}
class B extends A {
    B() {
        super("Hello"); // Pass value to superclass constructor
        System.out.println("Constructor of B");
    }
}

‚ùå super is not allowed in static methods
The super keyword refers to the current object‚Äôs superclass, but static methods belong to the class, not to any object.

üîç Why This Causes an Error:
‚û§Static methods do not have a this reference, because they can be called without creating an object.
‚û§Since super is used to refer to the parent of this object, and this doesn't exist in a static context, super becomes invalid there.

üß™ Example:
class A {
    int x = 10;
    static void staticShow() {
        System.out.println("Static method in A");
    }
}
class B extends A {
    static void staticTest() {
        // System.out.println(super.x); ‚ùå Compile-time error
        // super.staticShow();          ‚ùå Compile-time error
    }
}

üö´ Both lines give:
Cannot use 'super' in a static context

‚úÖ What You Can Do in Static Methods:
If you need to access static members of the parent class in a static method:
A.staticShow();  // ‚úÖ Correct
System.out.println(A.someStaticVariable);  // ‚úÖ Correct

Loops in Java
##############
1. for loop

Example 1;
---------
public class A {
	public static void main(String[] args) {
		for (int i = 0; i < 4; i++) { //0 to 3
			System.out.println(i);
		}
	} 
}
Example 2:
a. The user will enter the PIN 1234
b. If the entered PIN is valid, then the program should print Welcome and stop
c. If the PIN is invalid, the user can attempt to enter it a maximum of three times.
d. If all 3 times the PIN is invalid, then the card is blocked message we should get

Code:
package p1;
import java.util.Scanner;
//break
//1. Can be used only inside loops and switch case statements
//2. It stops the for loop execution
public class A {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		
		for(int i=0;i<3;i++) {//0 to 2
			System.out.println("Enter the pin number");
			int pinNumber = scan.nextInt();
			if(pinNumber==1234) {
				System.out.println("Welcome");
				break;
			}else {
				System.out.println("Invalid Pin number");
				if(i==2) {
					System.out.println("Card is blocked");
				}
			}
		}
		scan.close();
	} 
	
}

2. while loop
Example 1:
----------
package p1;
public class A {
	public static void main(String[] args) {
		int i=0;
		while(i<3) {//If condition true will enter while loop
			System.out.println(i);
			i++;
		}
	}	
}

Example 2:
--------
a. Enter the amount, and we should get a message, please collect cash
b. Then prompt a message: Do you want to continue(yes or no)
c. If yes, again enter the amount, and we should get a message, please collect cash
d. If no program is entered, it should stop

Code:
import java.util.Scanner;

public class A {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		String i="yes";
		while(i.equals("yes")) {//If condition true will enter while loop
			System.out.println("Enter the amount");
			int amount = scan.nextInt();
			System.out.println("Please collect the cash: rs. "+amount);
			System.out.println("Do you want to continue(yes/no)?");
			i = scan.next();
			
			if(i.equals("no")) {
				System.out.println("Thank you. Visit again");
			}
		}
	}
}

3. do while loop -  Will run first time without condition check. For the second iteration, the condition will be evaluated

Example 1:
---------
package p1;
public class A {
	public static void main(String[] args) {
		int i=100;
		do {
			System.out.println(i);
			i++;
		}while(i<3);
	}	
}

Example 2:
----------
package p1;
public class A {
	public static void main(String[] args) {
		int i=0;
		do {
			System.out.println(i);
			i++;
		}while(i<3);
	}	
}

4. for each loop - 
-> Works only with a data structure
-> Can only read the value of the data structure one by one
-> The loop will run until all values are read in the given data structure

Example:
package p1;
public class A {
	public static void main(String[] args) {
		int[] age = new int[3];
		age[0] = 100;
		age[1] = 101;
		age[2] = 120;
		
		for(int x:age) {
			System.out.println(x);
		}
	}
}

Continuation of Arrays using Loops:
######################

Example 1:
----------
package p1;
public class A {
	public static void main(String[] args) {
		int[] age = new int[3];
		age[0] = 100;
		age[1] = 101;
		age[2] = 120;
		
		for (int i = 0; i < age.length; i++) {//0 to 2
			System.out.println(age[i]);
		}
	}
}

ArrayIndexOutOfBoundsException
#####################################
‚û§When we exceed the array size, we get this exception

Example:
------
package p1;
public class A {
	public static void main(String[] args) {
		try {
			int[] age = new int[3];
			age[0] = 100;
			age[1] = 101;
			age[2] = 120;
			age[3] = 103;
		} catch (Exception e) {
			e.printStackTrace();
		}
		System.out.println("Welcome");
	}
}

Output:
java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3
Welcome

Continue Keyword in Java
#####################
The continue keyword is used inside loops (for, while, or do-while) to skip the current iteration and jump to the next one.

package p1;
public class A {
	public static void main(String[] args) {
		for (int i = 0; i < 5; i++) {
			
			if(i==3) {
				continue;
			}
			System.out.println(i);//0 1 2 4
		}
	}
}
Output:
0
1
2
4

else-if ladder statement
######################
-> If the user enters yes, it should print pass
-> If the user enters no, it should print fail
-> If the user enters something else, it should print invalid input

Example:
-------------
package p1;

import java.util.Scanner;

public class A {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		System.out.println("Enter the input(yes/no)");
		String value = scan.next();
		if(value.equals("yes")) {
			System.out.println("Pass");
		} else if(value.equals("no")) {
			System.out.println("Fail");
		} else {
			System.out.println("Invalid Input");
		}
	}	
}

Switch Case
############################

package p1;

import java.util.Scanner;

public class A {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		System.out.println("Enter the floor number");
		int key=scan.nextInt();
		switch (key) {
		case 1:
			System.out.println("1st Floor");
			break;
		case 2:
			System.out.println("2nd Floor");
			break;
		case 3:
			System.out.println("3rd Floor");
			break;
		default:
			System.out.println("Invalid input");
			break;
		}
	}	
}

Removing Duplicate elements from an array
###########################################
‚û§For the below logic array should be sorted

Steps:
1. Create a temp array which same size as that of x
int[] x = {3,3,4,5,6,6,7};
int[] temp = new int[x.length];

2. Compare i with i+1 of array x, if not equal copy the value from x[i] to temp[j] and increment j by 1

3. When you reach last index of array x, copy that value directly to temp[j];

package p1;
public class A {
	public static void main(String[] args) {
		int[] x = {3,3,4,5,6,6};
		int[] temp = new int[x.length];
		int j=0;
		for(int i=0;i<x.length-1;i++) {//i=5
			if(x[i]!=x[i+1]) {//with index 5 to 6
				temp[j] = x[i];
				j++;
			}
		}
		temp[j] = x[x.length-1];
		
		for(int arr:temp) {
			System.out.println(arr);
		}
	}
}

Logic For Swapping
##########################
package p1;
public class A {
	public static void main(String[] args) {
		int x = 10;
		int y = 20;
		int temp;
		temp=y;
		y=x;
		x=temp;
		System.out.println(x);
		System.out.println(y);
	}
}

File Handling in Java
#######################
Example 1:It holds the given path in the variable "f" without checking whether the file exists

package p1;
import java.io.File;
public class A {
	public static void main(String[] args) {
		File f = new File("E:\\april\\t1.txt");
		System.out.println(f);
	}
}

1. exists() - 
------------
a. It is a non-static method present inside the File class
b. The return type of this method is boolean
c. It checks whether the file exists in the given path.
d. If the file exists, it will return true or else false

Example:
---------
package p1;
import java.io.File;
public class A {
	public static void main(String[] args) {
		File f = new File("G:\\april\\t100.txt");
		boolean val = f.exists();
		System.out.println(val);
	}
}

2. delete() - 
------------
a. It is a non-static method present inside the File class
b. The return type of this method is boolean
c. It deletes the file that exists in the given path.
d. If the file is deleted, it will return true or else false

Example:
--------
package p1;
import java.io.File;
public class A {
	public static void main(String[] args) {
		File f = new File("G:\\april\\t1.txt");
		boolean val = f.delete();
		System.out.println(val);
	}
}

3.mkdir() - 
------------
a. It is a non-static method present inside the File class
b. The return type of this method is boolean
c. It creates a folder  in the given path.
d. If a folder is created, it will return true or else false
e. It will not replace the existing folder

Example:
-------
package p1;
import java.io.File;
public class A {
	public static void main(String[] args) {
		File f = new File("G:\\april\\p2");
		boolean val = f.mkdir();
		System.out.println(val);
	}
}

Example: To delete a Folder using the delete() method

public class A {
	public static void main(String[] args) {
		File f = new File("G:\\april\\p2");
		boolean val = f.delete();
		System.out.println(val);
	}
}

Note: The delete() method can delete both folders/files

4.length() - 
------------
a. It is a non-static method present inside the File class
b. The return type of this method is long
c. It counts characters with white spaces in the given file.

Example:
--------
package p1;
import java.io.File;
public class A {
	public static void main(String[] args) {
		File f = new File("G:\\april\\t1.txt");
		long val = f.length();
		System.out.println(val);
	}
}

Compile-time Exception/Checked Exception
_____________________________________________
-> These exceptions will occur even when the program is correct/Incorrect
-> Handling exceptions becomes mandatory when it is at compile time

5. createNewFile()-
-------------------
a. It is non non-static method present inside the File Class
b. Its return type is boolean
c. It throws a compile-time exception. So should be handled before executing the program
d. If the file is created, it will return true or else false
e. Will not replace existing file

Example:
------
package p1;
import java.io.File;
import java.io.IOException;
public class A {
	public static void main(String[] args) {
		try {
			File f = new File("G:\\april\\t1.txt");
			boolean val = f.createNewFile();
			System.out.println(val);
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}

IOException in Java
The IOException is a checked exception in Java, part of the java.io package. It is thrown when an Input/Output operation fails or is interrupted.

Scenario			Example
File not found			Reading a file that doesn't exist
File not readable		Permission denied or locked file
Network I/O failure		Socket disconnected unexpectedly
Stream closed unexpectedly	Trying to read from a closed stream
Writing to a full disk		OutputStream write failure


6. list()-
-------------------
a. It is non non-static method present inside the File Class
b. Its return type is String[] array
c. It gets all file/folder names from a given path

Example:
-------
package p1;
import java.io.File;
public class A {
	public static void main(String[] args) {
			File f = new File("G:\\april\\");
			String[] val = f.list();
			for(String x: val) {
				System.out.println(x);
			}
			System.out.println(val.length);
	}
}

2. FileReader:
‚û§ can read the text file content
‚û§read(): int

Example 1:
-----------
package app_java_3;
import java.io.FileReader;
public class A {
	public static void main(String[] args) {
		try {
			FileReader fr = new FileReader("G:\\april\\t1.txt");
			System.out.println((char)fr.read());
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

Example 2:
----------

package app_java_3;
import java.io.File;
import java.io.FileReader;
public class A {
	public static void main(String[] args) {
		try {
			File f = new File("G:\\april\\t1.txt");
			FileReader fr = new FileReader(f);
			for (int i = 0; i < f.length(); i++) {//0 to 3
				System.out.print((char)fr.read());
			}
			fr.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

‚û§read(char[] ch)
Example
-------
package app_java_3;
import java.io.File;
import java.io.FileReader;
public class A {
	public static void main(String[] args) {
		try {
			File f = new File("G:\\april\\t1.txt");
			FileReader fr = new FileReader(f);
			char[] ch = new char[(int)f.length()];
			fr.read(ch);
			
			for(char c:ch) {
				System.out.print(c);
			}
			fr.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

#####################
FileWriter class
#####################
1. It will write content to a text file
2. If the File is not present in the given path, it will create a new file
3. If the file is present in the given path, then it will replace the existing file by default
4. During FileWriter object creation, if true is given, then it will not replace the existing content of the file. But it  will create a new file if the file is not present in the given path
Example: FileWriter fw = new FileWriter("G:\\april\\t4.txt",true);
5. During FileWriter object creation, if a false/ no boolean value is given, then it will replace the existing content of the file and  will create a new file if the file was not present in the given path

Example: FileWriter fw = new FileWriter("G:\\april\\t4.txt",false);
Example: FileWriter fw = new FileWriter("G:\\april\\t4.txt");

Example:
---------
package app_java_3;

import java.io.FileWriter;

public class A {
	public static void main(String[] args) {
		try {
			FileWriter fw = new FileWriter("G:\\april\\t4.txt",false);
			fw.write(97);//write(int x)
			fw.write("100");//write(String x)
			
			char[] ch = {'a','b','c'};
			fw.write(ch);//write(char[] x)
			
			fw.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

Example 2:
----------
package app_java_3;

import java.io.FileWriter;

public class A {
	public static void main(String[] args) {
		try {
			FileWriter fw = new FileWriter("G://april//t1.txt");
			fw.write("mike");
			fw.write("\n");
			fw.write("stallin");
			fw.write("\n");
			fw.write("adam");
			fw.close();//Save the file content and close the file
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

BufferedReader
#######################
1. This will improve file reading performance
2. This should be used with the FileReader class. If we use only BufferedReader, then file reading cannot be done
3. It has readLine() method. Using this method we can read the entire line from the file

Example 1:
----------
package p1;
import java.io.BufferedReader;
import java.io.FileReader;
public class A {
	public static void main(String[] args) {
		try {
			FileReader fr = new FileReader("G://april//t1.txt");
			BufferedReader br = new BufferedReader(fr);
			System.out.println((char)br.read());
			br.close();
			fr.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

Example 2:
----------
package p1;
import java.io.BufferedReader;
import java.io.FileReader;
public class A {
	public static void main(String[] args) {
		try {
			FileReader fr = new FileReader("G://f1//t1.txt");
			BufferedReader br = new BufferedReader(fr);
			char[] ch = new char[4];
			br.read(ch);
			for(char c: ch) {
				System.out.print(c);
			}
			br.close();
			fr.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

Example 3:
-----------
package p1;
import java.io.BufferedReader;
import java.io.FileReader;
public class A {
	public static void main(String[] args) {
		try {
			FileReader fr = new FileReader("G://f1//t1.txt");
			BufferedReader br = new BufferedReader(fr);
			for(int i=0;i<3;i++) {
				System.out.println(br.readLine());
			}
			br.close();
			fr.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

BufferedWriter
#####################
‚û§It improves file writing performance
‚û§This should be used with the FileWriter class. If we use only BufferedWriter, then file writing cannot be done
‚û§BufferedWriter class has newline() method

Example 1:
----------
import java.io.BufferedWriter;
import java.io.FileWriter;
public class A {
	public static void main(String[] args) {
		try {
			FileWriter fw = new FileWriter("G://april//t1.txt",true);
			BufferedWriter bw = new BufferedWriter(fw);
			bw.write("mike");
			bw.newLine();
			bw.write(97);
			char[] ch = {'b','c','d'};
			bw.newLine();
			bw.write(ch);
			
			bw.close();
			fw.close();
			
			
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

################################
Serialization & Deserialization
################################

-> Serialization is a process of converting an object to byte code and storing that in a file system
-> Deserialization is a process of reading byte code from the file and forming an Object based on the byte code
-> To skip writing certain content to the object during serialization, we can use the  transient keyword

Example:
--------
package p1;
import java.io.Serializable;
public class A implements Serializable{
	String name="mike";
	transient String password = "testing";
}

package p1;
import java.io.FileOutputStream;
import java.io.ObjectOutputStream;
public class B {
	public static void main(String[] args) {
		A a1 = new A();
		try {
			FileOutputStream fos = new FileOutputStream("G:\\april\\file.ser");
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			oos.writeObject(a1);
		
			oos.close();
			fos.close();
		} catch (Exception e) {	
			e.printStackTrace();
		}
	}
}

package p1;
import java.io.FileInputStream;
import java.io.ObjectInputStream;
public class C {
	public static void main(String[] args) {
		try {
			FileInputStream fis = new FileInputStream("G:\\april\\file.ser");
			ObjectInputStream ois = new ObjectInputStream(fis);
			A a1 = (A)ois.readObject();
			System.out.println(a1.name);
			System.out.println(a1.password);
			
			ois.close();	
		} catch (Exception e) {	
			e.printStackTrace();
		}
	}
}

JDBC - Java Database Connectivity
##########################################
-> Database: Here we store data in the form of tables permanently
-> Popular Databases: MySQL, PostgreSQL, Oracle, SQL Server, MongoDB, Derby, h2Database
-> Install MySQL Database
Download from here: https://dev.mysql.com/downloads/windows/installer/8.0.html
-> When you download MySQL Workbench, you will get the following
a. IDE - To Write SQL Query (Structured Query Language)
(SQL query is used to interact with the database)
b. MySQL Server

Installation Doc: https://www.prowesstics.com/blogs/mysql-workbench-installation/

-> Launch MySQL Workbench
-> Create psaDB connection
-> Crate Database: Create Database psaDB
-> Connect to Database: use psaDB
-> Create Table Student: 
Create table student(
	name varchar(45),
    email varchar(128),
    mobile varchar(10)
)
-> Read Table Content: Select * from student
-> Insert data to table: insert into student values('mike','mike@gmail.com','9632629033')
-> Read Table Content: Select * from student

Assignment: Complete SQL Recorded Classes. Access will be given in the PSA App. Nearly covered 250+ examples

After installing MySQL Workbench, we can now start with the JDBC Concept
------------------------------------------------------------------------
-> Interacting with the database using Java program
-> Download Connector File for MySQL: https://dev.mysql.com/downloads/file/?id=538917
-> Create a folder with the name lib inside the root path of your Java project & paste the connector jar file inside it
-> Right click on project>>Go to properties>>select java build path>> click on libraries tab>>Click on add jar>>navigate to lib folder and select mysql connector j jar>> click apply + close

Example 1: JDBC code to insert data
-----------------------------------
package jdbc_examples;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.Statement;

public class A {
	public static void main(String[] args) {
		try {
//Connect to database - use psaDB (SQL)
			
Connection con=DriverManager.getConnection("jdbc:mysql://localhost:3306/psadb1","root","test");

//Write & execute SQl query
Statement stmnt =  con.createStatement();
stmnt.executeUpdate("insert into student values('adam','adam@gmail.com','9632629555')");
			
//Close database connection
con.close();
} catch (Exception e) {
	e.printStackTrace();
}
}
}
 
Example 2: JDBC Code to delete a record
---------------------------------------
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.Statement;

public class B {
	public static void main(String[] args) {
		try {
			//Connect to database - use psaDB (SQL)
		Connection con = 
					DriverManager.
	getConnection("jdbc:mysql://localhost:3306/psadb1","root","test");
					
			//Write & execute SQl query
			
			Statement stmnt =  con.createStatement();
			stmnt.executeUpdate("Delete from student where email='adam@gmail.com'");
			//Close database connection
			con.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

Example 3: JDBC Code to update a Record
-------------------------------------
import java.sql.*;

public class C {
	public static void main(String[] args) {
		try {
			//Step Connect to Database
			Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/psadb1", "root", "test");
			
			//Step 2: Execute SQL Query
			Statement stmnt = con.createStatement();
			stmnt.executeUpdate("Update student set mobile='9632882052' where email='mike@gmail.com'");
			
			//Step 3: Close Database Connection
			con.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

Example 4: JDBC Code to read data from the database
-----------------------------------------------
package p1;

import java.sql.*;

public class D {
	public static void main(String[] args) {
		try {
			//Step Connect to Database
			Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/psadb1", "root", "test");
			
			//Step 2: Execute SQl Query
			Statement stmnt = con.createStatement();
			ResultSet result = stmnt.executeQuery("Select * from student");
			
			while(result.next()) {
				System.out.println(result.getString(1));
				System.out.println(result.getString(2));
				System.out.println(result.getString(3));
			}
			
			//Step 3: Close Database Connection
			con.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

Multi-catch blocks:
---------------------
‚û§We can create multiple catch blocks.
‚û§Always start withthe  child exception class followed by the parent exception class

Example:
---------
package p1;

public class E {
	int x = 10;
	public static void main(String[] args) {
		try {
			Integer.parseInt("ahsjkdhas687");
			E a1 = null;
			System.out.println(a1.x);
			int x = 10/0;
		}catch (ArithmeticException e) {
			System.out.println(1);
		}catch (NullPointerException e) {
			System.out.println(2);
		}catch (Exception e) {
			System.out.println(3);
		}
		
	}
}

Finally block in Java
###########################
‚û§ This isan  extension of try try-catch block
‚û§The code that we write in the finally block will run 100%, regardless of the exception

Example:
--------
public class E {
	int x = 10;
	public static void main(String[] args) {
		try {
			int x = 100/0;
		}catch (Exception e) {
			e.printStackTrace();
		}finally {
			System.out.println("Finally");//Output: Finally
		}	
	}
}

Example:
--------
public class E {
	int x = 10;
	public static void main(String[] args) {
		try {
			int x = 100/2;
		}catch (Exception e) {
			e.printStackTrace();
		}finally {
			System.out.println("Finally")//;Output: Finally
		}
		
	}
}

Example: Can we write only a try-catch block: yes
--------
public class E {
	int x = 10;
	public static void main(String[] args) {
		try {
			int x = 100/0;
		}finally {
			System.out.println("Finally");
		}
		System.out.println("Welcome");
	}
}
Output: Finally
Exception in thread "main" java.lang.ArithmeticException: / by zero
	at jdbc_examples.E.main(E.java:7)


Note: Can u give a practical example where the finally block can be used?
Ans: 
a. We can perform a database closing operation
b. We can performa  file closing operation / Database closing Operation

Example :
package p1;

import java.sql.*;

public class A {
	public static void main(String[] args) {
		Connection con = null;
		try {
			//Step Connect to Database
			con = DriverManager.getConnection("jdbc:mysql://localhost:3306/psadb1", "root", "test");
			
			//Step 2: Execute SQl Query
			Statement stmnt = con.createStatement();
			stmnt.executeUpdate("insert into student values('adam','adam@gmail.com','9632629455')");
					
		} catch (Exception e) {
			e.printStackTrace();
		}finally {
			try {
				//Step 3: Close Database Connection
				con.close();
			} catch (Exception e2) {
				e2.printStackTrace();
			}
		}
	}
}

Interview Question:
a. Difference between final, finally, and finalize
=============================================================
final
--------
-> final makes variable constant
-> final prevents overriding
-> final on class stops inheritance

finally
-------
-> This is an extension of try try-catch block
-> The code that we write in the finally block will run 100%, regardless of the exception

finalize():
----------
-> This is a method inside the Object class, and herethe  Garbage collection logic is implemented
-> We can try calling the garbage collector using System.gc(). But it will not guarantee 100% execution.

