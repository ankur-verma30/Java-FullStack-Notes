🧠 Method Referencing in Java
🔹 What is Method Referencing
➤ A shorthand syntax of lambda expressions when the lambda body only calls an existing method.
➤ Improves readability and makes code look cleaner.
➤ Introduced in Java 8 with functional programming features.

🔹 Syntax
ClassName::methodName
object::methodName
ClassName::new  (for constructors)

🔹 Types of Method References
✅Type 1: Reference to a static method

list.forEach(System.out::println);  
// equivalent to: list.forEach(x -> System.out.println(x));

✅Type 2: Reference to an instance method of a particular object
String str = "hello";
Supplier<Integer> s = str::length;
System.out.println(s.get());  // 5

✅Type 3: Reference to an instance method of an arbitrary object of a particular type
List<String> names = Arrays.asList("Ankur", "Ravi", "Megha");
names.sort(String::compareToIgnoreCase);
// equivalent to (a, b) -> a.compareToIgnoreCase(b)

✅Type 4: Reference to a constructor
Supplier<Student> s = Student::new;
Student st = s.get();

🔹 Why Method Reference?
➤ Makes lambda shorter and cleaner.
➤ Avoids boilerplate (param) -> obj.method(param).
➤ mproves readability in sorting, filtering, mapping, etc.

🔹 Example: Sorting with Method Reference
students.sort(Comparator.comparingInt(Student::getAge));

Equivalent lambda:
students.sort((s1, s2) -> Integer.compare(s1.getAge(), s2.getAge()));

⚡ Tips
➤ Method reference is just syntactic sugar for lambdas.
➤ Works only when the method signature matches the functional interface method.
➤ Commonly used in Streams API (map, filter, forEach) and Comparator.

✅ Example Code Snippet
package collections;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;

class Student {
	String name;
	double gpa;

	Student(String name, double gpa) {
		this.name = name;
		this.gpa = gpa;
	}

	String getName() {
		return this.name;
	}

	double getGpa() {
		return this.gpa;
	}

} 
public class ArrayListIntro {

	public static void main(String[] args) {
		List<Student> students = new ArrayList<>();
		students.add(new Student("Charlie", 3.5));
		students.add(new Student("Bob", 3.7));
		students.add(new Student("Alice", 3.5));
		students.add(new Student("Ankur", 3.9));

		Comparator<Student> comparator = Comparator.comparing(Student::getGpa).reversed()
				.thenComparing(Student::getName);

		students.sort(comparator);
		for (Student s : students) {
			System.out.println(s.getName() + " " + s.getGpa());
		}

	}
}


🔷 Java 8 Basics
➤ Introduced to write minimal code and improve developer productivity.
➤ Functional Programming. For Example: lambda expressions, method references, streams, etc.

🌟 Lambda expression
// Functional interface
@FunctionalInterface
interface MathOperation {
    int operate(int a, int b);
}

public class LambdaMathOperation {
    public static void main(String[] args) {

        // Addition
        MathOperation add = (a, b) -> a + b;

        // Subtraction
        MathOperation subtract = (a, b) -> a - b;

        // Multiplication
        MathOperation multiply = (a, b) -> a * b;

        // Division (with check for divide by zero)
        MathOperation divide = (a, b) -> b != 0 ? a / b : 0;

        // Testing
        System.out.println("10 + 5 = " + add.operate(10, 5));
        System.out.println("10 - 5 = " + subtract.operate(10, 5));
        System.out.println("10 * 5 = " + multiply.operate(10, 5));
        System.out.println("10 / 5 = " + divide.operate(10, 5));
    }
}
✅ Output:
10 + 5 = 15
10 - 5 = 5
10 * 5 = 50
10 / 5 = 2


🌟Predicate
➤ A functional interface in java.util.function.
➤ Represents a boolean-valued function of one argument.
➤ Contains one abstract method:


🔄 Common Usage
➤ Filtering collections (Stream.filter()).
➤ Validation checks (like input checks, number checks, etc.).
➤ Combining multiple conditions.

✅Code Example:
import java.util.function.Predicate;

public class PredicateExample {
    public static void main(String[] args) {
        Predicate<Integer> isEven = x -> x % 2 == 0;
        Predicate<Integer> isPositive = x -> x > 0;

        System.out.println(isEven.test(4));   // true
        System.out.println(isPositive.test(-3)); // false
    }
}

🔄 Combining Predicates
Predicate provides default methods to combine multiple conditions:

👉 and() → Returns true if both predicates are true.
✅Code Example:
Predicate<Integer> isEven = x -> x % 2 == 0;
Predicate<Integer> isPositive = x -> x > 0;

Predicate<Integer> isEvenAndPositive = isEven.and(isPositive);
System.out.println(isEvenAndPositive.test(4));  // true
System.out.println(isEvenAndPositive.test(-2)); // false


👉 or() → Returns true if any one predicate is true.
✅Code Example:
Predicate<Integer> isEven = x -> x % 2 == 0;
Predicate<Integer> isNegative = x -> x < 0;

Predicate<Integer> isEvenOrNegative = isEven.or(isNegative);
System.out.println(isEvenOrNegative.test(3));   // false
System.out.println(isEvenOrNegative.test(-5));  // true


👉 negate() → Returns the opposite of the predicate.
✅Code Example:
Predicate<Integer> isEven = x -> x % 2 == 0;

Predicate<Integer> isOdd = isEven.negate();
System.out.println(isOdd.test(5));  // true


👉 isEqual() → Static method, checks if an object is equal to another.
✅Code Example:
Predicate<String> isHello = Predicate.isEqual("Hello");
System.out.println(isHello.test("Hello")); // true
System.out.println(isHello.test("Hi"));    // false

✅Real-Life Example: Filtering a List
import java.util.*;
import java.util.function.Predicate;
import java.util.stream.Collectors;

public class PredicateFilterExample {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(10, -3, 4, -7, 8, 15);

        Predicate<Integer> isPositive = x -> x > 0;
        Predicate<Integer> isEven = x -> x % 2 == 0;

        // Filter only positive even numbers
        List<Integer> result = numbers.stream()
                                      .filter(isPositive.and(isEven))
                                      .collect(Collectors.toList());

        System.out.println(result); // [10, 4, 8]
    }
}

🧠 Tips & Traps
✅ Predicate is mostly used in Streams API (e.g., filter() needs Predicate).
✅ Can be combined using .and(), .or(), .negate().
❌ Null values: Predicate can throw NullPointerException if not handled.
❓ Trick Q: How is Predicate<T> different from Function<T, Boolean>?
	✔️ Predicate<T> is specialized for boolean-returning conditions, while Function<T, Boolean> is generic.


🌟 Function
➤ A functional interface from java.util.function.
➤ Represents a function that takes one argument and returns a result.
➤ Abstract method:
🔗 R apply(T t);

✅Code Example:
import java.util.function.Function;

public class FunctionExample {
    public static void main(String[] args) {
        Function<Integer, Integer> square = x -> x * x;

        System.out.println(square.apply(5)); // 25
    }
}

🔄 Default Methods (Combining Functions)

👉 andThen()
➤ Executes the current function first, then applies another function.
✅Code Example
Function<Integer, Integer> multiplyBy2 = x -> x * 2;
Function<Integer, Integer> square = x -> x * x;

// First multiply by 2, then square
Function<Integer, Integer> resultFunc = multiplyBy2.andThen(square);

System.out.println(resultFunc.apply(3)); // (3*2)^2 = 36

👉 compose()
➤ Opposite of andThen(). Executes the given function first, then applies the current one.
✅Code Example
Function<Integer, Integer> multiplyBy2 = x -> x * 2;
Function<Integer, Integer> square = x -> x * x;

// First square, then multiply by 2
Function<Integer, Integer> resultFunc = multiplyBy2.compose(square);

System.out.println(resultFunc.apply(3)); // (3^2)*2 = 18

👉 identity() (Static Method)
➤ Returns a function that always returns its input.
✅Code Example
Function<String, String> identityFunc = Function.identity();
System.out.println(identityFunc.apply("Hello")); // Hello

✅ Real-Life Example: Convert & Process Data
import java.util.function.Function;

public class FunctionChainExample {
    public static void main(String[] args) {
        // Step 1: Convert string to integer
        Function<String, Integer> strToInt = Integer::parseInt;

        // Step 2: Square the integer
        Function<Integer, Integer> square = x -> x * x;

        // Chain them
        Function<String, Integer> process = strToInt.andThen(square);

        System.out.println(process.apply("6")); // 36
    }
}

🧠 Notes
✅ andThen() vs compose() → Order of execution is key (common trick Q).
✅ Function.identity() → used in collectors (e.g., toMap() in Streams).
❌ Be careful with NumberFormatException when using Integer::parseInt.
🔥 Advanced: There’s also BiFunction<T,U,R> for functions with two arguments.


🌟 Consumer

🌟 Streams



