#############################
ğŸ”· Creational Design Pattern
#############################
===============================
1ï¸âƒ£ Singleton Design Pattern
===============================
â¤ Singleton Pattern ensures that only one instance of a class exists in the entire application.
â¤ It also provides a global access point to that single instance.
â¤ In Java, this is commonly used for shared resources that must be centrally controlled.


ğŸ” Problem It Solves
Prevents multiple objects from being created for something that should exist only once.
Without Singleton:
    âœ”ï¸ Multiple instances â†’ inconsistent state
    âœ”ï¸ Wasted memory/resources
    âœ”ï¸ Hard-to-track bugs in large applications
Especially critical when:
    âœ”ï¸ Managing shared configuration
    âœ”ï¸ Handling centralized services
    âœ”ï¸ Controlling access to limited resources


ğŸ” Real-Life Analogy
Countryâ€™s Prime Minister
    âœ”ï¸ Only one Prime Minister exists at a time.
    âœ”ï¸ Everyone refers to the same authority.
    âœ”ï¸ If multiple PMs existed â†’ chaos and conflicting decisions.
Same idea: one object, one authority, global access.


ğŸ” Real-World Project Usage (Java / Spring â€“ No Code)
1ï¸âƒ£ Configuration Management
    âœ”ï¸ Application configuration is loaded once and shared across services.

2ï¸âƒ£ Logging System
    âœ”ï¸ A single logger instance handles logs from all parts of the application.

3ï¸âƒ£ Database Connection Manager
    âœ”ï¸ Controls access to database connections to avoid overload.

4ï¸âƒ£ Caching Layer
    âœ”ï¸ One cache instance shared across multiple services.

5ï¸âƒ£ Spring Boot Context
    âœ”ï¸ By default, Spring beans are Singleton-scoped, meaning the framework manages one instance per container.


ğŸ” Obervational Questions 
Tests understanding of:
    âœ”ï¸ Object lifecycle
    âœ”ï¸ Resource management
    âœ”ï¸ Concurrency implications

Often followed by:
    âœ”ï¸ â€œIs Singleton good or bad?â€
    âœ”ï¸ â€œHow does Spring handle Singleton internally?â€

===========================
ğŸ”· Factory Design Pattern
===========================
â¤ Factory Design Pattern provides a centralized way to create objects without exposing the object creation logic to the client.
â¤ The client only asks for an object; the factory decides which concrete class to instantiate.
â¤ Focuses on object creation abstraction.


ğŸ” Problem It Solves
â¤ Removes tight coupling between client code and concrete classes.
â¤ Without Factory:
    âœ”ï¸ Client code contains many new operations
    âœ”ï¸ Adding a new type requires modifying existing logic
    âœ”ï¸ Violates Openâ€“Closed Principle
â¤ Factory solves:
    âœ”ï¸ Object creation complexity
    âœ”ï¸ Frequent condition-based instantiation (ifâ€“else, switch)
    âœ”ï¸ Scalability issues when new types are added


ğŸ” Real-Life Analogy
â¤ Restaurant Kitchen
    âœ”ï¸ You order food (Pizza / Burger / Pasta)
    âœ”ï¸ You donâ€™t know how itâ€™s cooked or who cooks it
    âœ”ï¸ The kitchen (factory) decides which chef prepares your order
â¤ You ask â†’ Factory decides â†’ You receive the object


ğŸ” Real-World Project Usage 
1ï¸âƒ£ Payment Processing Systems
    âœ”ï¸ Factory returns different payment handlers (Card, UPI, Wallet) based on input.

2ï¸âƒ£ Notification Systems
    âœ”ï¸ Factory provides Email, SMS, or Push notification service.

3ï¸âƒ£ Document / File Processing
    âœ”ï¸ Factory creates PDF, Excel, or Word processors.

4ï¸âƒ£ Spring Framework Internals
    âœ”ï¸ Spring uses factories internally to create beans based on configuration.

5ï¸âƒ£ Microservices Integration
    âœ”ï¸ Choosing different client implementations based on environment or version.


ğŸ” Obervational Questions
Tests understanding of:
âœ”ï¸ Loose coupling
âœ”ï¸ SOLID principles
âœ”ï¸ Extensibility in large systems

Follow-up questions often include:
âœ”ï¸ Difference between Factory and Abstract Factory
âœ”ï¸ Why Factory is preferred over direct object creation


====================================
ğŸ”· Abstract Factory Design Pattern
====================================
â¤ Abstract Factory Pattern provides an interface to create families of related or dependent objects without specifying their concrete classes.
â¤ It is essentially a factory of factories.
â¤ Focuses on grouped object creation with consistency.


2ï¸âƒ£ Problem It Solves
â¤ When multiple related objects must be created together and compatible with each other.
â¤ Without Abstract Factory:
    âœ”ï¸ Mixing incompatible objects (wrong combinations)
    âœ”ï¸ Too many conditional checks
    âœ”ï¸ Difficult to switch entire product families
â¤ Solves:
    âœ”ï¸ Consistency across related objects
    âœ”ï¸ Easy switching between entire families
    âœ”ï¸ Cleaner architecture for large systems


3ï¸âƒ£ Real-Life Analogy
â¤ Car Manufacturing Plant
    âœ”ï¸ One plant produces SUV parts
    âœ”ï¸ Another produces Sedan parts
    âœ”ï¸ Each plant provides:
            ğŸ”— Engine
            ğŸ”— Tyres
            ğŸ”— Interior
    âœ”ï¸ You never mix SUV engine with Sedan interior
â¤ Each plant = Abstract Factory
â¤ Each part set = Product family


4ï¸âƒ£ Real-World Project Usage
1ï¸âƒ£ UI Theme Systems
    âœ”ï¸ Light theme factory produces light buttons, light dialogs, light inputs
    âœ”ï¸ Dark theme factory produces dark variants of all components

2ï¸âƒ£ Cloud Provider Integrations
    âœ”ï¸ AWS factory vs Azure factory providing storage, messaging, and compute services

3ï¸âƒ£ Cross-Database Support
    âœ”ï¸ MySQL factory vs Oracle factory creating compatible DAOs and query executors

4ï¸âƒ£ Enterprise Applications
    âœ”ï¸ Switching entire implementations based on client, region, or environment

5ï¸âƒ£ Spring Profiles
    âœ”ï¸ Different factories activated based on environment (dev, prod, test)


ğŸ” Obervational Questions
Tests understanding of:
    âœ”ï¸ Object families
    âœ”ï¸ High-level abstraction
    âœ”ï¸ Enterprise-level architecture thinking

Common follow-ups:
    âœ”ï¸ Factory vs Abstract Factory
    âœ”ï¸ When Abstract Factory is overkill


=============================
ğŸ”· Builder Design Pattern
=============================
â¤ Builder Design Pattern separates the construction of a complex object from its representation.
â¤ It allows creating objects step by step, giving control over which parts are built.
â¤ Especially useful when an object has many optional parameters.


ğŸ” Problem It Solves
Solves the telescoping constructor problem:
    âœ”ï¸ Too many constructors
    âœ”ï¸ Confusing parameter order
    âœ”ï¸ Poor readability and maintainability

Without Builder:
    âœ”ï¸ Hard-to-understand object creation
    âœ”ï¸ Bugs due to wrong parameter positioning
    âœ”ï¸ Difficult to enforce immutability

Builder provides:
    âœ”ï¸ Clear, readable object creation
    âœ”ï¸ Flexibility with optional fields
    âœ”ï¸ Safer construction of complex objects


ğŸ” Real-Life Analogy
Ordering a Custom Burger
    âœ”ï¸ Choose bun, patty, cheese, sauces, toppings step by step
    âœ”ï¸ You donâ€™t have to choose everything
    âœ”ï¸ Final burger is assembled only when youâ€™re done
Builder = Burger customization counter


ğŸ” Real-World Project Usage 
1ï¸âƒ£ User Registration / Profile Objects
    âœ”ï¸ Many optional fields like address, preferences, social links

2ï¸âƒ£ API Request / Response Objects
    âœ”ï¸ Constructing complex request payloads with optional parameters

3ï¸âƒ£ Configuration Objects
    âœ”ï¸ Database, security, or client configuration with optional settings

4ï¸âƒ£ Immutable Domain Models
    âœ”ï¸ Objects created once and never modified afterward

5ï¸âƒ£ Spring Framework Usage
    âœ”ï¸ Widely used in Java libraries (e.g., HTTP clients, ORM configurations)


ğŸ” Obervational Questions
Tests understanding of:
    âœ”ï¸ Object construction vs object usage
    âœ”ï¸ Immutability concepts
    âœ”ï¸ Clean and readable APIs

Common follow-ups:
    âœ”ï¸ Builder vs Factory
    âœ”ï¸ When Builder is better than constructors



===========================
ğŸ”· Prototye Design Pattern
===========================
â¤ Prototype Design Pattern creates new objects by cloning an existing object (prototype) instead of creating them from scratch.
â¤ Object creation is based on copying, not instantiation.
â¤ Especially useful when object creation is costly or complex.

ğŸ” Problem It Solves
When creating an object:
    âœ”ï¸ Is expensive (database calls, heavy computations)
    âœ”ï¸ Requires complex setup or configuration

Without Prototype:
    âœ”ï¸ Repeated heavy initialization
    âœ”ï¸ Performance overhead
    âœ”ï¸ Duplicate setup logic everywhere

Prototype solves:
    âœ”ï¸ Faster object creation
    âœ”ï¸ Reduced initialization cost
    âœ”ï¸ Cleaner and reusable object setup


ğŸ” Real-Life Analogy 
â¤ Photocopy Machine
    âœ”ï¸ You donâ€™t rewrite the entire document
    âœ”ï¸ You copy an existing one and make small changes
â¤ Prototype = Original document
â¤ New object = Photocopy


ğŸ” Real-World Project Usage 
1ï¸âƒ£ Game Development
    âœ”ï¸ Cloning enemies or characters with similar attributes

2ï¸âƒ£ Document / Template Systems
    âœ”ï¸ Creating reports or invoices from predefined templates

3ï¸âƒ£ Caching Systems
    âœ”ï¸ Store a prototype object and clone it on demand

4ï¸âƒ£ Configuration Objects
    âœ”ï¸ Base configuration cloned and customized per request

5ï¸âƒ£ ORM / Persistence Contexts
    âœ”ï¸ Creating entity copies for transactional or sandbox operations


ğŸ” Obervational Questions
Tests understanding of:
    âœ”ï¸ Object lifecycle
    âœ”ï¸ Deep vs shallow copy concepts
    âœ”ï¸ Performance optimization techniques
Common follow-ups:
    âœ”ï¸ When cloning is dangerous
    âœ”ï¸ How Prototype differs from Factory


#############################
ğŸ”· Behavioral Design Pattern
#############################
==========================================
ğŸ”· Chain of Responsibility Design Pattern
==========================================
â¤ Chain of Responsibility Pattern allows a request to be passed through a chain of handlers, where each handler can:
    âœ”ï¸ Process the request, or
    âœ”ï¸ Pass it to the next handler in the chain
â¤ The sender of the request does not know which handler will process it.


ğŸ” Problem It Solves
â¤ Eliminates tight coupling between the sender and receiver of a request.
â¤ Without this pattern:
    âœ”ï¸ Large if-else or switch blocks
    âœ”ï¸ Hard-coded processing order
    âœ”ï¸ Difficult to add or remove processing logic
â¤ Solves:
    âœ”ï¸ Flexible request handling
    âœ”ï¸ Dynamic processing pipelines
    âœ”ï¸ Cleaner and extensible design


ğŸ” Real-Life Analogy
â¤ Customer Support Escalation
    âœ”ï¸ Level 1 support tries to resolve the issue
    âœ”ï¸ If not resolved â†’ escalates to Level 2
    âœ”ï¸ Then Level 3 if needed
â¤ Each support agent = Handler
â¤ Issue moves along the chain until handled


ğŸ” Real-World Project Usage
1ï¸âƒ£ Authentication & Authorization Pipelines
    âœ”ï¸ Request passes through multiple security checks
2ï¸âƒ£ Validation Frameworks
    âœ”ï¸ Multiple validators applied sequentially
3ï¸âƒ£ Logging Systems
    âœ”ï¸ Different log levels handled by different log processors
4ï¸âƒ£ Workflow Engines
    âœ”ï¸ Each step processes or forwards the request
5ï¸âƒ£ Spring Security
    âœ”ï¸ Filter chain where each filter decides to act or pass the request


ğŸ” Obervational Questions
Tests understanding of:
    âœ”ï¸ Decoupling request sender and processor
    âœ”ï¸ Dynamic behavior chaining
    âœ”ï¸ Extensibility in enterprise systems
Common follow-ups:
    âœ”ï¸ Chain vs Pipeline
    âœ”ï¸ Drawbacks like debugging complexity


===========================
ğŸ”· Command Design Pattern
===========================
â¤ Command Design Pattern encapsulates a request as an object, allowing you to:
    âœ”ï¸ Parameterize clients with different requests
    âœ”ï¸ Queue, log, or undo operations
â¤ It separates the object that invokes an action from the object that performs it.


ğŸ” Problem It Solves
Without Command Pattern:
    âœ”ï¸ Invoker directly calls business logic
    âœ”ï¸ Tight coupling between UI / controller and service logic
    âœ”ï¸ Hard to support undo, redo, or request history
Command solves:
    âœ”ï¸ Decoupling request sender and executor
    âœ”ï¸ Flexible execution of operations
    âœ”ï¸ Easy extension of new commands without changing invoker


ğŸ” Real-Life Analogy
â¤ TV Remote Control
    âœ”ï¸ Buttons donâ€™t know how TV works
    âœ”ï¸ Each button sends a command (ON, OFF, Volume Up)
    âœ”ï¸ TV executes the command
â¤ Remote = Invoker
â¤ Button action = Command
â¤ TV = Receiver


ğŸ” Real-World Project Usage 
1ï¸âƒ£ UI Action Handling
    âœ”ï¸ Menu buttons triggering different operations
2ï¸âƒ£ Undo / Redo Functionality
    âœ”ï¸ Text editors, IDEs, drawing applications
3ï¸âƒ£ Job Queues
    âœ”ï¸ Encapsulating tasks to be executed later
4ï¸âƒ£ Transactional Systems
    âœ”ï¸ Each operation stored as a command for audit or rollback
5ï¸âƒ£ Spring Framework
    âœ”ï¸ Encapsulating requests in controllers or task executors


ğŸ” Obervational Questions
Tests understanding of:
    âœ”ï¸ Behavioral decoupling
    âœ”ï¸ Command history & rollback concepts
    âœ”ï¸ Clean separation of concerns
Common follow-ups:
    âœ”ï¸ Command vs Strategy
    âœ”ï¸ How undo/redo is implemented conceptually


================================
ğŸ”· Interpreter Design Pattern
================================
â¤ Interpreter Design Pattern defines a way to evaluate or interpret language grammar or expressions.
â¤ It represents grammar rules as classes and uses them to interpret sentences in that language.
â¤ Mainly used for simple, repetitive rule-based languages.


ğŸ” Problem It Solves
When you need to:
âœ”ï¸  Interpret expressions repeatedly
âœ”ï¸  Apply custom business rules dynamically
Without Interpreter:
âœ”ï¸  Hard-coded rule logic
âœ”ï¸  Poor extensibility for new grammar rules
âœ”ï¸  Complex conditional statements
Interpreter solves:
âœ”ï¸  Clean separation of grammar and logic
âœ”ï¸  Easy extension of language rules
âœ”ï¸  Readable and maintainable rule evaluation


ğŸ” Real-Life Analogy 
â¤ Language Translator
âœ”ï¸  Each word or grammar rule has meaning
âœ”ï¸  Sentences are interpreted word by word
â¤ Grammar rules = Expressions
â¤ Translator = Interpreter


ğŸ” Real-World Project Usage 
1ï¸âƒ£ Rule Engines
âœ”ï¸  Evaluating business rules like discounts or eligibility
2ï¸âƒ£ Search Filters
âœ”ï¸  Parsing search queries with conditions
3ï¸âƒ£ Expression Evaluators
âœ”ï¸  Mathematical or logical expression parsing
4ï¸âƒ£ Access Control Rules
âœ”ï¸  Permission expressions interpreted at runtime
5ï¸âƒ£ Configuration Parsing
âœ”ï¸  Interpreting DSLs (Domain Specific Languages)


ğŸ” Obervational Questions
Tests understanding of:
âœ”ï¸  Grammar-based design
âœ”ï¸  Expression trees
âœ”ï¸  Trade-offs between flexibility and complexity
Common follow-ups:
âœ”ï¸  Why Interpreter is rarely used
âœ”ï¸  Alternatives like rule engines or scripting

============================
ğŸ”· Iterator Design Pattern
============================
â¤ Iterator Design Pattern provides a standard way to access elements of a collection sequentially without exposing its internal structure.
â¤ It separates iteration logic from collection implementation.


ğŸ” Problem It Solves
Without Iterator:
    âœ”ï¸ Client code depends on collectionâ€™s internal representation
    âœ”ï¸ Different traversal logic for different data structures
    âœ”ï¸ Tight coupling between data storage and traversal
Iterator solves:
    âœ”ï¸ Uniform way to traverse collections
    âœ”ï¸ Encapsulation of internal structure
    âœ”ï¸ Cleaner, more maintainable client code


ğŸ” Real-Life Analogy 
â¤ TV Channel Remote
    âœ”ï¸ You press â€œNextâ€ to move forward
    âœ”ï¸ You donâ€™t know how channels are stored internally
â¤ Remote = Iterator
â¤ Channels list = Collection


ğŸ” Real-World Project Usage
1ï¸âƒ£ Java Collections Framework
    âœ”ï¸ Iterating over lists, sets, maps using a common interface
2ï¸âƒ£ Database Result Processing
    âœ”ï¸ Traversing query results row by row
3ï¸âƒ£ Log Processing
    âœ”ï¸ Sequentially reading log entries
4ï¸âƒ£ Pagination Systems
    âœ”ï¸ Iterating over large datasets in chunks
5ï¸âƒ£ Custom Data Structures
    âœ”ï¸ Providing traversal without exposing internals


ğŸ” Obervational Questions
Tests understanding of:
    âœ”ï¸ Encapsulation
    âœ”ï¸ Separation of concerns
    âœ”ï¸ Internal vs external iteration
Common follow-ups:
    âœ”ï¸ Iterator vs For-each loop
    âœ”ï¸ Fail-fast vs Fail-safe iterators


============================
ğŸ”· Mediator Design Pattern
============================
â¤ Mediator Design Pattern defines a central object (mediator) that handles communication between multiple objects.
â¤ Objects do not communicate directly with each other; they communicate only through the mediator.
â¤ Promotes loose coupling by reducing direct dependencies.


ğŸ” Problem It Solves
When many objects interact directly:
    âœ”ï¸ Too many dependencies
    âœ”ï¸ Difficult to change behavior
    âœ”ï¸ Hard-to-maintain â€œspaghetti communicationâ€
Without Mediator:
    âœ”ï¸ Every object knows about every other object
    âœ”ï¸ Small change breaks multiple components
Mediator solves:
    âœ”ï¸ Centralized communication logic
    âœ”ï¸ Reduced coupling
    âœ”ï¸ Easier system evolution


ğŸ” Real-Life Analogy 
â¤ Airport Air Traffic Control (ATC)
    âœ”ï¸ Planes donâ€™t talk to each other directly
    âœ”ï¸ All communication goes through ATC
â¤ ATC = Mediator
â¤ Planes = Colleague objects


ğŸ” Real-World Project Usage
1ï¸âƒ£ Chat Applications
    âœ”ï¸ Chat server mediates message exchange between users
2ï¸âƒ£ UI Components Interaction
    âœ”ï¸ Buttons, text fields, and dialogs communicate via a controller
3ï¸âƒ£ Workflow Orchestration
    âœ”ï¸ Central service coordinating multiple microservices
4ï¸âƒ£ Event-Based Systems
    âœ”ï¸ Mediator handles event routing and responses
5ï¸âƒ£ Spring MVC
    âœ”ï¸ Controller acts as mediator between view and service layers


ğŸ” Obervational Questions
Tests understanding of:
    âœ”ï¸ Decoupling
    âœ”ï¸ Centralized control vs distributed logic
    âœ”ï¸ Trade-offs of single point of control
Common follow-ups:
    âœ”ï¸ Mediator vs Observer
    âœ”ï¸ When Mediator becomes too complex


============================
ğŸ”· Memento Design Pattern
============================
â¤ Memento Design Pattern captures and stores an objectâ€™s internal state so it can be restored later without violating encapsulation.
â¤ The object itself decides what state to save and restore.


ğŸ” Problem It Solves
When you need:
    âœ”ï¸ Undo / rollback functionality
    âœ”ï¸ Temporary state preservation
Without Memento:
    âœ”ï¸ Exposing internal state (breaking encapsulation)
    âœ”ï¸ Complex manual state tracking
Memento solves:
    âœ”ï¸ Safe state restoration
    âœ”ï¸ Clean undo/redo mechanisms
    âœ”ï¸ Encapsulation-friendly backups


ğŸ” Real-Life Analogy
â¤ Game Save Point
    âœ”ï¸ You save the game state
    âœ”ï¸ If you fail, you reload the saved state
â¤ Save file = Memento
â¤ Game = Originator


ğŸ” Real-World Project Usage
1ï¸âƒ£ Undo / Redo Features
    âœ”ï¸ Text editors, IDEs, design tools
2ï¸âƒ£ Transactional Rollbacks
    âœ”ï¸ Restoring object state after failure
3ï¸âƒ£ Versioning Systems
    âœ”ï¸ Reverting to previous versions
4ï¸âƒ£ Form State Management
    âœ”ï¸ Restoring user input after navigation
5ï¸âƒ£ Workflow Systems
    âœ”ï¸ Step-by-step state rollback


ğŸ” Obervational Questions
Tests understanding of:
    âœ”ï¸ Encapsulation
    âœ”ï¸ State management
    âœ”ï¸ Object responsibility separation
Common follow-ups:
    âœ”ï¸ Memento vs Snapshot
    âœ”ï¸ Memory impact of storing states


============================
ğŸ”· Observer Design Pattern
============================
â¤ Observer Design Pattern defines a one-to-many dependency where:
    âœ”ï¸ One object (Subject) changes state
    âœ”ï¸ All dependent objects (Observers) are automatically notified
â¤ Observers react without tightly coupling to the subject.


ğŸ” Problem It Solves
â¤ When multiple components need to stay in sync with a single source of truth.
â¤ Without Observer:
    âœ”ï¸ Manual notifications
    âœ”ï¸ Tight coupling between components
    âœ”ï¸ Missed or inconsistent updates
â¤ Observer solves:
    âœ”ï¸ Automatic updates
    âœ”ï¸ Loose coupling
    âœ”ï¸ Event-driven communication


ğŸ” Real-Life Analogy
â¤ YouTube Channel Subscriptions
    âœ”ï¸ You subscribe to a channel
    âœ”ï¸ When a new video is uploaded, youâ€™re notified automatically
â¤ Channel = Subject
â¤ Subscribers = Observers


ğŸ” Real-World Project Usage
1ï¸âƒ£ Event-Driven Systems
    âœ”ï¸ Publishing events and notifying listeners
2ï¸âƒ£ UI Frameworks
    âœ”ï¸ UI components updating when data changes
3ï¸âƒ£ Microservices
    âœ”ï¸ Services reacting to domain events
4ï¸âƒ£ Spring Framework
    âœ”ï¸ Application events and listeners
5ï¸âƒ£ Stock / Price Monitoring
    âœ”ï¸ Multiple clients notified on price changes


ğŸ” Obervational Questions
â¤ Tests understanding of:
    âœ”ï¸ Event handling
    âœ”ï¸ Loose coupling
    âœ”ï¸ Reactive design
â¤ Common follow-ups:
    âœ”ï¸ Observer vs Pub-Sub
    âœ”ï¸ Problems like memory leaks with observers


=========================
ğŸ”· State Design Pattern
=========================
â¤ State Design Pattern allows an object to change its behavior when its internal state changes.
â¤ The object appears to change its class, but actually delegates behavior to state-specific objects.


ğŸ” Problem It Solves
â¤ When an object has multiple states and behavior varies based on the current state.
â¤ Without State:
    âœ”ï¸ Large if-else or switch statements
    âœ”ï¸ Hard-to-maintain logic
    âœ”ï¸ Difficult to add new states
â¤ State solves:
    âœ”ï¸ Cleaner state-based behavior
    âœ”ï¸ Easy addition of new states
    âœ”ï¸ Eliminates conditional complexity


ğŸ” Real-Life Analogy
â¤ Traffic Light
    âœ”ï¸ Red â†’ Stop
    âœ”ï¸ Yellow â†’ Ready
    âœ”ï¸ Green â†’ Go
â¤ Same object, different behavior based on state


ğŸ” Real-World Project Usage
1ï¸âƒ£ Order Lifecycle Management
    âœ”ï¸ Created â†’ Paid â†’ Shipped â†’ Delivered â†’ Cancelled
2ï¸âƒ£ Authentication Flow
    âœ”ï¸ Logged out â†’ Logged in â†’ Session expired
3ï¸âƒ£ Workflow Engines
    âœ”ï¸ Each workflow step behaves differently
4ï¸âƒ£ Game Development
    âœ”ï¸ Character behavior changes based on state
5ï¸âƒ£ Connection Management
    âœ”ï¸ Open, closed, suspended connections


ğŸ” Obervational Questions
â¤ Tests understanding of:
    âœ”ï¸ State-driven behavior
    âœ”ï¸ Eliminating conditionals
    âœ”ï¸ Clean extensibility
â¤ Common follow-ups:
    âœ”ï¸ State vs Strategy
    âœ”ï¸ State transition control

============================
ğŸ”· Strategy Design Pattern
============================
â¤ Strategy Design Pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable at runtime.
â¤ The behavior of an object can be changed dynamically without modifying its code.


ğŸ” Problem It Solves
â¤ When multiple algorithms exist for the same task.
â¤ Without Strategy:
    âœ”ï¸ Large if-else or switch logic
    âœ”ï¸ Tight coupling between algorithm and client
    âœ”ï¸ Hard to add new algorithms
â¤ Strategy solves:
    âœ”ï¸ Clean separation of algorithms
    âœ”ï¸ Openâ€“Closed Principle compliance
    âœ”ï¸ Runtime flexibility


ğŸ” Real-Life Analogy
â¤ Google Maps Route Selection
    âœ”ï¸ Fastest route
    âœ”ï¸ Shortest route
    âœ”ï¸ Toll-free route
â¤ Same destination, different strategies


4ï¸âƒ£ Real-World Project Usage
1ï¸âƒ£ Payment Processing
    âœ”ï¸ Different payment algorithms (Card, UPI, Wallet)
2ï¸âƒ£ Sorting / Filtering Logic
    âœ”ï¸ Different sorting strategies based on criteria
3ï¸âƒ£ Authentication Mechanisms
    âœ”ï¸ OAuth, JWT, Basic Auth strategies
4ï¸âƒ£ Pricing & Discount Engines
    âœ”ï¸ Different discount calculation rules
5ï¸âƒ£ Compression / Encryption
    âœ”ï¸ Multiple algorithms selected at runtime


5ï¸âƒ£ Obervational Questions
â¤ Tests understanding of:
    âœ”ï¸ Algorithm abstraction
    âœ”ï¸ Runtime polymorphism
    âœ”ï¸ Clean architecture
â¤ Common follow-ups:
    âœ”ï¸ Strategy vs State
    âœ”ï¸ When Strategy becomes over-engineering


==================================
ğŸ”· Template Method Design Pattern
==================================
â¤ Template Method Design Pattern defines the skeleton of an algorithm in a base class and lets subclasses override specific steps without changing the overall structure.
â¤ The algorithm flow is fixed, but certain steps are customizable.


ğŸ” Problem It Solves
â¤ When multiple algorithms follow the same steps but differ in specific parts.
â¤ Without Template Method:
    âœ”ï¸ Code duplication across similar workflows
    âœ”ï¸ Inconsistent execution order
    âœ”ï¸ Difficult maintenance
â¤ Template Method solves:
    âœ”ï¸ Reuse of common logic
    âœ”ï¸ Controlled extensibility
    âœ”ï¸ Consistent algorithm flow


ğŸ” Real-Life Analogy
â¤ Cooking Recipe
    âœ”ï¸ Steps like prepare â†’ cook â†’ serve are fixed
    âœ”ï¸ Ingredients or cooking style may vary
â¤ Recipe structure = Template
â¤ Variations = Custom steps


ğŸ” Real-World Project Usage
1ï¸âƒ£ Authentication Workflows
    âœ”ï¸ Validate â†’ Authenticate â†’ Authorize â†’ Respond
2ï¸âƒ£ Data Processing Pipelines
    âœ”ï¸ Read â†’ Process â†’ Save
3ï¸âƒ£ Spring Framework Development
    âœ”ï¸ Base classes defining lifecycle methods
4ï¸âƒ£ Batch Processing Jobs
    âœ”ï¸ Common job flow with customizable steps
5ï¸âƒ£ Spring Framework
    âœ”ï¸ Lifecycle hooks where framework controls flow, developers plug logic


5ï¸âƒ£ Obervational Questions
â¤ Tests understanding of:
    âœ”ï¸ Inheritance-based design
    âœ”ï¸ Control inversion
    âœ”ï¸ Reusability vs flexibility
â¤ Common follow-ups:
    âœ”ï¸ Template vs Strategy
    âœ”ï¸ When inheritance becomes limiting


==========================
ğŸ”· Visitor Design Pattern
==========================
â¤ Visitor Design Pattern allows you to add new operations to existing object structures without modifying their classes.
â¤ The operation logic is separated from the objects on which it operates.

ğŸ” Problem It Solves
â¤ When you need to perform multiple unrelated operations on a set of objects.
â¤ Without Visitor:
    âœ”ï¸ Adding new operations requires modifying every class
    âœ”ï¸ Violates Openâ€“Closed Principle
â¤ Visitor solves:
    âœ”ï¸ Easy addition of new behaviors
    âœ”ï¸ Cleaner separation of concerns
    âœ”ï¸ Centralized operation logic


ğŸ” Real-Life Analogy
â¤ Tax Auditor Visiting Departments
    âœ”ï¸ Auditor visits HR, Finance, Sales
    âœ”ï¸ Departments donâ€™t implement tax logic
â¤ Auditor = Visitor
â¤ Departments = Elements


ğŸ” Real-World Project Usage
1ï¸âƒ£ Report Generation
    âœ”ï¸ Generating different reports from same data structure
2ï¸âƒ£ Compiler Design
    âœ”ï¸ Syntax tree traversal for validation or optimization
3ï¸âƒ£ Billing & Pricing Engines
    âœ”ï¸ Applying different calculations on order components
4ï¸âƒ£ Analytics Systems
    âœ”ï¸ Collecting metrics from various object types
5ï¸âƒ£ Enterprise Rule Processing
    âœ”ï¸ Running cross-cutting operations on domain models


ğŸ” Obervational Questions
â¤ Tests understanding of:
    âœ”ï¸ Openâ€“Closed Principle
    âœ”ï¸ Separation of data and behavior
    âœ”ï¸ Double dispatch concept
â¤ Common follow-ups:
    âœ”ï¸ Visitor drawbacks
    âœ”ï¸ When Visitor becomes rigid


#############################
ğŸ”· Structural Design Pattern
#############################
============================
ğŸ”· Adapter Design Pattern
============================
â¤ Adapter Design Pattern allows two incompatible interfaces to work together.
â¤ It acts as a bridge between an existing class and a client that expects a different interface.
â¤ The adapter converts one interface into another that the client understands.


ğŸ” Problem It Solves
â¤ When you want to use an existing or third-party class but its interface does not match what your system expects.
â¤ Without Adapter:
    âœ”ï¸ You must modify existing code (often impossible for third-party libs)
    âœ”ï¸ Duplicate logic
    âœ”ï¸ Tight coupling
â¤ Adapter solves:
    âœ”ï¸ Reuse of existing classes
    âœ”ï¸ Integration without code changes
    âœ”ï¸ Clean compatibility layer


ğŸ” Real-Life Analogy
Mobile Charger Adapter
    âœ”ï¸ Wall socket â‰  mobile plug
    âœ”ï¸ Adapter converts socket output to what phone understands
â¤ Socket = Existing system
â¤ Phone = Client
â¤ Charger adapter = Adapter


ğŸ” Real-World Project Usage
1ï¸âƒ£ Third-Party API Integration
    âœ”ï¸ Adapting external API responses to internal DTOs
2ï¸âƒ£ Legacy System Integration
    âœ”ï¸ Wrapping old code to match new service interfaces
3ï¸âƒ£ Payment Gateway Integration
    âœ”ï¸ Unified interface for multiple payment providers
4ï¸âƒ£ Logging Frameworks
    âœ”ï¸ Adapting different logging libraries to a common interface
5ï¸âƒ£ Spring Framework
    âœ”ï¸ Adapters between HTTP requests and controller method signatures


ğŸ” Obervational Questions
â¤ Tests understanding of:
    âœ”ï¸ Interface compatibility
    âœ”ï¸ Reusability
    âœ”ï¸ Integration design
â¤ Common follow-ups:
    âœ”ï¸ Adapter vs Facade
    âœ”ï¸ Class Adapter vs Object Adapter


============================
ğŸ”· Bridge Design Pattern
============================
â¤ Bridge Design Pattern decouples abstraction from implementation so that both can evolve independently.
â¤ It avoids tight binding between what an object does (abstraction) and how it does it (implementation).


ğŸ” Problem It Solves
â¤ When abstraction and implementation grow together:
    âœ”ï¸ Class explosion (too many subclasses)
    âœ”ï¸ Rigid inheritance hierarchies
â¤ Without Bridge:
    âœ”ï¸ Every combination needs a new subclass
    (e.g., Shape + Color â†’ CircleRed, CircleBlue, SquareRedâ€¦)
â¤ Bridge solves:
    âœ”ï¸ Independent extensibility
    âœ”ï¸ Reduced class count
    âœ”ï¸ Cleaner separation of concerns


ğŸ” Real-Life Analogy
â¤ Remote Control and Devices
    âœ”ï¸ Remote = abstraction
    âœ”ï¸ TV, AC, Music System = implementations
    âœ”ï¸ Same remote can control different devices
â¤ You can change:
    âœ”ï¸ Remote behavior
    âœ”ï¸ Device implementation independently


ğŸ” Real-World Project Usage
1ï¸âƒ£ Cross-Platform Applications
    âœ”ï¸ Same business logic working on different platforms
2ï¸âƒ£ Messaging Systems
    âœ”ï¸ Message abstraction + different delivery mechanisms (Email, SMS, Push)
3ï¸âƒ£ Payment Systems
    âœ”ï¸ Payment abstraction + multiple payment providers
4ï¸âƒ£ Persistence Layers
    âœ”ï¸ Repository abstraction + different databases
5ï¸âƒ£ Framework Design
    âœ”ï¸ APIs decoupled from low-level implementations


ğŸ” Obervational Questions
â¤ Tests understanding of:
    âœ”ï¸ Composition over inheritance
    âœ”ï¸ Avoiding class explosion
    âœ”ï¸ Long-term scalability
â¤ Common follow-ups:
    âœ”ï¸ Bridge vs Adapter
    âœ”ï¸ Bridge vs Strategy


============================
ğŸ”· Composite Design Pattern
============================
â¤ Composite Design Pattern allows you to treat individual objects and compositions of objects uniformly.
â¤ It lets you build tree-like structures where both leaf objects and composite objects are handled the same way.


ğŸ” Problem It Solves
â¤ When working with hierarchical or tree structures.
â¤ Without Composite:
    âœ”ï¸ Client code must distinguish between single objects and groups
    âœ”ï¸ Complex conditional logic
â¤ Composite solves:
    âœ”ï¸ Uniform treatment of objects and groups
    âœ”ï¸ Simplified client logic
    âœ”ï¸ Clean hierarchical representation


ğŸ” Real-Life Analogy
â¤ Company Organization Structure
    âœ”ï¸ Employee â†’ individual object
    âœ”ï¸ Manager â†’ manages multiple employees
â¤ Both employee and manager are treated as company members
â¤ Manager is just a composite of employees


ğŸ” Real-World Project Usage
1ï¸âƒ£ File System
    âœ”ï¸ Files and folders handled the same way
2ï¸âƒ£ UI Component Trees
    âœ”ï¸ Buttons, panels, containers
3ï¸âƒ£ Menu Systems
    âœ”ï¸ Menus containing sub-menus
4ï¸âƒ£ Permission / Role Hierarchies
    âœ”ï¸ Roles composed of sub-roles
5ï¸âƒ£ Expression Trees
    âœ”ï¸ Simple and compound expressions evaluated uniformly


ğŸ” Obervational Questions
â¤ Tests understanding of:
    âœ”ï¸ Tree structures
    âœ”ï¸ Recursive design
    âœ”ï¸ Uniform interface usage
â¤ Common follow-ups:
    âœ”ï¸ Composite vs Decorator
    âœ”ï¸ Handling leaf-specific behavior


============================
ğŸ”· Decorator Design Pattern
============================
â¤ Decorator Design Pattern allows you to add new behavior to an object dynamically without modifying its original class.
â¤ It wraps the original object and enhances its behavior at runtime.
â¤ Follows Openâ€“Closed Principle.


ğŸ” Problem It Solves
â¤ When you need to add features dynamically.
â¤ Without Decorator:
    âœ”ï¸ Class explosion due to inheritance
    (Base + FeatureA + FeatureB + FeatureA+B â€¦)
    âœ”ï¸ Rigid design
â¤ Decorator solves:
    âœ”ï¸ Flexible feature extension
    âœ”ï¸ Avoids subclass explosion
    âœ”ï¸ Runtime behavior composition


ğŸ” Real-Life Analogy
â¤ Coffee Shop Add-ons
    âœ”ï¸ Base coffee
    âœ”ï¸ Add milk, sugar, cream, chocolate
â¤ Each add-on wraps the previous one
â¤ Final cost & taste are combined
â¤ Add-ons = Decorators


ğŸ” Real-World Project Usage
1ï¸âƒ£ Logging Enhancements
    âœ”ï¸ Base logger + file logging + async logging
2ï¸âƒ£ Input / Output Streams
    âœ”ï¸ Wrapping streams for buffering, compression, encryption
3ï¸âƒ£ Security
    âœ”ï¸ Adding authentication or authorization layers
4ï¸âƒ£ UI Components
    âœ”ï¸ Scrollbars, borders added dynamically
5ï¸âƒ£ Spring Framework
    âœ”ï¸ AOP proxies behave like decorators around beans


ğŸ” Obervational Questions
â¤ Tests understanding of:
    âœ”ï¸ Composition over inheritance
    âœ”ï¸ Runtime flexibility
    âœ”ï¸ Cross-cutting concerns
â¤ Common follow-ups:
    âœ”ï¸ Decorator vs Adapter
    âœ”ï¸ Decorator vs Proxy


============================
ğŸ”· Facade Design Pattern
============================
â¤ Facade Design Pattern provides a simplified, unified interface to a complex subsystem.
â¤ It hides internal complexity and exposes only what the client needs.


ğŸ” Problem It Solves
â¤ When a system has:
    âœ”ï¸ Multiple classes
    âœ”ï¸ Complex interactions
    âœ”ï¸ Hard-to-use APIs
â¤ Without Facade:
    âœ”ï¸ Client depends on many subsystem classes
    âœ”ï¸ High coupling
    âœ”ï¸ Difficult usage and maintenance
â¤ Facade solves:
    âœ”ï¸ Simpler client interaction
    âœ”ï¸ Reduced coupling
    âœ”ï¸ Clear separation between client and subsystem


ğŸ” Real-Life Analogy
â¤ Hotel Reception
    âœ”ï¸ You donâ€™t talk to housekeeping, kitchen, billing directly
    âœ”ï¸ Reception coordinates everything for you
â¤ Reception = Facade
â¤ Hotel services = Subsystems


ğŸ” Real-World Project Usage
1ï¸âƒ£ Service Layer in Spring Boot
    âœ”ï¸ Controller talks to a single service instead of multiple repositories
2ï¸âƒ£ Complex Business Workflows
    âœ”ï¸ One facade method triggers multiple internal operations
3ï¸âƒ£ Third-Party Library Wrapping
    âœ”ï¸ Simplified wrapper over complex external APIs
4ï¸âƒ£ Microservices Gateways
    âœ”ï¸ API Gateway acting as a facade for multiple services
5ï¸âƒ£ Spring Boot Startup / Bootstrap Logic
    âœ”ï¸ Single entry point to initialize multiple subsystems


ğŸ” Why Interviewers Like This Pattern
â¤ Tests understanding of:
    âœ”ï¸ API design
    âœ”ï¸ System abstraction
    âœ”ï¸ Coupling reduction
â¤ Common follow-ups:
    âœ”ï¸ Facade vs Adapter
    âœ”ï¸ Does Facade restrict subsystem usage?


============================
ğŸ”· Flyweight Design Pattern
============================
â¤ Flyweight Design Pattern minimizes memory usage by sharing common object state instead of creating many similar objects.
â¤ It separates:
    âœ”ï¸ Intrinsic state â†’ shared, immutable
    âœ”ï¸ Extrinsic state â†’ provided from outside, varies per use


ğŸ” Problem It Solves
â¤ When an application creates a large number of similar objects.
â¤ Without Flyweight:
    âœ”ï¸ High memory consumption
    âœ”ï¸ Performance degradation
    âœ”ï¸ Possible OutOfMemory errors
â¤ Flyweight solves:
    âœ”ï¸ Object reuse
    âœ”ï¸ Memory optimization
    âœ”ï¸ Efficient handling of massive object counts


ğŸ” Real-Life Analogy
â¤ Text Editor Characters
    âœ”ï¸ Each character (A, B, C) is stored once
    âœ”ï¸ Font, size, position are applied externally
â¤ Character shape = Intrinsic state
â¤ Position/style = Extrinsic state


ğŸ” Real-World Project Usage
1ï¸âƒ£ Java String Pool
    âœ”ï¸ Reusing identical string literals
2ï¸âƒ£ Caching Systems
    âœ”ï¸ Reusing frequently accessed objects
3ï¸âƒ£ Game Development
    âœ”ï¸ Trees, bullets, or NPCs shared across map
4ï¸âƒ£ UI Rendering
    âœ”ï¸ Reusing icons or graphical elements
5ï¸âƒ£ ORM Frameworks
    âœ”ï¸ Metadata and mapping information shared across entities


ğŸ” Obervational Questions
â¤ Tests understanding of:
    âœ”ï¸ Memory optimization
    âœ”ï¸ Intrinsic vs extrinsic state
    âœ”ï¸ Performance trade-offs
â¤ Common follow-ups:
    âœ”ï¸ Flyweight vs Singleton
    âœ”ï¸ When Flyweight is harmful

============================
ğŸ”· Proxy Design Pattern
============================
â¤ Proxy Design Pattern provides a placeholder or surrogate object that controls access to another real object.
â¤ The proxy sits between the client and the real object and may add extra behavior.


ğŸ” Problem It Solves
â¤ When direct access to an object is:
    âœ”ï¸ Expensive
    âœ”ï¸ Unsafe
    âœ”ï¸ Unnecessary at all times
â¤ Without Proxy:
    âœ”ï¸ Client directly accesses heavy or sensitive objects
    âœ”ï¸ No control over access, performance, or security
â¤ Proxy solves:
    âœ”ï¸ Access control
    âœ”ï¸ Lazy initialization
    âœ”ï¸ Additional behavior without modifying real object


ğŸ” Real-Life Analogy
â¤ Credit Card
    âœ”ï¸ You donâ€™t give cash directly
    âœ”ï¸ Card acts as a proxy to your bank account
â¤ Credit card = Proxy
â¤ Bank account = Real object


ğŸ” Real-World Project Usage
1ï¸âƒ£ Spring AOP
    âœ”ï¸ Proxies wrap beans to add logging, security, transactions
2ï¸âƒ£ Lazy Loading
    âœ”ï¸ Load heavy objects only when required
3ï¸âƒ£ Security Proxies
    âœ”ï¸ Check permissions before accessing real service
4ï¸âƒ£ Remote Proxies
    âœ”ï¸ Represent remote services locally
5ï¸âƒ£ Caching Proxies
    âœ”ï¸ Cache results before calling real object


ğŸ” Obervational Questions
â¤ Tests understanding of:
    âœ”ï¸ Structural control
    âœ”ï¸ Cross-cutting concerns
    âœ”ï¸ Runtime behavior wrapping
â¤ Common follow-ups:
    âœ”ï¸ Proxy vs Decorator
    âœ”ï¸ JDK Dynamic Proxy vs CGLIB
