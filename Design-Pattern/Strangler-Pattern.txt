Strangler Pattern is an incremental migration pattern where a legacy system is gradually replaced by a new system by routing specific functionality to the new system while the old system continues to run.

ğŸŒŸ Name comes from Strangler Fig Tree:
â¤ It grows around the old tree
â¤ Slowly replaces it
â¤ Eventually the old tree dies


âŒ Problem It Solves
Legacy systems often:
    âœ”ï¸ Are monolithic
    âœ”ï¸ Hard to change
    âœ”ï¸ Risky to rewrite fully
    âœ”ï¸ Business-critical (canâ€™t stop)
âŒ Big-bang rewrite = high risk + long downtime


âœ… Strangler Solution
âœ”ï¸ Keep legacy system running
âœ”ï¸ Introduce new system piece by piece
âœ”ï¸ Route traffic gradually
âœ”ï¸ Kill legacy parts only when safe


ğŸ” High-Level Architecture
Client
   |
   v
API Gateway / Router
   |
   |----> Legacy System
   |
   |----> New Microservice


ğŸ”„ How Strangler Works (Step-by-Step)
1ï¸âƒ£ Identify a feature boundary
2ï¸âƒ£ Build that feature in a new system
3ï¸âƒ£ Route requests to the new system
4ï¸âƒ£ Monitor & stabilize
5ï¸âƒ£ Remove legacy feature
6ï¸âƒ£ Repeat until legacy system disappears


âœ… Java + Spring Boot Example
Legacy monolith handles:
    âœ”ï¸ User Management
    âœ”ï¸ Order Management
We want to migrate Order Management to a new microservice.

1ï¸âƒ£ Legacy Monolith (Old System)
@RestController
@RequestMapping("/api")
public class LegacyController {

    @GetMapping("/orders/{id}")
    public String getOrder(@PathVariable String id) {
        return "Order " + id + " from LEGACY system";
    }
}

2ï¸âƒ£ New Microservice (Modern System)
@RestController
@RequestMapping("/api/orders")
public class OrderController {

    @GetMapping("/{id}")
    public String getOrder(@PathVariable String id) {
        return "Order " + id + " from NEW microservice";
    }
}

3ï¸âƒ£ Strangler Router (Gateway Layer)
@RestController
@RequestMapping("/api")
public class StranglerRouter {

    private final OrderServiceClient orderServiceClient;
    private final LegacyOrderService legacyOrderService;

    public StranglerRouter(
            OrderServiceClient orderServiceClient,
            LegacyOrderService legacyOrderService
    ) {
        this.orderServiceClient = orderServiceClient;
        this.legacyOrderService = legacyOrderService;
    }

    @GetMapping("/orders/{id}")
    public String routeOrder(@PathVariable String id) {

        if (isMigrated(id)) {
            return orderServiceClient.getOrder(id);
        }
        return legacyOrderService.getOrder(id);
    }

    private boolean isMigrated(String id) {
        // feature toggle / DB flag / percentage rollout
        return id.startsWith("N");
    }
}

4ï¸âƒ£ Service Clients
Legacy Service
@Service
public class LegacyOrderService {
    public String getOrder(String id) {
        return "Order " + id + " from LEGACY system";
    }
}

New Service Client
@Service
public class OrderServiceClient {
    public String getOrder(String id) {
        return "Order " + id + " from NEW microservice";
    }
}

âœ… Output Behavior
| Order ID | Routed To        |
| -------- | ---------------- |
| `L123`   | Legacy System    |
| `N456`   | New Microservice |
âœ”ï¸ Zero downtime
âœ”ï¸ Safe migration
âœ”ï¸ Gradual rollout


ğŸ§  Real-World Industry Examples
âœ… Amazon: Migrated monolith to microservices incrementally
âœ… Netflix: Strangled data centers with cloud services
âœ… Uber: Migrated core systems feature-by-feature


ğŸ” Key Techniques Used with Strangler
| Technique              | Purpose                |
| ---------------------- | ---------------------- |
| API Gateway            | Traffic routing        |
| Feature Flags          | Gradual rollout        |
| Canary Releases        | Risk reduction         |
| Blue-Green Deployments | Safe switching         |
| Database Strangling    | Gradual data migration |


ğŸ” Advantages
âœ… Zero downtime
âœ… Lower risk
âœ… Business continuity
âœ… Incremental delivery
âœ… Easier rollback


ğŸ” Disadvantages
âŒ Temporary complexity
âŒ Dual systems maintenance
âŒ Requires strong routing strategy


ğŸ†š Strangler vs Big-Bang Rewrite
| Strangler     | Big-Bang            |
| ------------- | ------------------- |
| Incremental   | All at once         |
| Low risk      | High risk           |
| Business safe | Business disruptive |
| Preferred     | Avoided             |


ğŸ” Traps &  Answers
â“ Is Strangler a design pattern or architecture pattern?
ğŸ‘‰ Itâ€™s an architectural migration pattern.

â“ Does it require microservices?
ğŸ‘‰ âŒ No â€” but it fits perfectly with microservices.

â“ Where does routing logic live?
ğŸ‘‰ API Gateway / Reverse Proxy / Load Balancer.


ğŸ” When to Use Strangler Pattern?
âœ”ï¸ Legacy modernization
âœ”ï¸ Monolith â†’ Microservices
âœ”ï¸ High-risk systems
âœ”ï¸ Continuous delivery environments