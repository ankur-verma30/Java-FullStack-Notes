==============================================
ğŸ”´ S â€“ Single Responsibility Principle (SRP)
==============================================
A class should have only ONE reason to change.
ğŸ‘‰ This does NOT mean â€œonly one methodâ€.
ğŸ‘‰ It means one responsibility / one axis of change.

âŒ SRP Violation (Bad Design)
class UserService {

    public void registerUser(String name) {
        System.out.println("User registered: " + name);
    }

    public void sendEmail(String email) {
        System.out.println("Email sent to " + email);
    }

    public void saveToDatabase(String name) {
        System.out.println("User saved in DB: " + name);
    }
}


âŒ Why this violates SRP?
â¤ Registration logic changes â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ class changes
â¤ Email logic changes â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ class changes
â¤ DB logic changes â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ class changes
ğŸ‘‰ Multiple reasons to change


âœ… SRP Compliant Design
class UserService {
    public void registerUser(String name) {
        System.out.println("User registered: " + name);
    }
}

class EmailService {
    public void sendEmail(String email) {
        System.out.println("Email sent to " + email);
    }
}

class UserRepository {
    public void save(String name) {
        System.out.println("User saved in DB: " + name);
    }
}
ğŸ‘‰ Each class has one responsibility


ğŸŒ± Spring Boot Mapping
ğŸ”— @Controller â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ HTTP handling
ğŸ”— @Service â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Business logic
ğŸ”— @Repository â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ DB logic


ğŸ”µ O â€“ Open/Closed Principle (OCP)
Software entities should be open for extension but closed for modification.
ğŸ‘‰ You should add new behavior without changing existing code.

âŒ OCP Violation
class DiscountService {

    public double calculateDiscount(String type, double amount) {
        if (type.equals("STUDENT")) {
            return amount * 0.1;
        } else if (type.equals("SENIOR")) {
            return amount * 0.2;
        }
        return 0;
    }
}
âŒ Every new discount â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ modify this class
âŒ Breaks OCP

âœ… OCP Compliant Design (Using Polymorphism)
Strategy Interface
interface Discount {
    double apply(double amount);
}

Implementations
class StudentDiscount implements Discount {
    public double apply(double amount) {
        return amount * 0.1;
    }
}

class SeniorDiscount implements Discount {
    public double apply(double amount) {
        return amount * 0.2;
    }
}

Service
class DiscountService {
    public double calculateDiscount(Discount discount, double amount) {
        return discount.apply(amount);
    }
}
ğŸ‘‰ Add new discount â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ no modification


ğŸŒ± Spring Boot Mapping
â¤ Use @Component
â¤ Inject via @Qualifier
â¤ Strategy pattern + OCP


ğŸŸ¢ L â€“ Liskov Substitution Principle (LSP)
Subclasses should be replaceable for their base class without breaking behavior.

âŒ LSP Violation
class Bird {
    public void fly() {
        System.out.println("Flying");
    }
}

class Ostrich extends Bird {
    public void fly() {
        throw new UnsupportedOperationException();
    }
}
âŒ Ostrich cannot fly
âŒ Breaks LSP

âœ… LSP Compliant Design
interface Bird {}

interface FlyingBird extends Bird {
    void fly();
}

class Sparrow implements FlyingBird {
    public void fly() {
        System.out.println("Sparrow flying");
    }
}

class Ostrich implements Bird {
    public void walk() {
        System.out.println("Ostrich walking");
    }
}
ğŸ‘‰ No behavioral contract violation


ğŸŒ± Spring Boot Mapping
â¤ Avoid forcing subclasses to implement unused methods
â¤ Use interfaces wisely


ğŸŸ¡ I â€“ Interface Segregation Principle (ISP)
Clients should not be forced to depend on interfaces they do not use.

âŒ ISP Violation
interface Worker {
    void work();
    void eat();
}

class Robot implements Worker {
    public void work() {}
    public void eat() {} // âŒ meaningless
}

âœ… ISP Compliant Design
interface Workable {
    void work();
}

interface Eatable {
    void eat();
}

class HumanWorker implements Workable, Eatable {
    public void work() {}
    public void eat() {}
}

class RobotWorker implements Workable {
    public void work() {}
}
ğŸ‘‰ Interfaces are small & specific


ğŸŒ± Spring Boot Mapping
â¤ Smaller interfaces = cleaner dependency injection
â¤ Avoid â€œfatâ€ service interfaces


ğŸ”µ D â€“ Dependency Inversion Principle (DIP)
High-level modules should not depend on low-level modules.
Both should depend on abstractions.

âŒ DIP Violation
class MySQLDatabase {
    void connect() {}
}

class UserService {
    private MySQLDatabase db = new MySQLDatabase();
}
âŒ Tight coupling
âŒ Hard to change DB

âœ… DIP Compliant Design
ğŸ”„ Abstraction
interface Database {
    void connect();
}

ğŸ”„ Implementations
class MySQLDatabase implements Database {
    public void connect() {
        System.out.println("MySQL connected");
    }
}

class MongoDatabase implements Database {
    public void connect() {
        System.out.println("MongoDB connected");
    }
}

ğŸ”„ High-Level Module
class UserService {
    private Database database;

    public UserService(Database database) {
        this.database = database;
    }

    public void connect() {
        database.connect();
    }
}
âœ”ï¸ Loosely coupled
âœ”ï¸ Easy to swap implementation

ğŸŒ± Spring Boot Mapping
â¤ @Autowired
â¤ Constructor injection
â¤ Interfaces everywhere


ğŸ”„ Summary of SOLID Principles
| Principle | Key Idea                 |
| --------- | ------------------------ |
| SRP       | One responsibility       |
| OCP       | Extend without modify    |
| LSP       | Substitutable subclasses |
| ISP       | Small interfaces         |
| DIP       | Depend on abstractions   |
