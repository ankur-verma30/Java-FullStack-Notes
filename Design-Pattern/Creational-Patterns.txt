=============================
ğŸ”· Singleton Design Pattern
=============================
The Singleton Pattern ensures that a class has only one instance throughout the application and provides a global point of access to that instance.

ğŸ”„Key Characteristics
1ï¸âƒ£ Single instance â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Only one object is created.
2ï¸âƒ£ Global access point â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Can be accessed from anywhere.
3ï¸âƒ£ Controlled instantiation â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Constructor is private; object created internally.

ğŸ”„ Real-world Analogy
Think of a Printer Spooler â€” you only want one object managing all print requests to prevent conflicts.

ğŸ”„ Java Implementation of Singleton
âœ… Example 1: Basic Lazy Initialization Singleton
public class DatabaseConnection {
    private static DatabaseConnection instance;

    private DatabaseConnection() {
        System.out.println("Database Connection created...");
    }

    public static DatabaseConnection getInstance() { 
        if (instance == null) {
            instance = new DatabaseConnection();
        }
        return instance;
    }
}
âš¡ Writing method name as getInstance is a convention for Singleton.
  
ğŸ‘‰ Usage
public class Main {
    public static void main(String[] args) {
        DatabaseConnection db1 = DatabaseConnection.getInstance();
        DatabaseConnection db2 = DatabaseConnection.getInstance();

        System.out.println(db1 == db2); // true (both refer to same instance)
    }
}

ğŸ”— Eager Initialization Singleton
â¤ Eager initialization means creating the instance of the object at the loading of the class
public class EagerSingleton {
    private static final EagerSingleton instance = new EagerSingleton();  

    private EagerSingleton() {}

    public static EagerSingleton getInstance() {
        return instance;
    }
}
âœ… Created at class loading time.
âŒ May create instance even if unused.


ğŸ”„ Different Ways to Break Singleton Pattern in Java
Even though the Singleton pattern ensures only one instance, there are several ways it can be broken if not handled properly.

1ï¸âƒ£ Reflection API
â— Problem: Reflection can access private constructors and create new instances.

âœ… Example:
public class Singleton {
    private static Singleton instance = new Singleton();

    private Singleton() {}

    public static Singleton getInstance() {
        return instance;
    }
}

ğŸ”— Breaking using Reflection:
import java.lang.reflect.Constructor;

public class ReflectionBreaker {
    public static void main(String[] args) throws Exception {
        Singleton instance1 = Singleton.getInstance();

        Constructor<Singleton> constructor = Singleton.class.getDeclaredConstructor();
        constructor.setAccessible(true);
        Singleton instance2 = constructor.newInstance();

        System.out.println(instance1 == instance2); // âŒ false
    }
}

ğŸ›¡ï¸ Prevention:
â¤ Add a check in the constructor:
private Singleton() {
    if (instance != null) {
        throw new RuntimeException("Use getInstance() method to create object");
    }
}
âœ… Or use Enum Singleton, which cannot be broken by Reflection.


2ï¸âƒ£ Serialization
â—Problem:
Serialization followed by deserialization creates a new instance.

âœ… Example:
import java.io.*;

class Singleton implements Serializable {
    private static final Singleton instance = new Singleton();
    private Singleton() {}
    public static Singleton getInstance() { return instance; }
}

public class SerializationBreaker {
    public static void main(String[] args) throws Exception {
        Singleton instance1 = Singleton.getInstance();

        // Serialization
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("obj.ser"));
        oos.writeObject(instance1); //converts the object into series of bytes into some file
        oos.close();

        // Deserialization
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream("obj.ser"));
        Singleton instance2 = (Singleton) ois.readObject();
        ois.close();

        System.out.println(instance1 == instance2); // âŒ false
    }
}

ğŸ›¡ï¸ Prevention:
â¤ Implement readResolve() method
â¤ During deserialization, Java creates a new object, which can break the Singleton pattern.
â¤ If a Singleton class defines readResolve(), the JVM replaces the deserialized object with the object returned by this method.
â¤ By returning the existing singleton instance, multiple instances are prevented.

protected Object readResolve() {
    return instance;
}

â¤ JVM discards the newly created deserialized object
â¤ Always returns the same Singleton instance
â¤ Ensures Singleton integrity after serialization


3ï¸âƒ£ Cloning
There are two types of cloning: shallow and deep.
1ï¸âƒ£ Shallow Cloning: It creates a new instance with the same reference for the reference type field as the original instance.
2ï¸âƒ£ Deep Cloning: It creates a new instance of the reference type with a deep copy of the original instance.

â— Problem:
If Singleton implements Cloneable, clone() can create a duplicate instance.

âœ… Example:
class Singleton implements Cloneable {
    private static Singleton instance = new Singleton();
    private Singleton() {}
    public static Singleton getInstance() { return instance; }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone(); // âŒ creates new instance
    }
}

ğŸ›¡ï¸ Prevention:
â¤ Override clone() to return the same instance:
@Override
protected Object clone() throws CloneNotSupportedException {
    return instance;
}

ğŸ‘‰ Or throw an exception:
@Override
protected Object clone() throws CloneNotSupportedException {
    throw new CloneNotSupportedException("Cloning not allowed");
}


4ï¸âƒ£ Multithreaded Environment
â— Problem:
Two threads might access getInstance() simultaneously before the instance is initialized â†’ multiple instances.

âœ… Example:
public class Singleton {
    private static Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton(); // âŒ race condition both the threads can create instance at the same time creating two objects  
        }
        return instance;
    }
}

ğŸ›¡ï¸ Prevention Techniques:
âœ… Option 1: Synchronize Method
public static synchronized Singleton getInstance() {
    if (instance == null) {
        instance = new Singleton();
    }
    return instance;
}
âŒ Drawback: Slower due to synchronization overhead.

âœ… Option 2: Double-checked Locking Pattern
â¤ We are checking if the instance is null and creating it if it is null in a synchronized block.
â¤ So if second thread comes it will not even reach to the synchronized block.
public class Singleton {
    private static volatile Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
ğŸ‘‰ Use volatile
To prevent instruction reordering by the JVM or CPU, declare instance as volatile:
private static volatile Singleton instance;
ğŸ‘‰ Without volatile, another thread might see a partially constructed object.

âœ… Option 3: Bill Pughâ€™s Inner Static Class (Best Approach)
public class Singleton {
    private Singleton() {}

    private static class Holder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return Holder.INSTANCE;
    }
}
âœ”ï¸ Lazy initialization
âœ”ï¸ Thread-safe
âœ”ï¸ No synchronization overhead


ğŸ§  Ultimate Protection Enum Singleton (Best Practice)

âœ… Example:
public enum EnumSingletonSafestPractice {
    INSTANCE;

    public void doSomething(){
        System.out.println("Singleton instance is doing something");
    }

    public static void main(String[] args) {
        EnumSingletonSafestPractice instance1=EnumSingletonSafestPractice.INSTANCE;
        EnumSingletonSafestPractice instance2=EnumSingletonSafestPractice.INSTANCE;

        System.out.println(instance1==instance2);
        instance1.doSomething();
        instance2.doSomething();
        System.out.println(System.identityHashCode(instance1));
        System.out.println(System.identityHashCode(instance2));
    }
}
ğŸ‘‰ Why best?
â¤ Thread-safe by default
â¤ Immune to Reflection, Serialization, and Cloning attacks
â¤ Simpler and JVM-managed

âœ… Example in Java Library: Runtime Class
Yes, java.lang.Runtime is a classic example of a Singleton.

public class Main {
    public static void main(String[] args) {
        Runtime runtime1 = Runtime.getRuntime();
        Runtime runtime2 = Runtime.getRuntime();

        System.out.println(runtime1 == runtime2); // true
    }
}

ğŸ‘‰ Internally, Runtime has:
public class Runtime {
    private static final Runtime currentRuntime = new Runtime();
    private Runtime() {}
    public static Runtime getRuntime() {
        return currentRuntime;
    }
}

ğŸ”„ Singleton Pattern in Spring Boot
Spring beans are Singletons by default (scoped as singleton).

âœ… Example:
import org.springframework.stereotype.Service;

@Service
public class NotificationService {
    public void send(String message) {
        System.out.println("Sending: " + message);
    }
}

ğŸ‘‰ Usage:
@Autowired
private NotificationService notificationService;
âœ”ï¸ Here, Spring creates one instance per ApplicationContext â€” any @Autowired injection points to the same object.

â¤ If you want different instances, you change scope:
@Scope("prototype")
@Service
public class NotificationService { ... }


ğŸ”„ Why Singleton is Used in Real Projects
| Use Case                         | Why Singleton?                                  |
| -------------------------------- | ----------------------------------------------- |
| Database connection pool manager | Only one shared connection pool                 |
| Logging service                  | Centralized logging instance                    |
| Configuration manager            | Single source of truth for app configs          |
| Cache manager                    | One shared cache instance                       |
| Spring beans                     | Maintain one instance for dependency management |


================
ğŸ”· Class Loader
================
â¤ A Class Loader in Java is a part of the JVM responsible for loading .class files into memory when they are needed by an application.
â¤ It converts the bytecode from .class files into Class objects that the JVM can use to create instances, call methods, etc.

ğŸ”„ Class Loading Process (3 Phases)
When a class is needed, the JVM performs 3 major steps:

Step 1ï¸âƒ£: Loading
The .class file is located and read into memory.
The ClassLoader loads it as a Class object into the JVM method area.
âœ… Example: Class.forName("com.example.MyClass");


Step 2ï¸âƒ£: Linking
Linking connects the class with other classes and prepares it for execution.
It involves 3 sub-steps:
â¤ Verification â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Ensures bytecode is valid and safe (no illegal instructions).
â¤ Preparation â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Allocates memory for static variables and sets default values.
â¤ Resolution â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Replaces symbolic references (like method names, class names) with actual memory references.

Step 3ï¸âƒ£: Initialization
Executes static blocks and initializes static variables with assigned values.
This is the final step before the class can be used.


ğŸ”„ Types of Class Loaders in Java
Java uses a hierarchical delegation model for class loading.

1ï¸âƒ£ Bootstrap Class Loader
â¤ Parent of all class loaders.
â¤ Part of the JVM itself (native code, not written in Java).
â¤ Loads core Java classes from: <JAVA_HOME>/lib/rt.jar

(In modern Java versions, from the modules folder)
âœ… Example: java.lang.*, java.util.*


2ï¸âƒ£ Extension (Platform) Class Loader
â¤ Loads extension classes from: <JAVA_HOME>/lib/ext/
or any directory listed in java.ext.dirs.
â¤ It loads classes that extend the core Java platform.


3ï¸âƒ£ System (Application) Class Loader
Loads classes from the classpath (the folder or JAR specified when running your program).

ğŸ”— java -cp myApp.jar com.example.Main
ğŸ‘‰ This is usually the class loader that loads your own classes.


ğŸ”„ Delegation Hierarchy
â¤ Each class loader delegates the task of loading a class to its parent first.
â¤ Only if the parent cannot find the class, does the child attempt to load it.

ğŸ‘‰ Flow:
Bootstrap Loader â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Extension Loader â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ System Loader â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Custom Loader (if any)
âœ”ï¸ This avoids duplicate loading and ensures core classes are trusted (e.g., java.lang.String canâ€™t be replaced by user code).


âœ… Code Example â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Printing Class Loader Hierarchy
public class ClassLoaderDemo {
    public static void main(String[] args) {
        ClassLoader classLoader = ClassLoaderDemo.class.getClassLoader();

        System.out.println("System ClassLoader: " + classLoader);
        System.out.println("Extension ClassLoader: " + classLoader.getParent());
        System.out.println("Bootstrap ClassLoader: " + classLoader.getParent().getParent());
    }
}

âœ… Output:
System ClassLoader: jdk.internal.loader.ClassLoaders$AppClassLoader@18b4aac2
Extension ClassLoader: jdk.internal.loader.ClassLoaders$PlatformClassLoader@4b67cf4d
Bootstrap ClassLoader: null
âš¡ Note: null for Bootstrap because itâ€™s implemented in native code (C/C++), not Java.


ğŸ”„ Custom Class Loader Example (Advanced)
You can define your own loader by extending ClassLoader.

public class CustomClassLoader extends ClassLoader {
    @Override
    public Class<?> findClass(String name) throws ClassNotFoundException {
        System.out.println("Custom loader loading class: " + name);
        return super.findClass(name);
    }
}

ğŸ‘‰ Usage:
CustomClassLoader loader = new CustomClassLoader();
Class<?> cls = loader.loadClass("com.example.MyClass");


ğŸ”„ Class Loader in Spring Boot
Spring Bootâ€™s ApplicationContext heavily uses custom class loaders to:
â¤ Dynamically load beans and configuration classes.
â¤ Load classes from JARs inside a fat JAR (Spring Boot uses LaunchedURLClassLoader).
â¤ Reload classes during development (DevTools).

â¤ You can inspect it:
@SpringBootApplication
public class DemoApplication {
    public static void main(String[] args) {
        ApplicationContext context = SpringApplication.run(DemoApplication.class, args);
        System.out.println("Class Loader: " + context.getClassLoader());
    }
}


ğŸ”„ Magic Number Check
In Java, the magical number check refers to verifying the first few bytes of a .class file to ensure itâ€™s a valid Java bytecode file before loading it.

â¤ Every compiled Java .class file starts with a specific 4-byte signature:
0xCA FE BA BE
ğŸ‘‰ This is called the magic number.

When the JVM or ClassLoader loads a class, it first checks these bytes to confirm itâ€™s a valid compiled Java class and not a corrupted or malicious file.

âœ… Example:
$ xxd MyClass.class | head -1
00000000: cafe babe 0000 0034 ...

ğŸ”— If the file doesnâ€™t start with CA FE BA BE, the JVM throws:
java.lang.ClassFormatError: Invalid magic number
Hence, Magic number check â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Ensures the file is a valid .class file (starts with CAFEBABE) before the JVM loads it.


============================  
ğŸ”· Factory Design Pattern
============================
â¤ Factory Design Pattern is a Creational Design Pattern that provides a way to create objects without exposing the object creation logic to the client and refers to the newly created object using a common interface.

â¤ Let the factory decide which subclass to instantiate.

ğŸ”„Core Idea
Instead of creating objects using new keyword everywhere,â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ we delegate the creation logic to a Factory class.

ğŸ‘‰ This improves:
1ï¸âƒ£ Loose coupling
2ï¸âƒ£ Code reusability
3ï¸âƒ£ Flexibility in object creation

ğŸ”„ Real-life Analogy
Imagine a Shape Factory that can produce Circle, Square, or Rectangle.
The client doesnâ€™t know how these shapes are created â€” it just asks the factory for one.

ğŸ”„ UML Structure
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚   ShapeFactory   â”‚  â† Factory
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚             â”‚             â”‚             â”‚
Circle       Square       Rectangle     Triangle  â† Concrete Classes

âœ… Example
1ï¸âƒ£ Create an interface
interface Shape {
    void draw();
}

2ï¸âƒ£ Create concrete implementations
class Circle implements Shape {
    @Override
    public void draw() {
        System.out.println("Drawing a Circle...");
    }
}

class Square implements Shape {
    @Override
    public void draw() {
        System.out.println("Drawing a Square...");
    }
}

class Rectangle implements Shape {
    @Override
    public void draw() {
        System.out.println("Drawing a Rectangle...");
    }
}

3ï¸âƒ£ Create the Factory class
class ShapeFactory {
    public Shape getShape(String shapeType) {
        if (shapeType == null) return null;
        return switch (shapeType.toLowerCase()) {
            case "circle" -> new Circle();
            case "square" -> new Square();
            case "rectangle" -> new Rectangle();
            default -> throw new IllegalArgumentException("Unknown shape type: " + shapeType);
        };
    }
}

4ï¸âƒ£ Client code
public class FactoryPatternDemo {
    public static void main(Stri ng[] args) {
        ShapeFactory shapeFactory = new ShapeFactory();

        Shape circle = shapeFactory.getShape("circle");
        circle.draw();

        Shape square = shapeFactory.getShape("square");
        square.draw();

        Shape rectangle = shapeFactory.getShape("rectangle");
        rectangle.draw();
    }
}
âœ… Output:
Drawing a Circle...
Drawing a Square...
Drawing a Rectangle...


ğŸ”„ Advantages
| Advantage                | Explanation                                        |
| ------------------------ | -------------------------------------------------- |
| Encapsulation            | Object creation logic is hidden inside the factory |
| Loose coupling           | Client depends on interface, not concrete classes  |
| Extensibility            | New product types can be added easily              |
| Centralized creation     | All creation logic in one place                    |

ğŸ”„ Disadvantages
â¤ Might add extra complexity for simple object creation.
â¤ If there are too many product types, the factory class can grow large.

ğŸ”„ Factory Pattern in Java (Built-in Examples)
| Class                                                    | Description                                                   |
| -------------------------------------------------------- | ------------------------------------------------------------- |
| java.util.Calendar#getInstance()                         | Returns different Calendar objects based on locale/timezone |
| java.text.NumberFormat#getInstance()                     | Returns a subclass instance for the given locale              |
| javax.xml.parsers.DocumentBuilderFactory#newInstance()   | Factory for XML parsers                                       |
| java.sql.DriverManager#getConnection()                   | Factory for JDBC connections                                  |


ğŸ”„ Factory Pattern in Spring Boot
Spring uses factories heavily â€” almost everywhere.

âœ… Example 1: BeanFactory / ApplicationContext
â¤ Springâ€™s IoC Container itself is based on the Factory Pattern.
â¤ BeanFactory is a factory for Spring Beans.
â¤ It creates and manages beans on demand, instead of the developer manually instantiating them.

ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");
Shape shape = context.getBean("circle", Shape.class);
shape.draw();
ğŸ‘‰ Spring decides which concrete class to instantiate â€” classic Factory pattern in action.


âœ… Example 2: RestTemplateBuilder (Spring Boot Factory Example)
@Bean
public RestTemplate restTemplate(RestTemplateBuilder builder) {
    return builder.build(); // Factory method
}
ğŸ‘‰ Here, RestTemplateBuilder acts as a factory, building pre-configured RestTemplate objects.


ğŸ”„ Real-world Use Cases in Projects
| Use Case                       | Factory Role                                               |
| -------------------------------| ---------------------------------------------------------- |
| Database Connection Factory    | Create MySQL, PostgreSQL, or Mongo connections dynamically |
| Notification Factory           | Return Email, SMS, or PushNotification sender              |
| Payment Gateway Factory        | Create Razorpay, Stripe, or PayPal service objects         |
| Message Converter Factory      | Return JSON, XML, or CSV converters based on config        |
| Shape/Image Processing Factory | For UI or graphic applications                             |


==========================
ğŸ”· Builder Design Pattern
==========================
â¤ The Builder pattern is a creational design pattern used to construct complex objects step by step.
â¤ It lets you create different representations of the same object using the same construction process.

ğŸ‘‰ Purpose: To separate the construction logic of a complex object from its representation, so the same construction process can create different types of objects.

ğŸ”„Real-world Analogy
Imagine building a Burger ğŸ” in a restaurant:
    â¤ You choose bun, patty, cheese, sauce, toppings, etc.
    â¤ You can build different burgers with the same steps but different ingredients.
Similarly, the Builder pattern constructs objects step by step.

ğŸ”„ Inner Builder Class (Preferred in Modern Java)
âœ… Example:
class Computer {
    private String CPU;
    private String RAM;
    private String storage;
    private boolean graphicsCard;

    private Computer(Builder builder) {
        this.CPU = builder.CPU;
        this.RAM = builder.RAM;
        this.storage = builder.storage;
        this.graphicsCard = builder.graphicsCard;
    }

    public static class Builder {
        private String CPU;
        private String RAM;
        private String storage;
        private boolean graphicsCard;

        public Builder setCPU(String CPU) {
            this.CPU = CPU;
            return this;
        }

        public Builder setRAM(String RAM) {
            this.RAM = RAM;
            return this;
        }

        public Builder setStorage(String storage) {
            this.storage = storage;
            return this;
        }

        public Builder setGraphicsCard(boolean graphicsCard) {
            this.graphicsCard = graphicsCard;
            return this;
        }

        public Computer build() {
            return new Computer(this);
        }
    }

    @Override
    public String toString() {
        return "Computer [CPU=" + CPU + ", RAM=" + RAM + ", storage=" + storage + ", graphicsCard=" + graphicsCard + "]";
    }
}

public class BuilderDemo {
    public static void main(String[] args) {
        Computer pc = new Computer.Builder()
                .setCPU("Intel i7")
                .setRAM("16GB")
                .setStorage("1TB SSD")
                .setGraphicsCard(true)
                .build();

        System.out.println(pc);
    }
}

ğŸ” Analogy
Think of it like this:
    âœ”ï¸ BuilderDemo â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ presses a button
    âœ”ï¸ Computer.Builder â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ does the construction
    âœ”ï¸ Only the factory (Computer) is allowed to create its own product

ğŸ”„ Spring Boot Example
Builder pattern is commonly used when constructing complex DTOs or entity objects.
âœ…  Example using Lombokâ€™s @Builder annotation (which implements this pattern internally):

import lombok.Builder;
import lombok.Data;

@Data
@Builder
public class UserResponse {
    private String name;
    private String email;
    private int age;
}

// Usage in service:
UserResponse response = UserResponse.builder()
        .name("Ankur Verma")
        .email("ankur@example.com")
        .age(23)
        .build();
In Spring Boot, Lombokâ€™s @Builder is a direct application of the Builder pattern.

ğŸ”„ Ways to Make Fields Mandatory
ğŸ”— Use @Builder + @NonNull (Lombok)

â¤ If you annotate certain fields with @NonNull, Lombok will add null-checks in the builderâ€™s build() method.
â¤ If a required field is missing, a NullPointerException is thrown at build-time (not compile-time).
  

ğŸ”„ Real Java Classes Using Builder Pattern
â¤ StringBuilder (though itâ€™s mutable, not a strict builder)
â¤ java.lang.StringBuffer
â¤ java.lang.StringBuilder#append()
â¤ java.time.LocalDateTime.Builder
â¤ HttpRequest.Builder in Java 11+
â¤ Stream.Builder

ğŸ”„Where to Use in Projects
âœ”ï¸ When object construction has many optional parameters
âœ”ï¸ When you want immutable objects
âœ”ï¸ When you want to avoid telescoping constructors
âœ”ï¸ When building REST API responses or configurations

âœ… Example:
âœ”ï¸ Building complex JSON responses in Spring REST controllers.
âœ”ï¸ Building request payloads for external APIs.
âœ”ï¸ Building configuration objects (like RestTemplateBuilder in Spring Boot).

ğŸ”„ Advantages
â¤ Improves code readability and maintainability.
â¤ Allows creation of immutable objects.
â¤ Reduces constructor overloading.
â¤ Provides step-by-step object construction.

ğŸ”„ Disadvantages
â¤ Slightly more boilerplate (if not using Lombok).
â¤ Increases number of classes.


=============================
ğŸ”· Prototype Design Pattern
=============================
The Prototype Design Pattern is used when the cost of creating a new object is high (e.g., complex object initialization, expensive database calls, or network calls).

Instead of creating a new instance, we clone an existing object (the prototype) and modify it if needed.
ğŸ§¬ â€œDonâ€™t build from zero â€” copy what already works.â€


ğŸ”„ Structure
1ï¸âƒ£ Prototype Interface / Abstract Class
    Declares a clone() method to create object copies.
2ï¸âƒ£ Concrete Prototype Classes
    Implements the clone() method to return a copy of itself.
3ï¸âƒ£ Client
    Uses the prototype to create new objects without depending on their concrete classes.

âœ… Example â€” Prototype Pattern in Java
Letâ€™s take an example of creating Employee objects with deep attributes (like address). Instead of creating new objects repeatedly, we clone an existing one.

1ï¸âƒ£ Define the Prototype Interface
public interface Prototype extends Cloneable {
    Prototype clone();
}

2ï¸âƒ£ Create the Concrete Prototype Class
class Employee implements Prototype {
    private int id;
    private String name;
    private String department;

    public Employee(int id, String name, String department) {
        this.id = id;
        this.name = name;
        this.department = department;
    }

    ğŸ‘‰ getters and setters
    public int getId() { return id; }
    public void setId(int id) { this.id = id; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public String getDepartment() { return department; }
    public void setDepartment(String department) { this.department = department; }

    @Override
    public Prototype clone() {
        try {
            return (Employee) super.clone();  // shallow copy
            return new Employee(this.id, this.name, this.department); // deep copy alternative 
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException("Clone not supported", e);
        }
    }

    @Override
    public String toString() {
        return "Employee [id=" + id + ", name=" + name + ", department=" + department + "]";
    }
}

3ï¸âƒ£ Client Code
public class PrototypePatternDemo {
    public static void main(String[] args) {
        Employee original = new Employee(1, "Ankur", "Development");

        // Clone the original employee
        Employee cloned = (Employee) original.clone();

        cloned.setName("Rahul"); // modify the clone

        System.out.println("Original Employee: " + original);
        System.out.println("Cloned Employee: " + cloned);
    }
}
âœ… Output
Original Employee: Employee [id=1, name=Ankur, department=Development]
Cloned Employee: Employee [id=1, name=Rahul, department=Development]


ğŸ”„ Deep Copy vs Shallow Copy
âœ”ï¸ Shallow Copy:
â¤ Copies primitive fields
â¤ Copies references for object fields
â¤ Both original and clone share the same referenced objects

âœ… Example
class Address {
    String city;
}

class Person implements Cloneable {
    String name;
    Address address;

    protected Object clone() throws CloneNotSupportedException {
        return super.clone(); // shallow copy
    }
}

â— Problem:
Person p1 = new Person();
Person p2 = (Person) p1.clone();

p2.address.city = "Delhi";
â¡ï¸ p1.address.city also becomes "Delhi"

ğŸ“Œ Key Point
Changes in referenced objects affect both original and clone.

âœ”ï¸ Deep Copy
âœ… What it does
â¤ Copies primitives
â¤ Creates new objects for referenced fields
â¤ Original and clone are fully independent

âœ… Example
protected Object clone() throws CloneNotSupportedException {
    Person cloned = (Person) super.clone();
    cloned.address = new Address();
    cloned.address.city = this.address.city;
    return cloned;
}
p2.address.city = "Delhi";
â¡ï¸ p1.address.city remains unchanged

ğŸ”„ Real-Life Example in Java
ğŸ‘‰ In Java API
Object.clone() â€” The core implementation of Prototype Pattern.
Classes like java.lang.Cloneable, java.lang.Object#clone() directly follow this pattern.

ğŸ‘‰ In Frameworks
Spring Frameworkâ€™s Bean Scopes:
    âœ”ï¸ When you define a bean with @Scope("prototype"), Spring returns a new instance (clone) every time itâ€™s requested.
    âœ”ï¸ While not literally using clone(), the concept is the same â€” Prototype scope ensures new object creation without shared state.

âœ… Example:
@Component
@Scope("prototype")
public class NotificationService {
    // Each injection will create a new instance (like cloning)
}

ğŸ”„ Where to Use Prototype Pattern
â¤ When object creation is resource-intensive.
â¤ When the system should be independent of how objects are created.
â¤ When you want different configurations of similar objects quickly.

âœ… Examples:
â¤ Creating objects representing UI elements, shapes, or configurations.
â¤ Caching and cloning objects in game development or configuration systems.

ğŸ”„ Advantages
â¤ Reduces cost of creating new objects.
â¤ Simplifies object creation for complex objects.
â¤ Provides flexibility â€” new objects can be customized easily.

ğŸ”„ Disadvantages
â¤ Cloning complex objects with deep hierarchies can be tricky.
â¤ Must handle deep vs shallow copy carefully.
â¤ Requires Cloneable interface and proper handling of exceptions.


====================================
ğŸ”· Abstract Factory Design Pattern
====================================
The Abstract Factory Pattern provides an interface for creating families of related or dependent objects without specifying their concrete classes.

Itâ€™s often called a â€œfactory of factoriesâ€.

So if the Factory Method Pattern is about creating one type of object,the Abstract Factory Pattern is about creating multiple related objects that belong to the same â€œfamilyâ€.

ğŸ”„ Structure
1ï¸âƒ£ AbstractFactory (Interface)
    âœ”ï¸ Declares methods to create abstract product families.
2ï¸âƒ£ ConcreteFactory
    âœ”ï¸ Implements creation of specific product families.
3ï¸âƒ£ AbstractProduct (Interface)
    âœ”ï¸ Declares product interfaces.
4ï¸âƒ£ ConcreteProduct
    âœ”ï¸ Implements actual product behavior.
5ï¸âƒ£ Client
    âœ”ï¸ Uses AbstractFactory and AbstractProduct interfaces, never directly instantiates concrete classes.

âœ… Example â€” GUI Theme Factory
Imagine youâ€™re developing a GUI library that supports two themes: Dark and Light.
Each theme has its own style of Button and Checkbox.

You want to create themed components without knowing their exact classes.

1ï¸âƒ£ â€” Define Product Interfaces
interface Button {
    void paint();
}

interface Checkbox {
    void paint();
}

2ï¸âƒ£ â€” Create Concrete Product Implementations
ğŸ‘‰ Light theme products
class LightButton implements Button {
    public void paint() {
        System.out.println("Rendering a Light Button");
    }
}

class LightCheckbox implements Checkbox {
    public void paint() {
        System.out.println("Rendering a Light Checkbox");
    }
}

ğŸ‘‰ Dark theme products
class DarkButton implements Button {
    public void paint() {
        System.out.println("Rendering a Dark Button");
    }
}

class DarkCheckbox implements Checkbox {
    public void paint() {
        System.out.println("Rendering a Dark Checkbox");
    }
}

3ï¸âƒ£ â€” Define Abstract Factory
interface GUIFactory {
    Button createButton();
    Checkbox createCheckbox();
}

4ï¸âƒ£ â€” Implement Concrete Factories
class LightThemeFactory implements GUIFactory {
    public Button createButton() {
        return new LightButton();
    }

    public Checkbox createCheckbox() {
        return new LightCheckbox();
    }
}

class DarkThemeFactory implements GUIFactory {
    public Button createButton() {
        return new DarkButton();
    }

    public Checkbox createCheckbox() {
        return new DarkCheckbox();
    }
}

5ï¸âƒ£ â€” Client Code
public class AbstractFactoryDemo {
    public static void main(String[] args) {
        GUIFactory factory = new DarkThemeFactory(); // or LightThemeFactory
        Button button = factory.createButton();
        Checkbox checkbox = factory.createCheckbox();

        button.paint();
        checkbox.paint();
    }
}
âœ… Output
Rendering a Dark Button
Rendering a Dark Checkbox

â¤ The Factory Method Pattern makes one type of object.
â¤ The Abstract Factory Pattern makes a set of related objects.


ğŸ”„ Real-Life Example in Java
1ï¸âƒ£ Java AWT / Swing
ğŸ‘‰ Java GUI toolkit uses Abstract Factory internally:
Toolkit toolkit = Toolkit.getDefaultToolkit();
Button button = new Button();  // internally delegates creation to platform factory

â¤ Toolkit acts as the Abstract Factory.
â¤ Different OS implementations (Windows, Mac, etc.) provide Concrete Factories.

2ï¸âƒ£ Spring Framework Analogy
ğŸ‘‰ Springâ€™s BeanFactory and ApplicationContext follow Abstract Factory principles.

âœ… Example:
ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");
MyService service = context.getBean(MyService.class);

â¤ ApplicationContext â†’ Abstract Factory
â¤ Each configuration (XML, annotation, JavaConfig) â†’ Concrete Factory
â¤ Beans â†’ Products

3ï¸âƒ£ Hibernate Dialects
In Hibernate, different dialects (MySQL, PostgreSQL, Oracle) are created via abstract factories that produce related SQL behavior objects.

ğŸ”„ When to Use
â¤ When you need to create families of related objects.
â¤ When you want to ensure products created are compatible with each other.
â¤ When object creation logic is complex or environment-dependent.

ğŸ”„ Advantages
â¤ Ensures product consistency across families.
â¤ Makes code extensible for new product families.
â¤ Encapsulates object creation â€” low coupling.

ğŸ”„ Disadvantages
â¤ Difficult to support new product types (need to modify all factories).
â¤ Increases complexity due to multiple classes/interfaces.

