ğŸ”· Singleton Design Pattern
The Singleton Pattern ensures that a class has only one instance throughout the application and provides a global point of access to that instance.

ğŸ”„Key Characteristics
1ï¸âƒ£ Single instance: Only one object is created.
2ï¸âƒ£ Global access point: Can be accessed from anywhere.
3ï¸âƒ£ Controlled instantiation: Constructor is private; object created internally.

ğŸ”„ Real-world Analogy
Think of a Printer Spooler â€” you only want one object managing all print requests to prevent conflicts.

ğŸ”„ Java Implementation of Singleton
âœ… Example 1: Basic Lazy Initialization Singleton
public class DatabaseConnection {
    private static DatabaseConnection instance;

    private DatabaseConnection() {
        System.out.println("Database Connection created...");
    }

    public static DatabaseConnection getInstance() { 
        if (instance == null) {
            instance = new DatabaseConnection();
        }
        return instance;
    }
}
âš¡ Writing method name as getInstance is a convention for Singleton.
  
ğŸ‘‰ Usage
public class Main {
    public static void main(String[] args) {
        DatabaseConnection db1 = DatabaseConnection.getInstance();
        DatabaseConnection db2 = DatabaseConnection.getInstance();

        System.out.println(db1 == db2); // true (both refer to same instance)
    }
}

ğŸ”— Eager Initialization Singleton
â¤ Eager initialization means creating the instance of the object at the loading of the class
public class EagerSingleton {
    private static final EagerSingleton instance = new EagerSingleton();  

    private EagerSingleton() {}

    public static EagerSingleton getInstance() {
        return instance;
    }
}
âœ… Created at class loading time.
âŒ May create instance even if unused.


ğŸ”„ Different Ways to Break Singleton Pattern in Java
Even though the Singleton pattern ensures only one instance, there are several ways it can be broken if not handled properly.

1ï¸âƒ£ Reflection API
â— Problem: Reflection can access private constructors and create new instances.

âœ… Example:
public class Singleton {
    private static Singleton instance = new Singleton();

    private Singleton() {}

    public static Singleton getInstance() {
        return instance;
    }
}

ğŸ”— Breaking using Reflection:
import java.lang.reflect.Constructor;

public class ReflectionBreaker {
    public static void main(String[] args) throws Exception {
        Singleton instance1 = Singleton.getInstance();

        Constructor<Singleton> constructor = Singleton.class.getDeclaredConstructor();
        constructor.setAccessible(true);
        Singleton instance2 = constructor.newInstance();

        System.out.println(instance1 == instance2); // âŒ false
    }
}

ğŸ›¡ï¸ Prevention:
â¤ Add a check in the constructor:

private Singleton() {
    if (instance != null) {
        throw new RuntimeException("Use getInstance() method to create object");
    }
}
âœ… Or use Enum Singleton, which cannot be broken by Reflection.


2ï¸âƒ£ Serialization
â—Problem:
Serialization followed by deserialization creates a new instance.

âœ… Example:
import java.io.*;

class Singleton implements Serializable {
    private static final Singleton instance = new Singleton();
    private Singleton() {}
    public static Singleton getInstance() { return instance; }
}

public class SerializationBreaker {
    public static void main(String[] args) throws Exception {
        Singleton instance1 = Singleton.getInstance();

        // Serialization
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("obj.ser"));
        oos.writeObject(instance1); //converts the object into series of bytes into some file
        oos.close();

        // Deserialization
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream("obj.ser"));
        Singleton instance2 = (Singleton) ois.readObject();
        ois.close();

        System.out.println(instance1 == instance2); // âŒ false
    }
}

ğŸ›¡ï¸ Prevention:
â¤ Implement readResolve() method:

protected Object readResolve() {
    return instance;
}
âœ”ï¸ This ensures deserialization returns the same instance.


3ï¸âƒ£ Cloning
There are two types of cloning: shallow and deep.
1ï¸âƒ£ Shallow Cloning: It creates a new instance with the same reference for the reference type field as the original instance.
2ï¸âƒ£ Deep Cloning: It creates a new instance of the reference type with a
 deep copy of the original instance.

â— Problem:
If Singleton implements Cloneable, clone() can create a duplicate instance.

âœ… Example:
class Singleton implements Cloneable {
    private static Singleton instance = new Singleton();
    private Singleton() {}
    public static Singleton getInstance() { return instance; }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone(); // âŒ creates new instance
    }
}

ğŸ›¡ï¸ Prevention:
â¤ Override clone() to return the same instance:
@Override
protected Object clone() throws CloneNotSupportedException {
    return instance;
}

ğŸ‘‰ Or throw an exception:
@Override
protected Object clone() throws CloneNotSupportedException {
    throw new CloneNotSupportedException("Cloning not allowed");
}


4ï¸âƒ£ Multithreaded Environment
â— Problem:
Two threads might access getInstance() simultaneously before the instance is initialized â†’ multiple instances.

âœ… Example:
public class Singleton {
    private static Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton(); // âŒ race condition both the threads can create instance at the same time creating two objects  
        }
        return instance;
    }
}

ğŸ›¡ï¸ Prevention Techniques:
âœ… Option 1: Synchronize Method
public static synchronized Singleton getInstance() {
    if (instance == null) {
        instance = new Singleton();
    }
    return instance;
}
âŒ Drawback: Slower due to synchronization overhead.

âœ… Option 2: Double-checked Locking Pattern
â¤ We are checking if the instance is null and creating it if it is null in a synchronized block.
â¤ So if second thread comes it will not even reach to the synchronized block.
public class Singleton {
    private static volatile Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
ğŸ‘‰ Use volatile
To prevent instruction reordering by the JVM or CPU, declare instance as volatile:
private static volatile Singleton instance;

ğŸ‘‰ Without volatile, another thread might see a partially constructed object.

âœ… Option 3: Bill Pughâ€™s Inner Static Class (Best Approach)
public class Singleton {
    private Singleton() {}

    private static class Holder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return Holder.INSTANCE;
    }
}
âœ”ï¸ Lazy initialization
âœ”ï¸ Thread-safe
âœ”ï¸ No synchronization overhead


ğŸ§  Ultimate Protection Enum Singleton (Best Practice)

âœ… Example:
public enum EnumSingleton {
    INSTANCE;

    public void show() {
        System.out.println("Using Enum Singleton!");
    }
}

ğŸ‘‰ Usage:
public class Main {
    public static void main(String[] args) {
        EnumSingleton.INSTANCE.show();
    }
}

ğŸ‘‰ Why best?
â¤ Thread-safe by default
â¤ Immune to Reflection, Serialization, and Cloning attacks
â¤ Simpler and JVM-managed

âœ… Example in Java Library: Runtime Class
Yes, java.lang.Runtime is a classic example of a Singleton.

public class Main {
    public static void main(String[] args) {
        Runtime runtime1 = Runtime.getRuntime();
        Runtime runtime2 = Runtime.getRuntime();

        System.out.println(runtime1 == runtime2); // true
    }
}

ğŸ‘‰ Internally, Runtime has:
public class Runtime {
    private static final Runtime currentRuntime = new Runtime();
    private Runtime() {}
    public static Runtime getRuntime() {
        return currentRuntime;
    }
}


ğŸ”„ Singleton Pattern in Spring Boot
Spring beans are Singletons by default (scoped as singleton).

âœ… Example:
import org.springframework.stereotype.Service;

@Service
public class NotificationService {
    public void send(String message) {
        System.out.println("Sending: " + message);
    }
}

ğŸ‘‰ Usage:
@Autowired
private NotificationService notificationService;
âœ”ï¸ Here, Spring creates one instance per ApplicationContext â€” any @Autowired injection points to the same object.

â¤ If you want different instances, you change scope:
@Scope("prototype")
@Service
public class NotificationService { ... }


ğŸ”„ Why Singleton is Used in Real Projects
| Use Case                         | Why Singleton?                                  |
| -------------------------------- | ----------------------------------------------- |
| Database connection pool manager | Only one shared connection pool                 |
| Logging service                  | Centralized logging instance                    |
| Configuration manager            | Single source of truth for app configs          |
| Cache manager                    | One shared cache instance                       |
| Spring beans                     | Maintain one instance for dependency management |


ğŸŒŸ Misllaneous Topic
ğŸ”· Class Loader
A Class Loader in Java is a part of the JVM responsible for loading .class files into memory when they are needed by an application.

It converts the bytecode from .class files into Class objects that the JVM can use to create instances, call methods, etc.

ğŸ”„ Class Loading Process (3 Phases)
When a class is needed, the JVM performs 3 major steps:

âš¡Step 1ï¸âƒ£: Loading
The .class file is located and read into memory.
The ClassLoader loads it as a Class object into the JVM method area.

âœ… Example: Class.forName("com.example.MyClass");


âš¡Step 2ï¸âƒ£: Linking
Linking connects the class with other classes and prepares it for execution.
It involves 3 sub-steps:
â¤ Verification â†’ Ensures bytecode is valid and safe (no illegal instructions).
â¤ Preparation â†’ Allocates memory for static variables and sets default values.
â¤ Resolution â†’ Replaces symbolic references (like method names, class names) with actual memory references.

âš¡Step 3ï¸âƒ£: Initialization
Executes static blocks and initializes static variables with assigned values.

This is the final step before the class can be used.


ğŸ”„ Types of Class Loaders in Java
Java uses a hierarchical delegation model for class loading.

1ï¸âƒ£ Bootstrap Class Loader
â¤ Parent of all class loaders.
â¤ Part of the JVM itself (native code, not written in Java).
â¤ Loads core Java classes from: 
ğŸ”— <JAVA_HOME>/lib/rt.jar

(In modern Java versions, from the modules folder)
âœ… Example: java.lang.*, java.util.*

2ï¸âƒ£ Extension (Platform) Class Loader
â¤ Loads extension classes from: 
ğŸ”— <JAVA_HOME>/lib/ext/
or any directory listed in java.ext.dirs.

â¤ It loads classes that extend the core Java platform.

3ï¸âƒ£ System (Application) Class Loader
Loads classes from the classpath (the folder or JAR specified when running your program).

ğŸ”— java -cp myApp.jar com.example.Main
ğŸ‘‰ This is usually the class loader that loads your own classes.


ğŸ”„ Delegation Hierarchy
â¤ Each class loader delegates the task of loading a class to its parent first.
â¤ Only if the parent cannot find the class, does the child attempt to load it.

ğŸ‘‰ Flow:
Bootstrap Loader â†’ Extension Loader â†’ System Loader â†’ Custom Loader (if any)
âœ”ï¸ This avoids duplicate loading and ensures core classes are trusted (e.g., java.lang.String canâ€™t be replaced by user code).


âœ… Code Example â€“ Printing Class Loader Hierarchy
public class ClassLoaderDemo {
    public static void main(String[] args) {
        ClassLoader classLoader = ClassLoaderDemo.class.getClassLoader();

        System.out.println("System ClassLoader: " + classLoader);
        System.out.println("Extension ClassLoader: " + classLoader.getParent());
        System.out.println("Bootstrap ClassLoader: " + classLoader.getParent().getParent());
    }
}

âœ… Output:
System ClassLoader: jdk.internal.loader.ClassLoaders$AppClassLoader@18b4aac2
Extension ClassLoader: jdk.internal.loader.ClassLoaders$PlatformClassLoader@4b67cf4d
Bootstrap ClassLoader: null

âš¡ Note: null for Bootstrap because itâ€™s implemented in native code (C/C++), not Java.


ğŸ”„ Custom Class Loader Example (Advanced)
You can define your own loader by extending ClassLoader.

public class CustomClassLoader extends ClassLoader {
    @Override
    public Class<?> findClass(String name) throws ClassNotFoundException {
        System.out.println("Custom loader loading class: " + name);
        return super.findClass(name);
    }
}

ğŸ‘‰ Usage:
CustomClassLoader loader = new CustomClassLoader();
Class<?> cls = loader.loadClass("com.example.MyClass");


ğŸ”„ Class Loader in Spring Boot
Spring Bootâ€™s ApplicationContext heavily uses custom class loaders to:
â¤ Dynamically load beans and configuration classes.
â¤ Load classes from JARs inside a fat JAR (Spring Boot uses LaunchedURLClassLoader).
â¤ Reload classes during development (DevTools).

â¤ You can inspect it:
@SpringBootApplication
public class DemoApplication {
    public static void main(String[] args) {
        ApplicationContext context = SpringApplication.run(DemoApplication.class, args);
        System.out.println("Class Loader: " + context.getClassLoader());
    }
}


ğŸ”„ Magic Number Check
In Java, the magical number check refers to verifying the first few bytes of a .class file to ensure itâ€™s a valid Java bytecode file before loading it.

â¤ Every compiled Java .class file starts with a specific 4-byte signature:
0xCA FE BA BE
ğŸ‘‰ This is called the magic number.

When the JVM or ClassLoader loads a class, it first checks these bytes to confirm itâ€™s a valid compiled Java class and not a corrupted or malicious file.

âœ… Example:
$ xxd MyClass.class | head -1
00000000: cafe babe 0000 0034 ...

ğŸ”— If the file doesnâ€™t start with CA FE BA BE, the JVM throws:
java.lang.ClassFormatError: Invalid magic number

Hence, Magic number check â†’ Ensures the file is a valid .class file (starts with CAFEBABE) before the JVM loads it.


ğŸ”· Factory Design Pattern
â¤ Factory Design Pattern is a Creational Design Pattern that provides a way to create objects without exposing the object creation logic to the client and refers to the newly created object using a common interface.

â¤ Let the factory decide which subclass to instantiate.

ğŸ”„Core Idea
Instead of creating objects using new keyword everywhere,
â†’ we delegate the creation logic to a Factory class.

ğŸ‘‰ This improves:
1ï¸âƒ£ Loose coupling
2ï¸âƒ£ Code reusability
3ï¸âƒ£ Flexibility in object creation

ğŸ”„ Real-life Analogy
Imagine a Shape Factory that can produce Circle, Square, or Rectangle.
The client doesnâ€™t know how these shapes are created â€” it just asks the factory for one.

ğŸ”„ UML Structure
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚   ShapeFactory   â”‚  â† Factory
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚             â”‚             â”‚             â”‚
Circle       Square       Rectangle     Triangle  â† Concrete Classes

âœ… Example
1ï¸âƒ£ Create an interface
interface Shape {
    void draw();
}

2ï¸âƒ£ Create concrete implementations
class Circle implements Shape {
    @Override
    public void draw() {
        System.out.println("Drawing a Circle...");
    }
}

class Square implements Shape {
    @Override
    public void draw() {
        System.out.println("Drawing a Square...");
    }
}

class Rectangle implements Shape {
    @Override
    public void draw() {
        System.out.println("Drawing a Rectangle...");
    }
}

3ï¸âƒ£ Create the Factory class
class ShapeFactory {
    public Shape getShape(String shapeType) {
        if (shapeType == null) return null;
        return switch (shapeType.toLowerCase()) {
            case "circle" -> new Circle();
            case "square" -> new Square();
            case "rectangle" -> new Rectangle();
            default -> throw new IllegalArgumentException("Unknown shape type: " + shapeType);
        };
    }
}

4ï¸âƒ£ Client code
public class FactoryPatternDemo {
    public static void main(Stri ng[] args) {
        ShapeFactory shapeFactory = new ShapeFactory();

        Shape circle = shapeFactory.getShape("circle");
        circle.draw();

        Shape square = shapeFactory.getShape("square");
        square.draw();

        Shape rectangle = shapeFactory.getShape("rectangle");
        rectangle.draw();
    }
}
âœ… Output:
Drawing a Circle...
Drawing a Square...
Drawing a Rectangle...


ğŸ”„ Advantages
| Advantage                | Explanation                                        |
| ------------------------ | -------------------------------------------------- |
| **Encapsulation**        | Object creation logic is hidden inside the factory |
| **Loose coupling**       | Client depends on interface, not concrete classes  |
| **Extensibility**        | New product types can be added easily              |
| **Centralized creation** | All creation logic in one place                    |


ğŸ”„ Disadvantages
â¤ Might add extra complexity for simple object creation.
â¤ If there are too many product types, the factory class can grow large.

ğŸ”„ Factory Pattern in Java (Built-in Examples)
| Class                                                    | Description                                                   |
| -------------------------------------------------------- | ------------------------------------------------------------- |
| `java.util.Calendar#getInstance()`                       | Returns different `Calendar` objects based on locale/timezone |
| `java.text.NumberFormat#getInstance()`                   | Returns a subclass instance for the given locale              |
| `javax.xml.parsers.DocumentBuilderFactory#newInstance()` | Factory for XML parsers                                       |
| `java.sql.DriverManager#getConnection()`                 | Factory for JDBC connections                                  |


ğŸ”„ Factory Pattern in Spring Boot
Spring uses factories heavily â€” almost everywhere.

âœ… Example 1: BeanFactory / ApplicationContext
â¤ Springâ€™s IoC Container itself is based on the Factory Pattern.
â¤ BeanFactory is a factory for Spring Beans.
â¤ It creates and manages beans on demand, instead of the developer manually instantiating them.

ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");
Shape shape = context.getBean("circle", Shape.class);
shape.draw();

ğŸ‘‰ Spring decides which concrete class to instantiate â€” classic Factory pattern in action.


âœ… Example 2: RestTemplateBuilder (Spring Boot Factory Example)
@Bean
public RestTemplate restTemplate(RestTemplateBuilder builder) {
    return builder.build(); // Factory method
}

ğŸ‘‰ Here, RestTemplateBuilder acts as a factory, building pre-configured RestTemplate objects.


ğŸ”„ Real-+world Use Cases in Projects
| Use Case                           | Factory Role                                               |
| ---------------------------------- | ---------------------------------------------------------- |
| **Database Connection Factory**    | Create MySQL, PostgreSQL, or Mongo connections dynamically |
| **Notification Factory**           | Return Email, SMS, or PushNotification sender              |
| **Payment Gateway Factory**        | Create Razorpay, Stripe, or PayPal service objects         |
| **Message Converter Factory**      | Return JSON, XML, or CSV converters based on config        |
| **Shape/Image Processing Factory** | For UI or graphic applications                             |


ğŸ”· Builder Design Pattern
â¤ The Builder pattern is a creational design pattern used to construct complex objects step by step.
â¤ It lets you create different representations of the same object using the same construction process.

ğŸ‘‰ Purpose:
â¤ To separate the construction logic of a complex object from its representation, so the same construction process can create different types of objects.

ğŸ”„Real-world Analogy
Imagine building a Burger ğŸ” in a restaurant:
    â¤ You choose bun, patty, cheese, sauce, toppings, etc.
    â¤ You can build different burgers with the same steps but different ingredients.
Similarly, the Builder pattern constructs objects step by step.

ğŸ”„ Inner Builder Class (Preferred in Modern Java)
âœ… Example:
class Computer {
    private String CPU;
    private String RAM;
    private String storage;
    private boolean graphicsCard;

    private Computer(Builder builder) {
        this.CPU = builder.CPU;
        this.RAM = builder.RAM;
        this.storage = builder.storage;
        this.graphicsCard = builder.graphicsCard;
    }

    public static class Builder {
        private String CPU;
        private String RAM;
        private String storage;
        private boolean graphicsCard;

        public Builder setCPU(String CPU) {
            this.CPU = CPU;
            return this;
        }

        public Builder setRAM(String RAM) {
            this.RAM = RAM;
            return this;
        }

        public Builder setStorage(String storage) {
            this.storage = storage;
            return this;
        }

        public Builder setGraphicsCard(boolean graphicsCard) {
            this.graphicsCard = graphicsCard;
            return this;
        }

        public Computer build() {
            return new Computer(this);
        }
    }

    @Override
    public String toString() {
        return "Computer [CPU=" + CPU + ", RAM=" + RAM + ", storage=" + storage + ", graphicsCard=" + graphicsCard + "]";
    }
}

public class BuilderDemo {
    public static void main(String[] args) {
        Computer pc = new Computer.Builder()
                .setCPU("Intel i7")
                .setRAM("16GB")
                .setStorage("1TB SSD")
                .setGraphicsCard(true)
                .build();

        System.out.println(pc);
    }
}

ğŸ”„ Spring Boot Example
Builder pattern is commonly used when constructing complex DTOs or entity objects.

âœ…  Example using Lombokâ€™s @Builder annotation (which implements this pattern internally):

import lombok.Builder;
import lombok.Data;

@Data
@Builder
public class UserResponse {
    private String name;
    private String email;
    private int age;
}

// Usage in service:
UserResponse response = UserResponse.builder()
        .name("Ankur Verma")
        .email("ankur@example.com")
        .age(23)
        .build();
In Spring Boot, Lombokâ€™s @Builder is a direct application of the Builder pattern.

ğŸ”„ Ways to Make Fields Mandatory
ğŸ”— Use @Builder + @NonNull (Lombok)

â¤ If you annotate certain fields with @NonNull, Lombok will add null-checks in the builderâ€™s build() method.
â¤ If a required field is missing, a NullPointerException is thrown at build-time (not compile-time).


ğŸ”„ Real Java Classes Using Builder Pattern
â¤ StringBuilder (though itâ€™s mutable, not a strict builder)
â¤ java.lang.StringBuffer
â¤ java.lang.StringBuilder#append()
â¤ java.time.LocalDateTime.Builder
â¤ HttpRequest.Builder in Java 11+
â¤ Stream.Builder

ğŸ”„Where to Use in Projects
âœ”ï¸ When object construction has many optional parameters
âœ”ï¸ When you want immutable objects
âœ”ï¸ When you want to avoid telescoping constructors
âœ”ï¸ When building REST API responses or configurations

âœ… Example:
âœ”ï¸ Building complex JSON responses in Spring REST controllers.
âœ”ï¸ Building request payloads for external APIs.
âœ”ï¸ Building configuration objects (like RestTemplateBuilder in Spring Boot).

ğŸ”„ Advantages
â¤ Improves code readability and maintainability.
â¤ Allows creation of immutable objects.
â¤ Reduces constructor overloading.
â¤ Provides step-by-step object construction.

ğŸ”„ Disadvantages
â¤ Slightly more boilerplate (if not using Lombok).
â¤ Increases number of classes.


