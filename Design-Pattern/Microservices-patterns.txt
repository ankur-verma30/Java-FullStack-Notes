ğŸ”· Saga Design Pattern
Saga is a microservices transaction management pattern used when a distributed transaction spans multiple services.
Instead of using a global transaction (which is impossible across microservices), Saga breaks the workflow into a sequence of local transactions, each with a compensating transaction to undo its effect if anything fails.

Simple idea: Each microservice completes its step and triggers the next. If any step fails, compensating actions undo the previous successful steps.

â“ Why Do We Need Saga
â¤ No distributed ACID transactions across microservices
â¤ Ensures eventual consistency
â¤ Avoids 2-Phase Commit (2PC) which is slow & blocking
â¤ Suitable for long-running business transactions
â¤ Allows failure recovery without rolling back DB transactions


âœ… Types of Saga
ğŸ”„ Choreography Saga (Event-driven)
â¤ No central orchestrator.
â¤ Each service listens to events and publishes new events.

ğŸ”„ Flow:
Order Service â†’ OrderCreatedEvent
        â†“
Payment Service â†’ PaymentCompletedEvent
        â†“
Inventory Service â†’ InventoryReservedEvent


ğŸ”„ If Inventory fails:
Inventory Service â†’ InventoryFailedEvent
        â†“
Payment Service â†’ Compensate Payment (Refund)
        â†“
Order Service â†’ Cancel Order

ğŸ”„ Pros
âœ”ï¸ Simple
âœ”ï¸ Fully decoupled
âœ”ï¸ Scales well

ğŸ”„ Cons
âœ”ï¸ Hard to manage complex flows
âœ”ï¸ Event chains become messy (â€œevent spaghettiâ€)


ğŸ”„  Orchestration Saga
A central orchestrator decides what to call next.

ğŸ”„ Flow:
Saga Orchestrator
   â¬‡         â¬† (compensation)
Order Service
   â¬‡
Payment Service
   â¬‡
Inventory Service

ğŸ”„ Pros
âœ”ï¸ Clear control
âœ”ï¸ Easy to modify workflow
âœ”ï¸ Easier debugging

ğŸ”„ Cons
âœ”ï¸ Orchestrator â‰ˆ God service (too much responsibility)


ğŸ”„ Real-World Use Case â€” E-Commerce Order Processing
Scenario: User places an order

ğŸ‘‰ Saga workflow:
1ï¸âƒ£ Order Service creates order
2ï¸âƒ£ Payment Service processes payment
3ï¸âƒ£ Inventory Service reserves stock
4ï¸âƒ£ Shipping Service schedules delivery
5ï¸âƒ£ If inventory fails, Saga triggers compensations:
6ï¸âƒ£ Shipping â†’ cancel
7ï¸âƒ£Inventory â†’ no-op
8ï¸âƒ£ Payment â†’ refund
9ï¸âƒ£ Order â†’ mark as failed


Dependencies
<dependency>
    <groupId>org.springframework.kafka</groupId>
    <artifactId>spring-kafka</artifactId>
</dependency>

There are two approaches:
1ï¸âƒ£ Choreography: event-driven, decentralized
2ï¸âƒ£ Orchestration: central coordinator controls the flow

âœ… Real example: Order â†’ Payment â†’ Inventory â†’ Shipping.
If inventory fails, Saga triggers refund + order cancellation.

ğŸŒŸ Advantages
â¤ No distributed locks
â¤ Ensures eventual consistency
â¤ Fault-tolerant
â¤ Works naturally in microservices
â¤ Local transactions â†’ faster

âŒ Disadvantages
â¤ Hard to debug
â¤ Needs compensating logic for each step
â¤ Event choreography becomes complex
â¤ Temporary inconsistency exists


ğŸ”„ Quick Text Diagram (Orchestrator)
[Order Service] 
     â†“
[Orchestrator] â†’ calls Payment â†’ OK
     â†“
[Orchestrator] â†’ calls Inventory â†’ FAIL
     â†“
[Compensating Actions Triggered]
Payment â†’ refund
Order â†’ cancel

âœ… Example:
Choreography Saga Pattern (Event-Driven)

ğŸ‘‰ Weâ€™ll build 3 services:
1ï¸âƒ£Order Service
2ï¸âƒ£ Payment Service
3ï¸âƒ£ Inventory Service

Events:
1ï¸âƒ£OrderCreatedEvent
2ï¸âƒ£ PaymentCompletedEvent
3ï¸âƒ£ InventoryReservedEvent
4ï¸âƒ£ Failure events: PaymentFailedEvent, InventoryFailedEvent

ğŸ” Choreography â€” Order Service  â†’  OrderCreatedEvent
@Data
@AllArgsConstructor
@NoArgsConstructor
public class OrderCreatedEvent {
    private Long orderId;
    private double amount;
}

ğŸ” Producer: Publish OrderCreatedEvent
@Service
public class OrderService {

    @Autowired
    private KafkaTemplate<String, Object> kafkaTemplate;

    public void createOrder(Long orderId, double amount) {
        OrderCreatedEvent event = new OrderCreatedEvent(orderId, amount);
        kafkaTemplate.send("order-created", event);

        System.out.println("OrderCreatedEvent sent: " + event);
    }
}

ğŸ” Choreography â€” Payment Service
1ï¸âƒ£ Listener for OrderCreatedEvent
@Service
public class PaymentEventHandler {

    @Autowired
    private KafkaTemplate<String, Object> kafkaTemplate;

    @KafkaListener(topics = "order-created", groupId = "payment")
    public void handleOrderCreated(OrderCreatedEvent event) {
        try {
            System.out.println("Processing payment for order: " + event.getOrderId());

            // simulate success
            PaymentCompletedEvent paymentEvent =
                    new PaymentCompletedEvent(event.getOrderId());

            kafkaTemplate.send("payment-completed", paymentEvent);

        } catch (Exception e) {
            kafkaTemplate.send("payment-failed",
                    new PaymentFailedEvent(event.getOrderId()));
        }
    }
}

ğŸ” PaymentCompletedEvent
@Data
@AllArgsConstructor
@NoArgsConstructor
public class PaymentCompletedEvent {
    private Long orderId;
}

ğŸ” Choreography â€” Inventory Service
A. Listener for PaymentCompletedEvent
@Service
public class InventoryEventHandler {

    @Autowired
    private KafkaTemplate<String, Object> kafkaTemplate;

    @KafkaListener(topics = "payment-completed", groupId = "inventory")
    public void handlePaymentCompleted(PaymentCompletedEvent event) {

        try {
            System.out.println("Reserving stock for order: " + event.getOrderId());

            // simulate failure
            throw new RuntimeException("Stock not available!");

        } catch (Exception e) {
            kafkaTemplate.send("inventory-failed",
                    new InventoryFailedEvent(event.getOrderId()));
        }
    }
}

ğŸ” Choreography â€” Compensation Example
Payment Service compensates on inventory failure
@Service
public class InventoryFailedListener {

    @KafkaListener(topics = "inventory-failed", groupId = "payment-compensation")
    public void compensatePayment(InventoryFailedEvent event) {
        System.out.println("Compensating Payment â†’ Refund for order: " + event.getOrderId());
        // refund logic here
    }
}


âœ… 2. Orchestration Saga Pattern (Coordinator + Services)
Here we introduce a Saga Orchestrator, which calls microservices and triggers compensations on failure.
ğŸ”„ Services:
1ï¸âƒ£ Order Service
2ï¸âƒ£ Payment Service
3ï¸âƒ£ Inventory Service
4ï¸âƒ£ Saga Orchestrator

ğŸ” Orchestrator Class
@Service
public class OrderSagaOrchestrator {

    @Autowired
    private PaymentClient paymentClient;

    @Autowired
    private InventoryClient inventoryClient;

    public void startSaga(Long orderId, double amount) {

        try {
            System.out.println("Saga started for order: " + orderId);

            // Step 1: payment
            paymentClient.process(orderId, amount);

            // Step 2: inventory
            inventoryClient.reserve(orderId);

            System.out.println("Saga completed â†’ Order confirmed");

        } catch (Exception e) {
            System.out.println("Saga failed â†’ Triggering compensations");

            paymentClient.refund(orderId);
            inventoryClient.release(orderId);

            System.out.println("Compensation completed â†’ Order Cancelled");
        }
    }
}

ğŸ” Payment Client (REST call)
@Service
public class PaymentClient {

    public void process(Long orderId, double amount) {
        System.out.println("Payment processed for " + orderId);
    }

    public void refund(Long orderId) {
        System.out.println("Refund issued for " + orderId);
    }
}

ğŸ” Inventory Client (REST call)
@Service
public class InventoryClient {

    public void reserve(Long orderId) {
        System.out.println("Stock reserved for order: " + orderId);

        // simulate failure
        throw new RuntimeException("Stock unavailable!");
    }

    public void release(Long orderId) {
        System.out.println("Stock released for order: " + orderId);
    }
}

ğŸ” Order Service triggers the orchestrator
@RestController
@RequestMapping("/order")
public class OrderController {

    @Autowired
    private OrderSagaOrchestrator orchestrator;

    @PostMapping("/create")
    public String createOrder(@RequestParam Long id,
                              @RequestParam double amount) {
        orchestrator.startSaga(id, amount);
        return "Order processing started";
    }
}

