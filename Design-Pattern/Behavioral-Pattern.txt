ğŸ”· Chain of Responsibility
â¤ The Chain of Responsibility pattern is used to pass a request along a chain of handlers.
â¤ Each handler decides either to process the request or pass it to the next handler in the chain.

ğŸ‘‰ Purpose:
To decouple the sender and receiver of a request by allowing multiple objects a chance to handle it.

ğŸ”„ Real-world Analogy
Imagine customer support:

Level 1 Support â†’ Level 2 Support â†’ Level 3 Support
If Level 1 canâ€™t solve your issue, it passes it to Level 2, and so on.

ğŸ”„Structure
1ï¸âƒ£ Handler (Interface/Abstract Class): Defines an interface for handling requests and setting the next handler.
2ï¸âƒ£ Concrete Handlers: Handle requests they are responsible for; otherwise, forward to the next handler.
3ï¸âƒ£ Client: Initiates the request.

âœ… Example:
âš¡Step 1: Abstract Handler
abstract class Logger {
    public static int INFO = 1;
    public static int DEBUG = 2;
    public static int ERROR = 3;

    protected int level;
    protected Logger nextLogger;

    public void setNextLogger(Logger nextLogger) {
        this.nextLogger = nextLogger;
    }

    public void logMessage(int level, String message) {
        if (this.level <= level) {
            write(message);
        }
        if (nextLogger != null) {
            nextLogger.logMessage(level, message);
        }
    }

    protected abstract void write(String message);
}

âš¡Step 2: Concrete Handlers
class InfoLogger extends Logger {
    public InfoLogger(int level) { this.level = level; }

    @Override
    protected void write(String message) {
        System.out.println("INFO: " + message);
    }
}

class DebugLogger extends Logger {
    public DebugLogger(int level) { this.level = level; }

    @Override
    protected void write(String message) {
        System.out.println("DEBUG: " + message);
    }
}

class ErrorLogger extends Logger {
    public ErrorLogger(int level) { this.level = level; }

    @Override
    protected void write(String message) {
        System.out.println("ERROR: " + message);
    }
}

âš¡Step 3: Client
public class ChainOfResponsibilityDemo {
    private static Logger getChainOfLoggers() {
        Logger errorLogger = new ErrorLogger(Logger.ERROR);
        Logger debugLogger = new DebugLogger(Logger.DEBUG);
        Logger infoLogger = new InfoLogger(Logger.INFO);

        errorLogger.setNextLogger(debugLogger);
        debugLogger.setNextLogger(infoLogger);
        return errorLogger; // head of chain
    }

    public static void main(String[] args) {
        Logger loggerChain = getChainOfLoggers();

        loggerChain.logMessage(Logger.INFO, "This is an information.");
        loggerChain.logMessage(Logger.DEBUG, "This is a debug level message.");
        loggerChain.logMessage(Logger.ERROR, "This is an error message.");
    }
}

âœ… Output
INFO: This is an information.
DEBUG: This is a debug level message.
INFO: This is a debug level message.
ERROR: This is an error message.
DEBUG: This is an error message.
INFO: This is an error message.


ğŸ”„ Spring Boot Example
In Spring Boot, the CoR pattern is often used in:
â¤ Request filtering and processing
â¤ Spring Security filter chains
â¤ Exception handling chains

âœ… Example: Custom Spring Boot Filter Chain

@Component
@Order(1)
public class AuthenticationFilter implements Filter {
    @Override
    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
            throws IOException, ServletException {
        System.out.println("Authentication Filter: Checking credentials");
        chain.doFilter(req, res); // Pass to next filter
    }
}

@Component
@Order(2)
public class LoggingFilter implements Filter {
    @Override
    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
            throws IOException, ServletException {
        System.out.println("Logging Filter: Logging request");
        chain.doFilter(req, res); // Pass to next filter
    }
}
ğŸ§  Here, Spring internally builds a chain of filtersâ€”just like our CoR pattern.

ğŸ”„ Real Java Classes Using CoR
â¤ javax.servlet.Filter and FilterChain
â¤ java.util.logging.Logger
â¤ Spring Security Filter Chain


ğŸ”„ Where to Use in Projects
â¤ Logging frameworks (like above example)
â¤ Event processing systems
â¤ Request validation or authentication pipelines
â¤ Error handling chains
â¤ Middleware request processing (Spring Filters, Interceptors)


ğŸ”„ Advantages
Decouples sender and receiver.
Promotes flexibility in assigning responsibilities.
Allows dynamic changes in handling order.

ğŸ”„ Disadvantages
â¤ Request may pass through many handlers, reducing performance.
â¤ Harder to debug and trace flow. 


ğŸ”· Iterator Design Pattern
The Iterator Design Pattern provides a way to access elements of a collection sequentially without exposing the underlying representation (like array, list, tree, etc.).

ğŸ‘‰ It allows you to traverse a collection object without exposing its internal structure.

ğŸ”„ Intent
â¤ To traverse elements of a collection object in a uniform way.
â¤ To separate the logic of iteration from the collectionâ€™s internal implementation.
â¤ To support multiple traversal strategies (forward, backward, filtered, etc.).


ğŸ”„ Structure
1ï¸âƒ£ Iterator (Interface) â€” defines methods like hasNext(), next().
2ï¸âƒ£ Concrete Iterator â€” implements iteration logic.
3ï¸âƒ£ Aggregate (Collection) â€” defines an interface to create an iterator.
4ï¸âƒ£ Concrete Aggregate (Concrete Collection) â€” implements creation of iterator.

âœ… Example:
Letâ€™s build our own iterator for a collection of Song objects.

1ï¸âƒ£ Iterator interface
interface Iterator<T> {
    boolean hasNext();
    T next();
}

2ï¸âƒ£ Aggregate interface
interface SongCollection {
    Iterator<String> createIterator();
}

3ï¸âƒ£ Concrete Aggregate
class Playlist implements SongCollection {
    private final String[] songs;
    private int index = 0;

    public Playlist(String[] songs) {
        this.songs = songs;
    }

    @Override
    public Iterator<String> createIterator() {
        return new PlaylistIterator(songs);
    }
}

4ï¸âƒ£ Concrete Iterator
class PlaylistIterator implements Iterator<String> {
    private final String[] songs;
    private int position = 0;

    public PlaylistIterator(String[] songs) {
        this.songs = songs;
    }

    @Override
    public boolean hasNext() {
        return position < songs.length;
    }

    @Override
    public String next() {
        return songs[position++];
    }
}


5ï¸âƒ£ Client code
public class IteratorPatternDemo {
    public static void main(String[] args) {
        String[] songs = {"Believer", "Thunder", "Demons"};
        Playlist playlist = new Playlist(songs);
        Iterator<String> iterator = playlist.createIterator();

        while (iterator.hasNext()) {
            System.out.println("Now playing: " + iterator.next());
        }
    }
}
âœ… Output
Now playing: Believer
Now playing: Thunder
Now playing: Demons

  
âœ… Example in Java Collections Framework
Javaâ€™s entire Collection API uses this pattern.

List<String> names = List.of("Ankur", "Ravi", "Karan");

Iterator<String> it = names.iterator();
while (it.hasNext()) {
    System.out.println(it.next());
}
ğŸ‘‰ Here:
â¤ List is the Concrete Aggregate.
â¤ Iterator is the Iterator Interface.
â¤ ArrayList.Itr is the Concrete Iterator.

So yes â€”
âœ… All Java Collections (ArrayList, HashSet, TreeMap, etc.) follow the Iterator pattern.


ğŸ”„ Iterator Methods in Java
| Method               | Description                                   |
| -------------------- | --------------------------------------------- |
| `hasNext()`          | Checks if there are more elements             |
| `next()`             | Returns next element                          |
| `remove()`           | Removes current element (optional)            |
| `forEachRemaining()` | Performs an action for each remaining element |

ğŸ”„ In Spring Boot
The Iterator pattern is indirectly used in:
âœ”ï¸ BeanFactory and ApplicationContext (for iterating over beans)
âœ”ï¸ JdbcTemplate result sets
âœ”ï¸ Environment properties iteration
âœ”ï¸ Spring Data Repositories when iterating over query results

âœ…Example:
@Autowired
private ApplicationContext context;

public void listBeans() {
    for (String beanName : context.getBeanDefinitionNames()) {
        System.out.println("Bean: " + beanName);
    }
}
ğŸ‘‰ Here, Spring internally uses the Iterator Pattern to traverse bean definitions.


ğŸ”„ Where to Use It in Projects
âœ”ï¸ When you want a uniform traversal mechanism across different collections.
âœ”ï¸ When internal representation (array, linked list, tree) should be hidden.
âœ”ï¸ When multiple traversal types are needed (e.g., forward/backward).
âœ”ï¸ When you want to support iteration over custom data structures.


ğŸ”„ Advantages
â¤ Decouples iteration logic from collection class.
â¤ Supports multiple traversal strategies.
â¤ Consistent interface for all collections.


ğŸ”„ Disadvantages
â¤ May increase number of classes (extra iterator class).
â¤ Complex for nested or bidirectional traversals.


ğŸ”· Observer Design Pattern
The Observer Design Pattern defines a one-to-many dependency between objects, so that when one object (subject) changes its state, all its dependents (observers) are notified and updated automatically.

ğŸ”„ Intent
â¤ To achieve loose coupling between objects.
â¤ To allow automatic notification when the state of one object changes.
â¤ To easily add or remove observers without changing the subject.

ğŸ”„ Real-world Analogy
Think of a YouTube channel:
â¤ The channel = Subject
â¤ The subscribers = Observers
â¤ When the channel uploads a new video, all subscribers get notified automatically.

ğŸ”„ Structure
1ï¸âƒ£ Subject (Observable)
    âœ”ï¸ Maintains a list of observers
    âœ”ï¸ Notifies them about state changes
2ï¸âƒ£ Observer (Subscriber)
    âœ”ï¸ Defines the update method
3ï¸âƒ£ ConcreteSubject
    âœ”ï¸ Implements Subject and triggers notifications
4ï¸âƒ£ ConcreteObserver
    âœ”ï¸ Implements the Observer and updates itself upon notification

âœ… Java Example
import java.util.ArrayList;
import java.util.List;

ğŸ” Observer Interface
interface Observer {
    void update(String message);
}

ğŸ” Subject Interface
interface Subject {
    void attach(Observer o);
    void detach(Observer o);
    void notifyObservers(String message);
}

ğŸ” Concrete Subject
class YouTubeChannel implements Subject {
    private final List<Observer> subscribers = new ArrayList<>();

    @Override
    public void attach(Observer o) {
        subscribers.add(o);
    }

    @Override
    public void detach(Observer o) {
        subscribers.remove(o);
    }

    @Override
    public void notifyObservers(String message) {
        for (Observer o : subscribers) {
            o.update(message);
        }
    }

    public void uploadVideo(String title) {
        System.out.println("Channel uploaded a new video: " + title);
        notifyObservers("New video uploaded: " + title);
    }
}

ğŸ” Concrete Observers
class Subscriber implements Observer {
    private final String name;

    public Subscriber(String name) {
        this.name = name;
    }

    @Override
    public void update(String message) {
        System.out.println(name + " received notification â†’ " + message);
    }
}

ğŸ” Client
public class ObserverPatternDemo {
    public static void main(String[] args) {
        YouTubeChannel channel = new YouTubeChannel();

        Observer s1 = new Subscriber("Ankur");
        Observer s2 = new Subscriber("Isha");
        Observer s3 = new Subscriber("Deepak");

        channel.attach(s1);
        channel.attach(s2);
        channel.attach(s3);

        channel.uploadVideo("Design Patterns in Java");
    }
}

âœ… Output
Channel uploaded a new video: Design Patterns in Java
Ankur received notification â†’ New video uploaded: Design Patterns in Java
Isha received notification â†’ New video uploaded: Design Patterns in Java
Deepak received notification â†’ New video uploaded: Design Patterns in Java


ğŸ”„ Example in Java
Java provides the Observer pattern built-in (though deprecated since Java 9):

import java.util.Observable;
import java.util.Observer;

class NewsAgency extends Observable {
    void setNews(String news) {
        setChanged();
        notifyObservers(news);
    }
}

class NewsChannel implements Observer {
    private String news;

    public void update(Observable o, Object arg) {
        this.news = (String) arg;
        System.out.println("News Updated: " + news);
    }
}
Even though this approach is deprecated, itâ€™s the classic example of the pattern built into Java.

ğŸ”„ Spring Boot Example (Real-world Use Case)
Springâ€™s ApplicationEventPublisher and @EventListener mechanism is a perfect implementation of the Observer Pattern.

1ï¸âƒ£ Define a custom event
import org.springframework.context.ApplicationEvent;

public class UserRegisteredEvent extends ApplicationEvent {
    private final String username;

    public UserRegisteredEvent(Object source, String username) {
        super(source);
        this.username = username;
    }

    public String getUsername() {
        return username;
    }
}

2ï¸âƒ£ Publish the event
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.stereotype.Service;

@Service
public class UserService {
    @Autowired
    private ApplicationEventPublisher publisher;

    public void registerUser(String username) {
        System.out.println("Registering user: " + username);
        publisher.publishEvent(new UserRegisteredEvent(this, username));
    }
}

3ï¸âƒ£ Listen for the event
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Component;

@Component
public class EmailNotificationListener {

    @EventListener
    public void handleUserRegistered(UserRegisteredEvent event) {
        System.out.println("Sending welcome email to " + event.getUsername());
    }
}

âœ… Output
Registering user: Ankur
Sending welcome email to Ankur

ğŸ‘‰ Here:
â¤ UserService â†’ Subject
â¤ EmailNotificationListener â†’ Observer
â¤ Spring Event System â†’ Automatically handles notification and decoupling

ğŸ”„ Where to Use in Projects
âœ”ï¸ When multiple components depend on a single event source
âœ”ï¸ For event-driven architectures (e.g., Spring Event System, Kafka, RabbitMQ)
âœ”ï¸ For notification systems (email, logs, analytics)
âœ”ï¸ For GUI listeners (like ActionListener in Swing/JavaFX)
âœ”ï¸ For reactive programming (RxJava, Reactor)

ğŸ”„ Java Classes That Use Observer Pattern
java.util.Observer and java.util.Observable
javax.servlet.http.HttpSessionBindingListener
java.awt.event.ActionListener
Springâ€™s ApplicationEventPublisher and @EventListener

ğŸ”„ Advantages
Loose coupling between components
Easy to add/remove observers dynamically
Promotes event-driven system design

ğŸ”„ Disadvantages
Memory leaks if observers are not properly removed
Unexpected update sequences if too many observers
Can get complex when there are multiple chains of notifications


ğŸ”· Strategy Design Pattern
The Strategy Design Pattern defines a family of algorithms,
encapsulates each one, and makes them interchangeable.
The client can choose which strategy (algorithm) to use at runtime without changing the code that uses it.

ğŸ”„ Intent
â¤ To define a set of interchangeable behaviors (algorithms).
â¤ To decouple algorithms from the classes that use them.
â¤ To easily switch between different algorithms at runtime.

ğŸ”„ Real-World Analogy
Think of a payment system:
â¤ Payment can be done by Credit Card, PayPal, or UPI.
â¤ Each is a different strategy for processing payment.
â¤ The ShoppingCart class doesnâ€™t need to know how the payment is processed â€” it just calls the chosen strategy.

ğŸ”„ Structure
1ï¸âƒ£ Strategy (Interface) â€” declares a common interface for all supported algorithms.
2ï¸âƒ£ Concrete Strategies â€” implement different versions of the algorithm.
3ï¸âƒ£ Context â€” maintains a reference to a Strategy object and delegates the execution to it.

âœ… Java Example â€” Payment System
1ï¸âƒ£ Strategy Interface
interface PaymentStrategy {
    void pay(int amount);
}

2ï¸âƒ£ Concrete Strategies
class CreditCardPayment implements PaymentStrategy {
    @Override
    public void pay(int amount) {
        System.out.println("Paid â‚¹" + amount + " using Credit Card.");
    }
}

class PayPalPayment implements PaymentStrategy {
    @Override
    public void pay(int amount) {
        System.out.println("Paid â‚¹" + amount + " using PayPal.");
    }
}

class UPIPayment implements PaymentStrategy {
    @Override
    public void pay(int amount) {
        System.out.println("Paid â‚¹" + amount + " using UPI.");
    }
}

3ï¸âƒ£ Context Class
class ShoppingCart {
    private PaymentStrategy paymentStrategy;

    // Set strategy at runtime
    public void setPaymentStrategy(PaymentStrategy paymentStrategy) {
        this.paymentStrategy = paymentStrategy;
    }

    public void checkout(int amount) {
        if (paymentStrategy == null) {
            throw new IllegalStateException("Payment method not set!");
        }
        paymentStrategy.pay(amount);
    }
}

4ï¸âƒ£ Client Code
public class StrategyPatternDemo {
    public static void main(String[] args) {
        ShoppingCart cart = new ShoppingCart();

        cart.setPaymentStrategy(new CreditCardPayment());
        cart.checkout(500);

        cart.setPaymentStrategy(new UPIPayment());
        cart.checkout(250);
    }
}
âœ… Output
Paid â‚¹500 using Credit Card.
Paid â‚¹250 using UPI.


ğŸ”„ In Java Frameworks
âœ”ï¸ The Strategy Pattern is used heavily inside the Java and Spring frameworks.

âœ… Java Examples
âœ”ï¸ java.util.Comparator â€” you pass a comparator (strategy) to sort data differently.

Collections.sort(list, Comparator.comparing(Student::getName));

âœ”ï¸ Here, different comparators = different sorting strategies.
âœ”ï¸ javax.servlet.http.HttpServlet â€” doGet(), doPost(), etc. act as different strategies for handling requests.

âœ… Spring Boot Example
Spring uses the Strategy pattern extensively â€” especially for:
âœ”ï¸ ResourceResolvers
âœ”ï¸ CacheStrategies
âœ”ï¸ DataSource selection
âœ”ï¸ AuthenticationProvider (Spring Security)
âœ”ï¸ ViewResolver, MessageConverter, etc.

ğŸ‘‰ Letâ€™s see a simple Spring Boot Strategy Example ğŸ‘‡
ğŸ”„ Payment Strategy in Spring
1ï¸âƒ£ Define the strategy interface
public interface PaymentStrategy {
    void pay(double amount);
}

2ï¸âƒ£ Implement concrete strategies
import org.springframework.stereotype.Component;

@Component("creditCard")
public class CreditCardPayment implements PaymentStrategy {
    public void pay(double amount) {
        System.out.println("Paid â‚¹" + amount + " using Credit Card.");
    }
}

@Component("upi")
public class UPIPayment implements PaymentStrategy {
    public void pay(double amount) {
        System.out.println("Paid â‚¹" + amount + " using UPI.");
    }
}

3ï¸âƒ£ Context class (using Spring to inject the strategy)
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;

@Service
public class PaymentService {
    private final PaymentStrategy paymentStrategy;

    @Autowired
    public PaymentService(@Qualifier("upi") PaymentStrategy paymentStrategy) {
        this.paymentStrategy = paymentStrategy;
    }

    public void processPayment(double amount) {
        paymentStrategy.pay(amount);
    }
}

4ï¸âƒ£ Controller or main class
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class StrategyPatternApp implements CommandLineRunner {
    @Autowired
    private PaymentService paymentService;

    public static void main(String[] args) {
        SpringApplication.run(StrategyPatternApp.class, args);
    }

    @Override
    public void run(String... args) {
        paymentService.processPayment(1000);
    }
}
âœ… Output
Paid â‚¹1000 using UPI.


ğŸ”„ Where to Use in Projects
â¤ When multiple algorithms can perform the same task (e.g., sorting, payment, compression, authentication).
â¤ When algorithms may change independently of the client.
â¤ When you want to choose behavior at runtime.
â¤ When you want to eliminate large if-else or switch statements.

ğŸ”„ Java Classes That Use Strategy Pattern
| Class                            | Strategy Used             |
| -------------------------------- | ------------------------- |
| `java.util.Comparator`           | Sorting strategy          |
| `javax.servlet.http.HttpServlet` | Request handling strategy |
| `java.util.zip.Deflater`         | Compression strategy      |
| `Spring AuthenticationProvider`  | Authentication strategy   |


ğŸ”„ Advantages
â¤ Promotes Open/Closed Principle (add new strategies without modifying context).
â¤ Simplifies code by removing complex conditional logic.
â¤ Allows dynamic behavior change at runtime.
â¤ Easy to unit test each strategy independently.

ğŸ”„ Disadvantages
â¤ Increases the number of classes.
â¤ Client must know which strategy to choose.
â¤ Can become overkill if there are very few variations.


ğŸ”· Template Design Pattern
The Template Method Pattern defines the skeleton (blueprint) of an algorithm in a base (abstract) class but lets subclasses override specific steps of the algorithm without changing its structure.

It promotes code reuse and inversion of control â€” the base class controls the overall process, and subclasses fill in the details.


ğŸ”„ Structure
1ï¸âƒ£ Abstract Class (Template)
âœ”ï¸ Defines the template method (final method) which outlines steps of an algorithm.
âœ”ï¸ Implements common steps.
âœ”ï¸ Declares abstract methods for steps that subclasses must implement.

2ï¸âƒ£ Concrete Subclasses
âœ”ï¸ Implement the abstract steps defined by the template class.  


âœ… Java Example: Template Method Pattern in Java
Weâ€™ll take an example of building a house â€” every house has a standard build process, but details differ for wooden and concrete houses.

1ï¸âƒ£ Create the Abstract Template Class
abstract class HouseTemplate {

    ğŸ‘‰ template method (final to prevent overriding)
    public final void buildHouse() {
        buildFoundation();
        buildPillars();
        buildWalls();
        buildWindows();
        System.out.println("House construction completed.\n");
    }

    private void buildFoundation() {
        System.out.println("Building foundation with cement, iron rods, and sand");
    }

    ğŸ‘‰ abstract methods to be implemented by subclasses
    protected abstract void buildPillars();
    protected abstract void buildWalls();

    private void buildWindows() {
        System.out.println("Building Glass Windows");
    }
}

2ï¸âƒ£ Create Concrete Implementations
class WoodenHouse extends HouseTemplate {
    @Override
    protected void buildPillars() {
        System.out.println("Building Pillars with Wood coating");
    }

    @Override
    protected void buildWalls() {
        System.out.println("Building Wooden Walls");
    }
}

class ConcreteHouse extends HouseTemplate {
    @Override
    protected void buildPillars() {
        System.out.println("Building Pillars with Cement and Iron");
    }

    @Override
    protected void buildWalls() {
        System.out.println("Building Concrete Walls");
    }
}

3ï¸âƒ£ Client Code
public class TemplatePatternDemo {
    public static void main(String[] args) {
        HouseTemplate houseType = new WoodenHouse();
        System.out.println("Building Wooden House...");
        houseType.buildHouse();

        houseType = new ConcreteHouse();
        System.out.println("Building Concrete House...");
        houseType.buildHouse();
    }
}

âœ… Output
Building Wooden House...
Building foundation with cement, iron rods, and sand
Building Pillars with Wood coating
Building Wooden Walls
Building Glass Windows
House construction completed.

Building Concrete House...
Building foundation with cement, iron rods, and sand
Building Pillars with Cement and Iron
Building Concrete Walls
Building Glass Windows
House construction completed.

ğŸ”„ Real-Life Example in Java & Spring
âœ… In Java:
java.util.AbstractList, java.util.AbstractSet, java.util.AbstractMap â€”

ğŸ‘‰ They provide partial implementations and let subclasses define specific behavior.

âœ… Example:
public abstract class AbstractList<E> implements List<E> {
    public boolean add(E e) {
        add(size(), e);  // Template method
        return true;
    }
    public abstract void add(int index, E element);
}
ğŸ‘‰ Here, add(E e) is a template method, and subclasses like ArrayList define add(int index, E element).

ğŸ”„ In Spring Framework:
Spring uses Template Pattern heavily in multiple places, for example:
â¤ JdbcTemplate, RestTemplate, JpaTemplate, etc.
These templates define the workflow of database or REST operations, while users provide specific callback implementations (like RowMapper, ResponseExtractor).

âœ… Example:
jdbcTemplate.query("SELECT * FROM users", new RowMapper<User>() {
    public User mapRow(ResultSet rs, int rowNum) throws SQLException {
        return new User(rs.getString("name"), rs.getInt("age"));
    }
});
ğŸ‘‰ Here, JdbcTemplate defines the template method, and you only fill in the variable part (how to map rows).

ğŸ§° Where to Use
â¤ When you want to define the skeleton of an algorithm once and let subclasses customize steps.
â¤ When you want consistent workflow but flexible implementation for certain parts.

ğŸ”„ Advantages
âœ”ï¸ Code reuse â€” common logic in one place.
âœ”ï¸ Control algorithm steps order.
âœ”ï¸ Enforces consistency across subclasses.

ğŸ”„ Disadvantages
âœ”ï¸ Tight coupling between base and subclasses.
âœ”ï¸ Hard to modify the flow dynamically at runtime.


ğŸ”· Momento Design Pattern
The Memento Pattern allows an object to capture its internal state and restore it later, without violating encapsulation.

It involves three main roles:
1ï¸âƒ£ Originator â€“ the object whose state needs to be saved/restored.
2ï¸âƒ£ Memento â€“ the object that stores the snapshot of the originatorâ€™s state.
3ï¸âƒ£ Caretaker â€“ manages saving and restoring mementos but doesnâ€™t modify them.

Think of it like Ctrl+Z (Undo) in text editors:
The editor = Originator
Snapshot = Memento
Undo stack = Caretaker

ğŸ”„ Structure
Originator -----> Memento
     ^
     |
Caretaker

â¤ Originator creates a Memento containing its current state and uses it to restore state later.
â¤ Caretaker stores Mementos but never modifies their contents.

âœ… Java Example: Text Editor Undo
1ï¸âƒ£ Memento Class
// Memento
public class TextEditorMemento {
    private final String content;

    public TextEditorMemento(String content) {
        this.content = content;
    }

    public String getContent() {
        return content;
    }
}

2ï¸âƒ£ Originator Class
// Originator
public class TextEditor {
    private String content = "";

    public void type(String words) {
        content += words;
    }

    public String getContent() {
        return content;
    }

    public TextEditorMemento save() {
        return new TextEditorMemento(content); // snapshot
    }

    public void restore(TextEditorMemento memento) {
        content = memento.getContent(); // restore snapshot
    }
}

3ï¸âƒ£ Caretaker Class
import java.util.ArrayList;
import java.util.List;

public class Caretaker {
    private List<TextEditorMemento> history = new ArrayList<>();

    public void addMemento(TextEditorMemento memento) {
        history.add(memento);
    }

    public TextEditorMemento getMemento(int index) {
        return history.get(index);
    }
}

4ï¸âƒ£ Client Code
public class MementoPatternDemo {
    public static void main(String[] args) {
        TextEditor editor = new TextEditor();
        Caretaker caretaker = new Caretaker();

        editor.type("Hello ");
        caretaker.addMemento(editor.save());

        editor.type("World!");
        caretaker.addMemento(editor.save());

        System.out.println("Current Content: " + editor.getContent());

        // Undo last action
        editor.restore(caretaker.getMemento(0));
        System.out.println("After Undo: " + editor.getContent());
    }
}

âœ… Output
Current Content: Hello World!
After Undo: Hello 

ğŸ§  Real-Life Examples in Java & Spring
1ï¸âƒ£ Java
java.util.Date and java.util.Calendar allow snapshots of state (conceptually similar).
JTextComponent in Swing uses UndoManager which internally follows Memento pattern.

2ï¸âƒ£ Spring Boot
Versioning of entity states or rollback operations can use Memento-like logic.

âœ… Example: Implementing an undo feature in a form:
â¤ Save snapshots of DTOs in memory or DB.
â¤ Restore previous state on user request.

âš–ï¸ Advantages
â¤ Encapsulates object state without exposing internal structure.
â¤ Enables undo/redo functionality.
â¤ Supports versioning or rollback mechanisms.

ğŸš« Disadvantages
âŒ Can consume large memory if many snapshots are stored.
âŒ Overhead if object state is large or complex.
âŒ Complexity increases if deep copying is required for nested objects.

ğŸ”„
ğŸ”„
ğŸ”„
ğŸ”„
ğŸ”„
ğŸ”„
ğŸ”„
