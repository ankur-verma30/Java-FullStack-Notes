ğŸ”· Chain of Responsibility
â¤ The Chain of Responsibility pattern is used to pass a request along a chain of handlers.
â¤ Each handler decides either to process the request or pass it to the next handler in the chain.

ğŸ‘‰ Purpose:
To decouple the sender and receiver of a request by allowing multiple objects a chance to handle it.

ğŸ”„ Real-world Analogy
Imagine customer support:

Level 1 Support â†’ Level 2 Support â†’ Level 3 Support
If Level 1 canâ€™t solve your issue, it passes it to Level 2, and so on.

ğŸ”„Structure
1ï¸âƒ£ Handler (Interface/Abstract Class): Defines an interface for handling requests and setting the next handler.
2ï¸âƒ£ Concrete Handlers: Handle requests they are responsible for; otherwise, forward to the next handler.
3ï¸âƒ£ Client: Initiates the request.

âœ… Example:
âš¡Step 1: Abstract Handler
abstract class Logger {
    public static int INFO = 1;
    public static int DEBUG = 2;
    public static int ERROR = 3;

    protected int level;
    protected Logger nextLogger;

    public void setNextLogger(Logger nextLogger) {
        this.nextLogger = nextLogger;
    }

    public void logMessage(int level, String message) {
        if (this.level <= level) {
            write(message);
        }
        if (nextLogger != null) {
            nextLogger.logMessage(level, message);
        }
    }

    protected abstract void write(String message);
}

âš¡Step 2: Concrete Handlers
class InfoLogger extends Logger {
    public InfoLogger(int level) { this.level = level; }

    @Override
    protected void write(String message) {
        System.out.println("INFO: " + message);
    }
}

class DebugLogger extends Logger {
    public DebugLogger(int level) { this.level = level; }

    @Override
    protected void write(String message) {
        System.out.println("DEBUG: " + message);
    }
}

class ErrorLogger extends Logger {
    public ErrorLogger(int level) { this.level = level; }

    @Override
    protected void write(String message) {
        System.out.println("ERROR: " + message);
    }
}

âš¡Step 3: Client
public class ChainOfResponsibilityDemo {
    private static Logger getChainOfLoggers() {
        Logger errorLogger = new ErrorLogger(Logger.ERROR);
        Logger debugLogger = new DebugLogger(Logger.DEBUG);
        Logger infoLogger = new InfoLogger(Logger.INFO);

        errorLogger.setNextLogger(debugLogger);
        debugLogger.setNextLogger(infoLogger);
        return errorLogger; // head of chain
    }

    public static void main(String[] args) {
        Logger loggerChain = getChainOfLoggers();

        loggerChain.logMessage(Logger.INFO, "This is an information.");
        loggerChain.logMessage(Logger.DEBUG, "This is a debug level message.");
        loggerChain.logMessage(Logger.ERROR, "This is an error message.");
    }
}

âœ… Output
INFO: This is an information.
DEBUG: This is a debug level message.
INFO: This is a debug level message.
ERROR: This is an error message.
DEBUG: This is an error message.
INFO: This is an error message.


ğŸ”„ Spring Boot Example
In Spring Boot, the CoR pattern is often used in:
â¤ Request filtering and processing
â¤ Spring Security filter chains
â¤ Exception handling chains

âœ… Example: Custom Spring Boot Filter Chain

@Component
@Order(1)
public class AuthenticationFilter implements Filter {
    @Override
    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
            throws IOException, ServletException {
        System.out.println("Authentication Filter: Checking credentials");
        chain.doFilter(req, res); // Pass to next filter
    }
}

@Component
@Order(2)
public class LoggingFilter implements Filter {
    @Override
    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
            throws IOException, ServletException {
        System.out.println("Logging Filter: Logging request");
        chain.doFilter(req, res); // Pass to next filter
    }
}
ğŸ§  Here, Spring internally builds a chain of filtersâ€”just like our CoR pattern.

ğŸ”„ Real Java Classes Using CoR
â¤ javax.servlet.Filter and FilterChain
â¤ java.util.logging.Logger
â¤ Spring Security Filter Chain


ğŸ”„ Where to Use in Projects
â¤ Logging frameworks (like above example)
â¤ Event processing systems
â¤ Request validation or authentication pipelines
â¤ Error handling chains
â¤ Middleware request processing (Spring Filters, Interceptors)


ğŸ”„ Advantages
Decouples sender and receiver.
Promotes flexibility in assigning responsibilities.
Allows dynamic changes in handling order.

ğŸ”„ Disadvantages
â¤ Request may pass through many handlers, reducing performance.
â¤ Harder to debug and trace flow. 

ğŸ”„