ğŸ”· Chain of Responsibility
â¤ The Chain of Responsibility pattern is used to pass a request along a chain of handlers.
â¤ Each handler decides either to process the request or pass it to the next handler in the chain.

ğŸ‘‰ Purpose:
To decouple the sender and receiver of a request by allowing multiple objects a chance to handle it.

ğŸ”„ Real-world Analogy
Imagine customer support:

Level 1 Support â†’ Level 2 Support â†’ Level 3 Support
If Level 1 canâ€™t solve your issue, it passes it to Level 2, and so on.

ğŸ”„Structure
1ï¸âƒ£ Handler (Interface/Abstract Class): Defines an interface for handling requests and setting the next handler.
2ï¸âƒ£ Concrete Handlers: Handle requests they are responsible for; otherwise, forward to the next handler.
3ï¸âƒ£ Client: Initiates the request.

âœ… Example:
âš¡Step 1: Abstract Handler
abstract class Logger {
    public static int INFO = 1;
    public static int DEBUG = 2;
    public static int ERROR = 3;

    protected int level;
    protected Logger nextLogger;

    public void setNextLogger(Logger nextLogger) {
        this.nextLogger = nextLogger;
    }

    public void logMessage(int level, String message) {
        if (this.level <= level) {
            write(message);
        }
        if (nextLogger != null) {
            nextLogger.logMessage(level, message);
        }
    }

    protected abstract void write(String message);
}

âš¡Step 2: Concrete Handlers
class InfoLogger extends Logger {
    public InfoLogger(int level) { this.level = level; }

    @Override
    protected void write(String message) {
        System.out.println("INFO: " + message);
    }
}

class DebugLogger extends Logger {
    public DebugLogger(int level) { this.level = level; }

    @Override
    protected void write(String message) {
        System.out.println("DEBUG: " + message);
    }
}

class ErrorLogger extends Logger {
    public ErrorLogger(int level) { this.level = level; }

    @Override
    protected void write(String message) {
        System.out.println("ERROR: " + message);
    }
}

âš¡Step 3: Client
public class ChainOfResponsibilityDemo {
    private static Logger getChainOfLoggers() {
        Logger errorLogger = new ErrorLogger(Logger.ERROR);
        Logger debugLogger = new DebugLogger(Logger.DEBUG);
        Logger infoLogger = new InfoLogger(Logger.INFO);

        errorLogger.setNextLogger(debugLogger);
        debugLogger.setNextLogger(infoLogger);
        return errorLogger; // head of chain
    }

    public static void main(String[] args) {
        Logger loggerChain = getChainOfLoggers();

        loggerChain.logMessage(Logger.INFO, "This is an information.");
        loggerChain.logMessage(Logger.DEBUG, "This is a debug level message.");
        loggerChain.logMessage(Logger.ERROR, "This is an error message.");
    }
}

âœ… Output
INFO: This is an information.
DEBUG: This is a debug level message.
INFO: This is a debug level message.
ERROR: This is an error message.
DEBUG: This is an error message.
INFO: This is an error message.


ğŸ”„ Spring Boot Example
In Spring Boot, the CoR pattern is often used in:
â¤ Request filtering and processing
â¤ Spring Security filter chains
â¤ Exception handling chains

âœ… Example: Custom Spring Boot Filter Chain

@Component
@Order(1)
public class AuthenticationFilter implements Filter {
    @Override
    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
            throws IOException, ServletException {
        System.out.println("Authentication Filter: Checking credentials");
        chain.doFilter(req, res); // Pass to next filter
    }
}

@Component
@Order(2)
public class LoggingFilter implements Filter {
    @Override
    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
            throws IOException, ServletException {
        System.out.println("Logging Filter: Logging request");
        chain.doFilter(req, res); // Pass to next filter
    }
}
ğŸ§  Here, Spring internally builds a chain of filtersâ€”just like our CoR pattern.

ğŸ”„ Real Java Classes Using CoR
â¤ javax.servlet.Filter and FilterChain
â¤ java.util.logging.Logger
â¤ Spring Security Filter Chain


ğŸ”„ Where to Use in Projects
â¤ Logging frameworks (like above example)
â¤ Event processing systems
â¤ Request validation or authentication pipelines
â¤ Error handling chains
â¤ Middleware request processing (Spring Filters, Interceptors)


ğŸ”„ Advantages
Decouples sender and receiver.
Promotes flexibility in assigning responsibilities.
Allows dynamic changes in handling order.

ğŸ”„ Disadvantages
â¤ Request may pass through many handlers, reducing performance.
â¤ Harder to debug and trace flow. 


ğŸ”· Iterator Design Pattern
The Iterator Design Pattern provides a way to access elements of a collection sequentially without exposing the underlying representation (like array, list, tree, etc.).

ğŸ‘‰ It allows you to traverse a collection object without exposing its internal structure.

ğŸ”„ Intent
â¤ To traverse elements of a collection object in a uniform way.
â¤ To separate the logic of iteration from the collectionâ€™s internal implementation.
â¤ To support multiple traversal strategies (forward, backward, filtered, etc.).


ğŸ”„ Structure
1ï¸âƒ£ Iterator (Interface) â€” defines methods like hasNext(), next().
2ï¸âƒ£ Concrete Iterator â€” implements iteration logic.
3ï¸âƒ£ Aggregate (Collection) â€” defines an interface to create an iterator.
4ï¸âƒ£ Concrete Aggregate (Concrete Collection) â€” implements creation of iterator.

âœ… Example:
Letâ€™s build our own iterator for a collection of Song objects.

1ï¸âƒ£ Iterator interface
interface Iterator<T> {
    boolean hasNext();
    T next();
}

2ï¸âƒ£ Aggregate interface
interface SongCollection {
    Iterator<String> createIterator();
}

3ï¸âƒ£ Concrete Aggregate
class Playlist implements SongCollection {
    private final String[] songs;
    private int index = 0;

    public Playlist(String[] songs) {
        this.songs = songs;
    }

    @Override
    public Iterator<String> createIterator() {
        return new PlaylistIterator(songs);
    }
}

4ï¸âƒ£ Concrete Iterator
class PlaylistIterator implements Iterator<String> {
    private final String[] songs;
    private int position = 0;

    public PlaylistIterator(String[] songs) {
        this.songs = songs;
    }

    @Override
    public boolean hasNext() {
        return position < songs.length;
    }

    @Override
    public String next() {
        return songs[position++];
    }
}


5ï¸âƒ£ Client code
public class IteratorPatternDemo {
    public static void main(String[] args) {
        String[] songs = {"Believer", "Thunder", "Demons"};
        Playlist playlist = new Playlist(songs);
        Iterator<String> iterator = playlist.createIterator();

        while (iterator.hasNext()) {
            System.out.println("Now playing: " + iterator.next());
        }
    }
}
âœ… Output
Now playing: Believer
Now playing: Thunder
Now playing: Demons

  
âœ… Example in Java Collections Framework
Javaâ€™s entire Collection API uses this pattern.

List<String> names = List.of("Ankur", "Ravi", "Karan");

Iterator<String> it = names.iterator();
while (it.hasNext()) {
    System.out.println(it.next());
}
ğŸ‘‰ Here:
â¤ List is the Concrete Aggregate.
â¤ Iterator is the Iterator Interface.
â¤ ArrayList.Itr is the Concrete Iterator.

So yes â€”
âœ… All Java Collections (ArrayList, HashSet, TreeMap, etc.) follow the Iterator pattern.


ğŸ”„ Iterator Methods in Java
| Method               | Description                                   |
| -------------------- | --------------------------------------------- |
| `hasNext()`          | Checks if there are more elements             |
| `next()`             | Returns next element                          |
| `remove()`           | Removes current element (optional)            |
| `forEachRemaining()` | Performs an action for each remaining element |

ğŸ”„ In Spring Boot
The Iterator pattern is indirectly used in:
âœ”ï¸ BeanFactory and ApplicationContext (for iterating over beans)
âœ”ï¸ JdbcTemplate result sets
âœ”ï¸ Environment properties iteration
âœ”ï¸ Spring Data Repositories when iterating over query results

âœ…Example:
@Autowired
private ApplicationContext context;

public void listBeans() {
    for (String beanName : context.getBeanDefinitionNames()) {
        System.out.println("Bean: " + beanName);
    }
}
ğŸ‘‰ Here, Spring internally uses the Iterator Pattern to traverse bean definitions.


ğŸ”„ Where to Use It in Projects
âœ”ï¸ When you want a uniform traversal mechanism across different collections.
âœ”ï¸ When internal representation (array, linked list, tree) should be hidden.
âœ”ï¸ When multiple traversal types are needed (e.g., forward/backward).
âœ”ï¸ When you want to support iteration over custom data structures.


ğŸ”„ Advantages
â¤ Decouples iteration logic from collection class.
â¤ Supports multiple traversal strategies.
â¤ Consistent interface for all collections.


ğŸ”„ Disadvantages
â¤ May increase number of classes (extra iterator class).
â¤ Complex for nested or bidirectional traversals.


ğŸ”· Observer Design Pattern
The Observer Design Pattern defines a one-to-many dependency between objects, so that when one object (subject) changes its state, all its dependents (observers) are notified and updated automatically.

ğŸ”„ Intent
â¤ To achieve loose coupling between objects.
â¤ To allow automatic notification when the state of one object changes.
â¤ To easily add or remove observers without changing the subject.

ğŸ”„ Real-world Analogy
Think of a YouTube channel:
â¤ The channel = Subject
â¤ The subscribers = Observers
â¤ When the channel uploads a new video, all subscribers get notified automatically.

ğŸ”„ Structure
1ï¸âƒ£ Subject (Observable)
    âœ”ï¸ Maintains a list of observers
    âœ”ï¸ Notifies them about state changes
2ï¸âƒ£ Observer (Subscriber)
    âœ”ï¸ Defines the update method
3ï¸âƒ£ ConcreteSubject
    âœ”ï¸ Implements Subject and triggers notifications
4ï¸âƒ£ ConcreteObserver
    âœ”ï¸ Implements the Observer and updates itself upon notification

âœ… Java Example
import java.util.ArrayList;
import java.util.List;

ğŸ” Observer Interface
interface Observer {
    void update(String message);
}

ğŸ” Subject Interface
interface Subject {
    void attach(Observer o);
    void detach(Observer o);
    void notifyObservers(String message);
}

ğŸ” Concrete Subject
class YouTubeChannel implements Subject {
    private final List<Observer> subscribers = new ArrayList<>();

    @Override
    public void attach(Observer o) {
        subscribers.add(o);
    }

    @Override
    public void detach(Observer o) {
        subscribers.remove(o);
    }

    @Override
    public void notifyObservers(String message) {
        for (Observer o : subscribers) {
            o.update(message);
        }
    }

    public void uploadVideo(String title) {
        System.out.println("Channel uploaded a new video: " + title);
        notifyObservers("New video uploaded: " + title);
    }
}

ğŸ” Concrete Observers
class Subscriber implements Observer {
    private final String name;

    public Subscriber(String name) {
        this.name = name;
    }

    @Override
    public void update(String message) {
        System.out.println(name + " received notification â†’ " + message);
    }
}

ğŸ” Client
public class ObserverPatternDemo {
    public static void main(String[] args) {
        YouTubeChannel channel = new YouTubeChannel();

        Observer s1 = new Subscriber("Ankur");
        Observer s2 = new Subscriber("Isha");
        Observer s3 = new Subscriber("Deepak");

        channel.attach(s1);
        channel.attach(s2);
        channel.attach(s3);

        channel.uploadVideo("Design Patterns in Java");
    }
}

âœ… Output
Channel uploaded a new video: Design Patterns in Java
Ankur received notification â†’ New video uploaded: Design Patterns in Java
Isha received notification â†’ New video uploaded: Design Patterns in Java
Deepak received notification â†’ New video uploaded: Design Patterns in Java


ğŸ”„ Example in Java
Java provides the Observer pattern built-in (though deprecated since Java 9):

import java.util.Observable;
import java.util.Observer;

class NewsAgency extends Observable {
    void setNews(String news) {
        setChanged();
        notifyObservers(news);
    }
}

class NewsChannel implements Observer {
    private String news;

    public void update(Observable o, Object arg) {
        this.news = (String) arg;
        System.out.println("News Updated: " + news);
    }
}
Even though this approach is deprecated, itâ€™s the classic example of the pattern built into Java.

ğŸ”„ Spring Boot Example (Real-world Use Case)
Springâ€™s ApplicationEventPublisher and @EventListener mechanism is a perfect implementation of the Observer Pattern.

1ï¸âƒ£ Define a custom event
import org.springframework.context.ApplicationEvent;

public class UserRegisteredEvent extends ApplicationEvent {
    private final String username;

    public UserRegisteredEvent(Object source, String username) {
        super(source);
        this.username = username;
    }

    public String getUsername() {
        return username;
    }
}

2ï¸âƒ£ Publish the event
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.stereotype.Service;

@Service
public class UserService {
    @Autowired
    private ApplicationEventPublisher publisher;

    public void registerUser(String username) {
        System.out.println("Registering user: " + username);
        publisher.publishEvent(new UserRegisteredEvent(this, username));
    }
}

3ï¸âƒ£ Listen for the event
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Component;

@Component
public class EmailNotificationListener {

    @EventListener
    public void handleUserRegistered(UserRegisteredEvent event) {
        System.out.println("Sending welcome email to " + event.getUsername());
    }
}

âœ… Output
Registering user: Ankur
Sending welcome email to Ankur

ğŸ‘‰ Here:
â¤ UserService â†’ Subject
â¤ EmailNotificationListener â†’ Observer
â¤ Spring Event System â†’ Automatically handles notification and decoupling

ğŸ”„ Where to Use in Projects
âœ”ï¸ When multiple components depend on a single event source
âœ”ï¸ For event-driven architectures (e.g., Spring Event System, Kafka, RabbitMQ)
âœ”ï¸ For notification systems (email, logs, analytics)
âœ”ï¸ For GUI listeners (like ActionListener in Swing/JavaFX)
âœ”ï¸ For reactive programming (RxJava, Reactor)

ğŸ”„ Java Classes That Use Observer Pattern
java.util.Observer and java.util.Observable
javax.servlet.http.HttpSessionBindingListener
java.awt.event.ActionListener
Springâ€™s ApplicationEventPublisher and @EventListener

ğŸ”„ Advantages
Loose coupling between components
Easy to add/remove observers dynamically
Promotes event-driven system design

ğŸ”„ Disadvantages
Memory leaks if observers are not properly removed
Unexpected update sequences if too many observers
Can get complex when there are multiple chains of notifications


ğŸ”· Strategy Design Pattern
The Strategy Design Pattern defines a family of algorithms,
encapsulates each one, and makes them interchangeable.
The client can choose which strategy (algorithm) to use at runtime without changing the code that uses it.

ğŸ”„ Intent
â¤ To define a set of interchangeable behaviors (algorithms).
â¤ To decouple algorithms from the classes that use them.
â¤ To easily switch between different algorithms at runtime.

ğŸ”„ Real-World Analogy
Think of a payment system:
â¤ Payment can be done by Credit Card, PayPal, or UPI.
â¤ Each is a different strategy for processing payment.
â¤ The ShoppingCart class doesnâ€™t need to know how the payment is processed â€” it just calls the chosen strategy.

ğŸ”„ Structure
1ï¸âƒ£ Strategy (Interface) â€” declares a common interface for all supported algorithms.
2ï¸âƒ£ Concrete Strategies â€” implement different versions of the algorithm.
3ï¸âƒ£ Context â€” maintains a reference to a Strategy object and delegates the execution to it.

âœ… Java Example â€” Payment System
1ï¸âƒ£ Strategy Interface
interface PaymentStrategy {
    void pay(int amount);
}

2ï¸âƒ£ Concrete Strategies
class CreditCardPayment implements PaymentStrategy {
    @Override
    public void pay(int amount) {
        System.out.println("Paid â‚¹" + amount + " using Credit Card.");
    }
}

class PayPalPayment implements PaymentStrategy {
    @Override
    public void pay(int amount) {
        System.out.println("Paid â‚¹" + amount + " using PayPal.");
    }
}

class UPIPayment implements PaymentStrategy {
    @Override
    public void pay(int amount) {
        System.out.println("Paid â‚¹" + amount + " using UPI.");
    }
}

3ï¸âƒ£ Context Class
class ShoppingCart {
    private PaymentStrategy paymentStrategy;

    // Set strategy at runtime
    public void setPaymentStrategy(PaymentStrategy paymentStrategy) {
        this.paymentStrategy = paymentStrategy;
    }

    public void checkout(int amount) {
        if (paymentStrategy == null) {
            throw new IllegalStateException("Payment method not set!");
        }
        paymentStrategy.pay(amount);
    }
}

4ï¸âƒ£ Client Code
public class StrategyPatternDemo {
    public static void main(String[] args) {
        ShoppingCart cart = new ShoppingCart();

        cart.setPaymentStrategy(new CreditCardPayment());
        cart.checkout(500);

        cart.setPaymentStrategy(new UPIPayment());
        cart.checkout(250);
    }
}
âœ… Output
Paid â‚¹500 using Credit Card.
Paid â‚¹250 using UPI.


ğŸ”„ In Java Frameworks
âœ”ï¸ The Strategy Pattern is used heavily inside the Java and Spring frameworks.

âœ… Java Examples
âœ”ï¸ java.util.Comparator â€” you pass a comparator (strategy) to sort data differently.

Collections.sort(list, Comparator.comparing(Student::getName));

âœ”ï¸ Here, different comparators = different sorting strategies.
âœ”ï¸ javax.servlet.http.HttpServlet â€” doGet(), doPost(), etc. act as different strategies for handling requests.

âœ… Spring Boot Example
Spring uses the Strategy pattern extensively â€” especially for:
âœ”ï¸ ResourceResolvers
âœ”ï¸ CacheStrategies
âœ”ï¸ DataSource selection
âœ”ï¸ AuthenticationProvider (Spring Security)
âœ”ï¸ ViewResolver, MessageConverter, etc.

ğŸ‘‰ Letâ€™s see a simple Spring Boot Strategy Example ğŸ‘‡
ğŸ”„ Payment Strategy in Spring
1ï¸âƒ£ Define the strategy interface
public interface PaymentStrategy {
    void pay(double amount);
}

2ï¸âƒ£ Implement concrete strategies
import org.springframework.stereotype.Component;

@Component("creditCard")
public class CreditCardPayment implements PaymentStrategy {
    public void pay(double amount) {
        System.out.println("Paid â‚¹" + amount + " using Credit Card.");
    }
}

@Component("upi")
public class UPIPayment implements PaymentStrategy {
    public void pay(double amount) {
        System.out.println("Paid â‚¹" + amount + " using UPI.");
    }
}

3ï¸âƒ£ Context class (using Spring to inject the strategy)
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;

@Service
public class PaymentService {
    private final PaymentStrategy paymentStrategy;

    @Autowired
    public PaymentService(@Qualifier("upi") PaymentStrategy paymentStrategy) {
        this.paymentStrategy = paymentStrategy;
    }

    public void processPayment(double amount) {
        paymentStrategy.pay(amount);
    }
}

4ï¸âƒ£ Controller or main class
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class StrategyPatternApp implements CommandLineRunner {
    @Autowired
    private PaymentService paymentService;

    public static void main(String[] args) {
        SpringApplication.run(StrategyPatternApp.class, args);
    }

    @Override
    public void run(String... args) {
        paymentService.processPayment(1000);
    }
}
âœ… Output
Paid â‚¹1000 using UPI.


ğŸ”„ Where to Use in Projects
â¤ When multiple algorithms can perform the same task (e.g., sorting, payment, compression, authentication).
â¤ When algorithms may change independently of the client.
â¤ When you want to choose behavior at runtime.
â¤ When you want to eliminate large if-else or switch statements.

ğŸ”„ Java Classes That Use Strategy Pattern
| Class                            | Strategy Used             |
| -------------------------------- | ------------------------- |
| `java.util.Comparator`           | Sorting strategy          |
| `javax.servlet.http.HttpServlet` | Request handling strategy |
| `java.util.zip.Deflater`         | Compression strategy      |
| `Spring AuthenticationProvider`  | Authentication strategy   |


ğŸ”„ Advantages
â¤ Promotes Open/Closed Principle (add new strategies without modifying context).
â¤ Simplifies code by removing complex conditional logic.
â¤ Allows dynamic behavior change at runtime.
â¤ Easy to unit test each strategy independently.

ğŸ”„ Disadvantages
â¤ Increases the number of classes.
â¤ Client must know which strategy to choose.
â¤ Can become overkill if there are very few variations.


ğŸ”· Template Design Pattern
The Template Method Pattern defines the skeleton (blueprint) of an algorithm in a base (abstract) class but lets subclasses override specific steps of the algorithm without changing its structure.

It promotes code reuse and inversion of control â€” the base class controls the overall process, and subclasses fill in the details.


ğŸ”„ Structure
1ï¸âƒ£ Abstract Class (Template)
âœ”ï¸ Defines the template method (final method) which outlines steps of an algorithm.
âœ”ï¸ Implements common steps.
âœ”ï¸ Declares abstract methods for steps that subclasses must implement.

2ï¸âƒ£ Concrete Subclasses
âœ”ï¸ Implement the abstract steps defined by the template class.  


âœ… Java Example: Template Method Pattern in Java
Weâ€™ll take an example of building a house â€” every house has a standard build process, but details differ for wooden and concrete houses.

1ï¸âƒ£ Create the Abstract Template Class
abstract class HouseTemplate {

    ğŸ‘‰ template method (final to prevent overriding)
    public final void buildHouse() {
        buildFoundation();
        buildPillars();
        buildWalls();
        buildWindows();
        System.out.println("House construction completed.\n");
    }

    private void buildFoundation() {
        System.out.println("Building foundation with cement, iron rods, and sand");
    }

    ğŸ‘‰ abstract methods to be implemented by subclasses
    protected abstract void buildPillars();
    protected abstract void buildWalls();

    private void buildWindows() {
        System.out.println("Building Glass Windows");
    }
}

2ï¸âƒ£ Create Concrete Implementations
class WoodenHouse extends HouseTemplate {
    @Override
    protected void buildPillars() {
        System.out.println("Building Pillars with Wood coating");
    }

    @Override
    protected void buildWalls() {
        System.out.println("Building Wooden Walls");
    }
}

class ConcreteHouse extends HouseTemplate {
    @Override
    protected void buildPillars() {
        System.out.println("Building Pillars with Cement and Iron");
    }

    @Override
    protected void buildWalls() {
        System.out.println("Building Concrete Walls");
    }
}

3ï¸âƒ£ Client Code
public class TemplatePatternDemo {
    public static void main(String[] args) {
        HouseTemplate houseType = new WoodenHouse();
        System.out.println("Building Wooden House...");
        houseType.buildHouse();

        houseType = new ConcreteHouse();
        System.out.println("Building Concrete House...");
        houseType.buildHouse();
    }
}

âœ… Output
Building Wooden House...
Building foundation with cement, iron rods, and sand
Building Pillars with Wood coating
Building Wooden Walls
Building Glass Windows
House construction completed.

Building Concrete House...
Building foundation with cement, iron rods, and sand
Building Pillars with Cement and Iron
Building Concrete Walls
Building Glass Windows
House construction completed.

ğŸ”„ Real-Life Example in Java & Spring
âœ… In Java:
java.util.AbstractList, java.util.AbstractSet, java.util.AbstractMap â€”

ğŸ‘‰ They provide partial implementations and let subclasses define specific behavior.

âœ… Example:
public abstract class AbstractList<E> implements List<E> {
    public boolean add(E e) {
        add(size(), e);  // Template method
        return true;
    }
    public abstract void add(int index, E element);
}
ğŸ‘‰ Here, add(E e) is a template method, and subclasses like ArrayList define add(int index, E element).

ğŸ”„ In Spring Framework:
Spring uses Template Pattern heavily in multiple places, for example:
â¤ JdbcTemplate, RestTemplate, JpaTemplate, etc.
These templates define the workflow of database or REST operations, while users provide specific callback implementations (like RowMapper, ResponseExtractor).

âœ… Example:
jdbcTemplate.query("SELECT * FROM users", new RowMapper<User>() {
    public User mapRow(ResultSet rs, int rowNum) throws SQLException {
        return new User(rs.getString("name"), rs.getInt("age"));
    }
});
ğŸ‘‰ Here, JdbcTemplate defines the template method, and you only fill in the variable part (how to map rows).

ğŸ§° Where to Use
â¤ When you want to define the skeleton of an algorithm once and let subclasses customize steps.
â¤ When you want consistent workflow but flexible implementation for certain parts.

ğŸ”„ Advantages
âœ”ï¸ Code reuse â€” common logic in one place.
âœ”ï¸ Control algorithm steps order.
âœ”ï¸ Enforces consistency across subclasses.

ğŸ”„ Disadvantages
âœ”ï¸ Tight coupling between base and subclasses.
âœ”ï¸ Hard to modify the flow dynamically at runtime.


ğŸ”· Momento Design Pattern
The Memento Pattern allows an object to capture its internal state and restore it later, without violating encapsulation.

It involves three main roles:
1ï¸âƒ£ Originator â€“ the object whose state needs to be saved/restored.
2ï¸âƒ£ Memento â€“ the object that stores the snapshot of the originatorâ€™s state.
3ï¸âƒ£ Caretaker â€“ manages saving and restoring mementos but doesnâ€™t modify them.

Think of it like Ctrl+Z (Undo) in text editors:
The editor = Originator
Snapshot = Memento
Undo stack = Caretaker

ğŸ”„ Structure
Originator -----> Memento
     ^
     |
Caretaker

â¤ Originator creates a Memento containing its current state and uses it to restore state later.
â¤ Caretaker stores Mementos but never modifies their contents.

âœ… Java Example: Text Editor Undo
1ï¸âƒ£ Memento Class
// Memento
public class TextEditorMemento {
    private final String content;

    public TextEditorMemento(String content) {
        this.content = content;
    }

    public String getContent() {
        return content;
    }
}

2ï¸âƒ£ Originator Class
// Originator
public class TextEditor {
    private String content = "";

    public void type(String words) {
        content += words;
    }

    public String getContent() {
        return content;
    }

    public TextEditorMemento save() {
        return new TextEditorMemento(content); // snapshot
    }

    public void restore(TextEditorMemento memento) {
        content = memento.getContent(); // restore snapshot
    }
}

3ï¸âƒ£ Caretaker Class
import java.util.ArrayList;
import java.util.List;

public class Caretaker {
    private List<TextEditorMemento> history = new ArrayList<>();

    public void addMemento(TextEditorMemento memento) {
        history.add(memento);
    }

    public TextEditorMemento getMemento(int index) {
        return history.get(index);
    }
}

4ï¸âƒ£ Client Code
public class MementoPatternDemo {
    public static void main(String[] args) {
        TextEditor editor = new TextEditor();
        Caretaker caretaker = new Caretaker();

        editor.type("Hello ");
        caretaker.addMemento(editor.save());

        editor.type("World!");
        caretaker.addMemento(editor.save());

        System.out.println("Current Content: " + editor.getContent());

        // Undo last action
        editor.restore(caretaker.getMemento(0));
        System.out.println("After Undo: " + editor.getContent());
    }
}

âœ… Output
Current Content: Hello World!
After Undo: Hello 

ğŸ§  Real-Life Examples in Java & Spring
1ï¸âƒ£ Java
java.util.Date and java.util.Calendar allow snapshots of state (conceptually similar).
JTextComponent in Swing uses UndoManager which internally follows Memento pattern.

2ï¸âƒ£ Spring Boot
Versioning of entity states or rollback operations can use Memento-like logic.

âœ… Example: Implementing an undo feature in a form:
â¤ Save snapshots of DTOs in memory or DB.
â¤ Restore previous state on user request.

âš–ï¸ Advantages
â¤ Encapsulates object state without exposing internal structure.
â¤ Enables undo/redo functionality.
â¤ Supports versioning or rollback mechanisms.

ğŸš« Disadvantages
âŒ Can consume large memory if many snapshots are stored.
âŒ Overhead if object state is large or complex.
âŒ Complexity increases if deep copying is required for nested objects.


#########################
ğŸ”· State Design Pattern
#########################
The State Design Pattern allows an object to change its behavior when its internal state changes.
It looks like the object changed its class dynamically.

â¡ You encapsulate different states into different classes.
â¡ The object delegates behaviors to the current state object.

ğŸ”„ What Problem Does It Solveâ“
Problem: Lots of if-else or switch logic
âœ… Example: Order can be in states:
âœ”ï¸ NEW
âœ”ï¸ PACKED
âœ”ï¸ SHIPPED
âœ”ï¸ DELIVERED
âœ”ï¸ CANCELLED

Typical bad code:
if (orderStatus.equals("NEW")) { ... }
else if (orderStatus.equals("PACKED")) { ... }
else if (orderStatus.equals("SHIPPED")) { ... }
...

âŒ Hard to maintain
âŒ Hard to extend
âŒ Violates Open/Closed Principle
âŒ All logic lives inside one massive class

ğŸ”„ State Pattern Does
It breaks each state into its own class.

Order
  |
  ---> NEW State (NewOrderState)
  ---> PACKED State (PackedState)
  ---> SHIPPED State (ShippedState)
  ---> DELIVERED State (DeliveredState)

Each state knows:
What it should do
What the next state can be

ğŸ”„ When To Use 
Use State Pattern when:
âœ”ï¸ Object needs to behave differently in different phases
âœ”ï¸ Object transitions between states
âœ”ï¸ You want to avoid if/else chains
âœ”ï¸ States have independent, evolving logic
âœ”ï¸ Workflow automation
âœ”ï¸ Stateful machines

âœ… Real world examples:
âœ”ï¸ Order workflow (order states)
âœ”ï¸ ATM machine (insert card â†’ enter PIN â†’ withdraw)
âœ”ï¸ Payment processing
âœ”ï¸ Traffic light system
âœ”ï¸ Document workflow (Draft â†’ Review â†’ Approved â†’ Published)


ğŸ”„ 5. UML Diagram (Simple)
          State (interface)
        /        |        \
   NewState  PackedState  ShippedState  ...
           â†‘
         Context (e.g., Order)
ğŸ‘‰ Context delegates behavior to current state.


ğŸ”„ 6. Real-Life Example in Java: Order Processing Workflow
Letâ€™s create a State Pattern for E-commerce Order.

ğŸŸ© Step 1ï¸âƒ£: State Interface
public interface OrderState {
    void next(OrderContext context);
    void prev(OrderContext context);
    String getStatus();
}

ğŸŸ© Step 2ï¸âƒ£: Create Concrete States
ğŸ” NEW â†’ PACKED
public class NewOrderState implements OrderState {

    @Override
    public void next(OrderContext context) {
        context.setState(new PackedState());
    }

    @Override
    public void prev(OrderContext context) {
        System.out.println("This is the first state. No previous state.");
    }

    @Override
    public String getStatus() {
        return "Order is in NEW state.";
    }
}

ğŸ” PACKED â†’ SHIPPED
public class PackedState implements OrderState {

    @Override
    public void next(OrderContext context) {
        context.setState(new ShippedState());
    }

    @Override
    public void prev(OrderContext context) {
        context.setState(new NewOrderState());
    }

    @Override
    public String getStatus() {
        return "Order is PACKED.";
    }
}

ğŸ” SHIPPED â†’ DELIVERED
public class ShippedState implements OrderState {

    @Override
    public void next(OrderContext context) {
        context.setState(new DeliveredState());
    }

    @Override
    public void prev(OrderContext context) {
        context.setState(new PackedState());
    }

    @Override
    public String getStatus() {
        return "Order is SHIPPED.";
    }
}

ğŸ” DELIVERED (Final State)
public class DeliveredState implements OrderState {

    @Override
    public void next(OrderContext context) {
        System.out.println("This is the final state. No next state.");
    }

    @Override
    public void prev(OrderContext context) {
        context.setState(new ShippedState());
    }

    @Override
    public String getStatus() {
        return "Order is DELIVERED.";
    }
}

ğŸŸ© Step 3ï¸âƒ£: Context Class
public class OrderContext {

    private OrderState state;

    public OrderContext() {
        this.state = new NewOrderState();   // default state
    }

    public void setState(OrderState state) {
        this.state = state;
    }

    public void nextState() {
        state.next(this);
    }

    public void previousState() {
        state.prev(this);
    }

    public String getStatus() {
        return state.getStatus();
    }
}

ğŸŸ© Step 4ï¸âƒ£: Using It
public class Main {
    public static void main(String[] args) {
        
        OrderContext order = new OrderContext();

        System.out.println(order.getStatus());  
        order.nextState();

        System.out.println(order.getStatus());  
        order.nextState();

        System.out.println(order.getStatus());  
        order.nextState();

        System.out.println(order.getStatus());
    }
}

âœ… Output:
Order is in NEW state.
Order is PACKED.
Order is SHIPPED.
Order is DELIVERED.

ğŸ”„ 7. Real Spring Boot Use Case (Production Grade)
A very common real-world project using State Pattern:
âœ”ï¸ Order State Workflow in Microservices
âœ”ï¸ (E-commerce, pharmacy, hospital, ticket booking)

Spring Boot code structure:

/states
   |- NewState
   |- PackedState
   |- ShippedState
   |- DeliveredState
/context
   |- OrderContext
/controller
   |- OrderController
/service
   |- OrderService
/entity
   |- OrderEntity

State transitions can be saved in DB:
âœ”ï¸ state = NEW
âœ”ï¸ state = PACKED
âœ”ï¸ state = SHIPPED

This is extremely useful in:
âœ”ï¸ Saga pattern
âœ”ï¸ Workflow engines
âœ”ï¸ State machines
âœ”ï¸ Payment gateways
âœ”ï¸ Microservice orchestration

ğŸ”„ Advantages of State Pattern
â¤ Removes complex if-else
â¤ Easy to extend new states
â¤ Better separation of concerns
â¤ Follows Open/Closed Principle
â¤ Cleaner workflow management

ğŸ”„ Disadvantages
â¤ More classes â†’ more boilerplate
â¤ Overkill for simple state transitions
â¤ Harder debugging if too many states


###########################
ğŸ”· Command Design Pattern
###########################
The Command Pattern is a behavioral design pattern that turns a request into a standalone object (Command object).
This allows you to parameterize methods with commands, queue or log requests, undo operations, and support macro operations.

â¡ In simple terms: It encapsulates â€œwhat needs to be doneâ€ inside an object.

ğŸ”„ Why is Command Pattern needed? 
âŒ Problems Without Command Pattern
â¤ Code becomes large if many operations are needed.
â¤ Hard-coded function calls â†’ no flexibility.
â¤ Cannot support undo/redo.
â¤ Cannot queue, delay, or log operations.
â¤ UI handlers tightly coupled with logic.

ğŸ”„ Command Pattern Solves This
â¤ Encapsulates each request into a Command object.
â¤ Loose coupling between requester (invoker) and performer (receiver).
â¤ Can queue commands, log commands, and undo/redo commands.
â¤ Supports macro commands (execute many commands in sequence).

ğŸ”„ Real-Life Examples
â¤ Remote control system: Buttons â†’ Commands.
â¤ GUI buttons (IDE, Photoshop): Save, Undo, Redo.
â¤ Database transaction queue: Insert, Update, Delete commands.
â¤ Message queues: Commands stored and executed later.
â¤ Microservices command queue: CQRS (Command Query Responsibility Segregation).

ğŸ”„ Core Components
| Component               | Role                                 |
| ----------------------- | ------------------------------------ |
| Command (interface)**   | Declares `execute()`                 |
| ConcreteCommand**       | Implements the action                |
| Receiver**              | The actual executor (business logic) |
| Invoker**               | Triggers the command                 |
| Client**                | Instantiates command & invoker       |

ğŸ”„ UML Diagram
Client ---> ConcreteCommand ---> Receiver
              ^
              |
           Command
              |
           Invoker ---> execute()

ğŸ”„ Simple Java Example 
1ï¸âƒ£: Command Interface
interface Command {
    void execute();
}

2ï¸âƒ£: Receiver (actual business logic)
class Light {
    public void turnOn() {
        System.out.println("Light is ON");
    }
    public void turnOff() {
        System.out.println("Light is OFF");
    }
}

3ï¸âƒ£: Concrete Commands
class TurnOnCommand implements Command {
    private Light light;

    public TurnOnCommand(Light light) {
        this.light = light;
    }

    @Override
    public void execute() {
        light.turnOn();
    }
}

class TurnOffCommand implements Command {
    private Light light;

    public TurnOffCommand(Light light) {
        this.light = light;
    }

    @Override
    public void execute() {
        light.turnOff();
    }
}

4ï¸âƒ£: Invoker
class RemoteControl {
    private Command command;

    public void setCommand(Command command) {
        this.command = command;
    }
    public void pressButton() {
        command.execute();
    }
}

5ï¸âƒ£: Client
public class Main {
    public static void main(String[] args) {
        Light light = new Light();

        RemoteControl remote = new RemoteControl();

        remote.setCommand(new TurnOnCommand(light));
        remote.pressButton();

        remote.setCommand(new TurnOffCommand(light));
        remote.pressButton();
    }
}

ğŸŸ¦ Command Pattern in Order Processing System
Use Case:
You have an e-commerce system with commands:
CreateOrderCommand
CancelOrderCommand
ShipOrderCommand

1ï¸âƒ£: Command Interface
public interface OrderCommand {
    void execute();
}

2ï¸âƒ£: Receiver (Service Layer)
@Service
public class OrderService {

    public void createOrder(Long id) {
        System.out.println("Order created: " + id);
    }

    public void cancelOrder(Long id) {
        System.out.println("Order cancelled: " + id);
    }

    public void shipOrder(Long id) {
        System.out.println("Order shipped: " + id);
    }
}

3ï¸âƒ£: Concrete Commands
public class CreateOrderCommand implements OrderCommand {
    private final OrderService orderService;
    private final Long orderId;

    public CreateOrderCommand(OrderService orderService, Long orderId) {
        this.orderService = orderService;
        this.orderId = orderId;
    }

    @Override
    public void execute() {
        orderService.createOrder(orderId);
    }
}

public class CancelOrderCommand implements OrderCommand {
    private final OrderService orderService;
    private final Long orderId;

    public CancelOrderCommand(OrderService orderService, Long orderId) {
        this.orderService = orderService;
        this.orderId = orderId;
    }

    @Override
    public void execute() {
        orderService.cancelOrder(orderId);
    }
}

public class ShipOrderCommand implements OrderCommand {
    private final OrderService orderService;
    private final Long orderId;

    public ShipOrderCommand(OrderService orderService, Long orderId) {
        this.orderService = orderService;
        this.orderId = orderId;
    }

    @Override
    public void execute() {
        orderService.shipOrder(orderId);
    }
}

4ï¸âƒ£ Invoker
@Component
public class OrderInvoker {

    public void executeCommand(OrderCommand command) {
        command.execute();
    }
}

5ï¸âƒ£ Controller (Client)
@RestController
@RequestMapping("/orders")
public class OrderController {

    private final OrderService orderService;
    private final OrderInvoker invoker;

    public OrderController(OrderService orderService, OrderInvoker invoker) {
        this.orderService = orderService;
        this.invoker = invoker;
    }

    @PostMapping("/{id}/create")
    public String createOrder(@PathVariable Long id) {
        invoker.executeCommand(new CreateOrderCommand(orderService, id));
        return "Order Created!";
    }

    @PostMapping("/{id}/cancel")
    public String cancelOrder(@PathVariable Long id) {
        invoker.executeCommand(new CancelOrderCommand(orderService, id));
        return "Order Cancelled!";
    }

    @PostMapping("/{id}/ship")
    public String shipOrder(@PathVariable Long id) {
        invoker.executeCommand(new ShipOrderCommand(orderService, id));
        return "Order Shipped!";
    }
}


âœ”ï¸ Advantages of Command Pattern
â¤ Decouples invoker & receiver.
â¤ Easy to add new commands.
â¤ Supports undo/redo.
â¤ Can queue, log, schedule commands.
â¤ Enables macro commands.

âœ”ï¸ Disadvantages
â¤ Increase in classes (each command is a new class).
â¤ Overkill if simple function calls suffice.

âœ”ï¸ When to Use (very important for interviews)
When you need:
â¤ Operations as objects.
â¤ Undo/redo support.
â¤ Logging or queueing tasks.
â¤ Decoupled UI actions from business logic.
â¤ Macro operations.


Command ğŸ†š Strategy ğŸ†š State ğŸ†š Observer
Command vs Adapter
| Attribute | Command               | Adapter                          |
| --------- | --------------------- | -------------------------------- |
| Purpose   | Encapsulate a request | Convert interface A to B         |
| Usage     | Undo, Queues, Macros  | When two incompatible interfaces |
| Focus     | Actions               | Interfaces                       |

Command vs Strategy
Strategy selects HOW to do something.
Command represents WHAT action to execute.

Command vs State
State changes behavior based on internal state.
Command is a request wrapped as an object.

Command vs Observer
Observer notifies subscribers.
Command encapsulates an action.
âœ…
ğŸ”„
ğŸ”„
ğŸ”„
ğŸ”„
ğŸ”„
ğŸ”„
ğŸ”„
