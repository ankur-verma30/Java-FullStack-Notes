ğŸ”· Decorator Pattern
The Decorator pattern allows you to dynamically add new behavior or responsibilities to an object without modifying its existing code.

ğŸ‘‰ Purpose:
To extend the functionality of objects at runtime, not at compile time â€” unlike inheritance. 

ğŸ”„ Real-World Analogy

Think of a coffee shop â˜•:
â¤ You start with a plain coffee.
â¤ Then you can add milk, sugar, or cream â€” each decorator adds extra behavior (cost + description).

You didnâ€™t modify the base coffee class â€” you just wrapped it!


ğŸ”„ Structure
â¤ Component (Interface): Defines the base behavior.
â¤ Concrete Component: The original object that we decorate.
â¤ Decorator (Abstract Class): Holds a reference to the component and delegates operations to it.
â¤ Concrete Decorators: Add new behavior around the base component.

âœ… Example:
Coffee Order System
1ï¸âƒ£ Component
interface Coffee {
    String getDescription();
    double getCost();
}

2ï¸âƒ£ Concrete Component
class BasicCoffee implements Coffee {
    @Override
    public String getDescription() {
        return "Basic Coffee";
    }

    @Override
    public double getCost() {
        return 50;
    }
}

3ï¸âƒ£ Abstract Decorator
abstract class CoffeeDecorator implements Coffee {
    protected Coffee decoratedCoffee;

    public CoffeeDecorator(Coffee decoratedCoffee) {
        this.decoratedCoffee = decoratedCoffee;
    }

    public String getDescription() {
        return decoratedCoffee.getDescription();
    }

    public double getCost() {
        return decoratedCoffee.getCost();
    }
}

4ï¸âƒ£ Concrete Decorators
class MilkDecorator extends CoffeeDecorator {
    public MilkDecorator(Coffee coffee) {
        super(coffee);
    }

    public String getDescription() {
        return super.getDescription() + ", Milk";
    }

    public double getCost() {
        return super.getCost() + 10;
    }
}

class SugarDecorator extends CoffeeDecorator {
    public SugarDecorator(Coffee coffee) {
        super(coffee);
    }

    public String getDescription() {
        return super.getDescription() + ", Sugar";
    }

    public double getCost() {
        return super.getCost() + 5;
    }
}

class CreamDecorator extends CoffeeDecorator {
    public CreamDecorator(Coffee coffee) {
        super(coffee);
    }

    public String getDescription() {
        return super.getDescription() + ", Cream";
    }

    public double getCost() {
        return super.getCost() + 15;
    }
}

5ï¸âƒ£ Client
public class DecoratorPatternDemo {
    public static void main(String[] args) {
        Coffee coffee = new BasicCoffee();                     // Base
        coffee = new MilkDecorator(coffee);                    // Add milk
        coffee = new SugarDecorator(coffee);                   // Add sugar
        coffee = new CreamDecorator(coffee);                   // Add cream

        System.out.println("Order: " + coffee.getDescription());
        System.out.println("Total Cost: â‚¹" + coffee.getCost());
    }
}
âœ… Output
Order: Basic Coffee, Milk, Sugar, Cream
Total Cost: â‚¹80.0

ğŸ”„ Where Used in Java
| Class                                          | Decorator Role                        |
| ---------------------------------------------- | ------------------------------------- |
| `java.io.BufferedReader`                       | Decorates `Reader`                    |
| `java.io.DataInputStream`                      | Decorates `InputStream`               |
| `java.util.Collections.synchronizedList()`     | Returns a decorated version of a List |
| `javax.servlet.http.HttpServletRequestWrapper` | Decorates a servlet request           |

ğŸ”„ Spring Boot 
In Spring Boot, Decorator pattern is commonly seen when adding behavior to Beans or Services dynamically.


âœ… Example: Logging Decorator for a Payment Service
1ï¸âƒ£ Component
public interface PaymentService {
    void pay(double amount);
}

2ï¸âƒ£ Concrete Component
@Service
class BasicPaymentService implements PaymentService {
    public void pay(double amount) {
        System.out.println("Processing payment of â‚¹" + amount);
    }
}

3ï¸âƒ£ Decorator
@Service
@Primary  // ensures this bean is used when autowired
class LoggingPaymentDecorator implements PaymentService {
    private final PaymentService paymentService;

    public LoggingPaymentDecorator(BasicPaymentService paymentService) {
        this.paymentService = paymentService;
    }

    @Override
    public void pay(double amount) {
        System.out.println("Logging: Payment started...");
        paymentService.pay(amount);
        System.out.println("Logging: Payment completed successfully.");
    }
}


ğŸ‘‰ Usage in Controller:
@RestController
public class PaymentController {
    private final PaymentService paymentService;

    public PaymentController(PaymentService paymentService) {
        this.paymentService = paymentService;
    }

    @PostMapping("/pay")
    public String pay(@RequestParam double amount) {
        paymentService.pay(amount);
        return "Payment Successful";
    }
}
ğŸ‘‰ This dynamically adds logging behavior without changing the original BasicPaymentService.


Decorator ğŸ†š Inheritance
| Aspect                | Decorator           | Inheritance              |
| --------------------- | ------------------- | ------------------------ |
| Flexibility           | âœ… Runtime extension | âŒ Compile-time extension |
| Class explosion       | âŒ Reduced           | âœ… Increases              |
| Open/Closed Principle | âœ… Respected         | âŒ Often violated         |
| Multiple Behaviors    | âœ… Easy to combine   | âŒ Harder to combine      |


ğŸ”„ Where to Use in Projects
â¤ Add logging, caching, security, validation, metrics to services dynamically.
â¤ Add response formatting or data enrichment in REST APIs.
â¤ Wrap repository/service beans for AOP-like behavior without using aspects.
â¤ Wrap HttpServletRequest or HttpResponse objects.

ğŸ”„ Advantages
Adds new behavior without modifying existing code (Open/Closed Principle).
Can combine multiple decorators flexibly.
Promotes composition over inheritance.

ğŸ”„ Disadvantages
Increases number of small objects.
Can become hard to debug if too many decorators wrap each other.
Order of decorators matters.

 
ğŸ”· Adapter Design Pattern
â¤ The Adapter pattern allows two incompatible interfaces to work together.
â¤ It acts as a bridge between a client expecting one type of interface and a class having a different interface.

ğŸ‘‰ Purpose:
To make incompatible classes compatible without changing their source code.

ğŸ”„ Real-world Analogy
â¤ Think of a mobile charger adapter ğŸ”Œ:
â¤ Your phone expects a Type-C port.
â¤ But the wall socket is AC power.
â¤ The charger adapter converts AC â†’ DC (interface translation).

Similarly, the Adapter pattern converts one interface into another expected by the client.

âš™ï¸ Structure
Target Interface: The interface the client expects to use.
Adaptee: The existing class with an incompatible interface.
Adapter: A class that bridges the gap by implementing the Target and internally using the Adaptee.
Client: Uses the Target interface to interact with the Adaptee indirectly.

âœ… Java Example: Media Player
1ï¸âƒ£ Target Interface
interface MediaPlayer {
    void play(String audioType, String fileName);
}

2ï¸âƒ£ Adaptee
class AdvancedMediaPlayer {
    public void playVlc(String fileName) {
        System.out.println("Playing vlc file: " + fileName);
    }
    public void playMp4(String fileName) {
        System.out.println("Playing mp4 file: " + fileName);
    }
}

3ï¸âƒ£ Adapter
class MediaAdapter implements MediaPlayer {
    private AdvancedMediaPlayer advancedMediaPlayer = new AdvancedMediaPlayer();

    @Override
    public void play(String audioType, String fileName) {
        if (audioType.equalsIgnoreCase("vlc")) {
            advancedMediaPlayer.playVlc(fileName);
        } else if (audioType.equalsIgnoreCase("mp4")) {
            advancedMediaPlayer.playMp4(fileName);
        }
    }
}

4ï¸âƒ£ Concrete Target Implementation (using Adapter)
class AudioPlayer implements MediaPlayer {
    private MediaAdapter mediaAdapter;

    @Override
    public void play(String audioType, String fileName) {
        if (audioType.equalsIgnoreCase("mp3")) {
            System.out.println("Playing mp3 file: " + fileName);
        } else if (audioType.equalsIgnoreCase("vlc") || audioType.equalsIgnoreCase("mp4")) {
            mediaAdapter = new MediaAdapter();
            mediaAdapter.play(audioType, fileName);
        } else {
            System.out.println("Invalid media type: " + audioType);
        }
    }
}

5ï¸âƒ£ Client
public class AdapterPatternDemo {
    public static void main(String[] args) {
        AudioPlayer player = new AudioPlayer();
        player.play("mp3", "song1.mp3");
        player.play("mp4", "movie.mp4");
        player.play("vlc", "video.vlc");
        player.play("avi", "old.avi");
    }
}

âœ… Output
Playing mp3 file: song1.mp3
Playing mp4 file: movie.mp4
Playing vlc file: video.vlc
Invalid media type: avi


ğŸ”„ Where Used in Java
| Java API                                                            | Role                                  |
| ------------------------------------------------------------------- | ------------------------------------- |
| `java.util.Arrays#asList()`                                         | Adapts arrays â†’ List                  |
| `java.io.InputStreamReader`                                         | Adapts `InputStream` â†’ `Reader`       |
| `java.io.OutputStreamWriter`                                        | Adapts `OutputStream` â†’ `Writer`      |
| `java.util.Enumeration` â†’ `Iterator` adapter (`Collections.list()`) |                                       |
| `javax.xml.bind.annotation.adapters.XmlAdapter`                     | Converts between XML and Java objects |


âœ… Example:
Reader reader = new InputStreamReader(new FileInputStream("file.txt"));
ğŸ‘‰ InputStreamReader acts as an Adapter between byte streams and character streams.

ğŸ”„ Spring Boot 
In Spring, adapters are used extensively for integration between different interfaces.

âœ… Example 1: HandlerAdapter in Spring MVC
Spring MVC uses the Adapter pattern internally to allow different types of controllers to be processed uniformly.

â¤ DispatcherServlet doesnâ€™t know about specific controller types.
â¤ It uses a HandlerAdapter to adapt each controller type into a standard format.

public interface HandlerAdapter {
    boolean supports(Object handler);
    ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler);
}
âœ… Example:
â¤ SimpleControllerHandlerAdapter adapts Controller interface-based controllers.
â¤ RequestMappingHandlerAdapter adapts @RequestMapping annotated controllers.
So Spring Boot internally uses the Adapter pattern to make DispatcherServlet independent of controller types.


âœ… Example 2: Custom Adapter in a Project
Suppose your app needs to integrate with two payment APIs (different formats).
You can use the Adapter pattern to unify them.

1ï¸âƒ£ Target
public interface PaymentGateway {
    void pay(double amount);
}

2ï¸âƒ£ Adaptee 1 - Razorpay API
class RazorpayAPI {
    public void makePayment(double amount) {
        System.out.println("Payment of â‚¹" + amount + " done via Razorpay.");
    }
}

3ï¸âƒ£ Adapter
@Component
class RazorpayAdapter implements PaymentGateway {
    private final RazorpayAPI razorpayAPI = new RazorpayAPI();

    @Override
    public void pay(double amount) {
        razorpayAPI.makePayment(amount);
    }
}

4ï¸âƒ£ Service using Target interface
@Service
public class PaymentService {
    private final PaymentGateway paymentGateway;

    @Autowired
    public PaymentService(PaymentGateway paymentGateway) {
        this.paymentGateway = paymentGateway;
    }

    public void processPayment(double amount) {
        paymentGateway.pay(amount);
    }
}
âœ… This approach lets you easily switch adapters (e.g., Stripe, PayPal) without changing service logic.


ğŸ”„ Adapter ğŸ†š Decorator vs Bridge
| Pattern       | Purpose                                  | Example             |
| ------------- | ---------------------------------------- | ------------------- |
| **Adapter**   | Convert one interface to another         | `InputStreamReader` |
| **Decorator** | Add new behavior dynamically             | `BufferedReader`    |
| **Bridge**    | Separate abstraction from implementation | JDBC Drivers        |


ğŸ”„ Where to Use in Projects
âœ”ï¸ When integrating legacy systems with new APIs
âœ”ï¸ When using third-party libraries that donâ€™t match your app interface
âœ”ï¸ When you want to reuse existing classes without modifying them
âœ”ï¸ When standardizing APIs (e.g., multiple payment or messaging gateways)


ğŸ”„ Advantages
â¤ Promotes code reusability (no need to rewrite incompatible classes).
â¤ Enables integration between legacy and new systems.
â¤ Follows Open/Closed Principle â€” no modification to existing classes.

ğŸ”„ Disadvantages
â¤ Adds extra layers (slight performance overhead).
â¤ Can become complex if overused.
â¤ Adapter logic might hide real implementation details.


ğŸ”„ Adapter = Backward Compatibility Layer
ğŸ‘‰ Purpose Recap:
The Adapter Pattern acts as a bridge between two incompatible interfaces â€”
it lets old code work with new code (or vice versa) without modifying existing logic.


ğŸ”„ How It Enables Backward Compatibility
Imagine a scenario:

â¤ You have old client code using interface OldPaymentGateway.
â¤ A new system introduces NewPaymentGateway, which works differently.
â¤ You canâ€™t change all existing client code â€” itâ€™s already in production.

âœ… Solution:
You create an Adapter that implements the OldPaymentGateway interface but internally calls the NewPaymentGateway.

So â€”
The adapter acts as a translator between old and new interfaces, ensuring that older clients can continue working even after system upgrades.


âœ… Example (Backward Compatibility in Java)
// Old Interface (used by existing code)
interface OldPaymentGateway {
    void makePayment(int amount);
}

// New class (new API or upgraded service)
class NewPaymentGateway {
    public void processPayment(double amountInRupees) {
        System.out.println("Processing payment of â‚¹" + amountInRupees + " via New Gateway");
    }
}

// Adapter to connect old system to new one
class PaymentAdapter implements OldPaymentGateway {
    private final NewPaymentGateway newGateway;

    public PaymentAdapter(NewPaymentGateway newGateway) {
        this.newGateway = newGateway;
    }

    @Override
    public void makePayment(int amount) {
        newGateway.processPayment(amount); // adapts call
    }
}

// Client (old code)
public class Client {
    public static void main(String[] args) {
        OldPaymentGateway gateway = new PaymentAdapter(new NewPaymentGateway());
        gateway.makePayment(500);  // Old method call, new system works!
    }
}
âœ… Output:
Processing payment of â‚¹500.0 via New Gateway

ğŸ§© In Frameworks (like Spring / Java APIs)
Yes â€” many frameworks use adapters for compatibility and extension without breaking old code:

âœ…Examples:
1ï¸âƒ£ Spring MVC Adapters â€”
â¤ HandlerAdapter adapts different controller types (e.g., @Controller, @RestController, or legacy ones).
â¤ Allows Spring to evolve without breaking existing controllers.

2ï¸âƒ£ Java JDBC Drivers â€”
â¤ Adapters let newer JDBC versions work with older driver implementations.

3ï¸âƒ£ Java I/O Streams â€”
â¤ InputStreamReader acts as an adapter between byte streams and character streams.

ğŸ”„  Why Itâ€™s Important in Technology Evolution
â¤ Technologies evolve (e.g., Java 8 â†’ 17, Spring 4 â†’ 6).
â¤ But millions of projects still depend on older APIs.
â¤ Rather than forcing developers to rewrite everything, frameworks introduce adapters or wrappers â€”
so new internal implementations can still support legacy interfaces.
ğŸ‘‰ Adapters = Smooth upgrade path without breaking old functionality



ğŸ”· Facade Design Pattern
The Facade Pattern provides a unified and simplified interface to a complex subsystem of classes, libraries, or APIs.

Think of it as a â€œfront deskâ€ of a hotel â€” you donâ€™t deal with room service, billing, and cleaning directly â€” the reception desk (facade) handles everything for you.


ğŸ”„ Intent
â¤ To hide system complexity
â¤ To decouple client code from subsystems
â¤ To make the API cleaner and easier to use


ğŸ”„ Structure
1ï¸âƒ£ Facade Class
    âœ”ï¸ Provides high-level, easy-to-use methods.
    âœ”ï¸ Internally delegates calls to multiple complex subsystem classes.
2ï¸âƒ£ Subsystem Classes
    âœ”ï¸ Implement actual logic and complex workflows.
3ï¸âƒ£ Client
    âœ”ï¸ Uses the Facade interface instead of interacting with all subsystems directly.

âœ… Example â€” Banking System
Imagine a banking application where multiple operations are needed to open an account (e.g., KYC verification, document checking, account creation, notification).

Instead of letting the user call each of them, weâ€™ll create a BankService Facade that simplifies it.

1ï¸âƒ£ Subsystem Classes
class KYCService {
    public void verifyDocuments(String name) {
        System.out.println("Verifying KYC documents for: " + name);
    }
}

class AccountService {
    public void createAccount(String name) {
        System.out.println("Creating account for: " + name);
    }
}

class NotificationService {
    public void sendWelcomeMessage(String name) {
        System.out.println("Sending welcome message to: " + name);
    }
}

2ï¸âƒ£ Facade Class
class BankServiceFacade {
    private final KYCService kycService;
    private final AccountService accountService;
    private final NotificationService notificationService;

    public BankServiceFacade() {
        this.kycService = new KYCService();
        this.accountService = new AccountService();
        this.notificationService = new NotificationService();
    }

    public void openAccount(String name) {
        kycService.verifyDocuments(name);
        accountService.createAccount(name);
        notificationService.sendWelcomeMessage(name);
        System.out.println("Account successfully opened for " + name + "\n");
    }
}

3ï¸âƒ£ Client Code
public class FacadePatternDemo {
    public static void main(String[] args) {
        BankServiceFacade bankService = new BankServiceFacade();
        bankService.openAccount("Ankur Verma");
    }
}
âœ… Output
Verifying KYC documents for: Ankur Verma
Creating account for: Ankur Verma
Sending welcome message to: Ankur Verma
Account successfully opened for Ankur Verma


ğŸ”„ Real-Life Example in Java
1ï¸âƒ£ JDBC API
ğŸ‘‰ When we use JDBC:

Connection con = DriverManager.getConnection(url, user, password);

â¤ DriverManager acts as a Facade.
â¤ Internally, it talks to different JDBC drivers, connection pools, etc.

2ï¸âƒ£ Spring Framework
In Spring Boot, the Facade Pattern is used heavily:

â¤ Springâ€™s JdbcTemplate, RestTemplate, KafkaTemplate, JmsTemplate are all facades.
â¤ They simplify complex subsystems (like handling connections, exceptions, serialization).

restTemplate.getForObject("https://api.github.com/users/ankur-verma30", String.class);

ğŸ‘‰ Internally, it handles:
âœ”ï¸ HTTP connection creation
âœ”ï¸ Request/response mapping
âœ”ï¸ Error handling
âœ”ï¸ Deserialization
â¤ All hidden behind one simple method â€” classic Facade.

3ï¸âƒ£ Spring Security
SecurityContextHolder acts as a Facade to simplify authentication and authorization details.

4ï¸âƒ£ Hibernate
SessionFactory and EntityManager act as Facades to hide complex ORM logic and SQL execution.


ğŸ”„ Where to Use
â¤ When you have a large system with multiple subsystems.+
â¤ When you want to simplify API usage for higher layers (like Controllers or Services).+
â¤ When you want to reduce coupling between client and system components.

âš–ï¸ Advantages
â¤ Simplifies usage of complex systems.
â¤ Improves code readability and maintainability.
â¤ Reduces coupling between client and subsystems.
â¤ Makes system easier to test and mock.

ğŸš« Disadvantages
âŒ Can become a â€œgod classâ€ if overloaded with too many responsibilities.
âŒ Hiding details may reduce flexibility for advanced users.


ğŸ”· Proxy Design Pattern
â¤ The Proxy Pattern provides a surrogate (substitute) or placeholder object that controls access to another object â€” known as the real subject.
â¤ Instead of calling the real object directly, you call a proxy,
â¤ The proxy adds some extra behavior (like logging, caching, security checks, or lazy initialization),

Then optionally delegates the call to the real object.

ğŸ”„ Intent
â¤ To control access to an object
â¤ To add functionality without changing the original class
â¤ To manage lifecycle or performance (like lazy loading)

ğŸ”„ Structure
1ï¸âƒ£ Subject (Interface)
    âœ”ï¸ Common interface shared by both RealObject and Proxy.
2ï¸âƒ£ RealSubject (Actual Class)
    âœ”ï¸ The real object that performs the actual logic.
3ï¸âƒ£ Proxy (Substitute Class)
    âœ”ï¸ Implements the same interface as RealSubject.
    âœ”ï¸ Controls access, performs extra tasks, or defers object creation.
4ï¸âƒ£ Client
    âœ”ï¸ Uses the Subject interface; doesnâ€™t know whether itâ€™s talking to the real object or proxy.

âœ… Example â€” Internet Access Proxy
Letâ€™s say an organization wants to restrict internet access for employees.
Employees should only access certain websites, and all requests must pass through a proxy.

1ï¸âƒ£ Define the Subject Interface
interface Internet {
    void connectTo(String serverHost) throws Exception;
}

2ï¸âƒ£ Real Object
class RealInternet implements Internet {
    @Override
    public void connectTo(String serverHost) {
        System.out.println("Connecting to " + serverHost);
    }
}

3ï¸âƒ£ Proxy Class
import java.util.ArrayList;
import java.util.List;

class ProxyInternet implements Internet {
    private Internet realInternet = new RealInternet();
    private static List<String> bannedSites;

    static {
        bannedSites = new ArrayList<>();
        bannedSites.add("abc.com");
        bannedSites.add("xyz.com");
    }

    @Override
    public void connectTo(String serverHost) throws Exception {
        if (bannedSites.contains(serverHost.toLowerCase())) {
            throw new Exception("Access Denied to " + serverHost);
        }
        realInternet.connectTo(serverHost);
    }
}

4ï¸âƒ£ Client Code
public class ProxyPatternDemo {
    public static void main(String[] args) {
        Internet internet = new ProxyInternet();
        try {
            internet.connectTo("openai.com");
            internet.connectTo("abc.com");
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }
}
âœ… Output
Connecting to openai.com
Access Denied to abc.com


ğŸ”„ Types of Proxies
| Type                 | Description                                                     | Example                   |
| -------------------- | --------------------------------------------------------------- | ------------------------- |
| **Virtual Proxy**    | Controls access to resource-heavy objects (lazy initialization) | Hibernate Lazy Loading    |
| **Remote Proxy**     | Represents an object in another address space                   | RMI, Web Services         |
| **Protection Proxy** | Adds access control                                             | Security layers in Spring |
| **Caching Proxy**    | Stores results to reduce load                                   | Redis, Caffeine caching   |
| **Logging Proxy**    | Adds logging/tracing before and after real calls                | Spring AOP @Before/@After |


âœ… Real-Life Examples in Java
1ï¸âƒ£ Java RMI (Remote Proxy)
When you use Java RMI:
MyRemoteService service = (MyRemoteService) Naming.lookup("//localhost/Service");
ğŸ‘‰ You actually get a proxy that represents the remote object, not the real one.

2ï¸âƒ£ Spring AOP (Dynamic Proxy)
Spring internally uses JDK Dynamic Proxies (for interfaces) or CGLIB Proxies (for classes) for:
    âœ”ï¸ Logging
    âœ”ï¸ Transaction management
    âœ”ï¸ Security checks
    âœ”ï¸ Performance monitoring

âœ… Example:
@Service
public class PaymentService {
    @Transactional  // Proxy handles transaction begin/commit/rollback
    public void processPayment() {
        System.out.println("Processing payment...");
    }
}
ğŸ‘‰ Here, @Transactional creates a proxy around PaymentService which:
1ï¸âƒ£ Starts a transaction before the method call.
2ï¸âƒ£ Invokes the real method.
3ï¸âƒ£ Commits or rolls back transaction afterward.

ğŸ‘‰ So your class never directly manages transactions â€” the proxy handles it.

3ï¸âƒ£ Hibernate Lazy Loading
When you call entity.getOrders(), Hibernate returns a proxy object that loads the data only when accessed â€” a Virtual Proxy.

âš–ï¸ Advantages
â¤ Adds functionality without changing original code.
â¤ Helps implement lazy loading, security, caching, logging easily.
â¤ Reduces system load by controlling access.

ğŸš« Disadvantages
âŒ Adds extra layer â€” slight performance overhead.
âŒ Complex to debug sometimes (especially in Spring AOP).
âŒ Harder to trace stack calls if many proxies are chained.

âœ… Spring Boot Example â€” Logging Proxy
Letâ€™s create a manual proxy that adds logging before calling the real service.

ğŸ” Service Interface
public interface PaymentService {
    void pay(double amount);
}

ğŸ” Real Service Implementation
@Service
public class PaymentServiceImpl implements PaymentService {
    public void pay(double amount) {
        System.out.println("Processing payment of Rs." + amount);
    }
}

ğŸ” Proxy Implementation (Manual)
@Component
public class PaymentServiceProxy implements PaymentService {
    private final PaymentService paymentService;

    @Autowired
    public PaymentServiceProxy(PaymentServiceImpl paymentService) {
        this.paymentService = paymentService;
    }

    @Override
    public void pay(double amount) {
        System.out.println("[LOG] Payment started...");
        paymentService.pay(amount); // delegate
        System.out.println("[LOG] Payment completed.");
    }
}

ğŸ” Controller
@RestController
@RequestMapping("/payment")
public class PaymentController {

    @Autowired
    private PaymentService paymentService; // Will be proxy

    @PostMapping("/{amount}")
    public String process(@PathVariable double amount) {
        paymentService.pay(amount);
        return "Payment Success!";
    }
}
âœ… Output
[LOG] Payment started...
Processing payment of Rs.5000.0
[LOG] Payment completed.


##################
ğŸ”· Bridge Pattern
##################
The Bridge Pattern is a structural design pattern that decouples an abstraction from its implementation so that the two can vary independently.

â¡ You split a big class into two separate hierarchies:
â¤ Abstraction (What the system does)
â¤ Implementation (How the system does it)

Both can evolve without affecting each other.

ğŸ”„  Need the Bridge Pattern
â— The problem:
When classes grow in two dimensions, inheritance becomes unmanageable.

Example:
If you have:
| Notification Type    | Delivery Channel |
| -------------------- | ---------------- |
| Order Notification   | Email, SMS, Push |
| Payment Notification | Email, SMS, Push |
| Refund Notification  | Email, SMS, Push |

ğŸ‘‰ If you use inheritance, you end up with:
âœ”ï¸ OrderEmailNotification
âœ”ï¸ OrderSMSNotification
âœ”ï¸ OrderPushNotification
âœ”ï¸ PaymentEmailNotification
âœ”ï¸ PaymentSMSNotification
â€¦ (explosion of classes)

âŒ Hard to maintain
âŒ Hard to extend
âŒ Code duplication
âœ… Bridge Pattern solves this.

ğŸ”„  Core Idea
Separate:
1ï¸âƒ£ Abstraction Layer
Defines high-level operations (e.g., â€œSend a notificationâ€).

2ï¸âƒ£ Implementation Layer
Defines how the work is done (e.g., sending via Email, SMS, Push, WhatsApp).
ğŸ‘‰ Both layers can be extended independently.


ğŸ”„  Bridge Pattern Structure
        Abstraction
            |
      Refined Abstraction
            |
         Implementor  <â€” bridge â€”> Concrete Implementors

ğŸŒŸ Abstraction
Has a reference to Implementor.

ğŸŒŸ Implementor
Interface for low-level operations.

ğŸŒŸ Concrete Implementors
Actual low-level implementations.


ğŸ”„  When to Use Bridge Pattern 
ğŸ” Use Bridge Pattern when:
âœ”ï¸ You want to avoid the "class explosion problem".
âœ”ï¸ You have two independent axes of change.
âœ”ï¸ You need to switch implementations at runtime.
âœ”ï¸ You need abstraction to remain stable, but implementation to vary.

ğŸ” Common real-world use cases:
âœ”ï¸ Notification systems
âœ”ï¸ Payment gateways
âœ”ï¸ Document generators (PDF, Excel, CSV)
âœ”ï¸ Logging frameworks
âœ”ï¸ Messaging systems (Kafka, RabbitMQ, SQS)

ğŸ”„  Real-Life Spring Boot Example: Notification System
We have:

1ï¸âƒ£ Abstraction dimension â†’ Notification Type
âœ”ï¸ Order Notification
âœ”ï¸ Payment Notification
âœ”ï¸ OTP Notification

Implementation dimension â†’ Delivery Channels
âœ”ï¸ Email
âœ”ï¸ SMS
âœ”ï¸ Push
âœ”ï¸ WhatsApp
ğŸ‘‰ The Bridge Pattern perfectly fits here.

ğŸŸ© STEP 1ï¸âƒ£: Implementor (Bridge Interface)
public interface NotificationSender {
    void sendNotification(String message);
}

ğŸŸ© STEP 2ï¸âƒ£: Concrete Implementors
ğŸ”— Email Notification Sender
@Service
public class EmailNotificationSender implements NotificationSender {

    @Override
    public void sendNotification(String message) {
        System.out.println("Sending EMAIL: " + message);
        // real code: JavaMailSender logic
    }
}

ğŸ”— SMS Notification Sender
@Service
public class SmsNotificationSender implements NotificationSender {

    @Override
    public void sendNotification(String message) {
        System.out.println("Sending SMS: " + message);
        // real code: Twilio API logic
    }
}

ğŸ”— Push Notification Sender
@Service
public class PushNotificationSender implements NotificationSender {

    @Override
    public void sendNotification(String message) {
        System.out.println("Sending PUSH: " + message);
        // real code: Firebase Cloud Messaging logic
    }
}

ğŸŸ© STEP 3ï¸âƒ£: Abstraction Layer
public abstract class Notification {

    protected NotificationSender sender;  // BRIDGE

    public Notification(NotificationSender sender) {
        this.sender = sender;
    }

    public abstract void send(String message);
}

ğŸŸ© STEP 4ï¸âƒ£: Refined Abstractions (Different Notification Types)
ğŸ”— Order Notification
public class OrderNotification extends Notification {

    public OrderNotification(NotificationSender sender) {
        super(sender);
    }

    @Override
    public void send(String message) {
        sender.sendNotification("ORDER: " + message);
    }
}

ğŸ”— Payment Notification
public class PaymentNotification extends Notification {

    public PaymentNotification(NotificationSender sender) {
        super(sender);
    }

    @Override
    public void send(String message) {
        sender.sendNotification("PAYMENT: " + message);
    }
}

ğŸŸ© STEP 5ï¸âƒ£: Using Bridge Pattern in Spring Boot
Example Controller
@RestController
@RequestMapping("/notify")
public class NotificationController {

    @Autowired
    private EmailNotificationSender emailSender;

    @Autowired
    private SmsNotificationSender smsSender;

    @Autowired
    private PushNotificationSender pushSender;

    @GetMapping("/order/email")
    public String orderEmail() {
        Notification notification = new OrderNotification(emailSender);
        notification.send("Order placed successfully!");
        return "Order Email Sent";
    }

    @GetMapping("/payment/sms")
    public String paymentSms() {
        Notification notification = new PaymentNotification(smsSender);
        notification.send("Payment received!");
        return "Payment SMS Sent";
    }

    @GetMapping("/order/push")
    public String orderPush() {
        Notification notification = new OrderNotification(pushSender);
        notification.send("Order shipped!");
        return "Order Push Sent";
    }
}

ğŸ”„  Advantages of Bridge Pattern
âœ”ï¸ Both hierarchies can grow independently
You can add:
â¤ New notification types
â¤ New delivery channels- Without touching existing classes.

âœ”ï¸ Eliminates class explosion
â¤ Reduces code complexity.

âœ”ï¸ Easy to maintain
â¤ Clear separation of concerns.

âœ”ï¸ Supports runtime changes
â¤ You can dynamically inject implementors.


ğŸ”„ Disadvantages of Bridge Pattern
âŒ More classes to manage
You create interfaces + abstractions + implementations.

âŒ Slightly complex design
More layers â†’ more architectural overhead.


ğŸ”„ Real-World Use Cases in Spring Boot
âœ”ï¸ Notification system (Email/SMS/Push)
âœ”ï¸ Payment system (Razorpay/Stripe/PayPal)
âœ”ï¸ Storage system (AWS S3, Azure Blob, Google Cloud)
âœ”ï¸ Report generation (PDF, Excel, CSV generators)
âœ”ï¸ Messaging system (Kafka, RabbitMQ, SQS)
âœ”ï¸ Logging (File logger, DB logger, Cloud logger)


#######################################################
Bridge Pattern vs Adapter Pattern (Interview Version)
#######################################################
1ï¸âƒ£ Bridge Pattern
â¤ Used to separate Abstraction from Implementation so both can evolve independently.
â¤ Aimed at designing the architecture from the beginning.

2ï¸âƒ£ Adapter Pattern
â¤ Used to convert the interface of an existing class into one you need.
â¤ Aimed at integration with old or incompatible systems.


ğŸ”„  2. Intent / Purpose
ğŸ” Bridge Pattern â†’ â€œDecoupleâ€
ğŸ‘‰ You have:
One abstraction (Notification)
Multiple implementations (Email, SMS, Push)

And you want both to grow independently.

ğŸ” Adapter Pattern â†’ â€œMake incompatible things work togetherâ€
You want to use a class whose interface does not match what your system expects.

ğŸ”„  When to Use Them
ğŸ” Use Bridge Pattern when:
â¤ You have two (or more) dimensions of variation e.g., Notification Type + Delivery Method
â¤ You want extensibility (add new platforms easily).
â¤ You want clean architecture from the start.

ğŸ” Use Adapter Pattern when:
â¤ You are integrating legacy code or third-party APIs.
â¤ You have an interface mismatch.
â¤ You want compatibility without modifying the original class.

ğŸ”„  Key Difference
ğŸŸ¦ Bridge:
Designed before implementation, to handle future growth.

ğŸŸ§ Adapter:
Used after implementation, to fix interface mismatches.

ğŸ”„ How They Look 
ğŸ” Bridge Pattern
â¤ Abstraction <----> Implementor
â¤ Each side can grow independently.

ğŸ” Adapter Pattern
â¤ Client -----> Adapter -----> Incompatible Class
â¤ Adapter makes the class usable.

ğŸ”„  Java/Spring Boot Real-Life Example
ğŸ” Bridge Pattern Example
In a Notification System:
    âœ”ï¸ Abstraction: Notification         
    âœ”ï¸ Implementor: NotificationSender (Email, SMS, Push)
ğŸ‘‰ You use Bridge when you want to support many notification types + many channels with minimal classes.

ğŸ” Adapter Pattern Example
âš¡ You switch SMS provider from Twilio to TextLocal, but your application expects this method:
sendSms(String mobile, String message)

âš¡ But the new provider has:
sendMessage(String msg, String phone, int priority)

âš¡ So you create an adapter:
public class TextLocalAdapter implements SmsService {
    private TextLocalClient client;

    @Override
    public void sendSms(String mobile, String message) {
        client.sendMessage(message, mobile, 1);
    }
}
ğŸ‘‰ This adapts the third-party API to your existing interface.

ğŸ”„  Major Conceptual Differences Table
| Feature              | Bridge Pattern                        | Adapter Pattern                             |
| -------------------- | ------------------------------------- | ------------------------------------------- |
| **Goal**             | Separate abstraction & implementation | Make incompatible interfaces compatible     |
| **When used?**       | Design time                           | Integration time                            |
| **Helps with?**      | Extensibility                         | Reusability / Compatibility                 |
| **Example**          | Payment type vs payment provider      | New payment API with different method names |
| **Changes allowed?** | Both sides can change                 | Adaptee cannot change                       |
| **Pattern Type**     | Structural                            | Structural                                  |
| **Focus**            | Decoupling                            | Conversion                                  |


ğŸ”„  8. Trick to Remember
ğŸ” Bridge = Designing forward
(For future flexibility)

ğŸ” Adapter = Fixing backward
(For legacy compatibility)
