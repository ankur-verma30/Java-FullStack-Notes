ğŸ”· Decorator Pattern
The Decorator pattern allows you to dynamically add new behavior or responsibilities to an object without modifying its existing code.

ğŸ‘‰ Purpose:
To extend the functionality of objects at runtime, not at compile time â€” unlike inheritance. 

ğŸ”„ Real-World Analogy

Think of a coffee shop â˜•:
â¤ You start with a plain coffee.
â¤ Then you can add milk, sugar, or cream â€” each decorator adds extra behavior (cost + description).

You didnâ€™t modify the base coffee class â€” you just wrapped it!


ğŸ”„ Structure
â¤ Component (Interface): Defines the base behavior.
â¤ Concrete Component: The original object that we decorate.
â¤ Decorator (Abstract Class): Holds a reference to the component and delegates operations to it.
â¤ Concrete Decorators: Add new behavior around the base component.

âœ… Example:
Coffee Order System
1ï¸âƒ£ Component
interface Coffee {
    String getDescription();
    double getCost();
}

2ï¸âƒ£ Concrete Component
class BasicCoffee implements Coffee {
    @Override
    public String getDescription() {
        return "Basic Coffee";
    }

    @Override
    public double getCost() {
        return 50;
    }
}

3ï¸âƒ£ Abstract Decorator
abstract class CoffeeDecorator implements Coffee {
    protected Coffee decoratedCoffee;

    public CoffeeDecorator(Coffee decoratedCoffee) {
        this.decoratedCoffee = decoratedCoffee;
    }

    public String getDescription() {
        return decoratedCoffee.getDescription();
    }

    public double getCost() {
        return decoratedCoffee.getCost();
    }
}

4ï¸âƒ£ Concrete Decorators
class MilkDecorator extends CoffeeDecorator {
    public MilkDecorator(Coffee coffee) {
        super(coffee);
    }

    public String getDescription() {
        return super.getDescription() + ", Milk";
    }

    public double getCost() {
        return super.getCost() + 10;
    }
}

class SugarDecorator extends CoffeeDecorator {
    public SugarDecorator(Coffee coffee) {
        super(coffee);
    }

    public String getDescription() {
        return super.getDescription() + ", Sugar";
    }

    public double getCost() {
        return super.getCost() + 5;
    }
}

class CreamDecorator extends CoffeeDecorator {
    public CreamDecorator(Coffee coffee) {
        super(coffee);
    }

    public String getDescription() {
        return super.getDescription() + ", Cream";
    }

    public double getCost() {
        return super.getCost() + 15;
    }
}

5ï¸âƒ£ Client
public class DecoratorPatternDemo {
    public static void main(String[] args) {
        Coffee coffee = new BasicCoffee();                     // Base
        coffee = new MilkDecorator(coffee);                    // Add milk
        coffee = new SugarDecorator(coffee);                   // Add sugar
        coffee = new CreamDecorator(coffee);                   // Add cream

        System.out.println("Order: " + coffee.getDescription());
        System.out.println("Total Cost: â‚¹" + coffee.getCost());
    }
}
âœ… Output
Order: Basic Coffee, Milk, Sugar, Cream
Total Cost: â‚¹80.0

ğŸ”„ Where Used in Java
| Class                                          | Decorator Role                        |
| ---------------------------------------------- | ------------------------------------- |
| `java.io.BufferedReader`                       | Decorates `Reader`                    |
| `java.io.DataInputStream`                      | Decorates `InputStream`               |
| `java.util.Collections.synchronizedList()`     | Returns a decorated version of a List |
| `javax.servlet.http.HttpServletRequestWrapper` | Decorates a servlet request           |

ğŸ”„ Spring Boot 
In Spring Boot, Decorator pattern is commonly seen when adding behavior to Beans or Services dynamically.


âœ… Example: Logging Decorator for a Payment Service
1ï¸âƒ£ Component
public interface PaymentService {
    void pay(double amount);
}

2ï¸âƒ£ Concrete Component
@Service
class BasicPaymentService implements PaymentService {
    public void pay(double amount) {
        System.out.println("Processing payment of â‚¹" + amount);
    }
}

3ï¸âƒ£ Decorator
@Service
@Primary  // ensures this bean is used when autowired
class LoggingPaymentDecorator implements PaymentService {
    private final PaymentService paymentService;

    public LoggingPaymentDecorator(BasicPaymentService paymentService) {
        this.paymentService = paymentService;
    }

    @Override
    public void pay(double amount) {
        System.out.println("Logging: Payment started...");
        paymentService.pay(amount);
        System.out.println("Logging: Payment completed successfully.");
    }
}


ğŸ‘‰ Usage in Controller:
@RestController
public class PaymentController {
    private final PaymentService paymentService;

    public PaymentController(PaymentService paymentService) {
        this.paymentService = paymentService;
    }

    @PostMapping("/pay")
    public String pay(@RequestParam double amount) {
        paymentService.pay(amount);
        return "Payment Successful";
    }
}
ğŸ‘‰ This dynamically adds logging behavior without changing the original BasicPaymentService.


Decorator ğŸ†š Inheritance
| Aspect                | Decorator           | Inheritance              |
| --------------------- | ------------------- | ------------------------ |
| Flexibility           | âœ… Runtime extension | âŒ Compile-time extension |
| Class explosion       | âŒ Reduced           | âœ… Increases              |
| Open/Closed Principle | âœ… Respected         | âŒ Often violated         |
| Multiple Behaviors    | âœ… Easy to combine   | âŒ Harder to combine      |


ğŸ”„ Where to Use in Projects
â¤ Add logging, caching, security, validation, metrics to services dynamically.
â¤ Add response formatting or data enrichment in REST APIs.
â¤ Wrap repository/service beans for AOP-like behavior without using aspects.
â¤ Wrap HttpServletRequest or HttpResponse objects.

ğŸ”„ Advantages
Adds new behavior without modifying existing code (Open/Closed Principle).
Can combine multiple decorators flexibly.
Promotes composition over inheritance.

ğŸ”„ Disadvantages
Increases number of small objects.
Can become hard to debug if too many decorators wrap each other.
Order of decorators matters.
ğŸ”„

ğŸ”„
ğŸ”„