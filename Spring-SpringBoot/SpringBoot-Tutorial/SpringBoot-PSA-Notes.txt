ğŸ”· SpringBoot
A framework built on top of Spring Framework that simplifies the development of production-ready Spring applications by removing boilerplate configuration.

ğŸ”„Key Features:
â¤ Auto-Configuration â†’ Automatically configures Spring application based on dependencies in the classpath.
â¤ Starter Dependencies â†’ Predefined dependency sets (e.g., spring-boot-starter-web, spring-boot-starter-data-jpa) to reduce manual configuration.
â¤ Embedded Servers â†’ Comes with Tomcat, Jetty, Undertow embedded servers, so no need to deploy WAR files separately.
â¤ Production Ready â†’ Provides health checks, metrics, logging, and monitoring with Spring Boot Actuator.
â¤ Convention over Configuration â†’ Focus more on logic, less on XML/bean configuration.

ğŸ”„ Advantages:
â¤ Rapid development of Java apps (especially REST APIs and microservices).
â¤ Reduces boilerplate code.
â¤ Easier integration with databases, security, and cloud platforms.

âœ…  Real World Example:
â¤ A company wants to build a RESTful microservice for user authentication.
â¤ Using Spring Boot, developers just add spring-boot-starter-security and spring-boot-starter-web.
â¤ No need to configure servlet containers or security filters manually.
â¤ Application runs directly with java -jar app.jar.


ğŸ”· Data Flow in a Spring Boot Application
[ User Interface (UI) ]
          |
          v
[ Controller Layer ]
   - Handles HTTP requests
   - Validates input
          |
          v
[ Service Layer ]
   - Business logic
   - Coordinates between controller & repository
          |
          v
[ Repository Layer (DAO) ]
   - Database operations (CRUD)
          |
          v
[ Database ]
   - Stores & retrieves data

ğŸ”„ Reverse flow from DB---> to UI
[ Database ] -> [ Repository Layer ] -> [ Service Layer ] -> [ Controller Layer ] -> [ User Interface ]


1ï¸âƒ£ User Interface (UI)
User interacts with the app (webpage, mobile app, Postman request, etc.).

2ï¸âƒ£ Controller Layer
â¤ Handles incoming HTTP requests (@RestController).
â¤ Validates input and forwards data to the Service Layer.
âœ… Example: UserController -> createUser()

3ï¸âƒ£ Service Layer
â¤ Contains business logic.
â¤ Coordinates between Controller and Repository.
âœ… Example: check if user already exists, encrypt password.

4ï¸âƒ£ Repository Layer (DAO)
â¤ Talks to the Database.
â¤ Usually interfaces extending JpaRepository or CrudRepository.

5ï¸âƒ£ Database (DB)
Stores and retrieves actual data (MySQL, PostgreSQL, MongoDB, etc.).


ğŸ“Œ In interviews, they often ask:
ğŸ‘‰ â€œWhy do we need the Service Layer if Controller can directly call Repository?â€
Answer:
âœ”ï¸ To keep business logic separate from request handling.
âœ”ï¸ For reusability (other controllers or services can use it).
âœ”ï¸ For testability (unit test services independently).


âœ… Example Scenario: User Registration
ğŸ”„ JSP Setup in Spring Boot
â¤ JSP files should be placed inside: src/main/webapp/WEB-INF/views/
â¤ Configure prefix & suffix in application.properties:
    âœ”ï¸ spring.mvc.view.prefix=/WEB-INF/views/
    âœ”ï¸ spring.mvc.view.suffix=.jsp
â¤ Add dependency: tomcat-embed-jasper for JSP rendering.

ğŸ”„ Controller Layer
â¤ Use @Controller for handling web views (not @RestController).
â¤ @RequestMapping("/view") maps the request URL to a view.
â¤ Return value = JSP file name (without prefix/suffix).

ğŸ”„ Execution Flow
User Request â†’ Controller â†’ Returns view name â†’ ViewResolver adds prefix & suffix â†’ Loads JSP

1ï¸âƒ£  JSP File â†’ registration.jsp

src/main/webapp/WEB-INF/views/registration.jsp
ğŸ”— Code:
<%@ page contentType="text/html; charset=UTF-8" language="java" %>
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Register</title>
</head>
<body>
    <h2>Register here...</h2>
</body>
</html>

2ï¸âƒ£ application.properties

spring.application.name=app
spring.mvc.view.prefix=/WEB-INF/views/
spring.mvc.view.suffix=.jsp

3ï¸âƒ£ Maven Dependency (pom.xml)
<dependency>
    <groupId>org.apache.tomcat.embed</groupId>
    <artifactId>tomcat-embed-jasper</artifactId>
</dependency>

4ï¸âƒ£ Controller Class â†’ EmployeeController.java
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class EmployeeController {

    @RequestMapping("/view")
    public String viewRegisterPage() {
        return "registration"; // resolves to /WEB-INF/views/registration.jsp
    }
}
ğŸ‘‰ When user accesses http://localhost:8080/view
ğŸ‘‰ The registration.jsp page is displayed.

ğŸ“’ Annotations Explanation
ğŸ”„ @Controller
â¤ Marks the class as a Spring MVC Controller.
â¤ Tells Spring: â€œThis class will handle web requests and return views (JSP, Thymeleaf, etc.).â€
â¤ Unlike @RestController, it does not return JSON directly; instead, it returns view names.

ğŸ”„ @RequestMapping("/view")
Maps HTTP requests (like http://localhost:8080/view) to a method in the controller.

â¤ In this case:
    âœ”ï¸ When user hits /view, Spring calls viewEmployeePage().
    âœ”ï¸ The method returns "employee".
    âœ”ï¸ Springâ€™s ViewResolver adds prefix + suffix â†’ /WEB-INF/views/employee.jsp.

âš¡ Flow with Annotations
User â†’ http://localhost:8080/view
   â†“
DispatcherServlet (Spring Front Controller)
   â†“
@Controller class (EmployeeController)
   â†“
@RequestMapping("/view") method â†’ returns "registration"
   â†“
ViewResolver applies prefix/suffix â†’ /WEB-INF/views/registration.jsp
   â†“
JSP rendered to user

ğŸŒŸ Specialized Annotations of @RequestMapping
ğŸ‘‰ @GetMapping
â¤ Handles HTTP GET requests.
â¤ Equivalent to:
@RequestMapping(value = "/view", method = RequestMethod.GET)

ğŸ‘‰ @PostMapping
â¤ Handles HTTP POST requests (commonly for form submissions or creating resources).
â¤ Equivalent to:
@RequestMapping(value = "/add", method = RequestMethod.POST)

ğŸ‘‰ @PutMapping
Handles HTTP PUT requests (used for updating resources).

ğŸ‘‰ @DeleteMapping
Handles HTTP DELETE requests (used for deleting resources).

ğŸ‘‰ @PatchMapping
Handles HTTP PATCH requests (used for partial updates).

âœ… Example:
@Controller
public class EmployeeController {

    @GetMapping("/register")
    public String showForm() {
        return "registration"; // loads registration.jsp
    }

    @PostMapping("/register")
    public String submitForm() {
        // handle form submission logic
        return "success";
    }
}

ğŸ”· Spring Boot Stand-Alone Application
A Spring Boot app that can run independently without requiring deployment to an external server (like Tomcat or JBoss).

ğŸ”„ Key Points:
â¤ Run with a simple main() method (just like a normal Java program).
â¤ Uses an embedded server (Tomcat, Jetty, Undertow).
â¤ No need to install or configure external application servers.
â¤ Packaged as an executable JAR (java -jar app.jar).

ğŸ”„ Why Important?
â¤ Fast setup â†’ no server installation overhead.
â¤ Easier deployment (just share JAR).
â¤ Ideal for microservices architecture.

ğŸ”· Spring MVC (Modelâ€“Viewâ€“Controller)
â¤ A web framework in the Spring ecosystem.
â¤ Follows the MVC design pattern â†’ separates Model (data), View (UI), and Controller (logic).
â¤ Used to build web applications and REST APIs.

ğŸŒŸ Work Flow of MVC:
1ï¸âƒ£ User Request
User hits a URL (e.g., /home) or submits an HTML form.

2ï¸âƒ£ DispatcherServlet (Front Controller)
Central entry point â†’ intercepts all requests.

3ï¸âƒ£ Controller Layer
â¤ DispatcherServlet finds matching method (@GetMapping, @PostMapping, etc.).
â¤ Controller executes business logic with help of Service/Model.

4ï¸âƒ£ Model
â¤ It allows the controller to send data (attributes) to the view.
â¤ The view can then access and display that data.
â¤ Model in Spring is an interface, not a class

5ï¸âƒ£ ViewResolver
Maps view name to actual JSP/HTML file.

6ï¸âƒ£ View (Response)
JSP/HTML page is returned to the user with dynamic data.

ğŸ‘‰ Some Annotations in Spring
ğŸ”— @Component
It is a stereotype annotation in Spring that marks a class as a Spring-managed bean.

ğŸ” Key Points:
âœ”ï¸ Bean Creation â†’ When Spring performs component scanning, it finds classes annotated with @Component and creates their objects (beans) inside the IOC container.
âœ”ï¸ Dependency Injection â†’ Once managed, these beans can be injected into other classes using @Autowired (or constructor injection).
âœ”ï¸ Generic Role â†’ Unlike specialized annotations like @Service, @Repository, or @Controller, @Component is generic and can be applied to any class.
âœ”ï¸ Bean Name â†’ By default, the bean name is the class name with the first letter in lowercase. (e.g., MyHelper â†’ myHelper).
âœ”ï¸ Scope â†’ Default scope is singleton, but it can be changed with @Scope("prototype"), etc.

ğŸ”— Specialized Annotations (built on top of @Component)
ğŸ‘‰ @Service â†’ Marks business logic classes (semantically meaningful).
ğŸ‘‰ @Repository â†’ Marks DAO (Data Access) classes, adds exception translation.
ğŸ‘‰ @Controller â†’ Marks controller classes in Spring MVC.
ğŸ‘‰ @RestController â†’ @Controller + @ResponseBody (returns JSON/XML directly).

âœ… Example of @Component:
import org.springframework.stereotype.Component;

@Component
public class EmailService {
    public void sendEmail(String to, String message) {
        System.out.println("Sending email to " + to + ": " + message);
    }
}
And then inject it:
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class NotificationService {
    private final EmailService emailService;

    @Autowired
    public NotificationService(EmailService emailService) {
        this.emailService = emailService;
    }

    public void notifyUser(String user, String msg) {
        emailService.sendEmail(user, msg);
    }
}
ğŸ‘‰ Here, EmailService is marked as @Component, Spring manages it, and NotificationService can inject and use it. 

ğŸ”· ModelMap in Spring MVC
ModelMap is a Spring MVC helper class used to pass data (key-value pairs) from a controller to the view layer (JSP, Thymeleaf, etc.).

ğŸ”„ Key Points:
    âœ”ï¸ Wrapper Around Map â†’ Works like a HashMap<String, Object> to store attributes.
    âœ”ï¸ Controller â†’ View Communication â†’ Data added to ModelMap in a controller method is available in the view template.
    âœ”ï¸ Type Safety â†’ Strongly typed compared to using a plain Map.
    âœ”ï¸ Convenience Methods â†’ Provides easy addAttribute() methods for chaining.
    âœ”ï¸ Scope â†’ Attributes live only for that request, not across sessions (unlike @SessionAttributes).

âœ… Example
import org.springframework.stereotype.Controller;
import org.springframework.ui.ModelMap;
import org.springframework.web.bind.annotation.GetMapping;

@Controller
public class HomeController {

    @GetMapping("/home")
    public String homePage(ModelMap model) {
        // Adding data to ModelMap
        model.addAttribute("username", "Ankur");
        model.addAttribute("role", "Full Stack Developer");

        // Returns the view name (home.jsp or home.html)
        return "home";
    }
}

âš¡ View (home.jsp)
<html>
<body>
    <h1>Welcome, ${username}!</h1>
    <p>Your role is: ${role}</p>
</body>
</html>


ğŸ‘‰ When user visits /home, the page will render:
Welcome, Ankur!
Your role is: Full Stack Developer

ğŸ†š Difference with Similar Types
Model â†’ Interface to pass data (commonly used).
ModelMap â†’ Implementation of Map with convenience methods.
ModelAndView â†’ Wraps both Model (data) + View (page name).

âœ… Example Scenario 2: Data submission with JSP in Spring Boot 
1ï¸âƒ£ JSP Page â†’ registration.jsp

src/main/webapp/WEB-INF/views/registration.jsp

<%@ page contentType="text/html; charset=UTF-8" language="java" %>
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Register</title>
</head>
<body>
    <h2>Register here</h2>
    <form action="saveReg" method="post">
        <pre>
First Name: <input type="text" name="firstName"/>
Last Name:  <input type="text" name="lastName"/>
Email Id:   <input type="text" name="email"/>
Mobile:     <input type="text" name="mobile"/>
<input type="submit" value="Save"/>
        </pre>
    </form>
    ${msg}
</body>
</html>

â¤ Provides a form for user input.
â¤ On submit, data is sent to /saveReg via POST.
â¤ ${msg} displays confirmation message from controller.

2ï¸âƒ£ Entity â†’ Employee.java
package com.app.entity;

import jakarta.persistence.*;

@Entity
public class Employee {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "first_name", nullable = false)
    private String firstName;

    @Column(name = "last_name", nullable = false)
    private String lastName;

    @Column(nullable = false, unique = true)
    private String email;

    @Column(nullable = false, unique = true)
    private String mobile;

    //contructors, getters, setters

}

â¤ Represents the Employee table in DB.
â¤ Fields â†’ mapped to columns with @Column.
â¤ @Id + @GeneratedValue â†’ auto-generated primary key.

3ï¸âƒ£ Repository â†’ EmployeeRepository.java
package com.app.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import com.app.entity.Employee;

public interface EmployeeRepository extends JpaRepository<Employee, Long> {}

â¤ Extends JpaRepository.
â¤ Spring Boot auto-implements methods like save(), findAll(), etc.

4ï¸âƒ£ Service â†’ EmployeeService.java
package com.app.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import com.app.entity.Employee;
import com.app.repository.EmployeeRepository;

@Service
public class EmployeeService {

    @Autowired
    private EmployeeRepository employeeRepository;

    public void saveEmployee(Employee employee) {
        employeeRepository.save(employee);
    }
}

â¤ Business logic layer.
â¤ Uses @Autowired to inject repository.
â¤ Method saveEmployee() saves employee to DB.

ğŸŒŸ Annotations used
ğŸ‘‰ @Service
â¤ Marks class as Service Layer component â†’ holds business logic.
â¤ Helps with component scanning & makes it clear this class belongs to the service layer.

ğŸ‘‰ @Autowired
â¤ Enables Dependency Injection.
â¤ Spring automatically injects the required bean (here: EmployeeRepository).

5ï¸âƒ£ Controller â†’ EmployeeController.java
package com.app.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import com.app.entity.Employee;
import com.app.service.EmployeeService;

@Controller
public class EmployeeController {

    @Autowired
    private EmployeeService employeeService;

    // Load registration form
    @RequestMapping("/view")
    public String showRegistrationPage() {
        return "registration"; // resolves to registration.jsp
    }

    // Handle form submission
    @PostMapping("/saveReg")
    public String handleRegistration(@ModelAttribute Employee employee, Model model) {
        employeeService.saveEmployee(employee);
        model.addAttribute("msg", "Record saved successfully!");
        return "registration";
    }
}
ğŸŒŸ Annotations used
ğŸ‘‰ @Controller
â¤ Marks class as Spring MVC Controller (handles requests, returns view names).

ğŸ‘‰ @ModelAttribute
â¤ Bind form data / request parameters directly to a Java object.
â¤ Expose data to the view layer before rendering.

ğŸ” Two Main Use Cases of ModelAttribute
1ï¸âƒ£  Method Parameter Binding
â¤ Automatically maps request parameters â†’ Java object fields.
â¤ Saves you from calling request.getParameter() manually.

âœ… Example:
@Controller
public class EmployeeController {

    @PostMapping("/register")
    public String registerEmployee(@ModelAttribute Employee emp) {
        // Spring automatically binds form fields to Employee object
        System.out.println(emp.getName() + " - " + emp.getEmail());
        return "success";
    }
}

Form (JSP):
<form action="/register" method="post">
    Name: <input type="text" name="name"/>
    Email: <input type="text" name="email"/>
    <button type="submit">Register</button>
</form>
ğŸ‘‰ Spring will automatically populate Employee.name and Employee.email from the form.

2ï¸âƒ£ Method Level Usage
Adds common attributes to the Model before every controller method.

âœ… Example:
@Controller
public class HomeController {

    // Runs before every @RequestMapping method
    @ModelAttribute
    public void addCommonData(Model model) {
        model.addAttribute("appName", "Employee Portal");
    }

    @GetMapping("/home")
    public String homePage() {
        return "home";  // appName will be available in the view
    }
}

ğŸ”— View (home.jsp):
<h2>Welcome to ${appName}</h2>

â“ Difference between @RequestParam and @ModelAttribute?
ğŸ‘‰ @RequestParam â†’ binds single request parameter (e.g., ?id=101).
ğŸ‘‰ @ModelAttribute â†’ binds entire form/request into a Java object.

â¤ /view â†’ loads the JSP form.
â¤ /saveReg (@PostMapping) â†’ receives form data as Employee object, calls service, adds success message to Model, and returns back to JSP.

6ï¸âƒ£ application.properties
spring.application.name=app

spring.mvc.view.prefix=/WEB-INF/views/
spring.mvc.view.suffix=.jsp

spring.datasource.url=jdbc:mysql://localhost:3306/appdb
spring.datasource.username=root
spring.datasource.password=test

spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect

â¤ Configures DB connection, view resolver (prefix/suffix), Hibernate settings.

â“ Why Constructor Injection is Better than Field Injection (@Autowired)
ğŸ”„ Field Injection
@Service
public class UserService {
    @Autowired
    private UserRepository userRepository;  // field injection
}

ğŸ”„ Constructor Injection
@Service
public class UserService {

    private final UserRepository userRepository;

    @Autowired  // optional since Spring 4.3+
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
}
ğŸ”„ Why Constructor Injection is Preferred:

1ï¸âƒ£ Immutability (Good Design Principle)
â¤ Dependencies are final â†’ canâ€™t be changed after object creation.
â¤ Makes your beans immutable, leading to safer and more predictable code.

private final UserRepository userRepository; // final ensures immutability

2ï¸âƒ£ Easier for Unit Testing
â¤ With field injection, you need reflection or Spring context to test.
â¤ With constructor injection, you can easily pass mock objects manually.

âœ… Example:
âŒ Field Injection (hard to test):
UserService service = new UserService();
ReflectionTestUtils.setField(service, "userRepository", mockRepo);

âœ… Constructor Injection (easy to test):
UserService service = new UserService(mockRepo);

3ï¸âƒ£ Detects Missing Dependencies at Compile Time
â¤ Constructor injection ensures all required dependencies are provided during bean creation.
â¤ If any dependency is missing â†’ Spring throws an error immediately.
â¤ Field injection, on the other hand, can fail at runtime â€” leading to NullPointerException.
âœ… Example:
âŒ Field Injection (compile-time error):
UserService service = new UserService();
service.userRepository = mockRepo;

âœ… Constructor Injection (no compile-time error):
UserService service = new UserService(mockRepo);

4ï¸âƒ£ Encourages Better Design
â¤ If a constructor has too many parameters, it signals too many dependencies â€” i.e. your class is doing too much (violates Single Responsibility Principle).
â¤ Hence, constructor injection naturally enforces clean architecture.

5ï¸âƒ£ Works Better with @RequiredArgsConstructor (Lombok)
â¤ Lombok can automatically generate constructor injection for all final fields:

@Service
@RequiredArgsConstructor
public class UserService {
    private final UserRepository userRepository;
    private final EmailService emailService;
}
ğŸ‘‰ This is clean, concise, and immutable.

6ï¸âƒ£ Avoids Circular Dependency Problems
â¤ Constructor injection fails fast if circular dependencies exist (e.g., A â†’ B â†’ A), making them easier to detect.
â¤ Field injection might allow circular dependencies silently and fail later in runtime.

7ï¸âƒ£ Works with @Profile or @Conditional Beans Easily
â¤ Since dependencies are clearly defined in constructors, itâ€™s straightforward for Spring to determine which beans to inject per profile/environment.


ğŸ”· Payload and DTO in SpringBoot
â“ What is a Payload?
In Spring Boot (and in general web development), a payload is the data sent by the client (browser, Postman, frontend app) to the server in an HTTP request.

âœ… Example: When you fill a form and click Submit, all form fields (firstName, lastName, email, etc.) are sent as the payload of the HTTP request.

ğŸ”„ Types of Payload:
â¤ Form Data (like in your JSP form)
â¤ JSON/XML Payload (common in REST APIs)

ğŸ‘‰ In your example:
When the user submits the registration.jsp form, this data is sent as payload:

ğŸ”— Code Block (registration.jsp)
<body>
	<h2>Register here..</h2>
	<form action="saveReg" method="post">
		<pre>
			First Name   <input type="text" name="firstName"/>
			Last Name    <input type="text" name="lastName"/>
			Email Id     <input type="text" name="email"/>
			Mobile       <input type="text" name="mobile"/>
			City         <input type="text" name="city"/>
			State        <input type="text" name="state"/>
			Pincode      <input type="text" name="pinCode"/>
			Address Line <input type="text" name="addressLine"/>
			<input type="submit" value="Save"/>
		</pre>
	</form>
	${msg}
</body>

firstName=John
lastName=Doe
email=john@gmail.com
mobile=1234567890
city=Delhi
state=Delhi
pinCode=110001
addressLine=Street 5, XYZ
ğŸ‘‰ This is the request payload.

â“ What is a DTO (Data Transfer Object)?
A DTO is a Java class created to receive, hold, and transfer the payload data between different layers of the application.

ğŸ”„ Purpose:
â¤ Prevents direct use of Entity for input/output.
â¤ Provides loose coupling between database structure and client requests.
â¤ Helps with validation, security, and clean separation of concerns.

ğŸ‘‰ In your example:
The payload (form data) is mapped to EmployeeDto.java:

public class EmployeeDto {
    private String firstName;
    private String lastName;
    private String email;
    private String mobile;

    private String city;
    private String state;
    private int pinCode;
    private String addressLine;

    // getters and setters
}
ğŸ‘‰ When the user submits the form â†’ Spring automatically binds request payload â†’ this EmployeeDto object using @ModelAttribute.

â“ How Payload and DTO Work Together in above Example
Step 1ï¸âƒ£:  Payload Submission
User fills the form â†’ clicks Save â†’ Payload sent:
firstName=John&lastName=Doe&email=john@gmail.com&mobile=12345&city=Delhi&state=Delhi&pinCode=110001&addressLine=Street 5

Step2ï¸âƒ£: Controller Receives Payload via DTO
ğŸ”— EmployeeController.java
@Controller
public class EmployeeController {
	
	@Autowired
	private EmployeeService employeeService;

	@GetMapping("/view")
	public String viewRegisterPage() {
		return "employee";
	}
	
	@PostMapping("/saveReg")
	public String saveEmployee(@ModelAttribute EmployeeDto employeeDto, Model model) {
		employeeService.saveEmployeeDetails(employeeDto);
		model.addAttribute("msg", "Record is saved successfully!");
        return "employee";
	}
}
â¤ @ModelAttribute EmployeeDto employeeDto â†’ Spring automatically maps form fields (payload) to EmployeeDto fields.

âœ… Example:
    âœ”ï¸ firstName â†’ employeeDto.setFirstName("John")
    âœ”ï¸ city â†’ employeeDto.setCity("Delhi")

ğŸ”— Address.java (Entity)
package com.app.entity;

import jakarta.persistence.*;

@Entity
public class Address {
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private long id;

	private String city;
	private String state;
	private int pinCode;
	private String addressLine;

	// Getters & Setters
}

Step 3ï¸âƒ£: Service Converts DTO â†’ Entities
EmployeeService.java

@Service
public class EmployeeService {
	
	@Autowired
	private EmployeeRepository employeeRepository;
	
	@Autowired
	private AddressRepository addressRepository;
	
	public void saveEmployeeDetails(EmployeeDto employeeDto) {
		// Convert DTO â†’ Entity
		Employee emp = new Employee();
		BeanUtils.copyProperties(employeeDto, emp);
		employeeRepository.save(emp);
		
		Address address = new Address();
		BeanUtils.copyProperties(employeeDto, address);
		addressRepository.save(address);
	}
}
â¤ DTO is not directly saved in DB.
â¤ Instead:
    âœ”ï¸ Employee entity stores employee-specific info.
    âœ”ï¸ Address entity stores address info.
    âœ”ï¸ BeanUtils.copyProperties() copies data from DTO â†’ Entities.

â“ Why Not Use Entity Instead of DTO?
Imagine you bound form data directly to Employee entity:

public String saveEmployee(@ModelAttribute Employee employee) { ... }

â— Problems:
1ï¸âƒ£ Tight Coupling â†’ If DB schema changes, your form & API also break.
2ï¸âƒ£ Security Risk â†’ Someone could inject malicious values into DB-only fields (like id or roles).
3ï¸âƒ£ Validation â†’ DTO can have @NotNull, @Email annotations to validate payload before saving.
4ï¸âƒ£ Different Structures â†’ Payload structure (form/JSON) may not exactly match DB structure. DTO solves this mismatch.