🔷 SpringBoot
A framework built on top of Spring Framework that simplifies the development of production-ready Spring applications by removing boilerplate configuration.

🔄Key Features:
➤ Auto-Configuration → Automatically configures Spring application based on dependencies in the classpath.
➤ Starter Dependencies → Predefined dependency sets (e.g., spring-boot-starter-web, spring-boot-starter-data-jpa) to reduce manual configuration.
➤ Embedded Servers → Comes with Tomcat, Jetty, Undertow embedded servers, so no need to deploy WAR files separately.
➤ Production Ready → Provides health checks, metrics, logging, and monitoring with Spring Boot Actuator.
➤ Convention over Configuration → Focus more on logic, less on XML/bean configuration.

🔄 Advantages:
➤ Rapid development of Java apps (especially REST APIs and microservices).
➤ Reduces boilerplate code.
➤ Easier integration with databases, security, and cloud platforms.

✅  Real World Example:
➤ A company wants to build a RESTful microservice for user authentication.
➤ Using Spring Boot, developers just add spring-boot-starter-security and spring-boot-starter-web.
➤ No need to configure servlet containers or security filters manually.
➤ Application runs directly with java -jar app.jar.


🔷 Data Flow in a Spring Boot Application
[ User Interface (UI) ]
          |
          v
[ Controller Layer ]
   - Handles HTTP requests
   - Validates input
          |
          v
[ Service Layer ]
   - Business logic
   - Coordinates between controller & repository
          |
          v
[ Repository Layer (DAO) ]
   - Database operations (CRUD)
          |
          v
[ Database ]
   - Stores & retrieves data

🔄 Reverse flow from DB---> to UI
[ Database ] -> [ Repository Layer ] -> [ Service Layer ] -> [ Controller Layer ] -> [ User Interface ]


1️⃣ User Interface (UI)
User interacts with the app (webpage, mobile app, Postman request, etc.).

2️⃣ Controller Layer
➤ Handles incoming HTTP requests (@RestController).
➤ Validates input and forwards data to the Service Layer.
✅ Example: UserController -> createUser()

3️⃣ Service Layer
➤ Contains business logic.
➤ Coordinates between Controller and Repository.
✅ Example: check if user already exists, encrypt password.

4️⃣ Repository Layer (DAO)
➤ Talks to the Database.
➤ Usually interfaces extending JpaRepository or CrudRepository.

5️⃣ Database (DB)
Stores and retrieves actual data (MySQL, PostgreSQL, MongoDB, etc.).


📌 In interviews, they often ask:
👉 “Why do we need the Service Layer if Controller can directly call Repository?”
Answer:
✔️ To keep business logic separate from request handling.
✔️ For reusability (other controllers or services can use it).
✔️ For testability (unit test services independently).


✅ Example Scenario: User Registration
🔄 JSP Setup in Spring Boot
➤ JSP files should be placed inside: src/main/webapp/WEB-INF/views/
➤ Configure prefix & suffix in application.properties:
    ✔️ spring.mvc.view.prefix=/WEB-INF/views/
    ✔️ spring.mvc.view.suffix=.jsp
➤ Add dependency: tomcat-embed-jasper for JSP rendering.

🔄 Controller Layer
➤ Use @Controller for handling web views (not @RestController).
➤ @RequestMapping("/view") maps the request URL to a view.
➤ Return value = JSP file name (without prefix/suffix).

🔄 Execution Flow
User Request → Controller → Returns view name → ViewResolver adds prefix & suffix → Loads JSP

1️⃣  JSP File → registration.jsp

src/main/webapp/WEB-INF/views/registration.jsp
🔗 Code:
<%@ page contentType="text/html; charset=UTF-8" language="java" %>
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Register</title>
</head>
<body>
    <h2>Register here...</h2>
</body>
</html>

2️⃣ application.properties

spring.application.name=app
spring.mvc.view.prefix=/WEB-INF/views/
spring.mvc.view.suffix=.jsp

3️⃣ Maven Dependency (pom.xml)
<dependency>
    <groupId>org.apache.tomcat.embed</groupId>
    <artifactId>tomcat-embed-jasper</artifactId>
</dependency>

4️⃣ Controller Class → EmployeeController.java
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class EmployeeController {

    @RequestMapping("/view")
    public String viewRegisterPage() {
        return "registration"; // resolves to /WEB-INF/views/registration.jsp
    }
}
👉 When user accesses http://localhost:8080/view
👉 The registration.jsp page is displayed.

📒 Annotations Explanation
🔄 @Controller
➤ Marks the class as a Spring MVC Controller.
➤ Tells Spring: “This class will handle web requests and return views (JSP, Thymeleaf, etc.).”
➤ Unlike @RestController, it does not return JSON directly; instead, it returns view names.

🔄 @RequestMapping("/view")
Maps HTTP requests (like http://localhost:8080/view) to a method in the controller.

➤ In this case:
    ✔️ When user hits /view, Spring calls viewEmployeePage().
    ✔️ The method returns "employee".
    ✔️ Spring’s ViewResolver adds prefix + suffix → /WEB-INF/views/employee.jsp.

⚡ Flow with Annotations
User → http://localhost:8080/view
   ↓
DispatcherServlet (Spring Front Controller)
   ↓
@Controller class (EmployeeController)
   ↓
@RequestMapping("/view") method → returns "registration"
   ↓
ViewResolver applies prefix/suffix → /WEB-INF/views/registration.jsp
   ↓
JSP rendered to user

🌟 Specialized Annotations of @RequestMapping
👉 @GetMapping
➤ Handles HTTP GET requests.
➤ Equivalent to:
@RequestMapping(value = "/view", method = RequestMethod.GET)

👉 @PostMapping
➤ Handles HTTP POST requests (commonly for form submissions or creating resources).
➤ Equivalent to:
@RequestMapping(value = "/add", method = RequestMethod.POST)

👉 @PutMapping
Handles HTTP PUT requests (used for updating resources).

👉 @DeleteMapping
Handles HTTP DELETE requests (used for deleting resources).

👉 @PatchMapping
Handles HTTP PATCH requests (used for partial updates).

✅ Example:
@Controller
public class EmployeeController {

    @GetMapping("/register")
    public String showForm() {
        return "registration"; // loads registration.jsp
    }

    @PostMapping("/register")
    public String submitForm() {
        // handle form submission logic
        return "success";
    }
}

🔷 Spring Boot Stand-Alone Application
A Spring Boot app that can run independently without requiring deployment to an external server (like Tomcat or JBoss).

🔄 Key Points:
➤ Run with a simple main() method (just like a normal Java program).
➤ Uses an embedded server (Tomcat, Jetty, Undertow).
➤ No need to install or configure external application servers.
➤ Packaged as an executable JAR (java -jar app.jar).

🔄 Why Important?
➤ Fast setup → no server installation overhead.
➤ Easier deployment (just share JAR).
➤ Ideal for microservices architecture.

🔷 Spring MVC (Model–View–Controller)
➤ A web framework in the Spring ecosystem.
➤ Follows the MVC design pattern → separates Model (data), View (UI), and Controller (logic).
➤ Used to build web applications and REST APIs.

🌟 Work Flow of MVC:
1️⃣ User Request
User hits a URL (e.g., /home) or submits an HTML form.

2️⃣ DispatcherServlet (Front Controller)
Central entry point → intercepts all requests.

3️⃣ Controller Layer
➤ DispatcherServlet finds matching method (@GetMapping, @PostMapping, etc.).
➤ Controller executes business logic with help of Service/Model.

4️⃣ Model
➤ It allows the controller to send data (attributes) to the view.
➤ The view can then access and display that data.
➤ Model in Spring is an interface, not a class

5️⃣ ViewResolver
Maps view name to actual JSP/HTML file.

6️⃣ View (Response)
JSP/HTML page is returned to the user with dynamic data.

👉 Some Annotations in Spring
🔗 @Component
It is a stereotype annotation in Spring that marks a class as a Spring-managed bean.

🔁 Key Points:
✔️ Bean Creation → When Spring performs component scanning, it finds classes annotated with @Component and creates their objects (beans) inside the IOC container.
✔️ Dependency Injection → Once managed, these beans can be injected into other classes using @Autowired (or constructor injection).
✔️ Generic Role → Unlike specialized annotations like @Service, @Repository, or @Controller, @Component is generic and can be applied to any class.
✔️ Bean Name → By default, the bean name is the class name with the first letter in lowercase. (e.g., MyHelper → myHelper).
✔️ Scope → Default scope is singleton, but it can be changed with @Scope("prototype"), etc.

🔗 Specialized Annotations (built on top of @Component)
👉 @Service → Marks business logic classes (semantically meaningful).
👉 @Repository → Marks DAO (Data Access) classes, adds exception translation.
👉 @Controller → Marks controller classes in Spring MVC.
👉 @RestController → @Controller + @ResponseBody (returns JSON/XML directly).

✅ Example of @Component:
import org.springframework.stereotype.Component;

@Component
public class EmailService {
    public void sendEmail(String to, String message) {
        System.out.println("Sending email to " + to + ": " + message);
    }
}
And then inject it:
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class NotificationService {
    private final EmailService emailService;

    @Autowired
    public NotificationService(EmailService emailService) {
        this.emailService = emailService;
    }

    public void notifyUser(String user, String msg) {
        emailService.sendEmail(user, msg);
    }
}
👉 Here, EmailService is marked as @Component, Spring manages it, and NotificationService can inject and use it. 

🔷 ModelMap in Spring MVC
ModelMap is a Spring MVC helper class used to pass data (key-value pairs) from a controller to the view layer (JSP, Thymeleaf, etc.).

🔄 Key Points:
    ✔️ Wrapper Around Map → Works like a HashMap<String, Object> to store attributes.
    ✔️ Controller → View Communication → Data added to ModelMap in a controller method is available in the view template.
    ✔️ Type Safety → Strongly typed compared to using a plain Map.
    ✔️ Convenience Methods → Provides easy addAttribute() methods for chaining.
    ✔️ Scope → Attributes live only for that request, not across sessions (unlike @SessionAttributes).

✅ Example
import org.springframework.stereotype.Controller;
import org.springframework.ui.ModelMap;
import org.springframework.web.bind.annotation.GetMapping;

@Controller
public class HomeController {

    @GetMapping("/home")
    public String homePage(ModelMap model) {
        // Adding data to ModelMap
        model.addAttribute("username", "Ankur");
        model.addAttribute("role", "Full Stack Developer");

        // Returns the view name (home.jsp or home.html)
        return "home";
    }
}

⚡ View (home.jsp)
<html>
<body>
    <h1>Welcome, ${username}!</h1>
    <p>Your role is: ${role}</p>
</body>
</html>


👉 When user visits /home, the page will render:
Welcome, Ankur!
Your role is: Full Stack Developer

🆚 Difference with Similar Types
Model → Interface to pass data (commonly used).
ModelMap → Implementation of Map with convenience methods.
ModelAndView → Wraps both Model (data) + View (page name).

✅ Example Scenario 2: Data submission with JSP in Spring Boot 
1️⃣ JSP Page → registration.jsp

src/main/webapp/WEB-INF/views/registration.jsp

<%@ page contentType="text/html; charset=UTF-8" language="java" %>
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Register</title>
</head>
<body>
    <h2>Register here</h2>
    <form action="saveReg" method="post">
        <pre>
First Name: <input type="text" name="firstName"/>
Last Name:  <input type="text" name="lastName"/>
Email Id:   <input type="text" name="email"/>
Mobile:     <input type="text" name="mobile"/>
<input type="submit" value="Save"/>
        </pre>
    </form>
    ${msg}
</body>
</html>

➤ Provides a form for user input.
➤ On submit, data is sent to /saveReg via POST.
➤ ${msg} displays confirmation message from controller.

2️⃣ Entity → Employee.java
package com.app.entity;

import jakarta.persistence.*;

@Entity
public class Employee {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "first_name", nullable = false)
    private String firstName;

    @Column(name = "last_name", nullable = false)
    private String lastName;

    @Column(nullable = false, unique = true)
    private String email;

    @Column(nullable = false, unique = true)
    private String mobile;

    //contructors, getters, setters

}

➤ Represents the Employee table in DB.
➤ Fields → mapped to columns with @Column.
➤ @Id + @GeneratedValue → auto-generated primary key.

3️⃣ Repository → EmployeeRepository.java
package com.app.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import com.app.entity.Employee;

public interface EmployeeRepository extends JpaRepository<Employee, Long> {}

➤ Extends JpaRepository.
➤ Spring Boot auto-implements methods like save(), findAll(), etc.

4️⃣ Service → EmployeeService.java
package com.app.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import com.app.entity.Employee;
import com.app.repository.EmployeeRepository;

@Service
public class EmployeeService {

    @Autowired
    private EmployeeRepository employeeRepository;

    public void saveEmployee(Employee employee) {
        employeeRepository.save(employee);
    }
}

➤ Business logic layer.
➤ Uses @Autowired to inject repository.
➤ Method saveEmployee() saves employee to DB.

🌟 Annotations used
👉 @Service
➤ Marks class as Service Layer component → holds business logic.
➤ Helps with component scanning & makes it clear this class belongs to the service layer.

👉 @Autowired
➤ Enables Dependency Injection.
➤ Spring automatically injects the required bean (here: EmployeeRepository).

5️⃣ Controller → EmployeeController.java
package com.app.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import com.app.entity.Employee;
import com.app.service.EmployeeService;

@Controller
public class EmployeeController {

    @Autowired
    private EmployeeService employeeService;

    // Load registration form
    @RequestMapping("/view")
    public String showRegistrationPage() {
        return "registration"; // resolves to registration.jsp
    }

    // Handle form submission
    @PostMapping("/saveReg")
    public String handleRegistration(@ModelAttribute Employee employee, Model model) {
        employeeService.saveEmployee(employee);
        model.addAttribute("msg", "Record saved successfully!");
        return "registration";
    }
}
🌟 Annotations used
👉 @Controller
➤ Marks class as Spring MVC Controller (handles requests, returns view names).

👉 @ModelAttribute
➤ Bind form data / request parameters directly to a Java object.
➤ Expose data to the view layer before rendering.

🔁 Two Main Use Cases of ModelAttribute
1️⃣  Method Parameter Binding
➤ Automatically maps request parameters → Java object fields.
➤ Saves you from calling request.getParameter() manually.

✅ Example:
@Controller
public class EmployeeController {

    @PostMapping("/register")
    public String registerEmployee(@ModelAttribute Employee emp) {
        // Spring automatically binds form fields to Employee object
        System.out.println(emp.getName() + " - " + emp.getEmail());
        return "success";
    }
}

Form (JSP):
<form action="/register" method="post">
    Name: <input type="text" name="name"/>
    Email: <input type="text" name="email"/>
    <button type="submit">Register</button>
</form>
👉 Spring will automatically populate Employee.name and Employee.email from the form.

2️⃣ Method Level Usage
Adds common attributes to the Model before every controller method.

✅ Example:
@Controller
public class HomeController {

    // Runs before every @RequestMapping method
    @ModelAttribute
    public void addCommonData(Model model) {
        model.addAttribute("appName", "Employee Portal");
    }

    @GetMapping("/home")
    public String homePage() {
        return "home";  // appName will be available in the view
    }
}

🔗 View (home.jsp):
<h2>Welcome to ${appName}</h2>

❓ Difference between @RequestParam and @ModelAttribute?
👉 @RequestParam → binds single request parameter (e.g., ?id=101).
👉 @ModelAttribute → binds entire form/request into a Java object.

➤ /view → loads the JSP form.
➤ /saveReg (@PostMapping) → receives form data as Employee object, calls service, adds success message to Model, and returns back to JSP.

6️⃣ application.properties
spring.application.name=app

spring.mvc.view.prefix=/WEB-INF/views/
spring.mvc.view.suffix=.jsp

spring.datasource.url=jdbc:mysql://localhost:3306/appdb
spring.datasource.username=root
spring.datasource.password=test

spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect

➤ Configures DB connection, view resolver (prefix/suffix), Hibernate settings.

❓ Why Constructor Injection is Better than Field Injection (@Autowired)
🔄 Field Injection
@Service
public class UserService {
    @Autowired
    private UserRepository userRepository;  // field injection
}

🔄 Constructor Injection
@Service
public class UserService {

    private final UserRepository userRepository;

    @Autowired  // optional since Spring 4.3+
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
}
🔄 Why Constructor Injection is Preferred:

1️⃣ Immutability (Good Design Principle)
➤ Dependencies are final → can’t be changed after object creation.
➤ Makes your beans immutable, leading to safer and more predictable code.

private final UserRepository userRepository; // final ensures immutability

2️⃣ Easier for Unit Testing
➤ With field injection, you need reflection or Spring context to test.
➤ With constructor injection, you can easily pass mock objects manually.

✅ Example:
❌ Field Injection (hard to test):
UserService service = new UserService();
ReflectionTestUtils.setField(service, "userRepository", mockRepo);

✅ Constructor Injection (easy to test):
UserService service = new UserService(mockRepo);

3️⃣ Detects Missing Dependencies at Compile Time
➤ Constructor injection ensures all required dependencies are provided during bean creation.
➤ If any dependency is missing → Spring throws an error immediately.
➤ Field injection, on the other hand, can fail at runtime — leading to NullPointerException.
✅ Example:
❌ Field Injection (compile-time error):
UserService service = new UserService();
service.userRepository = mockRepo;

✅ Constructor Injection (no compile-time error):
UserService service = new UserService(mockRepo);

4️⃣ Encourages Better Design
➤ If a constructor has too many parameters, it signals too many dependencies — i.e. your class is doing too much (violates Single Responsibility Principle).
➤ Hence, constructor injection naturally enforces clean architecture.

5️⃣ Works Better with @RequiredArgsConstructor (Lombok)
➤ Lombok can automatically generate constructor injection for all final fields:

@Service
@RequiredArgsConstructor
public class UserService {
    private final UserRepository userRepository;
    private final EmailService emailService;
}
👉 This is clean, concise, and immutable.

6️⃣ Avoids Circular Dependency Problems
➤ Constructor injection fails fast if circular dependencies exist (e.g., A → B → A), making them easier to detect.
➤ Field injection might allow circular dependencies silently and fail later in runtime.

7️⃣ Works with @Profile or @Conditional Beans Easily
➤ Since dependencies are clearly defined in constructors, it’s straightforward for Spring to determine which beans to inject per profile/environment.


🔷 Payload and DTO in SpringBoot
❓ What is a Payload?
In Spring Boot (and in general web development), a payload is the data sent by the client (browser, Postman, frontend app) to the server in an HTTP request.

✅ Example: When you fill a form and click Submit, all form fields (firstName, lastName, email, etc.) are sent as the payload of the HTTP request.

🔄 Types of Payload:
➤ Form Data (like in your JSP form)
➤ JSON/XML Payload (common in REST APIs)

👉 In your example:
When the user submits the registration.jsp form, this data is sent as payload:

🔗 Code Block (registration.jsp)
<body>
	<h2>Register here..</h2>
	<form action="saveReg" method="post">
		<pre>
			First Name   <input type="text" name="firstName"/>
			Last Name    <input type="text" name="lastName"/>
			Email Id     <input type="text" name="email"/>
			Mobile       <input type="text" name="mobile"/>
			City         <input type="text" name="city"/>
			State        <input type="text" name="state"/>
			Pincode      <input type="text" name="pinCode"/>
			Address Line <input type="text" name="addressLine"/>
			<input type="submit" value="Save"/>
		</pre>
	</form>
	${msg}
</body>

firstName=John
lastName=Doe
email=john@gmail.com
mobile=1234567890
city=Delhi
state=Delhi
pinCode=110001
addressLine=Street 5, XYZ
👉 This is the request payload.

❓ What is a DTO (Data Transfer Object)?
A DTO is a Java class created to receive, hold, and transfer the payload data between different layers of the application.

🔄 Purpose:
➤ Prevents direct use of Entity for input/output.
➤ Provides loose coupling between database structure and client requests.
➤ Helps with validation, security, and clean separation of concerns.

👉 In your example:
The payload (form data) is mapped to EmployeeDto.java:

public class EmployeeDto {
    private String firstName;
    private String lastName;
    private String email;
    private String mobile;

    private String city;
    private String state;
    private int pinCode;
    private String addressLine;

    // getters and setters
}
👉 When the user submits the form → Spring automatically binds request payload → this EmployeeDto object using @ModelAttribute.

❓ How Payload and DTO Work Together in above Example
Step 1️⃣:  Payload Submission
User fills the form → clicks Save → Payload sent:
firstName=John&lastName=Doe&email=john@gmail.com&mobile=12345&city=Delhi&state=Delhi&pinCode=110001&addressLine=Street 5

Step2️⃣: Controller Receives Payload via DTO
🔗 EmployeeController.java
@Controller
public class EmployeeController {
	
	@Autowired
	private EmployeeService employeeService;

	@GetMapping("/view")
	public String viewRegisterPage() {
		return "employee";
	}
	
	@PostMapping("/saveReg")
	public String saveEmployee(@ModelAttribute EmployeeDto employeeDto, Model model) {
		employeeService.saveEmployeeDetails(employeeDto);
		model.addAttribute("msg", "Record is saved successfully!");
        return "employee";
	}
}
➤ @ModelAttribute EmployeeDto employeeDto → Spring automatically maps form fields (payload) to EmployeeDto fields.

✅ Example:
    ✔️ firstName → employeeDto.setFirstName("John")
    ✔️ city → employeeDto.setCity("Delhi")

🔗 Address.java (Entity)
package com.app.entity;

import jakarta.persistence.*;

@Entity
public class Address {
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private long id;

	private String city;
	private String state;
	private int pinCode;
	private String addressLine;

	// Getters & Setters
}

Step 3️⃣: Service Converts DTO → Entities
EmployeeService.java

@Service
public class EmployeeService {
	
	@Autowired
	private EmployeeRepository employeeRepository;
	
	@Autowired
	private AddressRepository addressRepository;
	
	public void saveEmployeeDetails(EmployeeDto employeeDto) {
		// Convert DTO → Entity
		Employee emp = new Employee();
		BeanUtils.copyProperties(employeeDto, emp);
		employeeRepository.save(emp);
		
		Address address = new Address();
		BeanUtils.copyProperties(employeeDto, address);
		addressRepository.save(address);
	}
}
➤ DTO is not directly saved in DB.
➤ Instead:
    ✔️ Employee entity stores employee-specific info.
    ✔️ Address entity stores address info.
    ✔️ BeanUtils.copyProperties() copies data from DTO → Entities.

❓ Why Not Use Entity Instead of DTO?
Imagine you bound form data directly to Employee entity:

public String saveEmployee(@ModelAttribute Employee employee) { ... }

❗ Problems:
1️⃣ Tight Coupling → If DB schema changes, your form & API also break.
2️⃣ Security Risk → Someone could inject malicious values into DB-only fields (like id or roles).
3️⃣ Validation → DTO can have @NotNull, @Email annotations to validate payload before saving.
4️⃣ Different Structures → Payload structure (form/JSON) may not exactly match DB structure. DTO solves this mismatch.