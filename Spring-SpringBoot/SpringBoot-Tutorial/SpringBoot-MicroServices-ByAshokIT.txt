🔷 Architecture Types: Monolithic vs Microservices
1️⃣ Monolithic Architecture
A single unified codebase where all modules (UI, business logic, database access, etc.) are packaged and deployed together as one application.

🔄 Characteristics:
➤ Single codebase and build.
➤ Runs as one process.
➤ Tight coupling between components.
➤ Shared database for the whole app.

🔄 Advantages:
➤ Simple to develop and deploy initially.
➤ Easy debugging and testing since everything is in one place.
➤ Performance can be faster due to in-process calls (no network latency).

🔄 Disadvantages:
➤ Scalability bottleneck → must scale the entire application even if only one module needs resources.
➤ Hard to maintain and add new features as the codebase grows (becomes a “big ball of mud”).
➤ Technology lock-in (all parts must use the same stack).
➤ Fault isolation is poor → one bug can crash the entire system(Single Point of Failure).

🔄 Use Cases:
➤ Small-scale applications.
➤ Early-stage startups with limited complexity.
➤ Systems that won’t require frequent scaling or modularity.

2️⃣ Microservices Architecture
A collection of small, independent services that work together. Each service focuses on a single business capability and communicates via APIs (HTTP/gRPC, message queues, etc.).

🔄 Characteristics:
➤ Services are loosely coupled.
➤ Independent deployment, scaling, and development.
➤ Each microservice may have its own database (polyglot persistence).

🔄 Advantages:
➤ Scalability: Scale only the services that need extra resources.
➤ Flexibility: Different services can use different tech stacks.
➤ Faster development and deployment cycles (parallel teams working independently).
➤ Better fault isolation: A failure in one service doesn’t necessarily bring down the whole system.

🔄 Disadvantages:
➤ Operational complexity → needs service discovery, API gateways, monitoring, logging, distributed tracing.
➤ Network latency and data consistency issues (distributed system challenges).
➤ More difficult testing (end-to-end across services).
➤ Requires strong DevOps culture (CI/CD, containerization, orchestration like Kubernetes).

🔄 Use Cases:
➤ Large-scale applications (Amazon, Netflix, Uber).
➤ Systems needing high scalability, flexibility, or frequent updates.
➤ Teams spread across different domains who want autonomy.

🔄 Comparison
➤ Deployment: Monolithic → one unit | Microservices → many independent units
➤ Scalability: Monolithic → entire app | Microservices → per service
➤ Flexibility: Monolithic → one stack | Microservices → polyglot possible
➤ Complexity: Monolithic → simple | Microservices → complex (network + ops)
➤ Best for: Monolithic → small apps | Microservices → large, evolving systems


🔷 API (Application Programming Interface)
A set of rules and protocols that allows two software systems to communicate with each other.

👉 Role: Acts as a bridge between different applications, hiding internal logic and exposing only necessary functionalities.
✔️ Provides abstraction → only exposes endpoints, not implementation.
✔️ Ensures interoperability → different platforms/languages can interact.
✔️ Enables reusability → same service can be consumed by web, mobile, etc.
✔️ Statelessness (in REST) → each request is independent.

Types:
➤ REST API (HTTP-based, widely used)
➤ SOAP API (XML-based, older enterprise systems)
➤ GraphQL (query-based, flexible data fetching)
➤ gRPC (high-performance, binary protocol)

✅ Real-World Example
Google Maps API:
    ✔️ Apps like Uber, Zomato, Ola don’t build maps themselves.
    ✔️ They call Google Maps API to fetch location, directions, and distance.
    ✔️ API request: Send coordinates → API response: Returns map data & routes.


🔷 Spring Framework
Spring Framework is called as Application Development Framework.
By using spring we can develop end to end enterprise applications.
It is an open-source framework.
Spring developed in modular fashion.
So we can use required modules as per our need.

🔷 Spring Modules
1️⃣ Spring Core: 
➤ It is the fundamental module of the Spring framework. 
➤ It  is all about managing dependencies among the classes with loosely coupling.
➤ It provides the basic features of the Spring framework:
    ✔️ Inversion of Control (IoC) 
    ✔️ Dependency Injection (DI).
    ✔️ Bean Life cycles
    ✔️ Bean Scopes
    ✔️ Autowiring etc..
In project we will develop serveral classes. All those classes we can catergorize into 3 types:
    📝 POJO (Plain Old Java Object) Classes: These classes will contain only properties and their getters and setters(ordinary java class).

    📝 Java Bean Classes: Any class that follows bean specification rules.
    🔄 Rules of bean specification:
        👉 It should have a public no-argument constructor.
        👉 Properties should be private with public getters and setters.
        👉 It should be serializable (implements Serializable interface).
        ⚡ Notes: 
            1️⃣ All Java Beans are POJOs but all POJOs are not Java Beans.
            2️⃣ Bean classes are used to write business logic and to store and retrieve data.

    📝 Component Classes: Java class which contains business Classes logic and annotated with @Component annotation.
        👉 It is a special type of bean class.
        👉 It is used to define various layers of an application like Controller, Service, Repository etc..
        👉 Controller classes will have logic to deal with request and response.
        👉 Service classes will have business logic of out project.
        👉 DAO classes will contain the logic to communicate with database.

2️⃣ Spring Context
➤ It is built on top of the Spring Core module.
➤ It uses the concept of ApplicationContext which is a central interface to provide configuration for an application.
➤ It provides support for internationalization (i18n), event propagation, resource loading, and application-layer specific contexts such as WebApplicationContext for web applications.


3️⃣ Spring JDBC
➤ It provides a simplified approach to interact with relational databases using JDBC (Java Database Connectivity).
➤ It handles the creation and release of resources, which helps to avoid common errors such as forgetting to close database connections.
➤ It provides a JdbcTemplate class that simplifies the execution of SQL queries, updates, and stored procedures.

❌ Problems with JDBC:In java JDBC, developers often have to write a lot of boilerplate code for tasks like opening/closing connections, handling exceptions, and managing transactions. This can lead to repetitive and error-prone code. Spring JDBC addresses these issues by providing a higher-level abstraction that simplifies database interactions.


4️⃣ Spring AOP (Aspect Oriented Programming)
➤ It provides support for aspect-oriented programming, allowing the separation of cross-cutting concerns or secondary logic (like logging, security, and transaction management) from the main business logic.
Example: Security, Logging, Transaction, Exception Handling etc..

❌ Problems with AOP: If we combine business logic and cross-cutting concerns in the same class, it can lead to code that is hard to read and maintain. AOP helps to separate these concerns, making the code cleaner and more modular.


5️⃣ Spring Web MVC
➤ It provides a set of tools for building web applications and Distributed Applications using the Model-View-Controller (MVC) architectural pattern.
    ✔️  Applications: Applications which are developed using web technologies like HTML, CSS, JavaScript etc.. and run on web browsers.For Example: Gmail, Facebook, Amazon etc..
    ✔️ Distributed Applications: Applications which are developed in a distributed environment. For Example: IRCTC communicates with MakeMyTrip, Paytm etc.. to book tickets.
➤ It supports RESTful web services and provides features like data binding, validation, and view resolution.


6️⃣ Spring ORM
➤ It provides integration with popular Object-Relational Mapping (ORM) frameworks like Hibernate, JPA (Java Persistence API), and MyBatis.
➤ It simplifies the configuration and management of ORM frameworks, allowing developers to focus on writing business logic rather than boilerplate code. 

Note: JDBC will represent data in text format whereases ORM will represent data in object format.

7️⃣ Spring security
➤ It provides a comprehensive security framework for Java applications, including authentication, authorization, and protection against common security threats.
➤ It supports various authentication mechanisms, including form-based login, HTTP Basic authentication, and OAuth2.0


8️⃣ Spring Social
9️⃣ Spring Batch
➤ It provides support for batch processing, allowing the execution of large volumes of data in a reliable and efficient manner.
➤ It provides features like chunk-based processing, transaction management, and job scheduling.
➤ It simplifies the development of batch applications, making it easier to handle complex data processing tasks.



1️⃣0️⃣ Spring Test
➤ It provides tools for testing Spring applications, including unit tests, integration tests, and end-to-end tests.
➤ It supports various testing frameworks like JUnit, Mockito, and TestNG.


1️⃣1️⃣ Spring Cloud
➤ It provides tools for building cloud-native applications, including service discovery, load balancing, and distributed configuration management.
➤ It simplifies the development of microservices-based architectures, making it easier to build and deploy scalable and resilient applications.
➤ It provides monitoring facilities, circuit breakers, and retry mechanisms to handle failures gracefully. 
➤ Distributed Messaging: It supports various messaging systems like RabbitMQ, Kafka, and ActiveMQ, allowing microservices to communicate asynchronously.
➤ Routing and Load Balancing: It provides tools for routing requests to different microservices and load balancing traffic to ensure high availability and performance.

👉 Spring is a flexible framework. It will not force to use all the modules. Based on requirements we can pickup particular modules and we can use it.
👉 Spring is a versatile framework(Easily it can be integerated with other frameworks).

🔷 Work Flow of Spring Framework
➤ Developer will write the code using POJO classes, Bean classes and Component classes.
➤ Spring Container will create the objects of POJO classes, Bean classes and Component classes.

🔄 In a project multiple classes will be dependent on each other.
✅ For Example:
➤ Controller class is dependent on Service class.
➤ Service class is dependent on DAO class.
➤ DAO class is dependent on Database.

🔄 In Java one class can communicate with another class in 2 ways:
1. Inheritance(Is-A Relationship)
2. Composition or Object Reference(Has-A Relationship)


📝 Java Reflection API
➤ Reflection API in Java = Mechanism to inspect and manipulate classes, methods, fields, and constructors at runtime.
➤ Part of java.lang.reflect package.
➤ Lets you bypass compile-time checks and work dynamically.
👉 In simple words: Reflection allows Java programs to analyze or modify runtime behavior of objects and classes.

🔄 Key Features of Reflection
✔️ Get class information at runtime (Class.forName, getClass()).
✔️ Create objects dynamically (clazz.getDeclaredConstructor().newInstance()).
✔️ Access private fields & methods (setAccessible(true)).
✔️ Call methods dynamically (method.invoke()).
✔️ Useful when class/method names are not known at compile-time.

🔄 Use Cases of Reflection
👉 Frameworks (Spring, Hibernate) use reflection to create and inject objects without new.
👉 Dependency Injection (DI) → like assigning engine into Car dynamically.
👉 Testing tools (JUnit, Mockito) → access private methods/fields.
👉 Serialization libraries (Jackson, Gson) → inspect fields and methods.
👉 Plugins / Runtime loading → load classes dynamically.

✅Example: 
import in.ankur.reflection.Car;
import in.ankur.reflection.PetrolEngine;
import java.lang.reflect.Field;

public class Main {
    public static void main(String[] args) throws Exception {
        ➤ Loads Car class dynamically using its name (string).
        ➤ We don’t user new Car() directly.
        Class<?> clazz = Class.forName("in.ankur.reflection.Car");

        ➤ Creates a Car object at runtime without using new Car().
        Object object = clazz.getDeclaredConstructor().newInstance();
        Car carObj = (Car) object;

        ➤ Gets a reference to the private field engine.
        Field engineField = clazz.getDeclaredField("engine");

        ➤ Bypasses Java’s access modifier restrictions (private → accessible).
        engineField.setAccessible(true);  // break encapsulation

        ➤ Injects a PetrolEngine object into Car’s private engine field.
        engineField.set(carObj, new PetrolEngine());

        ➤ Now Car uses the injected engine to perform its logic.
        carObj.drive();
    }
}


🔷 Setter Injection using XML Configuration
🔗 IEngine.java Interface
package com.ankur;

public interface IEngine {
public int start();
}

✔️ Interface are used to pefrom loosely coupling between the classes so that dependency injection can be done.

🔗 PetrolEngineImpl.java Class
package com.ankur;

public class PetrolEngineImpl implements IEngine {
	
public PetrolEngineImpl() {
	System.out.println("PetrolEngine object created");
}

	@Override
	public int start() {
		System.out.println("Petrol Engine Started");
		return 1;
	}
}
✔️ Implementation of IEngine interface as PertrolEngineImpl class

🔗 DieselEngineImpl.java Class
package com.ankur;

public class DieselEngineImpl implements IEngine {
	
	public DieselEngineImpl() {
		System.out.println("DieselEngine object created");
	}

	@Override
	public int start() {
		System.out.println("Diesel Engine Started");
		return 1;
	}
}
✔️ Implementation of IEngine interface as DieselEngineImpl class

🔗 Car.java Class
package com.ankur;

public class Car {
	private IEngine iEngine;
	
	public Car() {
		System.out.println("Car constructor");
	}

	//setter dependency engine
	public void setIEngine(IEngine iEngine) {
		System.out.println("Set Engine method called"+ iEngine);
		this.iEngine = iEngine;
	}

	public void drive() {
		int start = iEngine.start();
		if (start == 1) {
			System.out.println("Journey Started");
		} else {
			System.out.println("Engine Problem");
		}
	}
}
✔️ Car class is performing dependency injection of IEngine interface by setter method
🌟 Note: If you are writing the setter then the paramters should be same as IEngine interface name in Car class and should follow the setter naming convention otherwise spring will not recognize the setter method.

🔗 Beans.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
           http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans.xsd">

    👉 Step 1
    <bean id="petrolEng" class="com.ankur.PetrolEngineImpl"/>
    <bean id="dieselEng" class="com.ankur.DieselEngineImpl"/>
    
    👉 Step2
    <bean id="car" class="com.ankur.Car">
    <!-- Property is used to perform setter injection -->
    <property name="iEngine" ref="petrolEng"></property>
   </bean>
</beans>
✔️ Define all the classes you want to make beans in the beans.xml file.
✔️ Then add the <property> tag to the <bean> tag to perform setter injection as
✔️ Property tag is used to perform the dependency injection
✔️ ref attribute is used to give the ref of the class you want to inject into the property name.

🔗 SpringStarterApp.java Class
package com.main;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import com.ankur.Car;

public class SpringStarterApp {

	public static void main(String[] args) {
		ApplicationContext context =
                new ClassPathXmlApplicationContext("Beans.xml");
		Car car=context.getBean("car",Car.class);
		car.drive();
	}
}
✔️ ApplicationContext is used to load the beans.xml file.
✔️ Then get the Car class object by calling the getBean method of ApplicationContext.

🔄 Use of Car.class:
    ➤ In Java, every type has a corresponding Class object that represents its metadata at runtime.
    ➤ Car.class is a class literal → it gives you the Class<Car> object that represents the Car type.

    🔑 Why Spring needs it
        👉 In context.getBean("car", Car.class):
            →  "car" → the bean id from your Beans.xml.
            →  Car.class → tells Spring what type you expect back.
        👉 Spring will then:
            →  Look up the bean with id "car".
            →  Check if its actual type is assignable to Car.

    ➤ Car.class is the runtime representation of the Car type, and in Spring it makes bean retrieval type-safe (no casting errors).
✔️ Then call the drive method of Car class to perform the dependency injection.