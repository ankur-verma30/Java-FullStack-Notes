ğŸ”· SpringBoot
â¤ SpringBoot is a framework that simplifies the development of Spring applications by providing a set of pre-configured features and tools.
â¤ SpringBoot=Spring - XML configuration.
â¤ It makes easy to create stand-alone, production-grade spring based application that you can just run.
â¤ SpringBoot is not a replacement for Spring Framework. It was developed on top of Spring Framework to provide a more simplified and efficient way to develop Spring applications.

ğŸ”„ Key Features
â¤ Auto-Configuration â†’ Automatically configure Spring application based on dependencies in the classpath.
â¤ Starter Dependencies â†’ Predefined dependency sets (e.g., spring-boot-starter-web, spring-boot-starter-data-jpa) to reduce manual configuration.
â¤ Embedded Servers â†’ Comes with Tomcat, Jetty, Undertow embedded servers, so no need to deploy WAR files separately.
â¤ Production Ready â†’ Provides health checks, metrics, logging, and monitoring with Spring Boot Actuator.
â¤ Convention over Configuration â†’ Focus more on logic, less on XML/bean configuration.


ğŸ”· SpringBBoot Application Folder Structure
â¤ src/main/java
â¤ src/main/resources
â¤ src/test/java
â¤ src/test/resources
â¤ target
â¤ pom.xml


ğŸ”· SpringBoot Main Method
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
â¤ It is enterpoint for boot application execution
â¤ @SpringBootApplication annotation is equal to 3 annotations:
    âœ”ï¸ @SpringBootConfiguration
    âœ”ï¸ @EnableAutoConfiguration
    âœ”ï¸ @ComponentScan
â¤ SpringBoot start class will act as a configuration class because of the @SpringBootConfiguration annotation.
â¤ @EnableAutoConfiguration annotation tells SpringBoot to auto-configure beans based on classpath dependencies.
â¤ @ComponentScan annotation scans the package (and sub-packages) of the class for components (@Component, @Service, @Repository, @Controller, etc.).

âš¡ Note:Package naming Convention will play a major role in compoenent scanning.
âœ…Example:  basePackage = com.tcs.vechiles
â¤ There should be one basePackage for all the packages, subpackages should be made inside this basePackage.
â¤ If we have multiple basePackage we have to manually tell the SpringBootApplication which package to scan by using @ComponentScan annotation and passing the array of basePackages.  


ğŸ”· SpringApplication.run() Method
â¤ It is used to start the Spring Boot application.
â¤ It takes 2 arguments:
    âœ”ï¸ Application class
    âœ”ï¸ Command-line arguments
â¤ SpringApplication.run() method takes care of configuring the embedded server and other necessary components.
â¤ It is the entry point for the Spring Boot application. This method will return reference of IOC.
â¤ It starts the Spring application context and also starts the embedded server.

âœ…Example:
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        ConfigurableApplicationContext context = SpringApplication.run(Application.class, args);
        System.out.println(context.getClass().getName());
    }
}

â¤ SpringApplication is a Predefined class and it will identify what type of application we have created based on dependencies added in pom.xml file:
    âœ”ï¸ standalone (spring-boot-starter)
        âš¡ ClassName: AnnotationConfigApplicationContext
    âœ”ï¸ web app (spring-boot-starter-web)
        âš¡ ClassName: AnnotationConfigServletWebServerApplicationContext
    âœ”ï¸ reactive-application (spring-boot-starter-webflux) etc.
        âš¡ ClassName: AnnotationConfigReactiveWebServerApplicationContext
ğŸ‘‰ If all there dependencies are added priority is given to web app.

â¤ If we want to remove the banner of the spring in application.properties file we can add:
ğŸ”— spring.main.banner-mode=off      ----> have 3 modes off, console, log

â¤ If we want to change the banner message we can add:
ğŸ”— spring.banner.image.location=classpath:banner.txt    ----> will print the banner message from this file
â¤ Or we can put the banner.txt file inside the src/main/resources folder where out application.properties file is there.

URL is:  https://patorjk.com/software/taag/#p=display&f=ANSI%20Shadow&t=SpringBoot


ğŸ”· Runners In SpringBoot
â¤ When a Spring Boot application starts, sometimes you want to run custom logic â€” for example:
    âœ”ï¸ Loading initial data into the database
    âœ”ï¸ Sending a notification at startup
    âœ”ï¸ Checking configurations
    âœ”ï¸ Running background tasks
â¤ For this, Spring Boot provides two special interfaces:
ğŸ‘‰ CommandLineRunner
ğŸ‘‰ ApplicationRunner

ğŸ”„ CommandLineRunner
This interface lets you run code after the Spring context is loaded (i.e., after all beans are initialized).

âœ… Example
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

@Component
public class MyStartupRunner implements CommandLineRunner {

    @Override
    public void run(String... args) throws Exception {
        System.out.println("Application started! Running initial setup...");
        // You can call a service, load data, etc.
    }
}
â“ What happens here:
When your Spring Boot app starts,
It automatically calls the run() method after all beans are created and the application context is ready.

ğŸ”„ ApplicationRunner
This is almost identical to CommandLineRunner,
but it provides a more structured way to access application arguments via the ApplicationArguments object.

âœ… Example
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.stereotype.Component;

@Component
public class MyAppRunner implements ApplicationRunner {

    @Override
    public void run(ApplicationArguments args) throws Exception {
        System.out.println("ApplicationRunner executing...");
        if (args.containsOption("debug")) {
            System.out.println("Debug mode is enabled!");
        }
    }
}
âœ”ï¸ You can now start your app with:
java -jar myapp.jar --debug

âœ”ï¸ And it will print:
ApplicationRunner executing...
Debug mode is enabled!

ğŸ”„ Difference Between CommandLineRunner and ApplicationRunner
| Feature          | CommandLineRunner | ApplicationRunner                                         |
| ---------------- | ----------------- | --------------------------------------------------------- |
| Arguments Type   | `String... args`  | `ApplicationArguments`                                    |
| Argument Parsing | Manual            | Built-in support for options and non-option args          |
| Use Case         | Simple tasks      | When you need to access or parse command-line args easily |


ğŸ”„ Execution Order
â¤ If both CommandLineRunner and ApplicationRunner are defined, they will run in the order they are declared in the application context.

â¤ If you have multiple runners, you can control their order using the @Order annotation.

import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;
import org.springframework.boot.CommandLineRunner;

@Component
@Order(1)
public class FirstRunner implements CommandLineRunner {
    @Override
    public void run(String... args) {
        System.out.println("Runner 1 executed");
    }
}

@Component
@Order(2)
public class SecondRunner implements CommandLineRunner {
    @Override
    public void run(String... args) {
        System.out.println("Runner 2 executed");
    }
}
âœ… Output:
Runner 1 executed
Runner 2 executed

ğŸ”„ Use Cases
| Use Case                | Description                                      |
| ---------------------   | ------------------------------------------------ |
| âœ… Data Initialization | Insert default users, roles, or configurations   |
| âœ… Validation          | Check environment variables or configs           |
| âœ… Logging             | Log startup details                              |
| âœ… Integration         | Trigger background processes when the app starts |

â“ When is a Runner executed?
âœ… After the Spring ApplicationContext is fully initialized but before the application is ready to receive requests.

â“ Difference between @PostConstruct and Runners?
@PostConstruct: Runs right after bean initialization.
Runners: Run after the entire Spring context is initialized (i.e., all beans are ready).


=========================================================================
ğŸ”· Which Dependency Injection is Better â€” Field, Setter, or Constructor?
=========================================================================
â¤ Spring supports three main types of Dependency Injection (DI):
    âœ”ï¸ Field Injection
    âœ”ï¸ Setter Injection
    âœ”ï¸ Constructor Injection
1ï¸âƒ£ Field Injection (@Autowired directly on fields)
âœ… Example:
@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;

    public void getUser() {
        System.out.println(userRepository.findAll());
    }
}
âš™ï¸ How it works:
ğŸ‘‰ Spring uses reflection to set the dependency field directly, even if itâ€™s private.

âš ï¸ Disadvantages:
âŒ Not testable easily â€“ canâ€™t inject mock dependencies manually for unit testing.
âŒ Hidden dependencies â€“ dependencies arenâ€™t visible in the constructor.
âŒ No immutability â€“ dependencies canâ€™t be declared final.
âŒ Difficult for mandatory dependencies â€“ Spring doesnâ€™t enforce that the field must be set.

ğŸ‘‰ Field injection is considered the worst practice for maintainable and testable code.

2ï¸âƒ£ Setter Injection
âœ… Example:
@Service
public class UserService {

    private UserRepository userRepository;

    @Autowired
    public void setUserRepository(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public void getUser() {
        System.out.println(userRepository.findAll());
    }
}
âœ… Advantages:
â¤ Allows optional dependencies (useful if bean might not always be required).
â¤ Makes it easier to change dependencies later.

âš ï¸ Disadvantages:
â¤ Not suitable for mandatory dependencies.
â¤ Object can be created without a dependency, which can lead to NullPointerException.
â¤ Still not fully immutable.

3ï¸âƒ£ Constructor Injection (Recommended âœ…)
âœ… Example:
@Service
public class UserService {

    private final UserRepository userRepository;

    @Autowired  //----------â¤ Not required since Spring 4.3+
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public void getUser() {
        System.out.println(userRepository.findAll());
    }
}

âœ… Advantages:
ğŸ’ª Immutable dependencies â†’ mark fields as final.
ğŸ§  Clear dependencies â†’ visible in the constructor.
ğŸ§ª Best for testing â†’ easy to pass mock objects in unit tests.
ğŸ” Ensures all mandatory dependencies are available during bean creation.
ğŸ’¡ Recommended by Spring Team (and used by Spring itself internally).

â¤ From Spring Framework 4.3 onward, if a class has only one constructor, Spring automatically injects dependencies â€” no need for @Autowired.

ğŸ”„ Comparison
| Feature                    | Field Injection | Setter Injection | Constructor Injection |
| -------------------------- | --------------- | ---------------- | --------------------- |
| Visibility                 | Hidden          | Visible          | Visible               |
| Immutability               | âŒ No           | âŒ No           | âœ… Yes                |
| Testability                | âŒ Poor        | âš™ï¸ Medium        | âœ… Best               |
| Optional Dependencies      | âš™ï¸ Medium      | âœ… Yes           | âŒ No                 |
| Mandatory Dependencies     | âŒ Risky        | âš™ï¸ Medium       | âœ… Best               |
| Spring Recommendation      | âŒ No           | âš™ï¸ Sometimes    | âœ… Yes                |

â¤ Adding all 3 types of DI in one class is not a good practice. It creates confusion and makes the code hard to maintain.
â¤ Choose one type of DI per class, preferably constructor injection for better maintainability and testability.

==========================================
ğŸ”· @Component vs @Service in Spring Boot
==========================================
â¤ Both @Component and @Service are annotations used in Spring to define beans, but they serve different purposes and convey different semantics. 
| Annotation   | Description                                                                                                     |
| ------------ | --------------------------------------------------------------------------------------------------------------- |
| `@Component` | Generic stereotype annotation that marks a class as a Spring-managed bean.                                      |
| `@Service`   | A specialized type of `@Component used to mark classes that hold business logic or service-layer code.          |

ğŸ”„ What They Do Internally
âœ… Both @Component and @Service
â¤ Register the class as a bean in the Spring ApplicationContext
â¤ Enable dependency injection via @Autowired.

ğŸ‘‰ In short:
@Service = @Component + Semantic meaning (used for service/business layer)

ğŸ”„ Layer Meaning in Spring 
| Layer                | Annotation                        | Purpose                                   |
| -------------------- | --------------------------------- | ----------------------------------------- |
| Controller Layer     | `@Controller` / `@RestController` | Handles web requests (presentation layer) |
| Service Layer        | `@Service`                        | Contains business logic                   |
| Repository Layer     | `@Repository`                     | Deals with persistence (database access)  |
| Generic Bean         | `@Component`                      | Used for any other general-purpose bean   |

âœ… Example: Using @Component
@Component
public class EmailValidator {
    public boolean isValid(String email) {
        return email.contains("@");
    }
}
â¤ Registered as a Spring Bean.
â¤ Can be injected anywhere:
@Autowired
private EmailValidator validator;

âœ… Example: Using @Service
@Service
public class UserService {
    public void registerUser(User user) {
        // business logic for registration
    }
}
â¤ Also a Spring Bean.
â¤ But used to represent business logic layer.

ğŸ”„ Key Difference â€” Intent and Semantics
| Feature                               | `@Component`         | `@Service`                                             |
| ------------------------------------- | -------------------- | ------------------------------------------------------ |
| Purpose                               | Generic bean         | Business logic layer                                   |
| Spring Behavior                       | Registers bean       | Registers bean (same behavior)                         |
| Semantic Meaning                      | Can be used anywhere | Indicates service-level component                      |
| AOP (Aspect-Oriented Programming)     | No special behavior  | May be used by Spring for transactional or proxy logic |
| Readability                           | Less descriptive     | More expressive for business services                  |

ğŸ”„ AOP (Aspect-Oriented Programming) Note
â¤ Spring often applies aspects (like @Transactional, @Async, etc.) at the service layer.
So using @Service:
â¤ Helps Spring automatically detect it as a target for business logicâ€“related aspects.

======================
ğŸ”· @Value Annotation
======================
In Spring Boot, the @Value annotation is used to inject values into fields, method parameters, or constructor arguments directly from:
âœ”ï¸ application.properties / application.yml
âœ”ï¸ Environment variables
âœ”ï¸ System properties
âœ”ï¸ Expression Language (SpEL)

ğŸ”„ Syntax
@Value("${property.key}")
private String value;
ğŸ‘‰ Spring replaces ${property.key} with the actual value from application.properties (or other sources).

âœ… Example 1: Injecting from application.properties
ğŸ”— application.properties
app.name=WeatherApp
app.version=1.0.3

ğŸ”— Java Class
@Component
public class AppConfig {
    
    @Value("${app.name}")
    private String appName;

    @Value("${app.version}")
    private String version;

    public void printDetails() {
        System.out.println(appName + " - " + version);
    }
}
âœ… Output:
WeatherApp - 1.0.3


âœ… Example 2: Default Value
If the property doesnâ€™t exist, you can provide a default value:

@Value("${app.description:Default Description}")
private String description;

âœ… Example 3: Injecting System or Environment Variables
You can directly access environment/system variables:
@Value("${JAVA_HOME}")
private String javaHome;

âœ… Example 4: Using SpEL (Spring Expression Language)
You can perform calculations or logic:
@Value("#{2 * 10}")
private int value; // 20

@Value("#{systemProperties['user.home']}")
private String userHome;

âœ… Example 5: Injecting Lists or Arrays
ğŸ”— application.properties

app.cities=Delhi,Mumbai,Bangalore

ğŸ”— Java Class
@Value("${app.cities}")
private List<String> cities;

ğŸ”„ When to Use @Value
â¤ For simple property injection (like strings, numbers, or constants).
â¤ When you donâ€™t need a full configuration class.

ğŸ”„ Better Alternative for Multiple Values â†’ @ConfigurationProperties
For injecting multiple related properties, prefer:

@ConfigurationProperties(prefix = "app")
public class AppConfig {
    private String name;
    private String version;
    // getters & setters
}
âœ… Cleaner and easier to maintain for grouped properties.

ğŸ”· application.properties vs application.yml in Spring Boot
1ï¸âƒ£ application.properties (Default format)
This is a key-value pair file.

âœ… Example:
# Server Configuration
server.port=8081

# Database Configuration
spring.datasource.url=jdbc:mysql://localhost:3306/testdb
spring.datasource.username=root
spring.datasource.password=1234

ğŸ§  Syntax Rules:
Each property is a key=value pair.
Hierarchical configs use dots (.).
Comments start with #.
Easy for simple configurations, but harder for nested data.

2ï¸âƒ£ application.yml ((Yet Another Markup Language)YAML format)
YAML is a human-readable hierarchical format (preferred for complex configs).

âœ… Example:
server:
  port: 8081

spring:
  datasource:
    url: jdbc:mysql://localhost:3306/testdb
    username: root
    password: 1234

ğŸ§  Syntax Rules:
Uses indentation (spaces, not tabs) to define hierarchy.
No = or : for nesting â€” just indentation.
Supports arrays/lists easily.

Example with list:
emails:
  - ankur@gmail.com
  - test@example.com

You can use both files together â€” Spring Boot automatically merges them.
Priority order:
application.properties (if defined later)
application.yml (if both exist, last loaded wins)

Properties files are used only in java language based projects.
YAML files can be used in any language based projects.


However, in real-world projects â€”
ğŸ‘‰ prefer YAML (.yml) for readability & structure,

ğŸ”„ Advantages of YAML over Properties:
| Feature            | `.properties` | `.yml`                      |
| ------------------ | ------------- | ------------------------    |
| Readability        | âŒ Average     | âœ… Excellent              |
| Hierarchical Data  | âŒ Complex     | âœ… Natural                |
| Array/List Support | âŒ Hard        | âœ… Easy                   |
| Structure          | Flat          | Nested                      |
| Popularity         | Legacy style  | Modern Spring Boot style    |
| Comments           | âœ… Supported   | âœ… Supported (`#`)        |


ğŸ”„ Profile-Specific Configurations
Spring Boot allows multiple environment profiles (e.g. dev, test, prod).

You can define profile-specific files:
application-dev.yml
application-prod.yml
application-test.yml

Then activate one in your main config:

In application.properties
spring.profiles.active=dev

In application.yml
spring:
  profiles:
    active: dev
In YML, multiple profiles can be configured in single YML file(three dashes --- is used to separate the profiles)
âœ…Example:
--- spring:
  profiles: dev
server:
  port: 8081

--- spring:
  profiles: prod
server:
  port: 8082


ğŸ”· Spring MVC
Spring MVC (Model-View-Controller) is a web framework within the Spring Framework used to build web applications (both traditional and RESTful).

It follows the MVC design pattern, which separates the application into:
â¤ Model â†’ Data & Business logic
â¤ View â†’ User Interface
â¤ Controller â†’ Request handling

ğŸ§  Goal of Spring MVC
To separate concerns and make the application flexible, maintainable, and testable.

âš™ï¸ Architecture Overview
Client (Browser)
   â†“
DispatcherServlet  â†â”€â”€ Front Controller
   â†“
HandlerMapping
   â†“
Controller
   â†“
Service / DAO / Model
   â†“
ViewResolver
   â†“
View (HTML / JSP / Thymeleaf / JSON)
   â†“
Response to Client

1ï¸âƒ£ Client sends request
â¤ A user makes a request (e.g., /patients).
â¤ The request first reaches the DispatcherServlet, the Front Controller.

2ï¸âƒ£ DispatcherServlet
â¤ Itâ€™s the central controller of the Spring MVC framework.
â¤ It delegates the request to appropriate components.
â¤ Defined in web.xml or automatically configured in Spring Boot.

3ï¸âƒ£ HandlerMapping
â¤ Determines which controller should handle the incoming request.
â¤ Uses annotations like @RequestMapping, @GetMapping, etc.

4ï¸âƒ£ Controller
Contains request-handling methods (business logic triggers).

âœ… Example:

@Controller
public class PatientController {

    @GetMapping("/patients")
    public String getPatients(Model model) {
        List<Patient> list = patientService.getAllPatients();
        model.addAttribute("patients", list);
        return "patientsView"; // logical view name
    }
}

5ï¸âƒ£ Model
â¤ Represents data that will be displayed in the view.
â¤ Often filled by the controller (via Model, ModelMap, or ModelAndView).

6ï¸âƒ£ ViewResolver
Resolves the logical view name (like "patientsView") to an actual view (e.g., patientsView.jsp or patients.html).

âœ… Common examples:
InternalResourceViewResolver â†’ JSP
ThymeleafViewResolver â†’ HTML template

7ï¸âƒ£ View
â¤ The actual UI component (e.g., JSP, Thymeleaf, React frontend, etc.)
â¤ Displays the model data and sends the final HTML (or JSON) to the browser.

8ï¸âƒ£ Response to Client
The generated view is returned to the DispatcherServlet, which sends it back as an HTTP response.

ğŸŒŸ Client can send data to server in three ways:
1ï¸âƒ£ Query Parameters (?key=value)
â¤ Data is sent in the URL after a ?, as key-value pairs.
â¤ Often used for filtering, searching, or optional parameters.
â¤ Query parameters are only present at the end of the url.
â¤ Query parameters are less secure as they are visible in the URL.
 
âœ… Example URL:
GET /patients?age=30&gender=male

âœ… Example:
@GetMapping("/patients")
public List<Patient> getPatients(
        @RequestParam int age,
        @RequestParam String gender) {
    return patientService.getByAgeAndGender(age, gender);
}
â¤ Use @RequestParam annotation.
â¤ Works only with GET or DELETE (not ideal for POST).
â¤ Data visible in URL (less secure).
â¤ Great for filtering/sorting/pagination.

2ï¸âƒ£ Path Parameters (Dynamic Part of URL)
â¤ Data is part of the URI path itself.
â¤ Used to identify a specific resource.
â¤ Path parameters can be present anywhere in the url.

âœ… Example URL:
GET /patients/101

âœ… Example:
@GetMapping("/patients/{id}")
public Patient getPatientById(@PathVariable Long id) {
    return patientService.getPatient(id);
}
â¤ Use @PathVariable annotation.
â¤ Used for resource identification (like ID, username, etc.).
â¤ RESTful & clean URLs.
â¤ More semantic than query params for IDs.

3ï¸âƒ£ Request Body
â¤ Data is sent inside the HTTP request body, not in the URL.
â¤ Used to send complex objects, JSON, or large data (e.g., user info, forms).

âœ… Example Request:
POST /patients
Content-Type: application/json
{
  "name": "Ankur Verma",
  "age": 25,
  "gender": "Male"
}

âœ… Example:
@PostMapping("/patients")
public Patient createPatient(@RequestBody Patient patient) {
    return patientService.save(patient);
}
â¤ Use @RequestBody annotation.
â¤ Works with POST, PUT, PATCH.
â¤ Ideal for sending JSON/XML payloads.
â¤ Must set appropriate Content-Type (e.g., application/json).

Spring Web MVC module provide Form Tag library to simplify form handling.
<form:form/>
<form:input/>
<form:errors/>
<form:label/>
<form:select/>
<form:password/>

âœ…Example:

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
    <h2>Login Here...</h2>
    <form action="login" method="post">
        <label>Email: </label> <input type="text" name="email" /> <br /> <label>Password:
        </label> <input type="password" name="password" /> <br /> <input
            type="submit" value="login" />
    </form>
</body>
</html>

ğŸ”· H2 database
H2 Database is a lightweight, fast, open-source relational database written in Java. Itâ€™s often used for development, testing, and small-scale production applications, especially when you donâ€™t want to set up a full external database like MySQL or PostgreSQL.

âš™ï¸ Key Features
â¤ -memory & file-based modes:
    âœ”ï¸ In-memory mode: Data is stored in RAM (deleted when app stops).
    âœ”ï¸ File-based mode: Data is stored on disk (persistent).
â¤ Pure Java: Runs anywhere Java runs.
â¤ Embedded or Server mode:
    âœ”ï¸ Embedded: Runs inside your application.
    âœ”ï¸ Server: Can be accessed remotely via TCP.
â¤ Compatible with JDBC & SQL: Fully supports standard SQL syntax.
â¤ Browser-based console: Comes with an easy-to-use web UI at http://localhost:8082.

Very fast startup & execution speed.

ğŸ§© Common Use Case
â¤ In Spring Boot projects, H2 is used for:
â¤ Quickly testing your JPA or Hibernate code.
â¤ Running unit/integration tests without needing MySQL/PostgreSQL.
â¤ Prototyping new applications before connecting to a real database.

âœ… Example (Spring Boot Application)
application.properties

spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=
spring.h2.console.enabled=true

Now you can access the database console at:
ğŸ‘‰ http://localhost:8080/h2-console

ğŸ—ƒï¸ Example Query
CREATE TABLE users (
  id INT AUTO_INCREMENT PRIMARY KEY,
  name VARCHAR(50),
  email VARCHAR(50)
);

INSERT INTO users (name, email) VALUES ('Ankur', 'ankur@example.com');
SELECT * FROM users;

âš¡ Advantages
â¤ Extremely lightweight and fast.
â¤ No setup required.
â¤ Ideal for testing and development.
â¤ 
ğŸš« Limitations
â¤ Not designed for high concurrency or large-scale production.
â¤ Data in memory mode is temporary.
â¤ Limited performance compared to enterprise DBs like PostgreSQL or MySQL. 


ğŸ”· @Valid Annottion and Binding result in Spring Boot
To enable validation in our spring project we have to add dependency:
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>

â¤ @Valid is used to trigger validation on an object (usually a request body or form input) before it reaches your controller logic.
â¤ It works with Jakarta Bean Validation (JSR-380) â€” typically using annotations like:
âœ”ï¸ @NotNull
âœ”ï¸ @NotEmpty
âœ”ï¸ @Size
âœ”ï¸ @Email
âœ”ï¸ @Min, @Max, etc.

âœ… Example: Using @Valid in a Controller
import jakarta.validation.Valid;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/users")
public class UserController {

    @PostMapping("/register")
    public String registerUser(@Valid @RequestBody User user, BindingResult result) {
        if (result.hasErrors()) {
            return "Validation failed: " + result.getAllErrors();
        }
        return "User registered successfully!";
    }
}

ğŸ§± User Entity Example
import jakarta.validation.constraints.*;

public class User {

    @NotEmpty(message = "Name cannot be empty")
    private String name;

    @Email(message = "Invalid email format")
    private String email;

    @Min(value = 18, message = "Age must be at least 18")
    private int age;

    // Getters and Setters
}

ğŸ”„ BindingResult in Spring Boot
â¤ BindingResult is used right after the @Valid annotated object.
â¤ It captures validation errors detected during the validation process.
â¤ It must immediately follow the validated parameter in the method signature, or Spring will throw an exception.

âš ï¸ Example â€” Wrong Order (will not work)
// âŒ Incorrect
public String registerUser(BindingResult result, @Valid @RequestBody User user) { ... }


âœ… Correct Order:
public String registerUser(@Valid @RequestBody User user, BindingResult result) { ... }

ğŸ”„ What BindingResult Contains
ğŸ”— result.hasErrors() â†’ checks if there are validation errors
ğŸ”— result.getAllErrors() â†’ returns all validation messages
ğŸ”— result.getFieldErrors() â†’ returns only field-specific errors

ğŸ”„ Typical Use Case Flow
â¤ Client sends JSON data to endpoint
â¤ Spring validates it using @Valid and annotations in the DTO
â¤ If errors exist â†’ captured in BindingResult
â¤ Controller handles validation failure gracefully (instead of 400 Bad Request)

âœ… Example Output (if invalid data sent)
Request Body:
{
  "name": "",
  "email": "invalid",
  "age": 15
}

âœ… Response:
Validation failed: [Field error in object 'user' on field 'name': rejected value []; 
 message: Name cannot be empty,
 Field error in object 'user' on field 'email': rejected value [invalid]; 
 message: Invalid email format,
 Field error in object 'user' on field 'age': rejected value [15]; 
 message: Age must be at least 18]


â“ How to configure Jetty as embedded server?
Even if you remove the spring-boot-starter-tomact-dependency from pom.xml file it will still work.
for that we have to use exclusions

<exclusions>
  <exclusion>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-tomcat</artifactId>
  </exclusion>
</exclusions>

<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-jetty</artifactId>
</dependency> 

@RestController is used to send direct response to client without any view files.


ğŸ”· Interceptor in Spring Web MVC
An Interceptor in Spring MVC is a component that intercepts HTTP requests and responses â€”
before they reach the controller and after the controller has executed.

Think of it as a middleware that can:
â¤ Pre-process requests (like checking authentication)
â¤ Post-process responses (like adding custom headers)
â¤ Handle after-completion logic (like logging or cleanup)

ğŸ”„ Use Case of Interceptor
â¤ Calculate each request processing time
â¤ Log Request and Response details
â¤ Add custom headers to responses
â¤ Add analytics/tracking events

âœ… Example: Interceptor in Spring Boot
import org.springframework.web.servlet.HandlerInterceptor;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

public class LoggingInterceptor implements HandlerInterceptor {

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        System.out.println("â¡ï¸ Request URL: " + request.getRequestURL());
        return true; // continue to controller
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, 
                           Object handler, org.springframework.web.servlet.ModelAndView modelAndView) {
        System.out.println("âœ… Controller executed successfully.");
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, 
                                Object handler, Exception ex) {
        System.out.println("ğŸ Request completed.");
    }
}

ğŸ”„ Microservices / Spring Boot REST APIs
    âœ”ï¸ Interceptors are still used, but less often for security, because:
    âœ”ï¸ Authentication/authorization is usually handled by Spring Security filters (JWT, OAuth2).
    âœ”ï¸ Cross-cutting concerns may be handled by AOP (Aspects) or Filters.
However, interceptors are still useful for:
    âœ”ï¸ API request/response logging
    âœ”ï¸ Adding custom headers (e.g., trace ID for distributed tracing)
    âœ”ï¸ Request timing or rate-limiting hooks
    âœ”ï¸ Analytics/tracking events before controller execution

ğŸ”„ In modern alternatives (Reactive apps)
â¤ For Spring WebFlux (reactive), the equivalent concept is called a WebFilter, not an interceptor.
â¤ So if the app is reactive, youâ€™ll rarely see traditional interceptors.


ğŸ”· Exception Handling in Spring MVC
1ï¸âƒ£ Using @ExceptionHandler (Method-Level)
Used inside a specific controller to handle exceptions thrown only by that controller.

@Controller
public class UserController {

    @GetMapping("/user/{id}")
    public String getUser(@PathVariable int id) {
        if (id <= 0)
            throw new IllegalArgumentException("Invalid ID");
        return "user";
    }

    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<String> handleInvalidId(IllegalArgumentException ex) {
        return ResponseEntity.badRequest().body(ex.getMessage());
    }
}
ğŸ“Œ Use when you want controller-specific exception handling.

2ï¸âƒ£ Using @ControllerAdvice (Global Exception Handling) or using @RestControllerAdvice
A class annotated with @ControllerAdvice applies to all controllers globally.

@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(Exception.class)
    public ResponseEntity<String> handleAll(Exception ex) {
        return ResponseEntity
                .status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body("Something went wrong: " + ex.getMessage());
    }

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<String> handleNotFound(ResourceNotFoundException ex) {
        return ResponseEntity
                .status(HttpStatus.NOT_FOUND)
                .body(ex.getMessage());
    }
}
ğŸ“Œ Best practice for production apps â€” keeps controllers clean.

3ï¸âƒ£ Using @ResponseStatus on Custom Exceptions
Attach HTTP status directly to an exception class.

@ResponseStatus(HttpStatus.NOT_FOUND)
public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String msg) {
        super(msg);
    }
}
Now if you throw new ResourceNotFoundException("User not found"),
Spring automatically returns a 404 response.

4ï¸âƒ£ Using ResponseEntityExceptionHandler (Framework-Level)
You can extend this base class to override built-in exception handling (like MethodArgumentNotValidException, HttpRequestMethodNotSupportedException, etc.).

@ControllerAdvice
public class CustomRestExceptionHandler extends ResponseEntityExceptionHandler {

    @Override
    protected ResponseEntity<Object> handleMethodArgumentNotValid(
        MethodArgumentNotValidException ex,
        HttpHeaders headers,
        HttpStatus status,
        WebRequest request) {

        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getFieldErrors().forEach(error ->
            errors.put(error.getField(), error.getDefaultMessage())
        );

        return new ResponseEntity<>(errors, HttpStatus.BAD_REQUEST);
    }
}
ğŸ“Œ Use this when you want to customize Springâ€™s built-in validation error responses.

ğŸ”„Hierarchy of Handling
If multiple exception handlers match:
    âœ”ï¸ Method-level @ExceptionHandler (highest priority)
    âœ”ï¸ @ControllerAdvice (global)
    âœ”ï¸ Default Spring error page (if not caught above)

âš¡ Example Flow
â¤ If /user/0 is requested:
    âœ”ï¸ IllegalArgumentException is thrown
    âœ”ï¸ Handled by either:
        â¤ @ExceptionHandler in UserController, OR
        â¤ global @ControllerAdvice, OR
        â¤ default Spring error JSON if none found