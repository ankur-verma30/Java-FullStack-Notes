🔷 SpringBoot
➤ Spring Boot is a framework for building application in the Java programming language. 
➤ It is built on top of the Spring framework and provides a simplified way to create stand-alone, production-grade Spring-based applications that can be easily deployed and run.
➤ The core spring framework already reduces bolierplate code and provides a lot of helpful features for Java applications.
➤ However, Spring Boot takes this convenience to the next level by focusing specifically on reducing the effort required to set up and configure Spring applications.
➤ While Spring does simplify many tasks like creating web applications, working with databases, managing transactions and many more. But setting a spring project can still involve quite bit of manual configuration.

Spring Boot provides:
1. Auto-configuration
2. Standaloene applications


🔷 SpringBootApplication annotation
➤ We use the @SpringBootApplication annotation on the main class. This single annotation replaces the need of setting up a manual Spring application context.
➤ We use SpringApplication.run() method to start the application and Spring Boot takes care of configuring the embedded server and other necessary components.
➤ The @SpringBootApplication annotation alone brings in a lot of pre-configured features, including automatic component scanning and embedded server configuration, which would have required more steps in a traditional Spring application.

🔷 Use of Maven and its importance --- refer to Maven.txt file


🔷 @SpringBootApplication?
➤ It’s a meta-annotation introduced in Spring Boot.
➤ Combines three important Spring annotations:
    ✔️@Configuration → marks class as a source of bean definitions.
    ✔️@EnableAutoConfiguration → tells Spring Boot to auto-configure beans based on classpath dependencies.
    ✔️@ComponentScan → scans the package (and sub-packages) of the class for components (@Component, @Service, @Repository, @Controller, etc.).

🟢 Working (Step-by-step)
1️⃣ App starts → SpringApplication.run(...) is called.
2️⃣ @SpringBootApplication kicks in:
    ✔️ Loads configurations (@Configuration).
    ✔️ Triggers auto-configuration (@EnableAutoConfiguration) → checks spring.factories for available configs.
    ✔️ Starts component scanning from the package of the main class.
3️⃣ Spring Context built → beans registered, dependencies injected.
4️⃣ Embedded server (Tomcat/Jetty/Undertow) starts if it’s a web app.


🔷 REST API
➤ REST = Representational State Transfer → an architectural style for designing networked applications.
➤ REST API = An API that follows REST principles → uses HTTP methods to perform operations on resources (data).
➤ Resources are identified by URIs (Uniform Resource Identifiers) and exchanged in formats like JSON / XML.

🔄 Core Principles of REST
➤ Stateless → Each request is independent; server doesn’t store client state.
➤ Client-Server → Separation of concerns (UI = client, data = server).
➤ Interface → Standard way to access resources (URIs + HTTP verbs).
➤ Resource-based → Everything is treated as a resource.
➤ Representation → Resource can be represented in multiple formats (JSON, XML).

🔄 HTTP Methods in REST
GET → Retrieve data.
POST → Create new resource.
PUT → Update/replace resource.
PATCH → Partially update resource.
DELETE → Remove resource.

✅ Example:
Endpoint:
GET /api/users/101

Meaning → Fetch details of user with ID = 101.
Response (JSON):
{
  "id": 101,
  "name": "Ankur",
  "email": "ankur@example.com"
}


🔷 ORM
➤ ORM = Object-Relational Mapping
➤ It’s a technique that lets developers interact with a database using objects instead of SQL queries.
➤ ORM automatically maps classes ↔ database tables and objects ↔ rows.
➤ It allows developers to work with databases using object-oriented programming concepts, making it easier to interact with relational databases.

✅ For Example:
✔️ Consider a Java class User and a database table users.
✔️ ORM framework like Hibernate can map the fields in the User class to columns in the users table, making it easier to insert, update, retrieve, and delete records.


🔷 JPA
➤ JPA = Java Persistence API.
➤ It’s a specification (interface) in Java for ORM (Object-Relational Mapping).
➤ Defines how Java objects should be mapped to relational database tables.
➤ To use JPA, you need a persistence provider. A persistence provider is a specific implementation of the JPA specification. 
✅ Examples include Hibernate, EclipseLink, and OpenJPA.
➤ This providers implement the JPA interfaces and provide the underlying functionality to interact with the database.

🔄 Use case of JPA
✔️ Standard way of ORM in Java (vendor-independent).
✔️ Simplifies database interaction → reduces boilerplate JDBC code.
✔️ Provides queries using JPQL (Java Persistence Query Language) instead of raw SQL.
✔️ Supports transactions, relationships, and more.


🔷 Spring Data JPA
➤ Spring Data JPA is a Spring project that builds on top of JPA.
➤ It makes working with databases even easier by removing boilerplate code (no need to write DAO classes manually).
➤ Provides ready-made repository interfaces to perform CRUD without writing queries.

🔄 Working of Spring Data JPA
✔️ You define a repository interface extending JpaRepository / CrudRepository.
✔️ Spring Data JPA creates implementation at runtime.
✔️ You can use method naming conventions or @Query to define custom queries.

⚡Note:

❗ Problem:
👉 JPA is primarily designed for working with relational databases, where data is stored in tables with a predefined schema. 
👉 MongoDB, on the other hand, is a NOSQL database that uses a different data model, typically based on collections of documents, which are schema-less or having flexible schemas. 
👉 This fundamental difference in data models means that JPA's ORM approach is not directly applicable to MongoDB.

✅ Solution:
👉 In case of MongoDB, you don't have a traditional JPA persistence provider. MongoDB is a NOSQL database and Spring Data MongoDB serves as the "persistence provider" for MongoDB.
👉 It provides the necessary abstraction and implementations to work with MongoDB in a Spring application.

🔄 Add dependency for Spring Data MongoDB in your Maven/Gradle configuration.

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-mongodb</artifactId>
</dependency>

🔄 Ways to Use Spring Data MongoDB
➤ Query Method DSL and Criteria API are two different ways to interact with a database when using Spring Data JPA for relational databases and Spring Data MongoDB for MongoDB.
  ✔️ Query Method DSL is a simple and convenient way to create queries based onn method naming conventions.
  ✔️ Criteria API offers a more dynamic and programatic approach for building complex and custom queries.

➤ Spring Data JPA is a part of Spring framework that simplifies data access in Java applications, while Spring Data MongoDB provides similar functionality for MongoDB.


🔷 @ResponseEntity
➤ ResponseEntity<T> → A Spring class used to represent the entire HTTP response (status, headers, body).
➤ Commonly used in REST APIs for precise control.
➤ It provides methods for setting the response status, headers, and body.
➤ You can use it to return different types of data in your controller methods such as JSON, XML, or plain text. 
➤ IT uses generics to specify the type of the response body.

❗ Confusion Alert:
➤ We often see things like:
return ResponseEntity.ok("Hello");

➤ And we also see annotations like @ResponseBody.
➤ That’s why many think @ResponseEntity exists — but it does not.

✅ Correction
➤ ResponseEntity (class) → Used in method return type.
➤ @ResponseBody (annotation) → Tells Spring to write the return object directly to HTTP response body (instead of resolving a view).
➤ @RestController (annotation) → Combines @Controller + @ResponseBody.

➤ An HTTP status code is a three-digit numeric code returned by a web server as parto of the response to an HTTP request made by a client.
➤ These status codes are used to convey information about the result or status of the requested operation.
➤ HTTP status codes are grouped into five categories based on the first digit of the code:
1️⃣ 1xx (Informational): These status codes indicate that the request was received and understood, and the server is continuing to process it.
These are typically used for informational purposes and are not commonly seen in everyday web interactions.

2️⃣ 2xx (Successful): These status codes indicate that the request was successfully received, understood, and accepted by the server.
  ✔️ 200 OK: The request has been successfully processed, and the server is returning the requested resource.
  ✔️ 201 Created: The request has been fulfilled, resulting in the creation of a new resource.
  ✔️ 204 No Content: The request has been fulfilled, but there is no response body(typically used for operation that don't return data, like a DELETE request).

3️⃣ 3xx (Redirection): These status codes indicate that further action is needed to complete the request. These are used when the client needs to take additional steps to access the requested resource.
  ✔️ 301 Moved Permanently: The requested resource has been permanently moved to a new URL.
  ✔️ 302 Found: The requested resource is temporarily located at a different URL.When server sends a response with a 302 status code, it typically includes a Location header that specifies the new URL where the resource can be found. The client is expected to make a new request to this URL to access the resource.
  ✔️ 304 Not Modified: The resource has not been modified since the last request. The client can use its cached version.

4️⃣ 4xx (Client Error): It indicates that there was an error on the client's side, such as malformed request or authentication issues.
  ✔️ 400 Bad Request: The server cannot process the request due to client error (e.g., malformed request syntax).
  ✔️ 401 Unauthorized: Authentication is required and has failed or has not yet been provided.
  ✔️ 403 Forbidden: The server understands the request but refuses to authorize it.
  ✔️ 404 Not Found: The requested resource could not be found on the server.

5️⃣ 5xx (Server Error): The server failed to fulfill a valid request.
  ✔️ 500 Internal Server Error: A generic error message indicating that the server encountered an unexpected condition.
  ✔️ 502 Bad Gateway: The server received an invalid response from an inbound server while acting as a gateway or proxy.
  ✔️ 503 Service Unavailable: The server is currently unable to handle the request due to temporary overload or maintenance.


🔷 Project Lombok
➤ Lombok is a Java library that reduces boilerplate code by using annotations.
➤ It generates common code like getters, setters, constructors, toString, equals, hashCode, builders, etc. at compile time.
➤ Achieved via annotation processing → IDE & compiler insert the code for you.

❓ Why use Lombok?
➤ Saves time → no need to manually write getters/setters.
➤ Makes code cleaner & readable.
➤ Reduces errors in repetitive boilerplate code.

🔄 Common Lombok Annotations
✔️ @Getter / @Setter → Generates getters & setters.
✔️ @ToString → Generates toString().
✔️ @EqualsAndHashCode → Generates equals() & hashCode().
✔️ @NoArgsConstructor / @AllArgsConstructor → Generates constructors.
✔️ @Data → Combines @Getter, @Setter, @ToString, @EqualsAndHashCode, @RequiredArgsConstructor.
✔️ @Builder → Provides builder pattern.
✔️ @Slf4j → Provides a ready-to-use logger.

✅ Example Without Lombok
public class Student {
    private int id;
    private String name;

    public Student() {}
    public Student(int id, String name) { this.id = id; this.name = name; }

    public int getId() { return id; }
    public void setId(int id) { this.id = id; }
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    @Override
    public String toString() { return "Student{id=" + id + ", name='" + name + "'}"; }
}

✅ Example With Lombok
import lombok.*;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class Student {
    private int id;
    private String name;
}
✅ Generates all boilerplate automatically (getters, setters, constructors, toString, equals, hashCode).


🔷 @Transactional Annotation
➤ @Transactional in Spring marks a method (or class) so that database operations inside it run within a single transaction.
➤ Either all succeed (commit) or all fail (rollback).
➤ Ensures ACID properties (Atomicity, Consistency, Isolation, Durability).

✅Example:
@Service
public class PaymentService {

    @Autowired
    private OrderRepository orderRepo;

    @Autowired
    private PaymentRepository paymentRepo;

    @Transactional
    public void processPayment(Order order, Payment payment) {
        orderRepo.save(order);       // Step 1
        paymentRepo.save(payment);   // Step 2

        // If any exception occurs here, both saves will rollback
    }
}
👉 Without @Transactional, if orderRepo.save() succeeds but paymentRepo.save() fails, you’d get inconsistent data. With @Transactional, both operations succeed or both rollback.

It can be applied at:
1️⃣ Method Level → Only that method runs in a transaction.
2️⃣ Class Level → All public methods in the class run in transactions.

Key Features

1️⃣ Rollback Rules
➤ By default, rolls back on unchecked exceptions (RuntimeException, Error).
➤ Checked exceptions don’t trigger rollback unless configured.

@Transactional(rollbackFor = Exception.class)
public void doWork() { ... }

2️⃣ Isolation Levels (how transactions interact with each other)
✔️ READ_COMMITTED (default in most DBs)
✔️ READ_UNCOMMITTED
✔️ REPEATABLE_READ
✔️ SERIALIZABLE

✅ Example:
@Transactional(isolation = Isolation.SERIALIZABLE)

3️⃣ Propagation (what happens if a method with a transaction calls another transactional method)
✔️ REQUIRED (default) → joins existing transaction or creates new one if none.
✔️ REQUIRES_NEW → always starts a new transaction.
✔️ MANDATORY → must run inside an existing transaction.
✔️ SUPPORTS, NOT_SUPPORTED, NEVER, NESTED.

✅ Example:
@Transactional(propagation = Propagation.REQUIRES_NEW)

4️⃣ Read-Only Transactions
Optimizes performance for queries.

@Transactional(readOnly = true)


🔷 Spring Security in Spring Boot
Spring Security is a powerful and highly customizable authentication and access-control framework for Java applications, particularly those built using the Spring framework. 
It provides a comprehensive set of features to secure applications against various threats, including authentication, authorization, and protection against common vulnerabilities.

🔄 dependency for Spring Security in Maven/Gradle configuration.
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>

➤ Once the dependency is added, Spring Boot automatically configures basic security settings for your application.
➤ It includes authentication, authorization, and session management by default.
➤ By default, Spring Security uses HTTP Basic Authentication it means that: 
  ✔️ The client sends an authorization header Authorizaiton:Basic<endcoded-credentials>.
  ✔️ The server decodes the string, extracts the username and password, and verifies them.
  ✔️ If they're correct access is granted, otherwise a 401 Unauthorized response is returned.

➤ Encoding Credentials are combined into a string like username:password and then encoded using Base64 encoding scheme.

➤ By default, all endpoints will be secured, Spring Security will generate a default user with a random password, which is printed in the console when the application starts if no user is created in the database.

➤ You can also configure username and password by setting properties in application.properties or application.yml file.
🔗 spring.security.user.name=your-username
🔗 spring.security.user.password=your-password
➤ You can customize the security settings by creating a configuration class that extends WebSecurityConfigurerAdapter and overrides the configure methods.

🔷 Code Implementation of Spring Security
🔗 SpringSecurity.java
package net.engineeringdigest.journalApp.config;

@Configuration
@EnableWebSecurity
public class SpringSecurity {
    //4. A configuration SecurityConfig to integrate everything with Spring Security.

    @Autowired
    private CustomUserDetailsServiceImpl userDetailsService;
    @Autowired
    private PasswordEncoder passwordEncoder;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http.authorizeHttpRequests()
                .antMatchers("/journal/**", "/user/**").authenticated()
                .anyRequest().permitAll()
                .and()
                .httpBasic();

        http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and().csrf().disable();

        return http.build();
    }

    @Autowired
    public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder);
    }
}

1️⃣ @Configuration
👉 Marks this class as a Spring Configuration class.
👉 Equivalent to an XML <beans> config file, but in Java-based configuration.
👉 Spring looks at this class and registers its beans in the Spring Application Context.

2️⃣ @EnableWebSecurity
👉 Enables Spring Security’s web security support.
👉 Without this, your configuration (HttpSecurity) would be ignored.
👉 Internally imports security filters and tells Spring Boot:
“Hey, use my custom security setup instead of defaults.”

3️⃣ @Autowired private CustomUserDetailsServiceImpl userDetailsService;
👉 Injects the CustomUserDetailsServiceImpl into the Spring Security configuration.
🔗 CustomUserDetailsServiceImpl.java class

@Component
public class CustomUserDetailsServiceImpl implements UserDetailsService {

    @Autowired
    private UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepository.findByUserName(username);
        if (user != null) {
            return org.springframework.security.core.userdetails.User.builder()
                    .username(user.getUserName())
                    .password(user.getPassword())
                    .roles(user.getRoles().toArray(new String[0]))
                    .build();
        }
        throw new UsernameNotFoundException("User not found with username: " + username);
    }
}
➤ CustomUserDetailsServiceImpl is your custom class that implements UserDetailsService.
⚡ Purpose:
👉 When a user tries to log in, Spring Security calls this service to load user details (username, password, roles).
✅ Example: you fetch user info from MongoDB / MySQL instead of in-memory users.

❓ What is happening in this Implementation class?
3️⃣.1️⃣ implements UserDetailsService
➤ UserDetailsService is a Spring Security interface.
➤ It has one method:
🔗 UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;

⚡ Purpose:
➤ Spring Security calls this method whenever a user tries to log in.
➤ You implement how the user is fetched (from DB, LDAP, API, etc.).
➤ Without this, Spring wouldn’t know how to authenticate against your custom database.

3️⃣.2️⃣ @Autowired private UserRepository userRepository;
➤ Injects your UserRepository (likely a JpaRepository / MongoRepository).
➤ Used to query the DB for a user by username.

✅ For example:
User user = userRepository.findByUserName(username);
👉 Here findByUserName is a custom finder method in your repository.

3️⃣.3️⃣ public UserDetails loadUserByUsername(String username)
➤ This is the main method executed during authentication.

⚡ Flow:
✔️ Spring Security extracts the username from login request.
✔️ Calls loadUserByUsername(username).
✔️ You query the DB for that user.
✔️ If found → build a UserDetails object and return.
✔️ If not found → throw UsernameNotFoundException.

3️⃣.4️⃣ User user = userRepository.findByUserName(username);
➤ Queries DB for a User entity.
➤ Your User entity probably looks something like:

@Document("users")
public class User {
    private String userName;
    private String password;
    private Set<String> roles;
}

3️⃣.5️⃣ Building UserDetails
return org.springframework.security.core.userdetails.User.builder()
        .username(user.getUserName())
        .password(user.getPassword())
        .roles(user.getRoles().toArray(new String[0]))
        .build();
👉 Here:
  ✔️ username(user.getUserName()) → sets the principal (login ID).
  ✔️ password(user.getPassword()) → sets the password (should be encoded with PasswordEncoder).
  ✔️ roles(user.getRoles()...) → converts your user’s roles into Spring Security authorities (like "ROLE_USER", "ROLE_ADMIN").
  ✔️ .build() → returns a fully constructed UserDetails object.

📌 Important:
➤ Spring Security internally uses its own User object (org.springframework.security.core.userdetails.User), not your entity.
➤ That’s why you map your entity → Spring Security UserDetails.

3️⃣.6️⃣ If User Not Found
➤ throw new UsernameNotFoundException("User not found with username: " + username);
➤ Spring Security catches this exception.
➤ It returns 401 Unauthorized to the client.

🔄 Authentication Flow with This Service
➤ Client calls /user API with HTTP Basic header (Authorization: Basic base64(username:password)).
➤ Spring Security extracts the username.
➤ Calls CustomUserDetailsServiceImpl.loadUserByUsername(username).
➤ Your code queries DB → returns user if found.
➤ Spring Security compares password (raw from request vs. encoded in DB).
➤ If match → authentication succeeds, SecurityContext is updated with the user.
➤ Now user can access protected endpoints.

✅ Why Do We Need This?
➤ Spring Security doesn’t know your DB structure.
➤ By implementing UserDetailsService, you bridge the gap between your DB and Spring Security.
➤ This allows you to:
  ✔️ Fetch users from MongoDB/MySQL/Postgres.
  ✔️ Support custom roles & permissions.
  ✔️ Control authentication logic.

4️⃣ @Autowired private PasswordEncoder passwordEncoder;
➤ Spring Security never stores raw passwords.
➤ PasswordEncoder (like BCryptPasswordEncoder) encodes passwords during registration and checks during login.
➤ Without this, Spring would throw errors like “There is no PasswordEncoder mapped for the id 'null'”.

👉 Example flow:
✔️ User enters password 12345.
✔️ Spring encodes it → $2a$10$skq...
✔️ Compares encoded form with stored password in DB.

5️⃣ @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http)
➤ This is the core of Spring Security config.
➤ It defines rules for how incoming HTTP requests are authenticated/authorized.

🔁.authorizeHttpRequests()
✔️ Starts the authorization configuration.
✔️ Decides which URL patterns need authentication.

🔁 .antMatchers("/journal/**", "/user/**").authenticated()
✔️ Any request to /journal/* or /user/* must be authenticated (user must log in).
✔️ If not authenticated → Spring returns 401 Unauthorized.

🔁 .anyRequest().permitAll()
✔️ Any other request is allowed without login.
✅ Example: /home, /about, /register → public pages.

🔁 .and().httpBasic()
✔️ Enables HTTP Basic Authentication:
✔️ Browser shows a popup asking for username:password.
✔️ Used mainly for APIs, not UI apps.
✔️ If this was .formLogin(), then you’d get a login page.

6️⃣ http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
➤ By default, Spring Security creates an HTTP session to store authentication state.
➤ STATELESS means:
  ✔️ No session is created.
  ✔️ Every request must send credentials (good for REST APIs + JWT).
  ✔️ Prevents storing anything in server memory → scalable microservice-style security.

7️⃣ .csrf().disable()
➤ CSRF = Cross-Site Request Forgery protection.
➤ By default, Spring requires a CSRF token for POST/PUT/DELETE requests.
➤ In APIs (especially with httpBasic or JWT), CSRF is usually disabled because:
  ✔️ APIs don’t use forms and cookies like traditional web apps.
  ✔️ Token-based security already prevents CSRF.
⚠️ But if you’re making a web app with forms, don’t disable CSRF!

8️⃣ @Autowired public void configureGlobal(AuthenticationManagerBuilder auth)
➤ This configures AuthenticationManager with your UserDetailsService and PasswordEncoder.
➤ Meaning:
  ✔️ When a user logs in → Spring calls userDetailsService.loadUserByUsername().
  ✔️ The password is checked using passwordEncoder.matches(raw, encoded).

⚙️ Flow of What Happens
➤ A user hits /user/update.
➤ Spring Security sees /user/** → requires authentication.
➤ If no login → return 401 Unauthorized.
➤ If login provided → Spring calls CustomUserDetailsServiceImpl to load user.
➤ Password is verified using PasswordEncoder.
➤ If OK → access is granted.
➤ If user is logged in but role-based restrictions exist → can also get 403 Forbidden.


🔷 Properties | YAML | How to pass command line arguments in spring boot application ?

1️⃣ application.properties
In Spring Boot, you can configure values in application.properties:
server.port=8081
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=root
spring.datasource.password=1234

2️⃣ YAML
In Spring Boot, you can configure values in application.yml:
server:
  port: 8081

spring:
  datasource:
    url: jdbc:mysql://localhost:3306/mydb
    username: root
    password: 1234
📌 Both properties and yml are supported by default. Spring Boot prefers application.yml if both are present.


3️⃣ Passing Command Line Arguments
Spring Boot allows overriding configuration from the command line.

⚡ Syntax:
🔗 java -jar myapp.jar --server.port=9090 --spring.datasource.username=ankur

Here:
🔗 --server.port=9090 → overrides server.port
🔗 --spring.datasource.username=ankur → overrides username

4️⃣ Accessing Values Inside Code
You can fetch values in your beans with @Value or @ConfigurationProperties.

Using @Value:
@Value("${server.port}")
private int port;

Using @ConfigurationProperties:
@Component
@ConfigurationProperties(prefix = "spring.datasource")
public class DBConfig {
    private String url;
    private String username;
    private String password;

    // getters & setters
}


🔷 JUnit 
JUnit is a Java testing framework used to write and run unit tests — small tests that verify individual parts of your code (usually methods or classes) to ensure they work as expected.

❓ Why JUnit?
➤ Automates testing of Java code.
➤ Ensures code works as intended after changes (Regression testing).
➤ Encourages writing modular, maintainable code.
➤ Integrates easily with build tools like Maven, Gradle, and CI/CD pipelines.

Concepts of JUnit:
1️⃣ @SpringBootTest
➤ Used to load the full Spring ApplicationContext for integration tests.
➤ It ensures all beans (@Service, @Repository, @Component, etc.) are available.
➤ Best for testing when your service class interacts with real Spring components (like repositories).

✅ Example:
@SpringBootTest
public class UserServiceTest {

    @Autowired
    private UserEntryService userEntryService;

    @Test
    void testSaveUser() {
        User user = new User("ankur", "ankur@gmail.com", "1234");
        boolean result = userEntryService.saveNewUser(user);
        assertTrue(result);
    }
}

2️⃣ Lifecycle Annotations
These define when a method runs in relation to the test lifecycle.
| Annotation    | Runs When             | Purpose                              |
| ------------- | --------------------- | ------------------------------------ |
| `@BeforeAll`  | Once before all tests | Set up shared resources              |
| `@BeforeEach` | Before each test      | Re-initialize test data              |
| `@AfterEach`  | After each test       | Clean up after a test                |
| `@AfterAll`   | Once after all tests  | Close connections, release resources |

✅Example:
@BeforeAll
static void initAll() {
    System.out.println("Runs once before all tests");
}

@BeforeEach
void init() {
    System.out.println("Runs before each test");
}

@AfterEach
void tearDown() {
    System.out.println("Runs after each test");
}

@AfterAll
static void tearDownAll() {
    System.out.println("Runs once after all tests");
}

3️⃣ @ParameterizedTest
➤ Allows you to run the same test with multiple inputs.
➤ Replaces the need to write multiple similar test methods.
➤ Works with several sources like @ValueSource, @CsvSource, @MethodSource, and @ArgumentsSource.

⚡ Using @ValueSource
Provides a single list of values (String, int, double, etc.)

✅Example:
@ParameterizedTest
@ValueSource(strings = {"Ram", "Shyam", "Ankur"})
void testFindByUserName(String name) {
    assertNotNull(userRepository.findByUserName(name), "Failed for: " + name);
}

⚡ Using @CsvSource
Provides a list of comma-separated values (String, int, double, etc.)

✅Example:
@ParameterizedTest
@CsvSource({
    "1,2,3",
    "2,3,5",
    "3,4,7"
})
void testAddition(int a, int b, int expected) {
    assertEquals(expected, a + b);
}
➡️ Runs 3 times:
testAddition(1, 2, 3)
testAddition(2, 3, 5)
testAddition(3, 4, 7)

⚡ Using @ArgumentsSource
➤ Used for complex or custom inputs (e.g., objects like User).
➤ Requires a separate class implementing ArgumentsProvider.

✅Example:
@ParameterizedTest
@ArgumentsSource(UserArgumentProvider.class)
void testSaveNewUser(User user) {
    assertTrue(userEntryService.saveNewUser(user));
}

👉 UserArgumentProvider example:

public class UserArgumentProvider implements ArgumentsProvider {
    @Override
    public Stream<? extends Arguments> provideArguments(ExtensionContext context) {
        return Stream.of(
            Arguments.of(new User("ankur", "ankur@gmail.com", "1234")),
            Arguments.of(new User("isha", "isha@gmail.com", "abcd"))
        );
    }
}

4️⃣ @Disabled
➤ Used to temporarily skip a test without deleting it.
➤ Helpful when a feature isn’t implemented yet or you want to ignore unstable tests.

✅ Example:
@Disabled("Disabled until bug #123 is fixed")
@Test
void testFeatureNotReady() {
    fail("This feature is under development");
}

5️⃣ Assertions
Assertions are used to verify the actual result against the expected result.
| Method                           | Usage                     |
| -------------------------------- | ------------------------- |
| `assertEquals(expected, actual)` | Check equality            |
| `assertTrue(condition)`          | Condition must be true    |
| `assertFalse(condition)`         | Condition must be false   |
| `assertNotNull(object)`          | Object should not be null |
| `assertNull(object)`             | Object should be null     |
| `assertThrows()`                 | Expected exception thrown |
✅Example:
@Test
void testAssertions() {
    assertEquals(4, 2 + 2);
    assertTrue(5 > 3);
    assertNotNull("Hello");
}


6️⃣ Test Naming & Organization
➤ Tests are usually written in the same package structure as the main code.
➤ Test class names typically end with Tests or Test.

✅ Example:
src/
 ├── main/java/net/engineeringdigest/journalApp/service/UserEntryService.java
 └── test/java/net/engineeringdigest/journalApp/service/UserServiceTests.java


🔷 Mockito
➤ Mockito is a mocking framework for Java used in unit testing to create fake (mock) objects that simulate the behavior of real objects.
➤ It allows you to test a class in isolation, without actually calling the real dependencies (like databases, APIs, or external services).

❓ Why Mockito is Needed
➤ Without mocking:
  ✔️ vUnit tests may depend on external systems like DB, APIs.
  ✔️ vTests may fail due to external failures, not your logic.
  ✔️ vTests become slow and hard to maintain.

➤ With Mockito:
  ✔️ vYou mock dependencies to test only your class logic.
  ✔️ vYou control the dependency behavior (what it returns).
  ✔️ vTests are fast, reliable, and isolated.


🔷 Spring Profiles 
➤ Spring Profiles allow you to activate or deactivate beans/configurations based on the current environment (like dev, test, prod).
➤ You can control which beans load depending on the active profile.
➤ You can create multiple versions of the same bean/class and Spring will only load the one matching the active profile.

🔄 Set Active Profile in application.properties
➤ You can specify the active profile directly in your main configuration file:
# application.properties
spring.profiles.active=dev

➤ This tells Spring Boot to load all settings from application-dev.properties in addition to the default application.properties.

🔄 Create Profile-Specific Property Files
Each profile has its own file following this naming convention:
application-{profile}.properties

✅ Example:
✔️ application-dev.properties
server.port=8081
spring.datasource.url=jdbc:mysql://localhost:3306/devdb
spring.datasource.username=dev_user
spring.datasource.password=dev123

✔️ application-prod.properties
server.port=8082
spring.datasource.url=jdbc:mysql://localhost:3306/proddb
spring.datasource.username=prod_user
spring.datasource.password=prod123

🔄 Activate Profile via Command Line
You can override the profile at runtime using the command line:

🔗 java -jar myapp.jar --spring.profiles.active=prod
👉 This overrides whatever is set in application.properties.


🔄 Using @Profile Annotation
You can annotate beans, components, or configuration classes to load only when a specific profile is active.

✅ Example: — Service Classes
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Service;

@Service
@Profile("dev")
public class DevEmailService implements EmailService {
    @Override
    public void sendEmail(String msg) {
        System.out.println("DEV: Sending mock email → " + msg);
    }
}

@Service
@Profile("prod")
public class ProdEmailService implements EmailService {
    @Override
    public void sendEmail(String msg) {
        System.out.println("PROD: Sending real email → " + msg);
    }
}
👉 If spring.profiles.active=dev, then only DevEmailService will be loaded.
👉 If spring.profiles.active=prod, then only ProdEmailService will load.

🔄 Using @Profile in Configuration Classes
You can also restrict entire configuration classes:

@Configuration
@Profile("test")
public class TestDatabaseConfig {

    @Bean
    public DataSource dataSource() {
        System.out.println("Using TEST database configuration");
        return new HikariDataSource();
    }
}
So when the active profile is test, this config will be used.

🔄 Get Active Profile Programmatically
You can access the active profile from the Spring Context’s Environment.

✅ Example:
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.stereotype.Component;

@Component
public class ActiveProfileLogger {

    @Autowired
    private ApplicationContext context;

    public void printActiveProfile() {
        String[] profiles = context.getEnvironment().getActiveProfiles();
        System.out.println("Active Profile: " + profiles[0]);
    }
}
✅ Output:
Active Profile: dev

🔄 Use in Tests (JUnit + Profiles)
You can set a profile for tests using @ActiveProfiles:

@SpringBootTest
@ActiveProfiles("test")
public class UserServiceTest {

    @Autowired
    private ApplicationContext context;

    @Test
    void checkProfile() {
        System.out.println("Running under profile: "
            + context.getEnvironment().getActiveProfiles()[0]);
    }
}
✅ Output:
Running under profile: test

🔄 Multiple Profiles at Once
You can activate more than one profile:
👉 spring.profiles.active=dev,local
Spring will load all beans matching either dev or local.

You can also use logical negation:
@Profile("!prod")   // load this bean in all profiles except prod

🔄 Using Profiles with YAML
You can define multiple profiles within a single YAML file using ---:
server:
  port: 8080

spring:
  profiles:
    active: dev

spring:
  config:
    activate:
      on-profile: dev
server:
  port: 8081


spring:
  config:
    activate:
      on-profile: prod
server:
  port: 9090
👉 Depending on which profile is active, the corresponding section will apply.

🔄 Checking Active Profile in Console (Quick Check)
In any Spring Boot class:
System.out.println(context.getEnvironment().getActiveProfiles()[0]);
👉 Prints the current active profile — very useful for debugging or verifying environment setup.


🔷 Logging in Spring Boot: SLF4J
➤ Logging is an essential aspect of the application development that allows developers to monitor and troubleshoot their applications.

➤ Spring Boot supports various logging frameworks, such as Logback, Log4J2, and Java Util Logging (JUL) out of the box.

🔄 understanding frameworks:
1️⃣ Logback: A popular logging framework that serves as default in many SpringBoot applications. It offers a flexible configuration and good performance.

2️⃣ Log4J2: A logging framework similar to Logback with features such as asynchronous logging and support various output formats.

3️⃣ Java Util Logging (JUL): A logging framework that is a part of the Java platform. While it's less feature rich than some third-party frameworks, it is straightforward to use.

✔️ Spring Boot uses Logback as the default logging framework provides a good balance between simplicity and performance.
✔️ The default configuration is embedded within the Spring Boot libraries, and it may not be visible in your application's source code.
✔️ If you want to customize the logging configuration, you can create your own logback-spring.xml or logback.xml file in the src/main/resources directory.
✔️ When SpringBoot detects this file in your project, it will use it instead of the default configuration.

🔄 Logging Levels
Spring Boot supports the following logging levels:
| Level     | Description             | Example                |
| --------- | ----------------------- | ---------------------- |
| TRACE     | Detailed debugging info | Fine-grained flow logs |
| DEBUG     | Useful for debugging    | Dev-time logs          |
| INFO      | General app flow        | Startup, shutdown      |
| WARN      | Potential issues        | Deprecated method used |
| ERROR     | Errors & exceptions     | DB connection failed   |
| OFF       | Turns off logging       | —                      |

We can set the desired logging levels for specific packages or classes, allowing them to control the amount of information logged at runtime.

Spring Boot provides annotations like @Slf4j and @Log4j2 to help with logging, that can be used to automatically inject logger instance


🔷 SLF4J
➤ SLF4J (Simple Logging Facade for Java) is a logging abstraction layer.
➤ It provides a common interface for various logging frameworks (Logback, Log4j2, JUL, etc.).
➤ Spring Boot internally uses SLF4J + Logback by default.
➤ Think of SLF4J as a “universal adapter” that lets you switch logging backends easily without changing your application code.

❓ Why Use SLF4J 
➤ Abstraction layer: decouples logging framework from code.
➤ Better performance: lazy evaluation of log messages ({} placeholders).
➤ Integration: widely supported in Spring, Hibernate, etc.
➤ Flexibility: easily switch from Logback → Log4j2 without code changes.

❓ How Logging Works in Spring Boot
➤ By defaultSLF4J API is used in code.
➤ Logback is the underlying implementation.
➤ Configurations are auto-loaded from:
  ✔️ application.properties or
  ✔️ logback-spring.xml

✅Example:
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

@Service
public class UserService {
    private static final Logger logger = LoggerFactory.getLogger(UserService.class);

    public void createUser(String name) {
        logger.info("Creating user: {}", name); 
        logger.debug("Debug info while creating user");
        logger.warn("This is a warning message");
        logger.error("Error occurred while creating user");
    }
}
✅ Output:
Creating user: Mike
Debug info while creating user
This is a warning message
Error occurred while creating user

🧠 Why {} ?
Because SLF4J supports parameterized logging — efficient and avoids string concatenation.

👉 We have to write:
 private static final Logger logger = LoggerFactory.getLogger(UserService.class);
 to use this line of code for every class for logging in Spring Boot.
 ⚡ We have to write log instead of logger in the code as well

 instead of this we can use:
 @Slf4j // annotation provided by lambok library
 @Service
 public class UserService {
     public void createUser(String name) {
         log.info("Creating user: {}", name);
         log.debug("Debug info while creating user");
         log.warn("This is a warning message");
         log.error("Error occurred while creating user");
     }
 }

🔄 Configure Logging in application.properties

🔗 Code Example:
# Root logging level
logging.level.root=INFO 
👉 this gives logs for all packages and classes of level info or severe than info i.e trace and debug will never get printed.

# Package-specific level
logging.level.net.engineeringdigest.journalApp=DEBUG

# Log file output
logging.file.name=app.log
logging.file.path=logs/

# Pattern for console output
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n

🔄 Logging with Profiles
You can set different logging levels for each Spring profile:

🔗 Code Example:
# application-dev.properties
logging.level.root=DEBUG

# application-prod.properties
logging.level.root=ERROR

And activate profile:
spring.profiles.active=dev

🔄  Access Logs in Code
You can print the active profile in your logs:

🔗 Code Example:
import org.springframework.core.env.Environment;
import org.springframework.beans.factory.annotation.Autowired;

@Autowired
private Environment env;

@PostConstruct
public void init() {
    String activeProfile = env.getActiveProfiles()[0];
    logger.info("Active profile: {}", activeProfile);
}

🔄 Configure in logback-spring.xml (Advanced)
When we have application.properties, we should use logback-spring.xml for logging configuration specifically.

🔗 Code Example:
<configuration>

👉 Console Appender 
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder> // encoder is a formatter for the output 
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger - %msg%n</pattern>
        </encoder>
    </appender>

👉 File appender
    <appender name="FILE" class="ch.qos.logback.core.FileAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
        <file>PAth_of_the_file</file>
    </appender>

👉 Set the root level and attach the console appender
    <root level="INFO">
        <appender-ref ref="CONSOLE"/>
        <appender-ref ref="FILE"/>
    </root>

👉 Set the log level for a specific package or classes
    <logger name="net.engineeringdigest.journalApp" level="DEBUG"/>

</configuration>

Understanding structure:
1️⃣ <configuration>
<!-- Appender and Logger configuration go here -->
</configuration>
➤ The <configuration> elements is the root element of the logback.xml file. All logback configuration is enclosed within this element.

🔄 Patter Syntax:
  ✔️ %d{yyyy-MM-dd HH:mm:ss} - date and time
  ✔️ [%thread] - thread name
  ✔️ %-5level - logging level(left justified text with atmost 5 characters)
  ✔️ %logger{36} - logger name upto 36 characters
  ✔️ %msg  %n - message and new line

🔄 Rolling FileAppender Based on Time
✅Example:

<configuration>
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>logs/application-%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>10</maxHistory>
        </rollingPolicy>
    </appender>
</configuration>

🔄 Rolling FileAppender Based on Size of File
✅Example:

<configuration>
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
        <rollingPolicy class="ch.qos.logback.core.rolling.SizeBasedRollingPolicy">
            <maxFileSize>10MB</maxFileSize>
            <maxHistory>10</maxHistory>
        </rollingPolicy>
    </appender>
</configuration>
👉 Rolling based of size and time can be used at the same time whatever happens first will make logs accordingly.
