🔷 SpringBoot
➤ Spring Boot is a framework for building application in the Java programming language. 
➤ It is built on top of the Spring framework and provides a simplified way to create stand-alone, production-grade Spring-based applications that can be easily deployed and run.
➤ The core spring framework already reduces bolierplate code and provides a lot of helpful features for Java applications.
➤ However, Spring Boot takes this convenience to the next level by focusing specifically on reducing the effort required to set up and configure Spring applications.
➤ While Spring does simplify many tasks like creating web applications, working with databases, managing transactions and many more. But setting a spring project can still involve quite bit of manual configuration.

Spring Boot provides:
1. Auto-configuration
2. Standaloene applications


🔷 SpringBootApplication annotation
➤ We use the @SpringBootApplication annotation on the main class. This single annotation replaces the need of setting up a manual Spring application context.
➤ We use SpringApplication.run() method to start the application and Spring Boot takes care of configuring the embedded server and other necessary components.
➤ The @SpringBootApplication annotation alone brings in a lot of pre-configured features, including automatic component scanning and embedded server configuration, which would have required more steps in a traditional Spring application.

🔷 Use of Maven and its importance --- refer to Maven.txt file


🔷 @SpringBootApplication?
➤ It’s a meta-annotation introduced in Spring Boot.
➤ Combines three important Spring annotations:
    ✔️@Configuration → marks class as a source of bean definitions.
    ✔️@EnableAutoConfiguration → tells Spring Boot to auto-configure beans based on classpath dependencies.
    ✔️@ComponentScan → scans the package (and sub-packages) of the class for components (@Component, @Service, @Repository, @Controller, etc.).

🟢 Working (Step-by-step)
1️⃣ App starts → SpringApplication.run(...) is called.
2️⃣ @SpringBootApplication kicks in:
    ✔️ Loads configurations (@Configuration).
    ✔️ Triggers auto-configuration (@EnableAutoConfiguration) → checks spring.factories for available configs.
    ✔️ Starts component scanning from the package of the main class.
3️⃣ Spring Context built → beans registered, dependencies injected.
4️⃣ Embedded server (Tomcat/Jetty/Undertow) starts if it’s a web app.


🔷 @Component vs @Service in Spring Boot
| Annotation   | Description                                                                                                     |
| ------------ | --------------------------------------------------------------------------------------------------------------- |
| `@Component` | Generic stereotype annotation that marks a class as a Spring-managed bean.                                      |
| `@Service`   | A specialized type of `@Component used to mark classes that hold business logic or service-layer code.          |

🔄 What They Do Internally
✅ Both @Component and @Service
➤ Register the class as a bean in the Spring ApplicationContext
➤ Enable dependency injection via @Autowired.

👉 In short:
@Service = @Component + Semantic meaning (used for service/business layer)

🔄 Layer Meaning in Spring 
| Layer                | Annotation                        | Purpose                                   |
| -------------------- | --------------------------------- | ----------------------------------------- |
| Controller Layer     | `@Controller` / `@RestController` | Handles web requests (presentation layer) |
| Service Layer        | `@Service`                        | Contains business logic                   |
| Repository Layer     | `@Repository`                     | Deals with persistence (database access)  |
| Generic Bean         | `@Component`                      | Used for any other general-purpose bean   |

✅ Example: Using @Component
@Component
public class EmailValidator {
    public boolean isValid(String email) {
        return email.contains("@");
    }
}
➤ Registered as a Spring Bean.
➤ Can be injected anywhere:
@Autowired
private EmailValidator validator;

✅ Example: Using @Service
@Service
public class UserService {
    public void registerUser(User user) {
        // business logic for registration
    }
}
➤ Also a Spring Bean.
➤ But used to represent business logic layer.

🔄 Key Difference — Intent and Semantics
| Feature                               | `@Component`         | `@Service`                                             |
| ------------------------------------- | -------------------- | ------------------------------------------------------ |
| Purpose                               | Generic bean         | Business logic layer                                   |
| Spring Behavior                       | Registers bean       | Registers bean (same behavior)                         |
| Semantic Meaning                      | Can be used anywhere | Indicates service-level component                      |
| AOP (Aspect-Oriented Programming)     | No special behavior  | May be used by Spring for transactional or proxy logic |
| Readability                           | Less descriptive     | More expressive for business services                  |

🔄 AOP (Aspect-Oriented Programming) Note
➤ Spring often applies aspects (like @Transactional, @Async, etc.) at the service layer.
So using @Service:
➤ Helps Spring automatically detect it as a target for business logic–related aspects.


🔷 REST API
➤ REST = Representational State Transfer → an architectural style for designing networked applications.
➤ REST API = An API that follows REST principles → uses HTTP methods to perform operations on resources (data).
➤ Resources are identified by URIs (Uniform Resource Identifiers) and exchanged in formats like JSON / XML.


🔷 @Value Annotation
In Spring Boot, the @Value annotation is used to inject values into fields, method parameters, or constructor arguments directly from:
✔️ application.properties / application.yml
✔️ Environment variables
✔️ System properties
✔️ Expression Language (SpEL)

🔄 Syntax
@Value("${property.key}")
private String value;
👉 Spring replaces ${property.key} with the actual value from application.properties (or other sources).

✅ Example 1: Injecting from application.properties
🔗 application.properties
app.name=WeatherApp
app.version=1.0.3

🔗 Java Class
@Component
public class AppConfig {
    
    @Value("${app.name}")
    private String appName;

    @Value("${app.version}")
    private String version;

    public void printDetails() {
        System.out.println(appName + " - " + version);
    }
}
✅ Output:
WeatherApp - 1.0.3


✅ Example 2: Default Value
If the property doesn’t exist, you can provide a default value:

@Value("${app.description:Default Description}")
private String description;

✅ Example 3: Injecting System or Environment Variables
You can directly access environment/system variables:
@Value("${JAVA_HOME}")
private String javaHome;

✅ Example 4: Using SpEL (Spring Expression Language)
You can perform calculations or logic:
@Value("#{2 * 10}")
private int value; // 20

@Value("#{systemProperties['user.home']}")
private String userHome;

✅ Example 5: Injecting Lists or Arrays
🔗 application.properties

app.cities=Delhi,Mumbai,Bangalore

🔗 Java Class
@Value("${app.cities}")
private List<String> cities;

🔄 When to Use @Value
➤ For simple property injection (like strings, numbers, or constants).
➤ When you don’t need a full configuration class.

🔄 Better Alternative for Multiple Values → @ConfigurationProperties
For injecting multiple related properties, prefer:

@ConfigurationProperties(prefix = "app")
public class AppConfig {
    private String name;
    private String version;
    // getters & setters
}
✅ Cleaner and easier to maintain for grouped properties.


🔷 @PostConstruct in Spring Boot
@PostConstruct is a lifecycle annotation used in Spring to execute a method after dependency injection is complete — but before the bean is put into service (i.e., before it’s ready to handle requests).

🔄 Purpose
It is mainly used for initialization logic — tasks you want to run once right after the bean is created and dependencies are injected.

✅ Example
@Component
public class DataLoader {

    @Autowired
    private UserRepository userRepository;

    @PostConstruct
    public void init() {
        System.out.println("Initializing data...");
        userRepository.save(new User("Ankur", "ankur@example.com"));
    }
}

🔄 What happens here:
    ✔️ Spring creates the DataLoader bean.
    ✔️ It injects the UserRepository dependency.
    ✔️ Then it automatically calls the init() method once.
    ✔️ This ensures your logic runs only after all beans and dependencies are ready.

❓ When is it Called?
➤ Called after the bean is constructed and all dependencies are injected.
➤ Runs before the @PreDestroy method (if any).
➤ Executes only once per bean lifecycle.

🔄 Common Use Cases
    ✔️  Loading initial data into the database
    ✔️  Validating configuration after injection
    ✔️  Establishing a connection or preloading cache
    ✔️  Printing startup messages

✅ Example with Logging and Config
@Component
public class AppStartup {

    @Value("${app.name}")
    private String appName;

    @PostConstruct
    public void onStart() {
        System.out.println("Application '" + appName + "' started successfully!");
    }
}

| Concept               | Description                                                                                       |
| --------------------- | ------------------------------------------------------------------------------------------------- |
| Annotation Source     | `jakarta.annotation.PostConstruct`                                                                |
| Runs When             | After dependency injection, before bean is used                                                   |
| Method Rules          | Must be `void`, no parameters, can throw exceptions                                               |
| Alternatives          | `InitializingBean.afterPropertiesSet()` or a custom `@EventListener(ApplicationReadyEvent.class)` |


🔄 Modern Alternative (Recommended in Spring Boot)
Instead of @PostConstruct, you can use an ApplicationListener or @EventListener(ApplicationReadyEvent.class) for cleaner startup logic:

@Component
public class StartupListener {

    @EventListener(ApplicationReadyEvent.class)
    public void onApplicationReady() {
        System.out.println("✅ Application is fully started and ready!");
    }
}
👉 This ns after the full Spring context is initialized (safer for web apps).

🔄 Core Principles of REST
➤ Stateless → Each request is independent; server doesn’t store client state.
➤ Client-Server → Separation of concerns (UI = client, data = server).
➤ Interface → Standard way to access resources (URIs + HTTP verbs).
➤ Resource-based → Everything is treated as a resource.
➤ Representation → Resource can be represented in multiple formats (JSON, XML).

🔄 HTTP Methods in REST
GET → Retrieve data.
POST → Create new resource.
PUT → Update/replace resource.
PATCH → Partially update resource.
DELETE → Remove resource.

✅ Example:
Endpoint:
GET /api/users/101

Meaning → Fetch details of user with ID = 101.
Response (JSON):
{
  "id": 101,
  "name": "Ankur",
  "email": "ankur@example.com"
}


🔷 ORM
➤ ORM = Object-Relational Mapping
➤ It’s a technique that lets developers interact with a database using objects instead of SQL queries.
➤ ORM automatically maps classes ↔ database tables and objects ↔ rows.
➤ It allows developers to work with databases using object-oriented programming concepts, making it easier to interact with relational databases.

✅ For Example:
✔️ Consider a Java class User and a database table users.
✔️ ORM framework like Hibernate can map the fields in the User class to columns in the users table, making it easier to insert, update, retrieve, and delete records.


🔷 JPA
➤ JPA = Java Persistence API.
➤ It’s a specification (interface) in Java for ORM (Object-Relational Mapping).
➤ Defines how Java objects should be mapped to relational database tables.
➤ To use JPA, you need a persistence provider. A persistence provider is a specific implementation of the JPA specification. 
✅ Examples include Hibernate, EclipseLink, and OpenJPA.
➤ This providers implement the JPA interfaces and provide the underlying functionality to interact with the database.

🔄 Use case of JPA
✔️ Standard way of ORM in Java (vendor-independent).
✔️ Simplifies database interaction → reduces boilerplate JDBC code.
✔️ Provides queries using JPQL (Java Persistence Query Language) instead of raw SQL.
✔️ Supports transactions, relationships, and more.


🔷 Spring Data JPA
➤ Spring Data JPA is a Spring project that builds on top of JPA.
➤ It makes working with databases even easier by removing boilerplate code (no need to write DAO classes manually).
➤ Provides ready-made repository interfaces to perform CRUD without writing queries.

🔄 Working of Spring Data JPA
✔️ You define a repository interface extending JpaRepository / CrudRepository.
✔️ Spring Data JPA creates implementation at runtime.
✔️ You can use method naming conventions or @Query to define custom queries.

⚡Note:

❗ Problem:
👉 JPA is primarily designed for working with relational databases, where data is stored in tables with a predefined schema. 
👉 MongoDB, on the other hand, is a NOSQL database that uses a different data model, typically based on collections of documents, which are schema-less or having flexible schemas. 
👉 This fundamental difference in data models means that JPA's ORM approach is not directly applicable to MongoDB.

✅ Solution:
👉 In case of MongoDB, you don't have a traditional JPA persistence provider. MongoDB is a NOSQL database and Spring Data MongoDB serves as the "persistence provider" for MongoDB.
👉 It provides the necessary abstraction and implementations to work with MongoDB in a Spring application.

🔄 Add dependency for Spring Data MongoDB in your Maven/Gradle configuration.

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-mongodb</artifactId>
</dependency>

🔄 Ways to Use Spring Data MongoDB
➤ Query Method DSL and Criteria API are two different ways to interact with a database when using Spring Data JPA for relational databases and Spring Data MongoDB for MongoDB.
  ✔️ Query Method DSL is a simple and convenient way to create queries based onn method naming conventions.
  ✔️ Criteria API offers a more dynamic and programatic approach for building complex and custom queries.

➤ Spring Data JPA is a part of Spring framework that simplifies data access in Java applications, while Spring Data MongoDB provides similar functionality for MongoDB.


🔷 @ResponseEntity
➤ ResponseEntity<T> → A Spring class used to represent the entire HTTP response (status, headers, body).
➤ Commonly used in REST APIs for precise control.
➤ It provides methods for setting the response status, headers, and body.
➤ You can use it to return different types of data in your controller methods such as JSON, XML, or plain text. 
➤ IT uses generics to specify the type of the response body.

❗ Confusion Alert:
➤ We often see things like:
return ResponseEntity.ok("Hello");

➤ And we also see annotations like @ResponseBody.
➤ That’s why many think @ResponseEntity exists — but it does not.

✅ Correction
➤ ResponseEntity (class) → Used in method return type.
➤ @ResponseBody (annotation) → Tells Spring to write the return object directly to HTTP response body (instead of resolving a view).
➤ @RestController (annotation) → Combines @Controller + @ResponseBody.

➤ An HTTP status code is a three-digit numeric code returned by a web server as parto of the response to an HTTP request made by a client.
➤ These status codes are used to convey information about the result or status of the requested operation.
➤ HTTP status codes are grouped into five categories based on the first digit of the code:
1️⃣ 1xx (Informational): These status codes indicate that the request was received and understood, and the server is continuing to process it.
These are typically used for informational purposes and are not commonly seen in everyday web interactions.

2️⃣ 2xx (Successful): These status codes indicate that the request was successfully received, understood, and accepted by the server.
  ✔️ 200 OK: The request has been successfully processed, and the server is returning the requested resource.
  ✔️ 201 Created: The request has been fulfilled, resulting in the creation of a new resource.
  ✔️ 204 No Content: The request has been fulfilled, but there is no response body(typically used for operation that don't return data, like a DELETE request).

3️⃣ 3xx (Redirection): These status codes indicate that further action is needed to complete the request. These are used when the client needs to take additional steps to access the requested resource.
  ✔️ 301 Moved Permanently: The requested resource has been permanently moved to a new URL.
  ✔️ 302 Found: The requested resource is temporarily located at a different URL.When server sends a response with a 302 status code, it typically includes a Location header that specifies the new URL where the resource can be found. The client is expected to make a new request to this URL to access the resource.
  ✔️ 304 Not Modified: The resource has not been modified since the last request. The client can use its cached version.

4️⃣ 4xx (Client Error): It indicates that there was an error on the client's side, such as malformed request or authentication issues.
  ✔️ 400 Bad Request: The server cannot process the request due to client error (e.g., malformed request syntax).
  ✔️ 401 Unauthorized: Authentication is required and has failed or has not yet been provided.
  ✔️ 403 Forbidden: The server understands the request but refuses to authorize it.
  ✔️ 404 Not Found: The requested resource could not be found on the server.

5️⃣ 5xx (Server Error): The server failed to fulfill a valid request.
  ✔️ 500 Internal Server Error: A generic error message indicating that the server encountered an unexpected condition.
  ✔️ 502 Bad Gateway: The server received an invalid response from an inbound server while acting as a gateway or proxy.
  ✔️ 503 Service Unavailable: The server is currently unable to handle the request due to temporary overload or maintenance.


🔷 Project Lombok
➤ Lombok is a Java library that reduces boilerplate code by using annotations.
➤ It generates common code like getters, setters, constructors, toString, equals, hashCode, builders, etc. at compile time.
➤ Achieved via annotation processing → IDE & compiler insert the code for you.

❓ Why use Lombok?
➤ Saves time → no need to manually write getters/setters.
➤ Makes code cleaner & readable.
➤ Reduces errors in repetitive boilerplate code.

🔄 Common Lombok Annotations
✔️ @Getter / @Setter → Generates getters & setters.
✔️ @ToString → Generates toString().
✔️ @EqualsAndHashCode → Generates equals() & hashCode().
✔️ @NoArgsConstructor / @AllArgsConstructor → Generates constructors.
✔️ @Data → Combines @Getter, @Setter, @ToString, @EqualsAndHashCode, @RequiredArgsConstructor.
✔️ @Builder → Provides builder pattern.
✔️ @Slf4j → Provides a ready-to-use logger.

✅ Example Without Lombok
public class Student {
    private int id;
    private String name;

    public Student() {}
    public Student(int id, String name) { this.id = id; this.name = name; }

    public int getId() { return id; }
    public void setId(int id) { this.id = id; }
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    @Override
    public String toString() { return "Student{id=" + id + ", name='" + name + "'}"; }
}

✅ Example With Lombok
import lombok.*;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class Student {
    private int id;
    private String name;
}
✅ Generates all boilerplate automatically (getters, setters, constructors, toString, equals, hashCode).


🔷 @Transactional Annotation
➤ @Transactional in Spring marks a method (or class) so that database operations inside it run within a single transaction.
➤ Either all succeed (commit) or all fail (rollback).
➤ Ensures ACID properties (Atomicity, Consistency, Isolation, Durability).

✅Example:
@Service
public class PaymentService {

    @Autowired
    private OrderRepository orderRepo;

    @Autowired
    private PaymentRepository paymentRepo;

    @Transactional
    public void processPayment(Order order, Payment payment) {
        orderRepo.save(order);       // Step 1
        paymentRepo.save(payment);   // Step 2

        // If any exception occurs here, both saves will rollback
    }
}
👉 Without @Transactional, if orderRepo.save() succeeds but paymentRepo.save() fails, you’d get inconsistent data. With @Transactional, both operations succeed or both rollback.

It can be applied at:
1️⃣ Method Level → Only that method runs in a transaction.
2️⃣ Class Level → All public methods in the class run in transactions.

Key Features

1️⃣ Rollback Rules
➤ By default, rolls back on unchecked exceptions (RuntimeException, Error).
➤ Checked exceptions don’t trigger rollback unless configured.

@Transactional(rollbackFor = Exception.class)
public void doWork() { ... }

2️⃣ Isolation Levels (how transactions interact with each other)
✔️ READ_COMMITTED (default in most DBs)
✔️ READ_UNCOMMITTED
✔️ REPEATABLE_READ
✔️ SERIALIZABLE

✅ Example:
@Transactional(isolation = Isolation.SERIALIZABLE)

3️⃣ Propagation (what happens if a method with a transaction calls another transactional method)
✔️ REQUIRED (default) → joins existing transaction or creates new one if none.
✔️ REQUIRES_NEW → always starts a new transaction.
✔️ MANDATORY → must run inside an existing transaction.
✔️ SUPPORTS, NOT_SUPPORTED, NEVER, NESTED.

✅ Example:
@Transactional(propagation = Propagation.REQUIRES_NEW)

4️⃣ Read-Only Transactions
Optimizes performance for queries.

@Transactional(readOnly = true)


🔷 Spring Security in Spring Boot
Spring Security is a powerful and highly customizable authentication and access-control framework for Java applications, particularly those built using the Spring framework. 
It provides a comprehensive set of features to secure applications against various threats, including authentication, authorization, and protection against common vulnerabilities.

🔄 dependency for Spring Security in Maven/Gradle configuration.
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>

➤ Once the dependency is added, Spring Boot automatically configures basic security settings for your application.
➤ It includes authentication, authorization, and session management by default.
➤ By default, Spring Security uses HTTP Basic Authentication it means that: 
  ✔️ The client sends an authorization header Authorizaiton:Basic<endcoded-credentials>.
  ✔️ The server decodes the string, extracts the username and password, and verifies them.
  ✔️ If they're correct access is granted, otherwise a 401 Unauthorized response is returned.

➤ Encoding Credentials are combined into a string like username:password and then encoded using Base64 encoding scheme.

➤ By default, all endpoints will be secured, Spring Security will generate a default user with a random password, which is printed in the console when the application starts if no user is created in the database.

➤ You can also configure username and password by setting properties in application.properties or application.yml file.
🔗 spring.security.user.name=your-username
🔗 spring.security.user.password=your-password
➤ You can customize the security settings by creating a configuration class that extends WebSecurityConfigurerAdapter and overrides the configure methods.

🔷 Code Implementation of Spring Security
🔗 SpringSecurity.java
package net.engineeringdigest.journalApp.config;

@Configuration
@EnableWebSecurity
public class SpringSecurity {
    //4. A configuration SecurityConfig to integrate everything with Spring Security.

    @Autowired
    private CustomUserDetailsServiceImpl userDetailsService;
    @Autowired
    private PasswordEncoder passwordEncoder;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http.authorizeHttpRequests()
                .antMatchers("/journal/**", "/user/**").authenticated()
                .anyRequest().permitAll()
                .and()
                .httpBasic();

        http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and().csrf().disable();

        return http.build();
    }

    @Autowired
    public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder);
    }
}

1️⃣ @Configuration
👉 Marks this class as a Spring Configuration class.
👉 Equivalent to an XML <beans> config file, but in Java-based configuration.
👉 Spring looks at this class and registers its beans in the Spring Application Context.

2️⃣ @EnableWebSecurity
👉 Enables Spring Security’s web security support.
👉 Without this, your configuration (HttpSecurity) would be ignored.
👉 Internally imports security filters and tells Spring Boot:
“Hey, use my custom security setup instead of defaults.”

3️⃣ @Autowired private CustomUserDetailsServiceImpl userDetailsService;
👉 Injects the CustomUserDetailsServiceImpl into the Spring Security configuration.
🔗 CustomUserDetailsServiceImpl.java class

@Component
public class CustomUserDetailsServiceImpl implements UserDetailsService {

    @Autowired
    private UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepository.findByUserName(username);
        if (user != null) {
            return org.springframework.security.core.userdetails.User.builder()
                    .username(user.getUserName())
                    .password(user.getPassword())
                    .roles(user.getRoles().toArray(new String[0]))
                    .build();
        }
        throw new UsernameNotFoundException("User not found with username: " + username);
    }
}
➤ CustomUserDetailsServiceImpl is your custom class that implements UserDetailsService.
⚡ Purpose:
👉 When a user tries to log in, Spring Security calls this service to load user details (username, password, roles).
✅ Example: you fetch user info from MongoDB / MySQL instead of in-memory users.

❓ What is happening in this Implementation class?
3️⃣.1️⃣ implements UserDetailsService
➤ UserDetailsService is a Spring Security interface.
➤ It has one method:
🔗 UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;

⚡ Purpose:
➤ Spring Security calls this method whenever a user tries to log in.
➤ You implement how the user is fetched (from DB, LDAP, API, etc.).
➤ Without this, Spring wouldn’t know how to authenticate against your custom database.

3️⃣.2️⃣ @Autowired private UserRepository userRepository;
➤ Injects your UserRepository (likely a JpaRepository / MongoRepository).
➤ Used to query the DB for a user by username.

✅ For example:
User user = userRepository.findByUserName(username);
👉 Here findByUserName is a custom finder method in your repository.

3️⃣.3️⃣ public UserDetails loadUserByUsername(String username)
➤ This is the main method executed during authentication.

⚡ Flow:
✔️ Spring Security extracts the username from login request.
✔️ Calls loadUserByUsername(username).
✔️ You query the DB for that user.
✔️ If found → build a UserDetails object and return.
✔️ If not found → throw UsernameNotFoundException.

3️⃣.4️⃣ User user = userRepository.findByUserName(username);
➤ Queries DB for a User entity.
➤ Your User entity probably looks something like:

@Document("users")
public class User {
    private String userName;
    private String password;
    private Set<String> roles;
}

3️⃣.5️⃣ Building UserDetails
return org.springframework.security.core.userdetails.User.builder()
        .username(user.getUserName())
        .password(user.getPassword())
        .roles(user.getRoles().toArray(new String[0]))
        .build();
👉 Here:
  ✔️ username(user.getUserName()) → sets the principal (login ID).
  ✔️ password(user.getPassword()) → sets the password (should be encoded with PasswordEncoder).
  ✔️ roles(user.getRoles()...) → converts your user’s roles into Spring Security authorities (like "ROLE_USER", "ROLE_ADMIN").
  ✔️ .build() → returns a fully constructed UserDetails object.

📌 Important:
➤ Spring Security internally uses its own User object (org.springframework.security.core.userdetails.User), not your entity.
➤ That’s why you map your entity → Spring Security UserDetails.

3️⃣.6️⃣ If User Not Found
➤ throw new UsernameNotFoundException("User not found with username: " + username);
➤ Spring Security catches this exception.
➤ It returns 401 Unauthorized to the client.

🔄 Authentication Flow with This Service
➤ Client calls /user API with HTTP Basic header (Authorization: Basic base64(username:password)).
➤ Spring Security extracts the username.
➤ Calls CustomUserDetailsServiceImpl.loadUserByUsername(username).
➤ Your code queries DB → returns user if found.
➤ Spring Security compares password (raw from request vs. encoded in DB).
➤ If match → authentication succeeds, SecurityContext is updated with the user.
➤ Now user can access protected endpoints.

✅ Why Do We Need This?
➤ Spring Security doesn’t know your DB structure.
➤ By implementing UserDetailsService, you bridge the gap between your DB and Spring Security.
➤ This allows you to:
  ✔️ Fetch users from MongoDB/MySQL/Postgres.
  ✔️ Support custom roles & permissions.
  ✔️ Control authentication logic.

4️⃣ @Autowired private PasswordEncoder passwordEncoder;
➤ Spring Security never stores raw passwords.
➤ PasswordEncoder (like BCryptPasswordEncoder) encodes passwords during registration and checks during login.
➤ Without this, Spring would throw errors like “There is no PasswordEncoder mapped for the id 'null'”.

👉 Example flow:
✔️ User enters password 12345.
✔️ Spring encodes it → $2a$10$skq...
✔️ Compares encoded form with stored password in DB.

5️⃣ @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http)
➤ This is the core of Spring Security config.
➤ It defines rules for how incoming HTTP requests are authenticated/authorized.

🔁.authorizeHttpRequests()
✔️ Starts the authorization configuration.
✔️ Decides which URL patterns need authentication.

🔁 .antMatchers("/journal/**", "/user/**").authenticated()
✔️ Any request to /journal/* or /user/* must be authenticated (user must log in).
✔️ If not authenticated → Spring returns 401 Unauthorized.

🔁 .anyRequest().permitAll()
✔️ Any other request is allowed without login.
✅ Example: /home, /about, /register → public pages.

🔁 .and().httpBasic()
✔️ Enables HTTP Basic Authentication:
✔️ Browser shows a popup asking for username:password.
✔️ Used mainly for APIs, not UI apps.
✔️ If this was .formLogin(), then you’d get a login page.

6️⃣ http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
➤ By default, Spring Security creates an HTTP session to store authentication state.
➤ STATELESS means:
  ✔️ No session is created.
  ✔️ Every request must send credentials (good for REST APIs + JWT).
  ✔️ Prevents storing anything in server memory → scalable microservice-style security.

7️⃣ .csrf().disable()
➤ CSRF = Cross-Site Request Forgery protection.
➤ By default, Spring requires a CSRF token for POST/PUT/DELETE requests.
➤ In APIs (especially with httpBasic or JWT), CSRF is usually disabled because:
  ✔️ APIs don’t use forms and cookies like traditional web apps.
  ✔️ Token-based security already prevents CSRF.
⚠️ But if you’re making a web app with forms, don’t disable CSRF!

8️⃣ @Autowired public void configureGlobal(AuthenticationManagerBuilder auth)
➤ This configures AuthenticationManager with your UserDetailsService and PasswordEncoder.
➤ Meaning:
  ✔️ When a user logs in → Spring calls userDetailsService.loadUserByUsername().
  ✔️ The password is checked using passwordEncoder.matches(raw, encoded).

⚙️ Flow of What Happens
➤ A user hits /user/update.
➤ Spring Security sees /user/** → requires authentication.
➤ If no login → return 401 Unauthorized.
➤ If login provided → Spring calls CustomUserDetailsServiceImpl to load user.
➤ Password is verified using PasswordEncoder.
➤ If OK → access is granted.
➤ If user is logged in but role-based restrictions exist → can also get 403 Forbidden.


🔷 Properties | YAML | How to pass command line arguments in spring boot application ?

1️⃣ application.properties
In Spring Boot, you can configure values in application.properties:
server.port=8081
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=root
spring.datasource.password=1234

2️⃣ YAML
In Spring Boot, you can configure values in application.yml:
server:
  port: 8081

spring:
  datasource:
    url: jdbc:mysql://localhost:3306/mydb
    username: root
    password: 1234
📌 Both properties and yml are supported by default. Spring Boot prefers application.yml if both are present.


3️⃣ Passing Command Line Arguments
Spring Boot allows overriding configuration from the command line.

⚡ Syntax:
🔗 java -jar myapp.jar --server.port=9090 --spring.datasource.username=ankur

Here:
🔗 --server.port=9090 → overrides server.port
🔗 --spring.datasource.username=ankur → overrides username

4️⃣ Accessing Values Inside Code
You can fetch values in your beans with @Value or @ConfigurationProperties.

Using @Value:
@Value("${server.port}")
private int port;

Using @ConfigurationProperties:
@Component
@ConfigurationProperties(prefix = "spring.datasource")
public class DBConfig {
    private String url;
    private String username;
    private String password;

    // getters & setters
}


🔷 JUnit 
JUnit is a Java testing framework used to write and run unit tests — small tests that verify individual parts of your code (usually methods or classes) to ensure they work as expected.

❓ Why JUnit?
➤ Automates testing of Java code.
➤ Ensures code works as intended after changes (Regression testing).
➤ Encourages writing modular, maintainable code.
➤ Integrates easily with build tools like Maven, Gradle, and CI/CD pipelines.

Concepts of JUnit:
1️⃣ @SpringBootTest
➤ Used to load the full Spring ApplicationContext for integration tests.
➤ It ensures all beans (@Service, @Repository, @Component, etc.) are available.
➤ Best for testing when your service class interacts with real Spring components (like repositories).

✅ Example:
@SpringBootTest
public class UserServiceTest {

    @Autowired
    private UserEntryService userEntryService;

    @Test
    void testSaveUser() {
        User user = new User("ankur", "ankur@gmail.com", "1234");
        boolean result = userEntryService.saveNewUser(user);
        assertTrue(result);
    }
}

2️⃣ Lifecycle Annotations
These define when a method runs in relation to the test lifecycle.
| Annotation    | Runs When             | Purpose                              |
| ------------- | --------------------- | ------------------------------------ |
| `@BeforeAll`  | Once before all tests | Set up shared resources              |
| `@BeforeEach` | Before each test      | Re-initialize test data              |
| `@AfterEach`  | After each test       | Clean up after a test                |
| `@AfterAll`   | Once after all tests  | Close connections, release resources |

✅Example:
@BeforeAll
static void initAll() {
    System.out.println("Runs once before all tests");
}

@BeforeEach
void init() {
    System.out.println("Runs before each test");
}

@AfterEach
void tearDown() {
    System.out.println("Runs after each test");
}

@AfterAll
static void tearDownAll() {
    System.out.println("Runs once after all tests");
}

3️⃣ @ParameterizedTest
➤ Allows you to run the same test with multiple inputs.
➤ Replaces the need to write multiple similar test methods.
➤ Works with several sources like @ValueSource, @CsvSource, @MethodSource, and @ArgumentsSource.

⚡ Using @ValueSource
Provides a single list of values (String, int, double, etc.)

✅Example:
@ParameterizedTest
@ValueSource(strings = {"Ram", "Shyam", "Ankur"})
void testFindByUserName(String name) {
    assertNotNull(userRepository.findByUserName(name), "Failed for: " + name);
}

⚡ Using @CsvSource
Provides a list of comma-separated values (String, int, double, etc.)

✅Example:
@ParameterizedTest
@CsvSource({
    "1,2,3",
    "2,3,5",
    "3,4,7"
})
void testAddition(int a, int b, int expected) {
    assertEquals(expected, a + b);
}
➡️ Runs 3 times:
testAddition(1, 2, 3)
testAddition(2, 3, 5)
testAddition(3, 4, 7)

⚡ Using @ArgumentsSource
➤ Used for complex or custom inputs (e.g., objects like User).
➤ Requires a separate class implementing ArgumentsProvider.

✅Example:
@ParameterizedTest
@ArgumentsSource(UserArgumentProvider.class)
void testSaveNewUser(User user) {
    assertTrue(userEntryService.saveNewUser(user));
}

👉 UserArgumentProvider example:

public class UserArgumentProvider implements ArgumentsProvider {
    @Override
    public Stream<? extends Arguments> provideArguments(ExtensionContext context) {
        return Stream.of(
            Arguments.of(new User("ankur", "ankur@gmail.com", "1234")),
            Arguments.of(new User("isha", "isha@gmail.com", "abcd"))
        );
    }
}

4️⃣ @Disabled
➤ Used to temporarily skip a test without deleting it.
➤ Helpful when a feature isn’t implemented yet or you want to ignore unstable tests.

✅ Example:
@Disabled("Disabled until bug #123 is fixed")
@Test
void testFeatureNotReady() {
    fail("This feature is under development");
}

5️⃣ Assertions
Assertions are used to verify the actual result against the expected result.
| Method                           | Usage                     |
| -------------------------------- | ------------------------- |
| `assertEquals(expected, actual)` | Check equality            |
| `assertTrue(condition)`          | Condition must be true    |
| `assertFalse(condition)`         | Condition must be false   |
| `assertNotNull(object)`          | Object should not be null |
| `assertNull(object)`             | Object should be null     |
| `assertThrows()`                 | Expected exception thrown |
✅Example:
@Test
void testAssertions() {
    assertEquals(4, 2 + 2);
    assertTrue(5 > 3);
    assertNotNull("Hello");
}


6️⃣ Test Naming & Organization
➤ Tests are usually written in the same package structure as the main code.
➤ Test class names typically end with Tests or Test.

✅ Example:
src/
 ├── main/java/net/engineeringdigest/journalApp/service/UserEntryService.java
 └── test/java/net/engineeringdigest/journalApp/service/UserServiceTests.java


🔷 Mockito
➤ Mockito is a mocking framework for Java used in unit testing to create fake (mock) objects that simulate the behavior of real objects.
➤ It allows you to test a class in isolation, without actually calling the real dependencies (like databases, APIs, or external services).

❓ Why Mockito is Needed
➤ Without mocking:
  ✔️ vUnit tests may depend on external systems like DB, APIs.
  ✔️ vTests may fail due to external failures, not your logic.
  ✔️ vTests become slow and hard to maintain.

➤ With Mockito:
  ✔️ vYou mock dependencies to test only your class logic.
  ✔️ vYou control the dependency behavior (what it returns).
  ✔️ vTests are fast, reliable, and isolated.


🔷 Spring Profiles 
➤ Spring Profiles allow you to activate or deactivate beans/configurations based on the current environment (like dev, test, prod).
➤ You can control which beans load depending on the active profile.
➤ You can create multiple versions of the same bean/class and Spring will only load the one matching the active profile.

🔄 Set Active Profile in application.properties
➤ You can specify the active profile directly in your main configuration file:
# application.properties
spring.profiles.active=dev

➤ This tells Spring Boot to load all settings from application-dev.properties in addition to the default application.properties.

🔄 Create Profile-Specific Property Files
Each profile has its own file following this naming convention:
application-{profile}.properties

✅ Example:
✔️ application-dev.properties
server.port=8081
spring.datasource.url=jdbc:mysql://localhost:3306/devdb
spring.datasource.username=dev_user
spring.datasource.password=dev123

✔️ application-prod.properties
server.port=8082
spring.datasource.url=jdbc:mysql://localhost:3306/proddb
spring.datasource.username=prod_user
spring.datasource.password=prod123

🔄 Activate Profile via Command Line
You can override the profile at runtime using the command line:

🔗 java -jar myapp.jar --spring.profiles.active=prod
👉 This overrides whatever is set in application.properties.


🔄 Using @Profile Annotation
You can annotate beans, components, or configuration classes to load only when a specific profile is active.

✅ Example: — Service Classes
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Service;

@Service
@Profile("dev")
public class DevEmailService implements EmailService {
    @Override
    public void sendEmail(String msg) {
        System.out.println("DEV: Sending mock email → " + msg);
    }
}

@Service
@Profile("prod")
public class ProdEmailService implements EmailService {
    @Override
    public void sendEmail(String msg) {
        System.out.println("PROD: Sending real email → " + msg);
    }
}
👉 If spring.profiles.active=dev, then only DevEmailService will be loaded.
👉 If spring.profiles.active=prod, then only ProdEmailService will load.

🔄 Using @Profile in Configuration Classes
You can also restrict entire configuration classes:

@Configuration
@Profile("test")
public class TestDatabaseConfig {

    @Bean
    public DataSource dataSource() {
        System.out.println("Using TEST database configuration");
        return new HikariDataSource();
    }
}
So when the active profile is test, this config will be used.

🔄 Get Active Profile Programmatically
You can access the active profile from the Spring Context’s Environment.

✅ Example:
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.stereotype.Component;

@Component
public class ActiveProfileLogger {

    @Autowired
    private ApplicationContext context;

    public void printActiveProfile() {
        String[] profiles = context.getEnvironment().getActiveProfiles();
        System.out.println("Active Profile: " + profiles[0]);
    }
}
✅ Output:
Active Profile: dev

🔄 Use in Tests (JUnit + Profiles)
You can set a profile for tests using @ActiveProfiles:

@SpringBootTest
@ActiveProfiles("test")
public class UserServiceTest {

    @Autowired
    private ApplicationContext context;

    @Test
    void checkProfile() {
        System.out.println("Running under profile: "
            + context.getEnvironment().getActiveProfiles()[0]);
    }
}
✅ Output:
Running under profile: test

🔄 Multiple Profiles at Once
You can activate more than one profile:
👉 spring.profiles.active=dev,local
Spring will load all beans matching either dev or local.

You can also use logical negation:
@Profile("!prod")   // load this bean in all profiles except prod

🔄 Using Profiles with YAML
You can define multiple profiles within a single YAML file using ---:
server:
  port: 8080

spring:
  profiles:
    active: dev

spring:
  config:
    activate:
      on-profile: dev
server:
  port: 8081


spring:
  config:
    activate:
      on-profile: prod
server:
  port: 9090
👉 Depending on which profile is active, the corresponding section will apply.

🔄 Checking Active Profile in Console (Quick Check)
In any Spring Boot class:
System.out.println(context.getEnvironment().getActiveProfiles()[0]);
👉 Prints the current active profile — very useful for debugging or verifying environment setup.


🔷 Logging in Spring Boot: SLF4J
➤ Logging is an essential aspect of the application development that allows developers to monitor and troubleshoot their applications.

➤ Spring Boot supports various logging frameworks, such as Logback, Log4J2, and Java Util Logging (JUL) out of the box.

🔄 understanding frameworks:
1️⃣ Logback: A popular logging framework that serves as default in many SpringBoot applications. It offers a flexible configuration and good performance.

2️⃣ Log4J2: A logging framework similar to Logback with features such as asynchronous logging and support various output formats.

3️⃣ Java Util Logging (JUL): A logging framework that is a part of the Java platform. While it's less feature rich than some third-party frameworks, it is straightforward to use.

✔️ Spring Boot uses Logback as the default logging framework provides a good balance between simplicity and performance.
✔️ The default configuration is embedded within the Spring Boot libraries, and it may not be visible in your application's source code.
✔️ If you want to customize the logging configuration, you can create your own logback-spring.xml or logback.xml file in the src/main/resources directory.
✔️ When SpringBoot detects this file in your project, it will use it instead of the default configuration.

🔄 Logging Levels
Spring Boot supports the following logging levels:
| Level     | Description             | Example                |
| --------- | ----------------------- | ---------------------- |
| TRACE     | Detailed debugging info | Fine-grained flow logs |
| DEBUG     | Useful for debugging    | Dev-time logs          |
| INFO      | General app flow        | Startup, shutdown      |
| WARN      | Potential issues        | Deprecated method used |
| ERROR     | Errors & exceptions     | DB connection failed   |
| OFF       | Turns off logging       | —                      |

We can set the desired logging levels for specific packages or classes, allowing them to control the amount of information logged at runtime.

Spring Boot provides annotations like @Slf4j and @Log4j2 to help with logging, that can be used to automatically inject logger instance


🔷 SLF4J
➤ SLF4J (Simple Logging Facade for Java) is a logging abstraction layer.
➤ It provides a common interface for various logging frameworks (Logback, Log4j2, JUL, etc.).
➤ Spring Boot internally uses SLF4J + Logback by default.
➤ Think of SLF4J as a “universal adapter” that lets you switch logging backends easily without changing your application code.

❓ Why Use SLF4J 
➤ Abstraction layer: decouples logging framework from code.
➤ Better performance: lazy evaluation of log messages ({} placeholders).
➤ Integration: widely supported in Spring, Hibernate, etc.
➤ Flexibility: easily switch from Logback → Log4j2 without code changes.

❓ How Logging Works in Spring Boot
➤ By defaultSLF4J API is used in code.
➤ Logback is the underlying implementation.
➤ Configurations are auto-loaded from:
  ✔️ application.properties or
  ✔️ logback-spring.xml

✅Example:
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

@Service
public class UserService {
    private static final Logger logger = LoggerFactory.getLogger(UserService.class);

    public void createUser(String name) {
        logger.info("Creating user: {}", name); 
        logger.debug("Debug info while creating user");
        logger.warn("This is a warning message");
        logger.error("Error occurred while creating user");
    }
}
✅ Output:
Creating user: Mike
Debug info while creating user
This is a warning message
Error occurred while creating user

🧠 Why {} ?
Because SLF4J supports parameterized logging — efficient and avoids string concatenation.

👉 We have to write:
 private static final Logger logger = LoggerFactory.getLogger(UserService.class);
 to use this line of code for every class for logging in Spring Boot.
 ⚡ We have to write log instead of logger in the code as well

 instead of this we can use:
 @Slf4j // annotation provided by lambok library
 @Service
 public class UserService {
     public void createUser(String name) {
         log.info("Creating user: {}", name);
         log.debug("Debug info while creating user");
         log.warn("This is a warning message");
         log.error("Error occurred while creating user");
     }
 }

🔄 Configure Logging in application.properties

🔗 Code Example:
# Root logging level
logging.level.root=INFO 
👉 this gives logs for all packages and classes of level info or severe than info i.e trace and debug will never get printed.

# Package-specific level
logging.level.net.engineeringdigest.journalApp=DEBUG

# Log file output
logging.file.name=app.log
logging.file.path=logs/

# Pattern for console output
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n

🔄 Logging with Profiles
You can set different logging levels for each Spring profile:

🔗 Code Example:
# application-dev.properties
logging.level.root=DEBUG

# application-prod.properties
logging.level.root=ERROR

And activate profile:
spring.profiles.active=dev

🔄  Access Logs in Code
You can print the active profile in your logs:

🔗 Code Example:
import org.springframework.core.env.Environment;
import org.springframework.beans.factory.annotation.Autowired;

@Autowired
private Environment env;

@PostConstruct
public void init() {
    String activeProfile = env.getActiveProfiles()[0];
    logger.info("Active profile: {}", activeProfile);
}

🔄 Configure in logback-spring.xml (Advanced)
When we have application.properties, we should use logback-spring.xml for logging configuration specifically.

🔗 Code Example:
<configuration>

👉 Console Appender 
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder> // encoder is a formatter for the output 
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger - %msg%n</pattern>
        </encoder>
    </appender>

👉 File appender
    <appender name="FILE" class="ch.qos.logback.core.FileAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
        <file>PAth_of_the_file</file>
    </appender>

👉 Set the root level and attach the console appender
    <root level="INFO">
        <appender-ref ref="CONSOLE"/>
        <appender-ref ref="FILE"/>
    </root>

👉 Set the log level for a specific package or classes
    <logger name="net.engineeringdigest.journalApp" level="DEBUG"/>

</configuration>

Understanding structure:
1️⃣ <configuration>
<!-- Appender and Logger configuration go here -->
</configuration>
➤ The <configuration> elements is the root element of the logback.xml file. All logback configuration is enclosed within this element.

🔄 Patter Syntax:
  ✔️ %d{yyyy-MM-dd HH:mm:ss} - date and time
  ✔️ [%thread] - thread name
  ✔️ %-5level - logging level(left justified text with atmost 5 characters)
  ✔️ %logger{36} - logger name upto 36 characters
  ✔️ %msg  %n - message and new line

🔄 Rolling FileAppender Based on Time
✅Example:

<configuration>
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>logs/application-%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>10</maxHistory>
        </rollingPolicy>
    </appender>
</configuration>


🔄 Rolling FileAppender Based on Size of File
✅Example:
<configuration>
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
        <rollingPolicy class="ch.qos.logback.core.rolling.SizeBasedRollingPolicy">
            <maxFileSize>10MB</maxFileSize>
            <maxHistory>10</maxHistory>
        </rollingPolicy>
    </appender>
</configuration>
👉 Rolling based of size and time can be used at the same time whatever happens first will make logs accordingly.



🔷 Working of Rest Template
@Component
public class WeatherService {
    private static final String apiKey = "a3cc93faecd095d1f1303fb69c75edae";
    private static final String API = "https://api.weatherstack.com/current?access_key=API_KEY" +
            "&query=CITY";

    @Autowired
    private RestTemplate restTemplate;

    public WeatherResponse getWeather(String city) {
        String finalURL = API.replace("API_KEY", apiKey).replace("CITY", city);
        ResponseEntity<WeatherResponse> res = restTemplate.exchange(
                finalURL,
                HttpMethod.GET,
                null,
                WeatherResponse.class
        );
        return res.getBody();
    }
}

➤ RestTemplate is a synchronous client to perform HTTP requests, exposing a simple, template method API over underlying HTTP client libraries such as the JDK HttpURLConnection, Apache HttpComponents, and others.
➤ It simplifies communication with HTTP servers, and enforces RESTful principles.
➤ Spring injects the RestTemplate bean here automatically.
➤ It simplifies sending HTTP requests and deserializing JSON responses into Java objects.

🔄 Making the REST Call
ResponseEntity<WeatherResponse> res = restTemplate.exchange(
        finalURL,             // URL
        HttpMethod.GET,        // HTTP Method
        null,                  // HTTP Entity (headers/body) — here null
        WeatherResponse.class  // Expected Response Type
);

👉 What Happens Here:
    ✔️ Sends a GET request to the Weather API.
    ✔️ The response (which is JSON) is automatically converted (deserialized) into a WeatherResponse Java object.
    ✔️ ResponseEntity<WeatherResponse> wraps the HTTP response → includes status code, headers, and body.


🔷 Headers in HTTP
➤ HTTP Headers are key-value pairs sent between the client and server in an HTTP request or response.
➤ They carry metadata about the request/response — such as content type, authorization token, user agent, etc.

✅ Example of Common HTTP Headers
GET /api/weather HTTP/1.1
Host: api.weatherstack.com
Authorization: Bearer abc123
Content-Type: application/json
User-Agent: PostmanRuntime/7.32.2

👉 Here:
    ✔️ Authorization → carries credentials or API keys
    ✔️ Content-Type → tells the server the data format (JSON, XML, etc.)
    ✔️ User-Agent → describes the client making the request

🔷 Pass Headers in Code (Spring Boot using RestTemplate)
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

@Service
public class WeatherService {

    private static final String API = "https://api.weatherstack.com/current?access_key={key}&query={city}";

    private final RestTemplate restTemplate = new RestTemplate();

    public WeatherResponse getWeather(String apiKey, String city) {

        // 1️⃣ Create headers
        HttpHeaders headers = new HttpHeaders();
        headers.set("Accept", "application/json"); // tells server to respond in JSON
        headers.set("User-Agent", "SpringBootApp");
        headers.set("Authorization", "Bearer some_token_here"); // example of passing token

        // 2️⃣ Build HttpEntity (headers + body)
        HttpEntity<String> entity = new HttpEntity<>(headers);

        // 3️⃣ Send request
        ResponseEntity<WeatherResponse> response = restTemplate.exchange(
                API,
                HttpMethod.GET,
                entity,                // includes headers
                WeatherResponse.class,
                apiKey, city           // replaces placeholders in URL
        );

        // 4️⃣ Return only body
        return response.getBody();
    }
}


🔄 Sending Headers + Body in a POST request
String url = "https://api.example.com/users";

// 1️⃣ Create headers
HttpHeaders headers = new HttpHeaders();
headers.setContentType(MediaType.APPLICATION_JSON);
headers.set("Authorization", "Bearer xyz123");

// 2️⃣ Create request body
User user = new User("Ankur", "ankur@example.com");

// 3️⃣ Combine headers and body
HttpEntity<User> entity = new HttpEntity<>(user, headers);

// 4️⃣ Make POST request
ResponseEntity<String> response = restTemplate.exchange(
        url,
        HttpMethod.POST,
        entity,
        String.class
);

🔄 Key Classes for HTTP Headers in Spring
| Class                   | Description                                        |
| ----------------------- | -------------------------------------------------- |
| `HttpHeaders            | Represents HTTP header values                      |
| `HttpEntity<T           | Represents request entity (headers + body)         |
| `ResponseEntity<T       | Represents the response (status, headers, body)    |
| `MediaType              | Helps specify content type like `application/json` |


🔄 Common HTTP Headers and Their Purposes
| Header          | Purpose                                                           |
| --------------- | ----------------------------------------------------------------- |
| `Content-Type`  | Tells server what type of data is being sent (`application/json`) |
| `Accept`        | Tells server what response format client expects                  |
| `Authorization` | Sends tokens, API keys, or credentials                            |
| `User-Agent`    | Identifies client making the request                              |
| `Cache-Control` | Caching policies                                                  |
| `Custom-Header` | You can define your own headers                                   |


🔷 MongoTemplate, Criteria, and Query in Spring Boot
➤ MongoTemplate is a core class in Spring Data MongoDB that provides:
    ✔️ Fine-grained control over queries,
    ✔️ Custom query building (beyond @Query or repository methods),
    ✔️ Access to MongoDB’s full query and aggregation power.
👉 It’s similar to how JdbcTemplate works for relational databases.

✅ Example:
  @Autowired
    private MongoTemplate mongoTemplate;

    public List<User> getUserForSentimentAnalysis() {
        Query query = new Query();
        query.addCriteria(Criteria.where("userName").is("Ram"));
        return mongoTemplate.find(query, User.class);

    }

➤ MongoTemplate is auto-configured by Spring Boot if MongoDB connection details exist in application.properties.
➤ Using @Autowired injects the template, allowing you to directly interact with the MongoDB database.

Query query = new Query();
👉 Creates a blank query object that can be configured with filters, sort, projection, etc.

query.addCriteria(Criteria.where("userName").is("Ram"));
👉 Builds a filter condition using Criteria.

This is equivalent to MongoDB’s JSON query:
{ "userName": "Ram" }
👉 You can chain multiple criteria using .and(), .orOperator(), .gt(), etc.

return mongoTemplate.find(query, User.class);
➤ Executes the query on the User collection (Spring automatically maps the class to the MongoDB collection).
➤ Converts each matching MongoDB document into a User Java object.
➤ Returns a List<User>

✅ Extended Examples: Find by multiple fields:
Query query = new Query();
query.addCriteria(Criteria.where("userName").is("Ram").and("age").gte(25));
List<User> users = mongoTemplate.find(query, User.class);

✅ Example: Using OR condition
Query query = new Query();
query.addCriteria(new Criteria().orOperator(
    Criteria.where("userName").is("Ram"),
    Criteria.where("email").is("ram@ram")
));
List<User> users = mongoTemplate.find(query, User.class);

❓ Why Use MongoTemplate Instead of MongoRepository?
| Use Case                                        | Prefer            |
| ----------------------------------------------- | ----------------- |
| Simple CRUD, auto queries                       | `MongoRepository` |
| Complex filters, dynamic criteria, aggregations | `MongoTemplate`   |


🔷 Send Email Using Spring Boot
1️⃣ Add Dependency

If you’re using Maven:
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-mail</artifactId>
</dependency>

2️⃣ Configure application.properties

For Gmail SMTP:
spring.mail.host=smtp.gmail.com
spring.mail.port=587
spring.mail.username=your_email@gmail.com
spring.mail.password=your_app_password
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true
spring.mail.properties.mail.debug=true
spring.mail.default-encoding=UTF-8

⚠️ Use an App Password for Gmail, not your normal password.

3️⃣ Create a Mail Service
Plain Text Email
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.stereotype.Service;

@Service
public class MailService {

    @Autowired
    private JavaMailSender mailSender;

    public void sendSimpleEmail(String to, String subject, String body) {
        SimpleMailMessage message = new SimpleMailMessage();
        message.setTo(to);
        message.setSubject(subject);
        message.setText(body);
        message.setFrom("your_email@gmail.com");

        mailSender.send(message);
        System.out.println("✅ Email sent successfully to " + to);
    }
}

HTML Email with Attachment
import org.springframework.core.io.FileSystemResource;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.stereotype.Service;

import jakarta.mail.MessagingException;
import jakarta.mail.internet.MimeMessage;
import java.io.File;

@Service
public class AdvancedMailService {

    private final JavaMailSender mailSender;

    public AdvancedMailService(JavaMailSender mailSender) {
        this.mailSender = mailSender;
    }

    public void sendHtmlEmailWithAttachment(String to, String subject, String htmlBody, String filePath) throws MessagingException {
        MimeMessage message = mailSender.createMimeMessage();
        MimeMessageHelper helper = new MimeMessageHelper(message, true);

        helper.setTo(to);
        helper.setSubject(subject);
        helper.setText(htmlBody, true); // true = HTML
        helper.setFrom("your_email@gmail.com");

        FileSystemResource file = new FileSystemResource(new File(filePath));
        helper.addAttachment(file.getFilename(), file);

        mailSender.send(message);
        System.out.println("✅ HTML Email with attachment sent to " + to);
    }
}


🔷 Scheduling Tasks with Cron Jobs in Spring Boot
🔄 Enabling Scheduling
Before you can schedule tasks, you must enable scheduling in your Spring Boot application.

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableScheduling  // ✅ Enables Spring’s scheduling capability
public class SchedulerApplication {
    public static void main(String[] args) {
        SpringApplication.run(SchedulerApplication.class, args);
    }
}

🔄 Creating a Scheduled Task
You can schedule any method to run automatically using the @Scheduled annotation.

import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

@Component
public class EmailScheduler {

    // Runs every 10 seconds
    @Scheduled(fixedRate = 10000)
    public void sendEmailReminder() {
        System.out.println("Sending reminder email at: " + java.time.LocalTime.now());
    }
}

🔄 Using Cron Expressions
For more flexible scheduling, you can use a cron expression.

@Component
public class CronJobScheduler {

    // Runs every day at 10:30 AM
    @Scheduled(cron = "0 30 10 * * ?")
    public void runDailyReport() {
        System.out.println("Running daily report at: " + java.time.LocalTime.now());
    }
}

🔄 Cron Expression Format
┌───────────── second (0–59)
│ ┌───────────── minute (0–59)
│ │ ┌───────────── hour (0–23)
│ │ │ ┌───────────── day of month (1–31)
│ │ │ │ ┌───────────── month (1–12)
│ │ │ │ │ ┌───────────── day of week (0–6) (Sunday=0 or 7)
│ │ │ │ │ │
│ │ │ │ │ │
* * * * * *

✅ Examples
Cron Expression	Meaning
| Cron Expression      | Meaning                               |
| -------------------- | ------------------------------------- |
| `0 * * * * *`        | Every minute                          |
| `0 0 * * * *`        | Every hour                            |
| `0 0 10 * * *`       | Every day at 10 AM                    |
| `0 0 10 * * MON-FRI` | Every weekday at 10 AM                |
| `0 */5 * * * *`      | Every 5 minutes                       |
| `0 0 0 1 * *`        | On the 1st of every month at midnight |


🔄 Scheduling with Zone and Initial Delay
You can specify time zones or add a delay before execution.

@Component
public class ReportScheduler {

    // Runs at 9 AM in IST time zone
    @Scheduled(cron = "0 0 9 * * *", zone = "Asia/Kolkata")
    public void generateReport() {
        System.out.println("Generating report at: " + java.time.ZonedDateTime.now());
    }

    // Runs 10 seconds after startup, then every 30 seconds
    @Scheduled(initialDelay = 10000, fixedRate = 30000)
    public void sendStartupNotification() {
        System.out.println("Running after startup: " + java.time.LocalTime.now());
    }
}

🔄 Use Cases
➤ Sending periodic emails (daily reports, reminders)
➤ Cleaning up database logs
➤ Generating reports
➤ Triggering backup jobs
➤ Running batch processes


🔷 Working with Redis in SpringBootApplication
➤ Redis is an open-source, in-memory data structure store used as a database, cache, and message broker.
➤ It supports various data structures such as strings, hashes, lists, sets, and more

install wsl (ubuntu) on windows and then follow below steps:
🟢 Redis Installation:
🔗 curl -fsSL https://packages.redis.io/gpg | sudo gpg --dearmor -o /usr/share/keyrings/redis-archive-keyring.gpg
🔗 echo "deb [signed-by=/usr/share/keyrings/redis-archive-keyring.gpg] https://packages.redis.io/deb $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/redis.list

🔗 sudo apt-get update
🔗 sudo apt-get install redis

🔗 sudo service redis-server start ----➤ this will start the server for the redis 
🔗 redis-cli ----➤ this will open the command line interface for redis we can see our port address on this 127.0.0.1:6379(localhost:port)

🔄 Adding Configuration in application.properties file:
🔗 spring.redis.host=localhost
🔗 spring.redis.port=6379

🔄 Redis Configuration Class
package net.engineeringdigest.journalApp.config;

@Configuration
public class RedisConfig {

    @Bean
    public RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory) {
        //redisConnectionFactory is used to make connection with the redis server
        RedisTemplate redisTemplate = new RedisTemplate();
        redisTemplate.setConnectionFactory(redisConnectionFactory);
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        redisTemplate.setValueSerializer(new StringRedisSerializer());
        redisTemplate.setHashKeySerializer(new StringRedisSerializer());
        redisTemplate.setHashValueSerializer(new StringRedisSerializer());
        return redisTemplate;
    }

} 
✅Explanation:
➤ RedisConnectionFactory: Spring injects this (normally a LettuceConnectionFactory by default in Spring Boot). It contains connection details (host/port/password) and manages connections to Redis nodes.
➤ RedisTemplate: Spring’s main helper for Redis operations. It exposes opsForValue(), opsForHash(), opsForList(), etc.
➤ Serializers:
    ✔️ Redis stores raw bytes. Serializers convert Java objects ↔ bytes.
    ✔️ StringRedisSerializer encodes/decodes UTF-8 strings. Using it for keys/values/hash entries ensures what you write looks the same in redis-cli.
➤ Why set all four serializers?
    ✔️ Keys: readable keys in CLI.
    ✔️ Values: you want stored JSON strings (not Java binary).
    ✔️ Hash key/value serializers: useful when using opsForHash() (Map-like structures).

👉 Effect: Your template writes keys and values as plain strings (UTF-8). Good for interoperability with other tools/clients.

🔄 RedisService.java
Redis Service package net.engineeringdigest.journalApp.service;
import java.util.concurrent.TimeUnit;

@Service
@Slf4j
public class RedisService {

    @Autowired
    private RedisTemplate redisTemplate;  ------➤ the raw RedisTemplate (no generics). It works but loses compile-time type safety.

    public <T> T getValue(String key, Class<T> entityClass) {
        try {
            Object object = redisTemplate.opsForValue().get(key);
            ObjectMapper mapper = new ObjectMapper();------➤ ObjectMapper is a Java library for reading and writing JSON, stored value (a string containing JSON), convert it to requested entityClass using ObjectMapper.
            return mapper.readValue(object.toString(), entityClass);
        } catch (Exception e) {
            log.error("Exception while getValue ", e);
            return null;
        }
    }

    public void setValue(String key, Object o, Long ttl) {
        try {
            ObjectMapper mapper = new ObjectMapper();
            String jsonValue = mapper.writeValueAsString(o);
            redisTemplate.opsForValue().set(key, jsonValue, ttl, TimeUnit.SECONDS);-----➤ Serialize o to JSON string and call set(key, value, ttl, SECONDS)
        } catch (Exception e) {
            log.error("Exception while setValue ", e);
        }
    }
}  

🔄 UserService.java
@Autowired
    private RestTemplate restTemplate;

    @Autowired
    private RedisService redisService;

    public WeatherResponse getWeather(String city) {
        WeatherResponse weatherResponse = redisService.getValue("weather_of_ " +city, WeatherResponse.class);
        if (weatherResponse != null) {
            return weatherResponse;
        } 
            
        String finalURL = API.replace("API_KEY", apiKey).replace("CITY", city);
        ResponseEntity<WeatherResponse> res = restTemplate.exchange(finalURL, HttpMethod.GET, null, WeatherResponse.class);//Deserializing the JSON

// response to the Java object is done automatically by the RestTemplate.
            WeatherResponse responseBody = res.getBody();
            if (responseBody != null) {
                redisService.setValue("weather_of_ " + city, responseBody, 5L * 60);
            }
        
        return weatherResponse;
    }  


========================
 🔷 Working with Kafka
 ========================
➤ Apache Kafka is a distributed event streaming platform used to:
    ✔️ Publish (send) and Subscribe (receive) streams of records/events.
    ✔️ Store streams of data durably.
    ✔️ Process streams of data in real time.
➤ Think of Kafka as a message broker — similar to RabbitMQ or ActiveMQ — but much more scalable, fault-tolerant, and high-throughput.
Kafka is designed to handle data that is constantly being generated and needs to be processed or analyzed in real time.

2️⃣ Real-World Example
Imagine you have an e-commerce system:
➤ When an order is placed → event published to Kafka.
➤  services listen:
    ✔️ Inventory Service → decreases stock.
    ✔️ Payment Service → charges the user.
    ✔️ Notification Service → sends email confirmation.

👉 These services are decoupled and communicate asynchronously via Kafka topics.

3️⃣ Core Kafka Concepts
| Concept            | Description                                                                        | Analogy                                   |
| ------------------ | ---------------------------------------------------------------------------------- | ----------------------------------------- |
| **Producer**       | Sends messages (events) to Kafka topics.                                           | Like a publisher.                         |
| **Consumer**       | Reads messages from Kafka topics.                                                  | Like a subscriber.                        |
| **Topic**          | A named category/feed where messages are stored.                                   | Like a “channel.”                         |
| **Partition**      | A topic is split into partitions for parallelism.                                  | Like dividing a queue into parts.         |
| **Offset**         | Each message in a partition has a unique ID (offset).                              | Like message index number.                |
| **Broker**         | A Kafka server that stores topics and data.                                        | Like a post office branch.                |
| **Consumer Group** | Group of consumers sharing the same topic messages.                                | Like team members splitting the workload. |
| **ZooKeeper**      | Manages Kafka brokers and cluster metadata. *(Now optional in new Kafka versions)* | Like a cluster manager.                   |

🔄 Kafka Connect
Kafka Connect is a framework provided by Apache Kafka to simplify data integration between Kafka and external systems such as databases, cloud storage, or APIs — without writing custom code.

🔄 Kafka Connect Architecture
        +-------------------+
        |    Source System  |
        | (e.g., MySQL DB)  |
        +-------------------+
                  |
                  |   Source Connector
                  v
           +----------------+
           |   Kafka Topic  |
           +----------------+
                  ^
                  |   Sink Connector
                  |
        +-------------------+
        |  Target System    |
        | (e.g., Elastic)   |
        +-------------------+


🔄 Kafka Topic:
➤ Named container for similar events, unique identifier of a topic is its name.
✅ Example: Student topic will have student related data.
➤ They are like tables in a database.
➤ They live insde a broker.
➤ Producer produce a message into the topic(ultimately to partitions in round robin fashion) or direectly to the partitions. Consumer poll continuously for few message using the topic name.

✔️ Partition:A topic is partitioned and distributed to kafka brokers in round robin fashion to achieve distributed system.
✔️ Replication Factor: A partition is replicated by this factor and it is replicated in another broker to prevent fault tolerance.


🔄 Partitions
➤ A topic is split into serveral parts which are known as the partitions of the topic.
➤ Partitions is where actually the message is located inside the topic.
➤ Therefore, while creating a topic we need to specify the number of partitions (the number is arbitrary and depends on the use case).
➤ Each partition is an ordered, immutable sequence of messages that is continually appended to—a structured commit log.
➤ Each message gets stored into partitions with an incremental id known as the offset valu.
➤ Ordering is there only at partition level(so if data is to be stored in order than do it on same partition).
➤ Partition continuously grows(offset increases) as new records are produced.
➤ All the records exist in distributed log file.

🔄 Working of Partitioner
We can send message with key or without key.
➤ If we send message without key, the producer will send the message to the partitions in round robin fashion hence, we cannot gurantee the ordering of message as consumer poll the message from all the partitions at the same time.
➤ If we send message with key, the producer will hash the key and then decide the partition to which the message is to be sent and the ordering will be maintained.

4️⃣ Why Use Kafka?
✅ High Throughput – Can process millions of events per second.
✅ Scalable – Add brokers or partitions easily.
✅ Durable – Data persisted to disk and replicated.
✅ Fault-Tolerant – If one broker fails, others continue.
✅ Decoupled Microservices – Producer and consumer are independent.

5️⃣ Kafka Architecture Overview
+-------------+        +----------------+         +----------------+
|   Producer  | -----> |     Kafka       | ----->  |    Consumer    |
|  (Publisher)|        |  (Topic, Broker)|         |  (Subscriber)  |
+-------------+        +----------------+         +----------------+
Topic: "weather_updates"
    ✔️ Producer: Weather Service publishing updates.
    ✔️ Consumer: Dashboard Service receiving updates.



🧰 6️⃣ Spring Boot Kafka Integration 
Add in pom.xml:

<dependencies>
    <!-- Spring Boot Kafka -->
    <dependency>
        <groupId>org.springframework.kafka</groupId>
        <artifactId>spring-kafka</artifactId>
    </dependency>
</dependencies>

🔄 Step 2: Configure application.properties
# Kafka broker address (local or remote)
spring.kafka.bootstrap-servers=localhost:9092

# Producer properties
spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer
spring.kafka.producer.value-serializer=org.apache.kafka.common.serialization.StringSerializer

# Consumer properties
spring.kafka.consumer.group-id=my-group
spring.kafka.consumer.auto-offset-reset=earliest
spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer
spring.kafka.consumer.value-deserializer=org.apache.kafka.common.serialization.StringDeserializer

🔄 Step 3: Create a Producer (Publisher)
package com.example.kafka.producer;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Service;

@Service
public class KafkaProducerService {

    private static final String TOPIC = "weather_updates";

    @Autowired
    private KafkaTemplate<String, String> kafkaTemplate;

    public void sendMessage(String message) {
        System.out.println("📤 Sending message: " + message);
        kafkaTemplate.send(TOPIC, message);
    }
}

🔄 Step 4: Create a Consumer (Subscriber)
package com.example.kafka.consumer;

import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.stereotype.Service;

@Service
public class KafkaConsumerService {

    @KafkaListener(topics = "weather_updates", groupId = "my-group")
    public void consumeMessage(String message) {
        System.out.println("📩 Received message: " + message);
    }
}

🔄 Step 5: Create Controller to Test
package com.example.kafka.controller;

import com.example.kafka.producer.KafkaProducerService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/kafka")
public class KafkaController {

    @Autowired
    private KafkaProducerService producer;

    @GetMapping("/publish/{message}")
    public String publishMessage(@PathVariable String message) {
        producer.sendMessage(message);
        return "Message published successfully: " + message;
    }
}

▶️ Step 6: Run Kafka + Zookeeper Locally (Docker Example)
Create docker-compose.yml:
version: '3'
services:
  zookeeper:
    image: wurstmeister/zookeeper
    ports:
      - "2181:2181"

  kafka:
    image: wurstmeister/kafka
    ports:
      - "9092:9092"
    environment:
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:9092
      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT
      KAFKA_INTER_BROKER_LISTENER_NAME: PLAINTEXT

Then run:
docker-compose up -d

✅ Step 7: Test
Open browser:
http://localhost:8080/kafka/publish/HelloKafka

Console output:
📤 Sending message: HelloKafka
📩 Received message: HelloKafka


🎉 Success! You have a fully working Kafka producer–consumer setup.

🔄 Advanced Concepts
| Concept                                | Explanation                                                                     |
| -------------------------------------- | ------------------------------------------------------------------------------- |
| **Partitions**                         | Split topic data for scalability; each consumer reads from specific partitions. |
| **Replication**                        | Kafka keeps multiple copies of data across brokers for fault tolerance.         |
| **Offset Management**                  | Keeps track of which messages were read by which consumer.                      |
| **Consumer Groups**                    | Multiple consumers in same group share messages (load-balanced).                |
| **Dead Letter Topics**                 | Store failed messages for debugging.                                            |
| **Avro / JSON / Protobuf Serializers** | For structured message formats.                                                 |
| **Kafka Streams / ksqlDB**             | For processing and aggregating data in real time.                               |
