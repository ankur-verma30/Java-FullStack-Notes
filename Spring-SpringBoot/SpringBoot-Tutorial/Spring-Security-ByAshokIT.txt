ğŸ”· Spring Security?

Spring Security is a powerful and customizable security framework provided by the Spring ecosystem.
It is used to secure Java web applications, especially Spring Boot applications, by handling
âœ”ï¸ Authentication â†’ Who are you
âœ”ï¸ Authorization â†’ What are you allowed to do?

Itâ€™s like a security guard that checks the identity of users and ensures they can only access what theyâ€™re permitted to.


ğŸ”„ Core Features of Spring Security
| Feature                    | Description                                                                   |
| -------------------------- | ----------------------------------------------------------------------------- |
| ğŸ”‘ **Authentication**      | Verifies the userâ€™s identity (e.g., via username/password, JWT, OAuth2, etc.) |
| ğŸ§¾ **Authorization**       | Controls access to specific endpoints or resources                            |
| ğŸ§± **Session Management**  | Handles login sessions, cookies, and logout behavior                          |
| ğŸ•µï¸ **CSRF Protection**    | Prevents Cross-Site Request Forgery attacks                                   |
| ğŸ›¡ï¸ **CORS Handling**      | Controls which front-end origins can access backend APIs                      |
| ğŸ”’ **Password Encryption** | Uses secure hashing (e.g., BCrypt) for passwords                              |
| ğŸŒ **Integration Support** | Works with JWT, OAuth2, LDAP, SSO, etc.                                       |


ğŸ”„ How Spring Security Works
1ï¸âƒ£ User sends a request
âœ… Example:
POST /login
{
  "username": "ankur",
  "password": "1234"
}

2ï¸âƒ£ Spring Security intercepts the request
It checks whether the request requires authentication or not.

3ï¸âƒ£ Authentication Manager verifies credentials
â¤ The AuthenticationManager delegates authentication to providers (like a DaoAuthenticationProvider).
â¤ It loads the user using a UserDetailsService from the database or in-memory storage.
â¤ Passwords are compared using a PasswordEncoder (e.g., BCrypt).

4ï¸âƒ£ If successful
â¤ Spring Security generates an Authentication object.
â¤ The userâ€™s details are stored in the SecurityContext.
â¤ The user gains access to secured endpoints.

5ï¸âƒ£ If failed
The framework automatically returns a 401 Unauthorized or 403 Forbidden response.


ğŸ”„ Key Components
| Component                 | Description                                                              |
| ------------------------- | ------------------------------------------------------------------------ |
| **SecurityFilterChain**   | Defines which routes are secured and what kind of authentication applies |
| **AuthenticationManager** | Core engine that performs authentication                                 |
| **UserDetailsService**    | Loads user info from DB or memory                                        |
| **UserDetails**           | Represents a single user                                                 |
| **PasswordEncoder**       | Encrypts and verifies passwords                                          |
| **SecurityContextHolder** | Stores the authenticated user details in current thread                  |

â¤ By default spring security gives password and after that the endpoints can be accessed by using:
âœ”ï¸ username: user 
âœ”ï¸ password: <password given on console>

We can override the default behavior by using:
ğŸ”— spring.security.user.name=your-username
ğŸ”— spring.security.user.password=your-password

We do not need security for all the endpoints just some of it so we can configure it using configuration file of spring security.

âœ… Example (Modern Spring Boot 3+)
In Spring Boot 3, security configuration uses a bean instead of extending WebSecurityConfigurerAdapter (which is deprecated).

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable()) // disable CSRF for APIs
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/public/**").permitAll()   // no auth required
                .requestMatchers("/api/admin/**").hasRole("ADMIN") // only ADMIN
                .anyRequest().authenticated()                    // others need login
            )
            .httpBasic(Customizer.withDefaults()); // basic auth (username/password)
        return http.build();
    }

    @Bean
    public UserDetailsService userDetailsService() {
        UserDetails user = User.withUsername("ankur")
                .password(passwordEncoder().encode("1234"))
                .roles("USER")
                .build();

        UserDetails admin = User.withUsername("admin")
                .password(passwordEncoder().encode("admin"))
                .roles("ADMIN")
                .build();

        return new InMemoryUserDetailsManager(user, admin);
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
ğŸ‘‰ Now:
âœ”ï¸ /api/public/** â†’ accessible to everyone
âœ”ï¸ /api/admin/** â†’ accessible only to ADMIN
âœ”ï¸ /api/** â†’ requires authentication

ğŸ”„ Types of Authentication Supported
| Type                     | Description                                                                     |
| ------------------------ | ------------------------------------------------------------------------------- |
| **Basic Auth**           | Username and password in the request header (simple, but not very secure alone) |
| **Form Login**           | Traditional HTML login form                                                     |
| **JWT (JSON Web Token)** | Token-based authentication for REST APIs                                        |
| **OAuth2 / SSO**         | Login with Google, GitHub, etc.                                                 |
| **LDAP**                 | Enterprise authentication system                                                |

ğŸ”„ Spring Security + Microservices
â¤ In a microservice architecture:
    âœ”ï¸ API Gateway often handles authentication (via JWT).
    âœ”ï¸ Individual microservices use Spring Security to verify and authorize requests based on roles/claims inside the JWT.

â¤ Common pattern:
    âœ”ï¸ Gateway validates the token â†’ passes user info in headers.
    âœ”ï¸ Downstream services apply @PreAuthorize or role-based access control.


 
ğŸ”„
ğŸ”„
ğŸ”„
ğŸ”„
ğŸ”„
ğŸ”„
ğŸ”„