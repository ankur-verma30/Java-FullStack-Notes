üî∑ Distributed Application
A distributed application is an application where components are spread across multiple computers (nodes) connected through a network, but they work together as a single system.
‚û§ They are used for Business to Business commnication unlike web applciaton communicate with Business to Client (C2B).

‚öôÔ∏è Key Idea:
Instead of all logic running on one server (like in a monolithic app), different parts ‚Äî frontend, backend, databases, microservices, etc. ‚Äî run on different machines or locations and communicate via network protocols (like HTTP, RPC, or gRPC).

‚úÖ Example: E-commerce Application
‚û§ Frontend (React app) ‚Üí runs on user‚Äôs browser.
‚û§ Backend API (Spring Boot) ‚Üí runs on AWS server.
‚û§ Database (MySQL) ‚Üí runs on a separate database server.
‚û§ Payment service (third-party) ‚Üí hosted externally.

All these parts interact to form one working e-commerce platform ‚Äî that‚Äôs a distributed application.

üîÑ Characteristics:
‚û§ Multiple independent nodes (different machines).
‚û§ Communication over network (e.g., REST, gRPC).
‚û§ Data sharing and synchronization between components.
‚û§ Scalability ‚Äì you can scale specific services independently.
‚û§ Fault tolerance ‚Äì if one node fails, others can still run.

üß± Architecture Examples:
‚û§ Client‚ÄìServer (basic distributed system)
‚û§ 3-Tier Architecture (UI, Application Server, Database)
‚û§ Microservices Architecture (each service deployed independently)
‚û§ Cloud-Native Applications (services running across data centers)

üß∞ Technologies Used:
‚û§ APIs / REST / gRPC for communication
‚û§ Message Queues (Kafka, RabbitMQ) for async communication
‚û§ Databases like MongoDB, Cassandra (distributed data)
‚û§ Load Balancers for traffic distribution
‚û§ Containers / Kubernetes for deployment

üîÅ Another Scenario of Distributed Application
‚úÖExample:MMT ‚Üî IRCTC ‚Äî A Real Distributed Interaction Example
‚û§ Both MMT (MakeMyTrip) and IRCTC are independent distributed systems,
but they interact with each other over a network to complete a single user request.
‚û§ That interaction itself makes the overall system ‚Äî the combination of MMT + IRCTC + users ‚Äî a larger distributed ecosystem.
‚û§ MMT doesn‚Äôt own the train data ‚Äî it connects to IRCTC‚Äôs distributed system through APIs.
‚û§ Both systems communicate and cooperate over the internet, while users experience it as one smooth platform.
‚û§ XML and JSON data will be used as mediaters to transfer data between MMT and IRCTC.


üî∑ Intereoperability
‚û§ The term interoperability refers to the ability of two or more systems to work together, even if they are not built for the same purpose or use the same architecture.
‚û§ It is a way to ensure that different systems can communicate and exchange data with each other, even if they are built using different technologies or have different interfaces.


üî∑ XML
XML (eXtensible Markup Language) is a markup language used to store and transport data in a structured, human-readable, and machine-readable format.

‚úÖ Example:
<Student>  -------------> compound eleement containing other elements
    <Name>Ankur Verma</Name>--------> simple element
    <RollNo>101</RollNo>
    <Branch>Information Technology</Branch>
</Student>
üëâ This stores structured data about a student ‚Äî not for displaying (like HTML), but for data exchange.

üîÑ Key Features:
‚û§ Self-descriptive ‚Äì Tags describe the data.
‚û§ Custom tags ‚Äì You can define your own (unlike HTML‚Äôs fixed tags).
‚û§ Platform-independent ‚Äì Works across systems and languages.
‚û§ Hierarchical structure ‚Äì Data stored in parent‚Äìchild format.
‚û§ Supports validation ‚Äì You can define structure rules using:
‚û§ DTD (Document Type Definition)
‚û§ XSD (XML Schema Definition)

üîÑ Common Uses:
‚û§ Configuration files (e.g., web.xml in Java web apps)
‚û§ Data exchange between systems (SOAP APIs, web services)
‚û§ Document storage (e.g., Office files internally use XML)
‚û§Serialization (saving objects in XML format)


üî∑ JAXB (Java Architecture for XML Binding) ‚Äî also called JAX-B API
‚úîÔ∏è JAXB is a Java API that allows you to convert Java objects into XML (marshalling) and XML back into Java objects (unmarshalling) easily.

‚úîÔ∏è It‚Äôs part of the Jakarta / Java EE (formerly JAX-B) stack and simplifies XML handling in Java applications ‚Äî no manual parsing required.

Upto Java 1.8 JAXB was part of the Java SE platform but removed from Java 1.9 version if you want to use should have a jax-b dependency.

üîÑ Core Operations:
1Ô∏è‚É£ Marshalling: Converts Java objects into XML.
2Ô∏è‚É£ Unmarshalling: Converts XML into Java objects.
3Ô∏è‚É£ Binding: Maps Java classes to XML elements and attributes.
4Ô∏è‚É£ Validation: Validates XML against a schema.
5Ô∏è‚É£ Schema Generation: Generates XML schemas from Java classes.

‚úÖ Example: 1Ô∏è‚É£ Create a java class
import jakarta.xml.bind.annotation.XmlElement;
import jakarta.xml.bind.annotation.XmlRootElement;

@XmlRootElement(name = "student")
public class Student {
    private String name;
    private int rollNo;

    // Default constructor (required by JAXB)
    public Student() {}

    public Student(String name, int rollNo) {
        this.name = name;
        this.rollNo = rollNo;
    }

    @XmlElement
    public String getName() {
        return name;
    }

    @XmlElement
    public int getRollNo() {
        return rollNo;
    }
}

2Ô∏è‚É£ Marshalling(Java --> XML)
import jakarta.xml.bind.JAXBContext;
import jakarta.xml.bind.Marshaller;

public class MarshallExample {
    public static void main(String[] args) throws Exception {
        Student s = new Student("Ankur Verma", 101);
        JAXBContext context = JAXBContext.newInstance(Student.class);
        Marshaller marshaller = context.createMarshaller();
        marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
        marshaller.marshal(s, System.out); // prints XML to console
    }
}
‚úÖ Output XML:
<student>
    <name>Ankur Verma</name>
    <rollNo>101</rollNo>
</student>

3Ô∏è‚É£ Unmarshalling(XML --> Java)
import jakarta.xml.bind.Unmarshaller;
import java.io.File;

public class UnmarshallExample {
    public static void main(String[] args) throws Exception {
        JAXBContext context = JAXBContext.newInstance(Student.class);
        Unmarshaller unmarshaller = context.createUnmarshaller();
        Student s = (Student) unmarshaller.unmarshal(new File("student.xml"));
        System.out.println(s.getName() + " - " + s.getRollNo());
    }
}
‚úÖ Output:
Ankur Verma - 101

üîÑ Real-World Use Cases:
‚û§ Converting XML payloads in SOAP web services
‚û§ Reading/writing config files in XML
‚û§ Data exchange between Java systems via XML
‚û§ Used in Spring Boot (for XML-based request/response mapping)


üî∑ JSON (JavaScript Object Notation)
JSON is a lightweight data-interchange format used to store and exchange data between a client and a server.

It‚Äôs language-independent, but easily readable by both humans and machines.

‚úÖ Example:
{
  "name": "Ankur Verma",
  "rollNo": 101,
  "branch": "Information Technology"
}

üîÑ Key Features of JSON:
‚û§ Lightweight ‚Äì smaller and faster than XML
‚û§ Easy to parse ‚Äì simple key-value structure
‚û§ Language-independent
‚û§ Key-value pair format
‚û§ Used widely in REST APIs
‚û§ Supports basic data types: string, number, boolean, array, object, null

üîÑJSON in Java (Working & Usage)
Java doesn‚Äôt have built-in JSON support, but several popular libraries make it easy to convert between Java objects and JSON:

Common libraries:
‚û§ Jackson (most popular, used by Spring Boot)
‚û§ Gson (by Google)
‚û§ org.json

1Ô∏è‚É£ Using Jackson Library (Most Common in Spring Boot)
‚úÖ Example of Java Class:
public class Student {
    private String name;
    private int rollNo;

    public Student() {}
    public Student(String name, int rollNo) {
        this.name = name;
        this.rollNo = rollNo;
    }

    // Getters and setters
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public int getRollNo() { return rollNo; }
    public void setRollNo(int rollNo) { this.rollNo = rollNo; }
}

üåÄ Object ‚Üí JSON (Serialization)
import com.fasterxml.jackson.databind.ObjectMapper;

public class ObjectToJson {
    public static void main(String[] args) throws Exception {
        Student s = new Student("Ankur Verma", 101);
        ObjectMapper mapper = new ObjectMapper();

        String jsonString = mapper.writeValueAsString(s);
        // for adding the json to a file
        // mapper.writeValue(new File("student.json"), s);
        System.out.println(jsonString);
    }
}

‚úÖ Output:
{"name":"Ankur Verma","rollNo":101}

üîÅ JSON ‚Üí Object (Deserialization)
public class JsonToObject {
    public static void main(String[] args) throws Exception {
        String jsonString = "{\"name\":\"Ankur Verma\",\"rollNo\":101}";
        ObjectMapper mapper = new ObjectMapper();

        Student s = mapper.readValue(jsonString, Student.class);
        System.out.println(s.getName() + " - " + s.getRollNo());
    }
}
‚úÖ Output:
Ankur Verma - 101

2Ô∏è‚É£ Using Gson Library (Alternative)
import com.google.gson.Gson;

public class GsonExample {
    public static void main(String[] args) {
        Student s = new Student("Ankur", 101);
        Gson gson = new Gson();

        // Object ‚Üí JSON
        String json = gson.toJson(s);
        System.out.println(json);

        // JSON ‚Üí Object
        Student obj = gson.fromJson(json, Student.class);
        System.out.println(obj.getName());
    }
}

Spring Boot automatically uses Jackson internally for JSON conversion.

üîÑ Real-World Use Cases:
‚û§ Reading/writing config files in JSON
‚û§ Data exchange between Java systems via JSON


üî∑ HTTP protocol
‚û§ HTTP (HyperText Transfer Protocol) is a client-server communication protocol used for transmitting data over the web.
‚û§ It defines how messages are formatted and transmitted, and how web servers and browsers should respond to various commands.
‚û§ It is a stateless protocol. It will treat each request independently.


‚ùìHow It Works
‚û§ Client sends a request ‚Üí (e.g., a web browser or REST client sends an HTTP request to the server).
‚û§ Server processes the request ‚Üí The web server receives the request, processes it, and prepares a response.
‚û§ Server sends back a response ‚Üí The server returns an HTTP response (status code + data).
‚û§ Connection may close (in HTTP/1.1 or remain open for HTTP/2 and HTTP/3).

üåü Basic Structure
1Ô∏è‚É£ HTTP Request Structure
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Chrome/108.0
Accept: text/html


2Ô∏è‚É£ HTTP Response Structure
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 1234

<html>
<body>Hello, World!</body>
</html>

üîÑ Common HTTP Methods
| Method     | Description                                       |
| ---------- | ------------------------------------------------- |
| **GET**    | Retrieve data from the server (no body).          |
| **POST**   | Send data to the server (used for creating data). |
| **PUT**    | Update existing resource completely.              |
| **PATCH**  | Update part of a resource.                        |
| **DELETE** | Delete a resource.                                |
| **HEAD**   | Same as GET but returns only headers.             |

üîπ HTTP Status Codes
| Code Range | Meaning       | Example                        |
| ---------- | ------------- | ------------------------------ |
| **1xx**    | Informational | 100 Continue                   |
| **2xx**    | Success       | 200 OK, 201 Created            |
| **3xx**    | Redirection   | 301 Moved Permanently          |
| **4xx**    | Client Error  | 400 Bad Request, 404 Not Found |
| **5xx**    | Server Error  | 500 Internal Server Error      |

üîÑ Features
‚û§ Stateless: Each request is independent; no session info is stored by default.
‚û§ Text-based: Human-readable request and response format.
‚û§ Extensible: Supports custom headers, cookies, and authentication.
‚û§ Uses TCP (Port 80) or HTTPS (Port 443) for secure communication.


üî∑ HTTP Request and HTTP Response
1Ô∏è‚É£ HTTP Request
An HTTP request is a message sent by the client (like a browser or app) to ask the server to perform an action ‚Äî such as fetching data, submitting a form, or deleting a record.

üîÑ Structure of an HTTP Request
Method  URL  Protocol-Version
Headers
(blank line)
Body (optional)

‚úÖ Example:
GET /users?id=10 HTTP/1.1
Host: example.com
User-Agent: Chrome/121.0
Accept: application/json

üîÑ Main Components:
‚û§ Request Line
    ‚úîÔ∏è Includes HTTP method, URL, and HTTP version.
    ‚úÖ Example: GET /home HTTP/1.1
‚û§ Headers
    ‚úîÔ∏è Provide additional info like content type, authentication, etc.
    ‚úÖ Example:
            Content-Type: application/json
            Authorization: Bearer token123
‚û§ Body (Optional)
    ‚úîÔ∏è Carries data with requests like POST, PUT, or PATCH.
    ‚úÖ Example:
        {
          "name": "Ankur",
          "email": "ankur@gmail.com"
        }

2Ô∏è‚É£ HTTP Response
An HTTP response is the message sent by the server back to the client after processing the request.

üîÑ Structure of an HTTP Response
Protocol-Version Status-Code Status-Message
Headers
(blank line)
Body (optional)

‚úÖ Example:
HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 47
{
  "id": 10,
  "name": "Ankur",
  "email": "ankur@gmail.com"
}

üîÑ Main Components:
‚û§ Status Line
‚úÖ Example: HTTP/1.1 200 OK
    üîó Includes:
        ‚úîÔ∏è HTTP version (HTTP/1.1)
        ‚úîÔ∏è Status code (200)
        ‚úîÔ∏è Status message (OK)
‚û§ Headers
    ‚úîÔ∏è Give info about the response.
    ‚úÖ Example:
        Content-Type: text/html
        Cache-Control: no-cache
‚û§ Body (Optional)
    ‚úîÔ∏è Contains the actual data (HTML, JSON, XML, etc.)

üîÑ Request‚ÄìResponse Flow Example
üîó Client (Browser):
    GET /products HTTP/1.1
    Host: www.shop.com

üîó Server (Response):
    HTTP/1.1 200 OK
    Content-Type: application/json
    [{"id":1,"name":"Laptop","price":50000}]


üî∑ Media Types in Rest API
‚û§ A Media Type (or MIME type) tells the format of data being sent or received in an HTTP message.
‚û§ It helps the client and server understand how to interpret the request or response body.

üí° Syntax: type/subtype

‚úÖ Examples:
| Media Type            | Description           |
| --------------------- | --------------------- |
| `application/json`    | JSON data             |
| `application/xml`     | XML data              |
| `text/html`           | HTML content          |
| `text/plain`          | Plain text            |
| `multipart/form-data` | Used for file uploads |
| `application/pdf`     | PDF file              |


1Ô∏è‚É£ Media Type in HTTP Request
When a client sends data (like in a POST or PUT request), it uses the Content-Type header to specify the format.
‚úÖ Example:
POST /api/users HTTP/1.1
Content-Type: application/json

{
  "name": "Ankur",
  "email": "ankur@gmail.com"
}
‚û°Ô∏è This tells the server that the body is in JSON format.

2Ô∏è‚É£ Media Type in HTTP Response
The server uses the Content-Type header to tell the client what type of data it‚Äôs returning.
‚úÖ Example:
HTTP/1.1 200 OK
Content-Type: application/json

{
  "status": "success",
  "id": 101
}
‚û°Ô∏è This tells the client that the response body is JSON.

3Ô∏è‚É£ Content Negotiation in REST APIs
In REST, the client can tell the server which format it accepts using the Accept header.
‚úÖ Example:
GET /api/users HTTP/1.1
Accept: application/json
‚úîÔ∏è The client says: ‚ÄúI want the response in JSON.‚Äù
‚úîÔ∏è The server will then return data in JSON format (if supported).

‚û§ If the client instead says:
Accept: application/xml

‚û§ The server can respond with:
Content-Type: application/xml


4Ô∏è‚É£ Media Types in Spring Boot REST APIs
In Spring Boot, you can specify media types using:
‚û§ @RequestMapping, @PostMapping, @GetMapping etc.
@RestController
@RequestMapping("/api")
public class UserController {

    @PostMapping(
        value = "/users",
        consumes = "application/json",     // Request body format 
        produces = "application/json"      // Response format
    )
    // can provide multiple values for the consumes and produces
    public ResponseEntity<User> addUser(@RequestBody User user) {
        return ResponseEntity.ok(user);
    }
}

‚úÖ consumes ‚Üí tells what type of input the API accepts
‚úÖ produces ‚Üí tells what type of output the API returns

üìã Common Media Types in REST APIs
| Media Type                          | Use                            |
| ----------------------------------- | ------------------------------ |
| `application/json`                  | Most common for REST APIs      |
| `application/xml`                   | Used in SOAP or XML-based APIs |
| `text/plain`                        | Simple text data               |
| `multipart/form-data`               | File uploads (e.g. image, PDF) |
| `application/x-www-form-urlencoded` | HTML form submissions          |


‚ö° Real-World Example
‚úÖ Request:
POST /upload HTTP/1.1
Content-Type: multipart/form-data
Accept: application/json

‚úÖ Response:
HTTP/1.1 200 OK
Content-Type: application/json
{"message": "File uploaded successfully!"}



üî∑ Rest Client Development
A REST Client is a tool, library, or component that allows you to send HTTP requests (GET, POST, PUT, DELETE, etc.) to a REST API and receive responses ‚Äî typically used to test, consume, or interact with RESTful web services.

A REST Client acts as a consumer of REST APIs.
It sends HTTP requests to the server (REST API endpoint) and reads the HTTP responses returned.

In springboot we can develop REST Client using 3 ways:
1Ô∏è‚É£ Using RestTemplate (Synchrnous Communication: sending request and wating for response then processing other requests)
2Ô∏è‚É£ Using WebClient (Synchrnous + Asynchrnous Communication)
3Ô∏è‚É£ Using Feign

üîÑ Example in Real Life
‚û§ When you use Postman, you‚Äôre using a REST Client application to test APIs.
‚û§ When a frontend app (React, Angular, Flutter) calls an API using fetch() or axios, those are REST Client libraries making HTTP calls.

‚úÖ Example - Java REST Client Using RestTemplate
import org.springframework.web.client.RestTemplate;
import org.springframework.http.ResponseEntity;


üîÑ Working of RestTemplate
‚û§ RestTemplate is a class provided by Spring Framework that acts as a synchronous REST client.
‚û§ It allows your Spring application to make HTTP requests (GET, POST, PUT, DELETE) to consume REST APIs.

‚û§ Think of it as your Java-based Postman ‚Äî but used inside your application code.

2Ô∏è‚É£ When to Use It
‚û§ You use RestTemplate when:
    ‚úîÔ∏è Your Spring app wants to call another REST API (either external or internal).
    ‚úîÔ∏è You need to integrate multiple microservices.
    ‚úîÔ∏è You want to send or receive JSON data programmatically

3Ô∏è‚É£ How It Works Internally
Here‚Äôs the internal flow:

[Your Spring App] ‚Üí (RestTemplate) ‚Üí [HTTP Request] ‚Üí [Target REST API] 
‚Üí [Response] ‚Üí (RestTemplate parses it) ‚Üí [Java Object or String]

‚úÖ Example Flow:
You call:
restTemplate.getForObject("https://jsonplaceholder.typicode.com/posts/1", Post.class);
‚Üí It makes a GET request to that URL
‚Üí Gets the JSON response
‚Üí Converts it automatically into a Post Java object using Jackson JSON Mapper

‚úÖ Example:
Let's say we have StudentService and a client Service that calls it.

üîó StudentController.java (Server/API Provider)
package com.example.demo.controller;

import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/students")
public class StudentController {

    @GetMapping("/{id}")
    public Student getStudent(@PathVariable int id) {
        return new Student(id, "Ankur Verma", "IT");
    }
}

üîó StudentService.java 
package com.example.demo.request;
@Data
class Student {
    private int id;
    private String name;
    private String department;
}

üîó StudentClient.java (Consumer using RestTemplate)
package com.example.demo.client;

import org.springframework.http.ResponseEntity;
import org.springframework.web.client.RestTemplate;
import org.springframework.stereotype.Component;

@Component
public class StudentClient {

    private final RestTemplate restTemplate = new RestTemplate();

    public void getStudentDetails() {
        String url = "http://localhost:8080/api/students/1";

        // Make GET request and receive response as Student object
        ResponseEntity<Student> response = restTemplate.getForEntity(url, Student.class);

        // Print response
        System.out.println("Status Code: " + response.getStatusCode());
        System.out.println("Student Details:");
        System.out.println("ID: " + response.getBody().getId());
        System.out.println("Name: " + response.getBody().getName());
        System.out.println("Department: " + response.getBody().getDepartment());
    }
}

// Student model (same structure as in API)
@Data
class Student {
    private int id;
    private String name;
    private String department;
}

üîÑ Running the Example
‚û§ Run the StudentController application (port 8080).
‚Üí It exposes an endpoint:
GET http://localhost:8080/api/students/1

‚û§ Run StudentClient class (it can be in another app or in same app).
‚Üí It makes a GET call using RestTemplate.

‚úÖ You‚Äôll see output like:
Status Code: 200 OK
Student Details:
ID: 1
Name: Ankur Verma
Department: IT


Commonly Used RestTemplate Methods
| Method                            | Purpose                                                  | Example                                                   |
| --------------------------------- | -------------------------------------------------------- | --------------------------------------------------------- |
| `getForObject(url, class)`        | GET request and returns object directly                  | `restTemplate.getForObject(url, Student.class)`           |
| `getForEntity(url, class)`        | GET request and returns `ResponseEntity` (status + body) | `restTemplate.getForEntity(url, Student.class)`           |
| `postForObject(url, body, class)` | POST request and returns created object                  | `restTemplate.postForObject(url, student, Student.class)` |
| `postForEntity(url, body, class)` | POST request returning full response                     | `restTemplate.postForEntity(url, student, Student.class)` |
| `put(url, body)`                  | PUT request (no return)                                  | `restTemplate.put(url, student)`                          |
| `delete(url)`                     | DELETE request                                           | `restTemplate.delete(url)`                                |


üî∑ WebClient
‚û§ WebClient is part of Spring WebFlux, a reactive web framework introduced in Spring 5.
‚û§ It is used to make asynchronous, non-blocking HTTP requests to REST APIs.

üëâ Think of it as:
A reactive, lightweight, and flexible version of RestTemplate

üîÑ Why WebClient Was Introduced
‚û§ RestTemplate (older client) works in a blocking manner ‚Äî
that means each thread waits for the response before continuing.
‚û§ In contrast, WebClient is non-blocking ‚Äî
it can handle many requests concurrently with fewer threads, improving performance and scalability.

üîÑ Key Features of WebClient
| Feature                      | Description                                                               |
| ---------------------------- | ------------------------------------------------------------------------- |
| **Reactive (Non-blocking)**  | Uses Project Reactor (`Mono` and `Flux`) for async programming.           |
| **Lightweight**              | Doesn‚Äôt depend on Servlet API. Works in both Spring MVC and WebFlux apps. |
| **Supports Streaming**       | Can handle continuous data streams (e.g., SSE, WebSockets).               |
| **Functional API**           | Fluent builder-style syntax for constructing requests.                    |
| **Can Replace RestTemplate** | Fully supports GET, POST, PUT, DELETE, etc.                               |


üîÑ When to Use WebClient
‚úîÔ∏è When building reactive or high-performance applications.
‚úîÔ∏è When handling multiple concurrent API calls.
‚úîÔ∏è When you need to stream data (e.g., continuous updates).
‚úîÔ∏è When you‚Äôre using Spring WebFlux or microservices.

üîÑ Basic Syntax
WebClient webClient = WebClient.create("http://localhost:8080");

Mono<Student> studentMono = webClient.get()
    .uri("/api/students/1")
    .retrieve()
    .bodyToMono(Student.class);
Mono<Student> is a reactive type that represents one asynchronous result (like a Future<Student>).


üîÑ WebClient vs RestTemplate
| Feature                   | `RestTemplate`                  | `WebClient`                 |
| ------------------------- | ------------------------------- | --------------------------- |
| **Introduced In**         | Spring 3                        | Spring 5 (WebFlux)          |
| **Type**                  | Synchronous (Blocking)          | Asynchronous (Non-blocking) |
| **Performance**           | Slower (one thread per request) | Faster (reactive model)     |
| **Reactive Support**      | ‚ùå No                            | ‚úÖ Yes                       |
| **Streaming Support**     | ‚ùå No                            | ‚úÖ Yes                       |
| **Recommended By Spring** | Deprecated (for new apps)       | ‚úÖ Official Replacement      |


Maven dependency for WebClient:
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-webflux</artifactId>
</dependency>

‚û§ spring-boot-starter-web --> class
‚û§ spring-boot-starter-webflux --> interface

üîÑ Reactive Concepts Used
1Ô∏è‚É£ Mono<T> ‚Üí represents 0 or 1 asynchronous result (like one Student).
2Ô∏è‚É£ Flux<T> ‚Üí represents 0 or many asynchronous results (like list of Students).

‚úÖ Example:
Flux<Student> students = webClient.get()
    .uri("/api/students")
    .retrieve()
    .bodyToFlux(Student.class);

üîÑ Real-World Use Case Example
Let‚Äôs say you have a Student Service that needs to call another Course Service.

@Service
public class StudentService {

    private final WebClient webClient = WebClient.create("http://course-service:8081");

    public Mono<Course> getCourseDetails(int studentId) {
        return webClient.get()
                .uri("/api/courses/student/{id}", studentId)
                .retrieve()
                .bodyToMono(Course.class);
    }
}
‚úÖ Non-blocking, so the thread doesn‚Äôt wait for the response ‚Äî
it can handle hundreds of concurrent API calls efficiently.


üî∑ Spring Data REST
‚û§ Spring Data REST is a module of the Spring Data project that automatically exposes RESTful APIs for your Spring Data Repositories ‚Äî without writing any controller code.

‚û§ If you already have a JpaRepository, Spring Data REST will automatically create REST endpoints (GET, POST, PUT, DELETE) for you.

üîÑ How It Works
When you include the dependency spring-boot-starter-data-rest, Spring Boot:
‚û§ Scans your repositories (like StudentRepository).
‚û§ Automatically creates REST endpoints under /entities or your custom path.
‚û§ Converts Java entities to JSON responses.
‚û§ Handles CRUD operations and pagination by default.


üîÑ Dependency
üëâ Add this dependency in your pom.xml:

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-rest</artifactId>
</dependency>
‚ö° (You must also have spring-boot-starter-data-jpa and a database driver like mysql-connector-java.)

‚úÖ Example: Exposing Student Repository as REST API
1Ô∏è‚É£ Entity Class
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;

@Entity
public class Student {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private String course;

    // getters and setters
}

2Ô∏è‚É£ Repository Interface
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.rest.core.annotation.RepositoryRestResource;

@RepositoryRestResource(path = "students")
public interface StudentRepository extends JpaRepository<Student, Long> {
}
‚úÖ The @RepositoryRestResource(path = "students") annotation tells Spring Data REST to expose this repository as a REST resource under /students.

3Ô∏è‚É£ Run the Application
When you start your Spring Boot app, Spring Data REST automatically generates endpoints like:
| HTTP Method | Endpoint         | Description                        |
| ----------- | ---------------- | ---------------------------------- |
| **GET**     | `/students`      | Get all students (with pagination) |
| **GET**     | `/students/{id}` | Get student by ID                  |
| **POST**    | `/students`      | Create a new student               |
| **PUT**     | `/students/{id}` | Update an existing student         |
| **DELETE**  | `/students/{id}` | Delete student by ID               |

‚úÖ Example Request & Response
üëâ POST Request:
POST /students
Content-Type: application/json
{
  "name": "Ankur Verma",
  "course": "B.Tech IT"
}

üëâ Response:
{
  "id": 1,
  "name": "Ankur Verma",
  "course": "B.Tech IT"
}

üîÑ Customization Options
| Annotation                               | Purpose                                                               |
| ---------------------------------------- | --------------------------------------------------------------------- |
| `@RepositoryRestResource`                | Customize path, collection name, and relation name.                   |
| `@RestResource`                          | Customize endpoint exposure for specific methods.                     |
| `@Projection`                            | Control what fields are shown in REST responses.                      |
| `@ExcerptProjection`                     | Show summarized data when listing entities.                           |
| `@HandleBeforeSave` / `@HandleAfterSave` | Add custom logic (like events) before or after repository operations. |


‚úÖ Example of Customization
@RepositoryRestResource(collectionResourceRel = "learners", path = "students")
public interface StudentRepository extends JpaRepository<Student, Long> {

    @RestResource(path = "byName", rel = "byName")
    List<Student> findByNameContaining(@Param("name") String name);
}
üëâ Now you can access:
For findBy queries we have to add /search to the path, for example:
GET /students/search/byName?name=Ankur

üîÑ Internals & Concepts
‚û§ Spring Data REST uses HAL (Hypertext Application Language) format by default for HATEOAS links.
‚û§ Uses Spring MVC under the hood, but you don‚Äôt need to write controllers.
‚û§ It‚Äôs built on Spring Data Repositories, so all query methods automatically become endpoints.

üîÑ Advantages
‚úÖ No need to write boilerplate controller code.
‚úÖ Automatic CRUD and pagination.
‚úÖ HATEOAS support for navigable APIs.
‚úÖ Integrates easily with JPA, MongoDB, Neo4j, etc.
‚úÖ Easy to customize endpoints and data projections.

üîÑ When Not to Use
‚û§ If your API requires complex business logic or custom response structures.
‚û§ If you need authentication, role-based access, or API versioning ‚Äî then you‚Äôd better write custom controllers.

üîÑ Goal
Restrict or disable specific HTTP methods (like POST, PUT, or DELETE) for certain entities when using Spring Data REST.

1Ô∏è‚É£ Create Configuration Class
You‚Äôll use RepositoryRestConfigurer to customize repository exposure.

package com.example.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.data.rest.core.config.RepositoryRestConfiguration;
import org.springframework.data.rest.webmvc.config.RepositoryRestConfigurer;
import org.springframework.http.HttpMethod;

import com.example.entity.Student;

@Configuration
public class RestRepositoryConfig implements RepositoryRestConfigurer {

    @Override
    public void configureRepositoryRestConfiguration(RepositoryRestConfiguration config) {

        // Disable HTTP methods for Student entity: PUT, POST, DELETE
        HttpMethod[] unsupportedActions = {HttpMethod.PUT, HttpMethod.POST, HttpMethod.DELETE};

        // Apply restrictions
        config.getExposureConfiguration()
                .forDomainType(Student.class)
                .withItemExposure((metadata, httpMethods) ->
                        httpMethods.disable(unsupportedActions))
                .withCollectionExposure((metadata, httpMethods) ->
                        httpMethods.disable(unsupportedActions));
    }
}


üîÑ Apply Restrictions to Multiple Entities
You can restrict multiple repositories easily:

config.getExposureConfiguration()
        .forDomainType(Student.class)
        .withItemExposure((metadata, httpMethods) -> httpMethods.disable(unsupportedActions))
        .withCollectionExposure((metadata, httpMethods) -> httpMethods.disable(unsupportedActions));

config.getExposureConfiguration()
        .forDomainType(Course.class)
        .withItemExposure((metadata, httpMethods) -> httpMethods.disable(unsupportedActions))
        .withCollectionExposure((metadata, httpMethods) -> httpMethods.disable(unsupportedActions));

üîÑ Optional ‚Äî Expose Entity IDs in JSON
By default, Spring Data REST hides entity IDs.
You can expose them in the same config class:

config.exposeIdsFor(Student.class);


üî∑ REST API Exception handling
In springboot we can handle exception in 2 ways:
| Type                         | Description                                                                 | Scope               |
| ---------------------------- | --------------------------------------------------------------------------- | ------------------- |
| **Global Exception Handler** | Handles exceptions **across all controllers** using `@RestControllerAdvice` | Application-wide    |
| **Local Exception Handler**  | Handles exceptions **within a single controller** using `@ExceptionHandler` | Controller-specific |

üîÑ Steps:
‚û§ Create User Defined Exception class
‚û§ Create ExceptionInfo binding class
‚û§ Create Rest Controller Advice to handle global exceptions in our application.

Step 1Ô∏è‚É£ Create User-Defined Exception Class
This is your custom business exception ‚Äî for example, when a student is not found.

package com.example.exception;

public class StudentNotFoundException extends RuntimeException {
    public StudentNotFoundException(String message) {
        super(message);
    }
}

2Ô∏è‚É£ Create ExceptionInfo (Response Model) Class
This class represents the structure of the error response returned to the client.

package com.example.exception;

import java.time.LocalDateTime;
import lombok.AllArgsConstructor;
import lombok.Data;

@AllArgsConstructor
@Data
public class ExceptionInfo {
    private String message;
    private String path;
    private LocalDateTime timestamp;
    private String errorCode;
    
}

üåê 3Ô∏è‚É£ Global Exception Handler ‚Äî @RestControllerAdvice
This handles exceptions for the entire Spring Boot application.
package com.example.exception;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.context.request.WebRequest;

@RestControllerAdvice
public class GlobalExceptionHandler {

    // Handle specific exception
    @ExceptionHandler(StudentNotFoundException.class)
    public ResponseEntity<ExceptionInfo> handleStudentNotFound(StudentNotFoundException ex, WebRequest request) {
        ExceptionInfo info = new ExceptionInfo(
                ex.getMessage(),
                request.getDescription(false),
                "STUDENT_NOT_FOUND"
        );
        return new ResponseEntity<>(info, HttpStatus.NOT_FOUND);
    }

    // Handle all other exceptions (fallback)
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ExceptionInfo> handleGeneralException(Exception ex, WebRequest request) {
        ExceptionInfo info = new ExceptionInfo(
                ex.getMessage(),
                request.getDescription(false),
                "INTERNAL_SERVER_ERROR"
        );
        return new ResponseEntity<>(info, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
üëâ What Happens Here:
‚û§ Whenever StudentNotFoundException is thrown in any controller, this advice class catches it.
‚û§ It returns a JSON response with details like timestamp, error message, and URL


üîÑ Local Exception Handler (Controller-Specific)
This handles exceptions inside a specific controller only.

package com.example.controller;

import com.example.exception.StudentNotFoundException;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/students")
public class StudentController {

    @GetMapping("/{id}")
    public String getStudent(@PathVariable int id) {
        if (id != 1) {
            throw new StudentNotFoundException("Student with ID " + id + " not found!");
        }
        return "Student Found: Ankur";
    }

    // Local handler ‚Äî only works inside this controller
    @ExceptionHandler(StudentNotFoundException.class)
    public String handleLocalException(StudentNotFoundException ex) {
        return "‚ö† Local Handler: " + ex.getMessage();
    }
}
üëâ What Happens:
‚úîÔ∏è When /api/students/5 is called, it throws StudentNotFoundException.
‚úîÔ∏è The local exception handler catches it first (if available).
‚úîÔ∏è If not defined locally, then the global handler catches it.

üßæ 5Ô∏è‚É£ Sample JSON Response (From Global Handler)
{
  "message": "Student with ID 10 not found!",
  "path": "uri=/api/students/10",
  "timestamp": "2025-11-04T15:12:40.305",
  "errorCode": "STUDENT_NOT_FOUND"
}


üî∑ DIFFERENCE BETWEEN @ControllerAdvice AND @RestControllerAdvice
Annotation              | Description / Behavior
---------------------------------------------------------------------------------------
@ControllerAdvice        | Used to handle exceptions globally across controllers.
                         | Returns a view name (HTML/JSP) by default.
                         | Typically used in web MVC applications (non-REST).
                         | Must use @ResponseBody on methods to return JSON.
                         | Combines well with @ExceptionHandler, @ModelAttribute, etc.
                         | Example: returns "error-page" view template.

@RestControllerAdvice    | Introduced as a specialized version of @ControllerAdvice.
                         | It combines @ControllerAdvice + @ResponseBody.
                         | All handler methods return JSON or XML automatically.
                         | Ideal for REST APIs (Spring Boot RESTful services).
                         | No need to explicitly add @ResponseBody on methods.
                         | Example: returns JSON error response instead of a view.

---------------------------------------------------------------------------------------

‚úÖ Example 1 ‚Äî Using @ControllerAdvice (Web MVC)
@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(Exception.class)
    public ModelAndView handleException(Exception ex) {
        ModelAndView mav = new ModelAndView("error");
        mav.addObject("message", ex.getMessage());
        return mav;
    }
}
üîÑ Explanation:
‚û§ Used in normal Spring MVC web apps.
‚û§ Returns a view page (e.g., error.html or error.jsp).
‚û§ If you want JSON, you must manually add @ResponseBody to the method.


‚úÖ Example 2 ‚Äî Using @RestControllerAdvice (REST API)
@RestControllerAdvice
public class GlobalRestExceptionHandler {

    @ExceptionHandler(Exception.class)
    public ResponseEntity<Map<String, String>> handleAll(Exception ex) {
        Map<String, String> error = new HashMap<>();
        error.put("error", ex.getMessage());
        error.put("status", "500");
        return ResponseEntity.status(500).body(error);
    }
}
üîÑ Explanation:
‚û§ Used for REST controllers.
‚û§ Automatically converts return values to JSON (no need for @ResponseBody).
‚û§ Cleaner and preferred for Spring Boot RESTful APIs.


üî∑ REST(Representation State Transfer) Architecture Principles 
1Ô∏è‚É£ Client-Server Architecture  
‚û§ Separation of concerns between client (frontend/UI) and server (backend).  
‚û§ Client handles UI and user interaction; server handles data storage and logic.  
‚û§ Enables scalability, modularity, and independent development.

2Ô∏è‚É£ Statelessness  
‚û§ Each request from client to server must contain all required information.  
‚û§ Server does not store any client session data.  
‚û§ Improves reliability and scalability since each request is independent.

3Ô∏è‚É£ Cacheability  
‚û§ Responses must define themselves as cacheable or non-cacheable.  
‚û§ Reduces client-server interactions, improves performance.  
‚û§ Example: HTTP headers like Cache-Control, ETag.

4Ô∏è‚É£ Uniform Interface  
‚û§ Common standard way to communicate between client and server.  
‚û§ Core of REST design ‚Äî ensures simplicity and decoupling.  
‚û§ Includes:
    ‚úîÔ∏è Resource Identification (using URIs)
    ‚úîÔ∏è Manipulation of Resources through representations (JSON/XML)
    ‚úîÔ∏è Self-descriptive messages (metadata in headers)
    ‚úîÔ∏è HATEOAS (Hypermedia as the Engine of Application State)

5Ô∏è‚É£ Layered System  
‚û§ Architecture composed of hierarchical layers (client, API gateway, server, DB).  
‚û§ Each layer has a specific function and does not need to know others‚Äô details.  
‚û§ Improves scalability and security through load balancers, proxies, etc.

6Ô∏è‚É£ Code-on-Demand (Optional)  
‚û§ Allows server to send executable code (like JavaScript) to client for execution.  
‚û§ Adds flexibility, but rarely used due to security concerns.


