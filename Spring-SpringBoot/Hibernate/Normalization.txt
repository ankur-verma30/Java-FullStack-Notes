🔷 Normalization
A database design technique to organize data efficiently.

Goals:
✔️ Reduce redundancy (no unnecessary repetition of data).
✔️ Improve data consistency and integrity.
✔️ Break a large unstructured table into smaller, related tables.  

Forms of Normalization:
🌟 First Normal Form (1NF)

Rules:
👉 Each column must have atomic values (no multiple values in a single cell, e.g., "CS, IT").
👉 Values in a column must be of the same data type (no mixing, e.g., phone number + email in one column).
👉 Each row must be unique → requires a primary key.
👉 No repeating groups or arrays allowed.

✅ Example (Before 1NF):
| StudentID | Name | Subjects | Phone Numbers |
| --------- | ---- | -------- | ------------- |
| 1         | Alex | CS, IT   | 1234, 5678    |

✅ After 1NF:
| StudentID | Name | Subject | PhoneNumber |
| --------- | ---- | ------- | ----------- |
| 1         | Alex | CS      | 1234        |
| 1         | Alex | IT      | 5678        |

🌟 Second Normal Form (2NF)
Precondition: Must already satisfy 1NF.

Rules:
👉 No partial dependency → every non-key attribute should depend on the whole primary key, not just a part of it.
👉 Applies only when the table has a composite primary key (more than one column as PK).

✅ Example (Before 2NF):
| StudentID | CourseID | StudentName | CourseName | Instructor |
➤ Composite key = (StudentID, CourseID)
➤ Problem: StudentName depends only on StudentID, not on CourseID.

✅ After 2NF:
➤ Students Table: (StudentID → StudentName)
➤ Courses Table: (CourseID → CourseName, Instructor)
➤ Enrollment Table: (StudentID, CourseID)

🌟 Third Normal Form (3NF)
Precondition: Must already satisfy 2NF.

Rules:
👉 No transitive dependency → non-key attributes should not depend on other non-key attributes.
👉 Every non-key column must depend only on the primary key.

✅ Example (Before 3NF):
| StudentID | Name | DeptID | DeptName | DeptHead |
➤ Problem: DeptName and DeptHead depend on DeptID, not directly on StudentID.

✅ After 3NF:
➤ Students Table: (StudentID → Name, DeptID)
➤ Departments Table: (DeptID → DeptName, DeptHead)

⚡ Tips:
Emphasize:
✔️ 1NF → Atomic values, no repeating groups.
✔️ 2NF → Remove partial dependency.
✔️ 3NF → Remove transitive dependency.

🧠 Common trap: Interviewers may ask if 2NF applies when there is no 
 composite key.
🔄 Answer: No, because partial dependency exists only with composite keys.

🧠 Working through normalization step-by-step helps ensure a well-structured database design.

✅ For Example:
(0) Unnormalized table (UNF)

OrderSheet (single table)
OrderID | OrderDate|CustomerName|CustomerEmail|CustomerAddress|BookISBN| BookTitle | BookAuthor  |UnitPrice  |Quantity|LineTotal|  PhoneNumbers (comma-separated)
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
101     |2025-08-01| John Smith | john@x.com | 221B Baker St| 999-1    | SQL Basics| Ada Lovelace| 500       | 1      | 500     | Phones: "98765, 91234"
101     |2025-08-01| John Smith | john@x.com | 221B Baker St| 999-2    | DB Design | E. Codd     | 700       | 2      | 1400    | Phones: "98765, 91234"
102     |2025-08-02| Robert Ray | rob@y.com  | 42 Galaxy Way| 999-2    | DB Design | E. Codd     | 700       | 1      | 700     | Phones: "99887"

What’s wrong here:
➤ Multi-valued attribute: PhoneNumbers = "98765, 91234" (not atomic).
➤ Redundancy: customer & book details repeat across rows.
➤ Update anomalies: change John’s address → must update many rows.
➤ Insert/delete anomalies: can’t insert a new book without an order; deleting John’s order may “lose” the book’s master data.

🌟 First Normal Form (1NF)
Goal:
➤ Make every cell atomic, consistent types, define a key, and eliminate repeating groups.

Fixes we’ll do
➤ Remove comma-separated phones into a separate table.
➤ Keep a composite primary key (OrderID, BookISBN) in the order-lines so two books in one order are allowed.
➤ Keep other columns as-is for now.

1NF schema
OrderLines_1NF(
  OrderID,        -- part of PK
  BookISBN,       -- part of PK
  OrderDate,
  CustomerName,
  CustomerEmail,
  CustomerAddress,
  BookTitle,
  BookAuthor,
  UnitPrice,
  Quantity,
  LineTotal
  PRIMARY KEY (OrderID, BookISBN)
)

CustomerPhones_1NF(
  CustomerEmail,  -- we’ll temporarily use email to link phones
  PhoneNumber,
  PRIMARY KEY (CustomerEmail, PhoneNumber)
)

⚡Why this is 1NF now
➤ No multi-valued fields; phones are atomic and stored as separate rows.
➤ A row is uniquely identified by (OrderID, BookISBN).
➤ Column types are consistent.

Still redundant: Customer info depends only on OrderID; book info depends only on BookISBN. That’s the 2NF problem.

🌟 Second Normal Form (2NF):
✅ Precondition: Table(s) are in 1NF.

❗Rule: No partial dependency—every non-key attribute must depend on the entire composite key (when a composite key exists).

In OrderLines_1NF, the PK is (OrderID, BookISBN):
➤ OrderDate, CustomerName, CustomerEmail, CustomerAddress depend only on OrderID (part of the key) → partial dependency.
➤ BookTitle, BookAuthor, UnitPrice depend only on BookISBN (part of the key) → partial dependency.
➤ Quantity, LineTotal depend on both → fine.

Decompose to remove partial dependencies

2NF schema
Orders_2NF(
  OrderID PK,
  OrderDate,
  CustomerName,
  CustomerEmail,
  CustomerAddress
)

Books_2NF(
  BookISBN K,
  BookTitle,
  BookAuthor,
  UnitPrice
)

OrderItems_2NF(
  OrderID        -- part of PK, FK -> Orders_2NF(OrderID)
  BookISBN       -- part of PK, FK -> Books_2NF(BookISBN)
  Quantity,
  LineTotal,
  PRIMARY KEY (OrderID, BookISBN)
)

CustomerPhones_2NF(
  CustomerEmail,
  PhoneNumber,
  PRIMARY KEY (CustomerEmail, PhoneNumber)
)

🔗 What we gained
➤ No attribute in OrderItems_2NF depends only on part of its composite key.
➤ Book and customer order headers are stored once—redundancy drops.

Still an issue for 3NF: In Orders_2NF, CustomerName/Email/Address are really properties of a Customer, not of an Order. We also still keep LineTotal, which is derivable (Quantity × UnitPrice). That creates a transitive/derived dependency risk.

🌟 Third Normal Form (3NF)
✅ Precondition: In 2NF.
❗ Rule: No transitive dependency—non-key attributes must not depend on other non-key attributes.

What’s transitive here?

If we introduce a stable CustomerID, then:
➤ Orders would have CustomerID (FK) and non-key attributes like CustomerName/Email/Address would depend on CustomerID, not directly on OrderID → transitive dependency in Orders_2NF.
➤ LineTotal depends on Quantity and UnitPrice (the latter is in Books). It’s derivable, and storing it risks inconsistency.

🔄 Decompose & clean

Final 3NF schema
Customers(
  CustomerID     PK,
  CustomerName,
  CustomerEmail  UNIQUE,
  CustomerAddress
)

CustomerPhones(
  CustomerID     FK -> Customers(CustomerID),
  PhoneNumber,
  PRIMARY KEY (CustomerID, PhoneNumber)
)

Orders(
  OrderID        PK,
  OrderDate,
  CustomerID     FK -> Customers(CustomerID)
)

Books(
  BookISBN       PK,
  BookTitle,
  BookAuthor,
  UnitPrice
)

OrderItems(
  OrderID        FK -> Orders(OrderID),
  BookISBN       FK -> Books(BookISBN),
  Quantity,
  -- no LineTotal here (computed when needed)
  PRIMARY KEY (OrderID, BookISBN)
)
🔗 Why this is 3NF:
➤ In Orders, every non-key attribute (OrderDate, CustomerID) depends only on the key (OrderID), and nothing depends on another non-key attribute.
➤ Customer details live in Customers; phones in CustomerPhones with a clean 1-to-many.
➤ Book master data is in Books.
➤ OrderItems only has attributes that depend on the whole composite key (OrderID, BookISBN).
➤ Derived value LineTotal removed → no transitive/derived dependency.

Sample data (3NF)

📝 Customers
CustomerID | CustomerName | CustomerEmail | CustomerAddress
-----------------------------------------------------------
C001       | John Smith   | john@x.com    | 221B Baker St
C002       | Robert Ray   | rob@y.com     | 42 Galaxy Way

📝 CustomerPhones
CustomerID | PhoneNumber
------------------------
C001       | 98765
C001       | 91234
C002       | 99887

📝 Books
BookISBN | BookTitle     | BookAuthor   | UnitPrice
---------------------------------------------------
999-1    | SQL Basics    | Ada Lovelace | 500
999-2    | DB Design     | E. Codd      | 700

📝 Orders
OrderID | OrderDate   | CustomerID
-----------------------------------
101     | 2025-08-01  | C001
102     | 2025-08-02  | C002

📝 OrderItems
OrderID | BookISBN | Quantity
-----------------------------
101     | 999-1    | 1
101     | 999-2    | 2
102     | 999-2    | 1

🔄 Practical SQL (3NF):
Create tables
-- Master tables

CREATE TABLE Customers (
  CustomerID      VARCHAR(10) PRIMARY KEY,
  CustomerName    VARCHAR(100) NOT NULL,
  CustomerEmail   VARCHAR(150) UNIQUE NOT NULL,
  CustomerAddress VARCHAR(200) NOT NULL
);

CREATE TABLE CustomerPhones (
  CustomerID   VARCHAR(10) NOT NULL,
  PhoneNumber  VARCHAR(20) NOT NULL,
  PRIMARY KEY (CustomerID, PhoneNumber),
  FOREIGN KEY (CustomerID) REFERENCES Customers(CustomerID)
);

CREATE TABLE Books (
  BookISBN    VARCHAR(20) PRIMARY KEY,
  BookTitle   VARCHAR(150) NOT NULL,
  BookAuthor  VARCHAR(100) NOT NULL,
  UnitPrice   DECIMAL(10,2) NOT NULL
);

-- Transaction tables
CREATE TABLE Orders (
  OrderID     INT PRIMARY KEY,
  OrderDate   DATE NOT NULL,
  CustomerID  VARCHAR(10) NOT NULL,
  FOREIGN KEY (CustomerID) REFERENCES Customers(CustomerID)
);

CREATE TABLE OrderItems (
  OrderID    INT NOT NULL,
  BookISBN   VARCHAR(20) NOT NULL,
  Quantity   INT NOT NULL CHECK (Quantity > 0),
  PRIMARY KEY (OrderID, BookISBN),
  FOREIGN KEY (OrderID)  REFERENCES Orders(OrderID),
  FOREIGN KEY (BookISBN) REFERENCES Books(BookISBN)
);


⚡ Compute an order’s total (derived at query-time, no redundancy):
➤ SELECT
  oi.OrderID,
  SUM(oi.Quantity * b.UnitPrice) AS OrderTotal
FROM OrderItems oi
JOIN Books b ON b.BookISBN = oi.BookISBN
WHERE oi.OrderID = 101
GROUP BY oi.OrderID;

⚡ List line items with computed line totals:
➤ SELECT
  o.OrderID,
  o.OrderDate,
  c.CustomerName,
  b.BookTitle,
  oi.Quantity,
  (oi.Quantity * b.UnitPrice) AS LineTotal
FROM Orders o
JOIN Customers c   ON c.CustomerID = o.CustomerID
JOIN OrderItems oi ON oi.OrderID = o.OrderID
JOIN Books b       ON b.BookISBN = oi.BookISBN
WHERE o.OrderID = 101;

✅ Key takeaways (interview-friendly)
⚡ 1NF: Atomic values, no repeating groups; define a key.
⚡ 2NF: Remove partial dependencies from tables with composite keys (separate order header vs. book master vs. order items).
⚡ 3NF: Remove transitive dependencies (move customer details to Customers; drop derived LineTotal).

Result: minimal redundancy, better integrity; queries use joins to rebuild the full picture.
