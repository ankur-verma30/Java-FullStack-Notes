ðŸ”· Normalization
A database design technique to organize data efficiently.

Goals:
âœ”ï¸ Reduce redundancy (no unnecessary repetition of data).
âœ”ï¸ Improve data consistency and integrity.
âœ”ï¸ Break a large unstructured table into smaller, related tables.  

Forms of Normalization:
ðŸŒŸ First Normal Form (1NF)

Rules:
ðŸ‘‰ Each column must have atomic values (no multiple values in a single cell, e.g., "CS, IT").
ðŸ‘‰ Values in a column must be of the same data type (no mixing, e.g., phone number + email in one column).
ðŸ‘‰ Each row must be unique â†’ requires a primary key.
ðŸ‘‰ No repeating groups or arrays allowed.

âœ… Example (Before 1NF):
| StudentID | Name | Subjects | Phone Numbers |
| --------- | ---- | -------- | ------------- |
| 1         | Alex | CS, IT   | 1234, 5678    |

âœ… After 1NF:
| StudentID | Name | Subject | PhoneNumber |
| --------- | ---- | ------- | ----------- |
| 1         | Alex | CS      | 1234        |
| 1         | Alex | IT      | 5678        |

ðŸŒŸ Second Normal Form (2NF)
Precondition: Must already satisfy 1NF.

Rules:
ðŸ‘‰ No partial dependency â†’ every non-key attribute should depend on the whole primary key, not just a part of it.
ðŸ‘‰ Applies only when the table has a composite primary key (more than one column as PK).

âœ… Example (Before 2NF):
| StudentID | CourseID | StudentName | CourseName | Instructor |
âž¤ Composite key = (StudentID, CourseID)
âž¤ Problem: StudentName depends only on StudentID, not on CourseID.

âœ… After 2NF:
âž¤ Students Table: (StudentID â†’ StudentName)
âž¤ Courses Table: (CourseID â†’ CourseName, Instructor)
âž¤ Enrollment Table: (StudentID, CourseID)

ðŸŒŸ Third Normal Form (3NF)
Precondition: Must already satisfy 2NF.

Rules:
ðŸ‘‰ No transitive dependency â†’ non-key attributes should not depend on other non-key attributes.
ðŸ‘‰ Every non-key column must depend only on the primary key.

âœ… Example (Before 3NF):
| StudentID | Name | DeptID | DeptName | DeptHead |
âž¤ Problem: DeptName and DeptHead depend on DeptID, not directly on StudentID.

âœ… After 3NF:
âž¤ Students Table: (StudentID â†’ Name, DeptID)
âž¤ Departments Table: (DeptID â†’ DeptName, DeptHead)

âš¡ Tips:
Emphasize:
âœ”ï¸ 1NF â†’ Atomic values, no repeating groups.
âœ”ï¸ 2NF â†’ Remove partial dependency.
âœ”ï¸ 3NF â†’ Remove transitive dependency.

ðŸ§  Common trap: Interviewers may ask if 2NF applies when there is no 
 composite key.
ðŸ”„ Answer: No, because partial dependency exists only with composite keys.

ðŸ§  Working through normalization step-by-step helps ensure a well-structured database design.

âœ… For Example:
(0) Unnormalized table (UNF)

OrderSheet (single table)
OrderID | OrderDate|CustomerName|CustomerEmail|CustomerAddress|BookISBN| BookTitle | BookAuthor  |UnitPrice  |Quantity|LineTotal|  PhoneNumbers (comma-separated)
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
101     |2025-08-01| John Smith | john@x.com | 221B Baker St| 999-1    | SQL Basics| Ada Lovelace| 500       | 1      | 500     | Phones: "98765, 91234"
101     |2025-08-01| John Smith | john@x.com | 221B Baker St| 999-2    | DB Design | E. Codd     | 700       | 2      | 1400    | Phones: "98765, 91234"
102     |2025-08-02| Robert Ray | rob@y.com  | 42 Galaxy Way| 999-2    | DB Design | E. Codd     | 700       | 1      | 700     | Phones: "99887"

Whatâ€™s wrong here:
âž¤ Multi-valued attribute: PhoneNumbers = "98765, 91234" (not atomic).
âž¤ Redundancy: customer & book details repeat across rows.
âž¤ Update anomalies: change Johnâ€™s address â†’ must update many rows.
âž¤ Insert/delete anomalies: canâ€™t insert a new book without an order; deleting Johnâ€™s order may â€œloseâ€ the bookâ€™s master data.

ðŸŒŸ First Normal Form (1NF)
Goal:
âž¤ Make every cell atomic, consistent types, define a key, and eliminate repeating groups.

Fixes weâ€™ll do
âž¤ Remove comma-separated phones into a separate table.
âž¤ Keep a composite primary key (OrderID, BookISBN) in the order-lines so two books in one order are allowed.
âž¤ Keep other columns as-is for now.

1NF schema
OrderLines_1NF(
  OrderID,        -- part of PK
  BookISBN,       -- part of PK
  OrderDate,
  CustomerName,
  CustomerEmail,
  CustomerAddress,
  BookTitle,
  BookAuthor,
  UnitPrice,
  Quantity,
  LineTotal
  PRIMARY KEY (OrderID, BookISBN)
)

CustomerPhones_1NF(
  CustomerEmail,  -- weâ€™ll temporarily use email to link phones
  PhoneNumber,
  PRIMARY KEY (CustomerEmail, PhoneNumber)
)

âš¡Why this is 1NF now
âž¤ No multi-valued fields; phones are atomic and stored as separate rows.
âž¤ A row is uniquely identified by (OrderID, BookISBN).
âž¤ Column types are consistent.

Still redundant: Customer info depends only on OrderID; book info depends only on BookISBN. Thatâ€™s the 2NF problem.

ðŸŒŸ Second Normal Form (2NF):
âœ… Precondition: Table(s) are in 1NF.

â—Rule: No partial dependencyâ€”every non-key attribute must depend on the entire composite key (when a composite key exists).

In OrderLines_1NF, the PK is (OrderID, BookISBN):
âž¤ OrderDate, CustomerName, CustomerEmail, CustomerAddress depend only on OrderID (part of the key) â†’ partial dependency.
âž¤ BookTitle, BookAuthor, UnitPrice depend only on BookISBN (part of the key) â†’ partial dependency.
âž¤ Quantity, LineTotal depend on both â†’ fine.

Decompose to remove partial dependencies

2NF schema
Orders_2NF(
  OrderID PK,
  OrderDate,
  CustomerName,
  CustomerEmail,
  CustomerAddress
)

Books_2NF(
  BookISBN K,
  BookTitle,
  BookAuthor,
  UnitPrice
)

OrderItems_2NF(
  OrderID        -- part of PK, FK -> Orders_2NF(OrderID)
  BookISBN       -- part of PK, FK -> Books_2NF(BookISBN)
  Quantity,
  LineTotal,
  PRIMARY KEY (OrderID, BookISBN)
)

CustomerPhones_2NF(
  CustomerEmail,
  PhoneNumber,
  PRIMARY KEY (CustomerEmail, PhoneNumber)
)

ðŸ”— What we gained
âž¤ No attribute in OrderItems_2NF depends only on part of its composite key.
âž¤ Book and customer order headers are stored onceâ€”redundancy drops.

Still an issue for 3NF: In Orders_2NF, CustomerName/Email/Address are really properties of a Customer, not of an Order. We also still keep LineTotal, which is derivable (Quantity Ã— UnitPrice). That creates a transitive/derived dependency risk.

ðŸŒŸ Third Normal Form (3NF)
âœ… Precondition: In 2NF.
â— Rule: No transitive dependencyâ€”non-key attributes must not depend on other non-key attributes.

Whatâ€™s transitive here?

If we introduce a stable CustomerID, then:
âž¤ Orders would have CustomerID (FK) and non-key attributes like CustomerName/Email/Address would depend on CustomerID, not directly on OrderID â†’ transitive dependency in Orders_2NF.
âž¤ LineTotal depends on Quantity and UnitPrice (the latter is in Books). Itâ€™s derivable, and storing it risks inconsistency.

ðŸ”„ Decompose & clean

Final 3NF schema
Customers(
  CustomerID     PK,
  CustomerName,
  CustomerEmail  UNIQUE,
  CustomerAddress
)

CustomerPhones(
  CustomerID     FK -> Customers(CustomerID),
  PhoneNumber,
  PRIMARY KEY (CustomerID, PhoneNumber)
)

Orders(
  OrderID        PK,
  OrderDate,
  CustomerID     FK -> Customers(CustomerID)
)

Books(
  BookISBN       PK,
  BookTitle,
  BookAuthor,
  UnitPrice
)

OrderItems(
  OrderID        FK -> Orders(OrderID),
  BookISBN       FK -> Books(BookISBN),
  Quantity,
  -- no LineTotal here (computed when needed)
  PRIMARY KEY (OrderID, BookISBN)
)
ðŸ”— Why this is 3NF:
âž¤ In Orders, every non-key attribute (OrderDate, CustomerID) depends only on the key (OrderID), and nothing depends on another non-key attribute.
âž¤ Customer details live in Customers; phones in CustomerPhones with a clean 1-to-many.
âž¤ Book master data is in Books.
âž¤ OrderItems only has attributes that depend on the whole composite key (OrderID, BookISBN).
âž¤ Derived value LineTotal removed â†’ no transitive/derived dependency.

Sample data (3NF)

ðŸ“ Customers
CustomerID | CustomerName | CustomerEmail | CustomerAddress
-----------------------------------------------------------
C001       | John Smith   | john@x.com    | 221B Baker St
C002       | Robert Ray   | rob@y.com     | 42 Galaxy Way

ðŸ“ CustomerPhones
CustomerID | PhoneNumber
------------------------
C001       | 98765
C001       | 91234
C002       | 99887

ðŸ“ Books
BookISBN | BookTitle     | BookAuthor   | UnitPrice
---------------------------------------------------
999-1    | SQL Basics    | Ada Lovelace | 500
999-2    | DB Design     | E. Codd      | 700

ðŸ“ Orders
OrderID | OrderDate   | CustomerID
-----------------------------------
101     | 2025-08-01  | C001
102     | 2025-08-02  | C002

ðŸ“ OrderItems
OrderID | BookISBN | Quantity
-----------------------------
101     | 999-1    | 1
101     | 999-2    | 2
102     | 999-2    | 1

ðŸ”„ Practical SQL (3NF):
Create tables
-- Master tables

CREATE TABLE Customers (
  CustomerID      VARCHAR(10) PRIMARY KEY,
  CustomerName    VARCHAR(100) NOT NULL,
  CustomerEmail   VARCHAR(150) UNIQUE NOT NULL,
  CustomerAddress VARCHAR(200) NOT NULL
);

CREATE TABLE CustomerPhones (
  CustomerID   VARCHAR(10) NOT NULL,
  PhoneNumber  VARCHAR(20) NOT NULL,
  PRIMARY KEY (CustomerID, PhoneNumber),
  FOREIGN KEY (CustomerID) REFERENCES Customers(CustomerID)
);

CREATE TABLE Books (
  BookISBN    VARCHAR(20) PRIMARY KEY,
  BookTitle   VARCHAR(150) NOT NULL,
  BookAuthor  VARCHAR(100) NOT NULL,
  UnitPrice   DECIMAL(10,2) NOT NULL
);

-- Transaction tables
CREATE TABLE Orders (
  OrderID     INT PRIMARY KEY,
  OrderDate   DATE NOT NULL,
  CustomerID  VARCHAR(10) NOT NULL,
  FOREIGN KEY (CustomerID) REFERENCES Customers(CustomerID)
);

CREATE TABLE OrderItems (
  OrderID    INT NOT NULL,
  BookISBN   VARCHAR(20) NOT NULL,
  Quantity   INT NOT NULL CHECK (Quantity > 0),
  PRIMARY KEY (OrderID, BookISBN),
  FOREIGN KEY (OrderID)  REFERENCES Orders(OrderID),
  FOREIGN KEY (BookISBN) REFERENCES Books(BookISBN)
);


âš¡ Compute an orderâ€™s total (derived at query-time, no redundancy):
âž¤ SELECT
  oi.OrderID,
  SUM(oi.Quantity * b.UnitPrice) AS OrderTotal
FROM OrderItems oi
JOIN Books b ON b.BookISBN = oi.BookISBN
WHERE oi.OrderID = 101
GROUP BY oi.OrderID;

âš¡ List line items with computed line totals:
âž¤ SELECT
  o.OrderID,
  o.OrderDate,
  c.CustomerName,
  b.BookTitle,
  oi.Quantity,
  (oi.Quantity * b.UnitPrice) AS LineTotal
FROM Orders o
JOIN Customers c   ON c.CustomerID = o.CustomerID
JOIN OrderItems oi ON oi.OrderID = o.OrderID
JOIN Books b       ON b.BookISBN = oi.BookISBN
WHERE o.OrderID = 101;

âœ… Key takeaways (interview-friendly)
âš¡ 1NF: Atomic values, no repeating groups; define a key.
âš¡ 2NF: Remove partial dependencies from tables with composite keys (separate order header vs. book master vs. order items).
âš¡ 3NF: Remove transitive dependencies (move customer details to Customers; drop derived LineTotal).

Result: minimal redundancy, better integrity; queries use joins to rebuild the full picture.
