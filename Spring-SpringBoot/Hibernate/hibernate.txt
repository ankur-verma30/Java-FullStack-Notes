🔷 Hibernate
➤ Hibernate is an Object Relational Mapping (ORM) framework in Java.
➤ It maps Java classes to database tables and Java objects to table rows.
➤ It removes the need to write raw SQL queries by providing an abstraction layer.
➤ CRUD operations are automated and handled internally by Hibernate.
➤ It is an implementation of JPA (Java Persistence API) specification.

🔷  Features of Hibernate
👉 ORM support → Direct mapping between Java objects and database tables.
👉 Database Independent → Code works with multiple RDBMS without changes.
👉 HQL (Hibernate Query Language) → Object-oriented query language.
👉 Caching support → Improves performance using first-level and second-level cache.
👉 Lazy Loading → Data fetched only when required.
👉 Automatic Table Creation → Schema generation can be managed.
👉 Transaction Management → Integrated with Java Transaction API(JTA) and Java Database connectivity(JDBC) transactions.

🔷 Advantages of Hibernate
➤ Eliminates boilerplate JDBC code.
➤ Portable across different databases.
➤ Improved productivity → Less code, more functionality.
➤ HQL provides flexibility compared to SQL.
➤ Performance optimization using caching and batch fetching.
➤ Easy relationship management between entities (@OneToOne, @OneToMany, etc.).

🔷 Hibernate Architecture
🌟 Application Starts → Configuration Loaded
➤ Hibernate first loads its configuration (usually hibernate.cfg.xml or application.properties in Spring Boot).
➤ This file contains:
    🔗 DB connection info (URL, username, password).
    🔗 Hibernate dialect (e.g., MySQLDialect).
    🔗 Entity class mappings (Employee.class, etc.).
➤ Hibernate builds a Configuration object in memory.

🌟 SessionFactory Creation
➤ From the configuration, Hibernate creates a SessionFactory.
➤ SessionFactory is a heavyweight, thread-safe object, created once per application.
➤ It:
    🔗 Reads all mappings (e.g., @Entity annotations).
    🔗 Prepares SQL templates for CRUD operations.
    🔗 Maintains a connection pool.
👉 Think of SessionFactory as a blueprint for working with the database.

🌟 Session Opening
➤ When you need to interact with DB, you call:
➤ Session session = sessionFactory.openSession();
Session is a lightweight, short-lived object (not thread-safe).
➤ It represents a unit of work with the database.

🌟 Transaction Begins
➤ Hibernate uses Transaction API (backed by JDBC or JTA).
➤ When you call:
    Transaction tx = session.beginTransaction();
➤ Hibernate ensures ACID properties:
    All queries either succeed (commit) or fail together (rollback).

🌟 Object State Management
Hibernate tracks objects in three states:
✔️ Transient → new Java object (not linked to DB/session).
✔️ Persistent → after calling session.save(obj), Hibernate tracks it. Any changes are auto-synced to DB.
✔️ Detached → once the session is closed, objects are no longer tracked.

🌟 Hibernate Converts Objects → SQL
✅ Example:
Employee emp = new Employee();
emp.setId(1);
emp.setName("John");
emp.setSalary(50000);
session.save(emp);

Behind the scenes, Hibernate generates SQL:
🔗 insert into Employee (id, name, salary) values (1, 'John', 50000);

➤ Hibernate uses Dialect (e.g., MySQLDialect, OracleDialect) to generate SQL that matches the DB vendor.
➤ It then executes the query via JDBC internally.

🌟 Caching & Optimization
➤ Hibernate uses First-Level Cache (Session scope) automatically → if you call session.get(Employee.class, 1) multiple times in the same session, Hibernate only queries the DB once.
➤ It can also use Second-Level Cache (SessionFactory scope) to cache data across sessions.

🌟 Transaction Commit or Rollback
➤ On tx.commit():
    🔗 Hibernate flushes all pending changes (dirty checking).
    🔗 Executes SQL statements.
    🔗 Commits the JDBC/JTA transaction.
➤ On tx.rollback():
    🔗 All operations are discarded.

🌟 Session Close
➤ After commit/rollback, the session is closed:
session.close();
➤ Persistent objects become detached.
➤ Session’s first-level cache is cleared.

✅Flow:
Application → SessionFactory → Session → Transaction → Database

🔷Difference between Hibernate and JDBC
| Aspect                     | JDBC (Java Database Connectivity)                                                                   | Hibernate                                                                             |
| -------------------------- | ------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------- |
| Definition             | A Java API to connect and execute SQL statements directly with relational databases.                | An ORM framework that maps Java objects to database tables and automates persistence. |
| Level of Work          | Low-level → You write SQL manually and handle DB logic.                                                 | High-level → Works with Java objects, Hibernate generates SQL.                            |
| Boilerplate Code       | Requires a lot of code (`Connection`, `Statement`, `ResultSet`, exception handling, closing resources). | Minimal code → Hibernate manages connection, query execution, mapping automatically.      |
| Query Language         | Uses SQL (Structured Query Language).                                                               | Uses HQL (Hibernate Query Language) and Criteria API (object-oriented queries).       |
| Database Independence  | SQL is database-specific → migration to another DB requires changes.                                | Database-independent → Hibernate dialects handle DB differences.                          |
| Mapping                | Manual → you map ResultSet columns to Java objects.                                                     | Automatic ORM mapping between Java class and DB table.                                    |
| Transaction Management | Manual → developer must call `commit()` / `rollback()`.                                                 | Built-in → integrates with JDBC or JTA for transaction handling.                  |
| Caching                | No caching → always hits the database.                                                                  | Built-in First-level & Second-level caching for performance.                          |
| **Relationships          | Developer must handle foreign keys manually with SQL joins.                                             | Relationships (`@OneToOne`, `@OneToMany`, `@ManyToMany`) handled automatically.           |
| Productivity           | Lower → more boilerplate, repetitive work.                                                              | Higher → less code, faster development.                                                   |


✅Example Code Snippet: Entity Class Employee

@Entity
public class Employee {	
	@Id
	private int id;
	private String name;
	private float salary;
	
	//setters
	public void setId(int id) {
		this.id = id;
	}
	
	public void setName(String name) {
		this.name = name;
	}
	
	public void setSalary(float salary) {
		this.salary = salary;
	}

	//Getters
	public int getId() {
		return id;
	}

	public String getName() {
		return name;
	}

	public float getSalary() {
		return salary;
	}	
}

⚡ Explanation:
➤ @Entity → tells Hibernate: “This class should be mapped to a database table.”
➤ By default, table name = class name (Employee).
➤ @Id → tells Hibernate which field is the primary key column in the table.
➤ Other fields (name, salary) will be mapped as columns in the table.

✅Flow Diagram:
Employee class  <-->  Employee table
id              <-->  primary key column
name            <-->  column name
salary          <-->  column salary

🔷 Hibernate Annotations
✔️ @Entity → Marks a class as an entity.
✔️ @Table(name="...") → Maps class to table.
✔️ @Id → Marks primary key field.
✔️ @GeneratedValue → Defines primary key generation strategy.
✔️ @Column(name="...") → Maps property to a column.

Relationships:
✔️ @OneToOne
✔️ @OneToMany
✔️ @ManyToOne
✔️ @ManyToMany

🔷 JPA
👉JPA (Java Persistence API) is a specification, not an implementation.
👉It defines a standard set of interfaces, annotations, and rules for persisting Java objects into relational databases.
👉JPA itself does not provide the actual code — it’s like a contract that ORM tools must follow.

Example JPA annotations:
@Entity, @Id, @Table, @Column

Example JPA interface:
EntityManager (similar to Hibernate’s Session)

👉 Think of JPA as a blueprint: It only says “this is how persistence should be done”, but does not do the work itself.

🔷 Relation between Hibernate and JPA
➤ Hibernate is an implementation of JPA.
➤ It provides the actual code that fulfills JPA specifications.
➤ It extends JPA and adds extra features not covered by JPA, like:
    🔗 Hibernate Query Language (HQL)
    🔗 Advanced caching
    🔗 Better performance tuning options

➤ Other JPA implementations besides Hibernate:
    🔗 EclipseLink
    🔗 OpenJPA
    🔗 DataNucleus

👉 Think of Hibernate as a real car built from JPA’s design:
JPA = design/specification
Hibernate = actual car (with even more features)

✅ Tip:
What is the difference between JPA and Hibernate?
✔️ JPA is a specification (interfaces + annotations, no implementation).
✔️ Hibernate is an implementation of JPA, plus it offers additional features.
✔️ So, when you write JPA code, you’re usually running it on Hibernate underneath.

🔷 Hibernate Mappings

🌟 OneToMany Mapping
➤ One record in Table A is related to multiple records in Table B.
➤ Annotation: @OneToMany
✅ Example:
    1. In an E-commerce application, one Customer can have multiple Delivery Addresses saved in their profile.
    2. In a Banking system, one Bank Branch can have multiple Accounts.
    3. In a Healthcare system, one Doctor can have multiple Patients assigned.

🌟 ManyToOne Mapping
➤ Multiple records in Table A map to one record in Table B.
➤ Annotation: @ManyToOne
✅ Example:
    1. In an E-commerce system, many Orders belong to one Customer.
    2. In a Corporate HR system, many Employees report to one Department.
    3. In a Travel Booking platform, many Flight Bookings are associated with one User.    

🌟 ManyToMany Mapping
➤ Records in one table are associated with multiple records in another table and vice versa.
➤ Annotation: @ManyToMany
✅ Example:
    1. In a Learning Management System (LMS), many Students can enroll in many Courses.
    2. In a Job Portal, many Candidates can apply to many Job Postings.
    3. In a Music Streaming App, many Artists can be part of many Playlists, and playlists can include multiple artists.    

🌟 OneToOne Mapping
One record in Table A maps exactly to one record in Table B.
Annotation: @OneToOne
✅ Example:
    1. In a Banking application, one Customer has exactly one PAN Card or KYC record.
    2. In an HR system, one Employee has exactly one EmployeeProfile record (with DOB, address, etc.).
    3. In a Car Rental app, one Car has exactly one Insurance Policy.    

🔷 Spring Data JPA
Spring Data JPA is a Spring framework project built on top of JPA (Java Persistence API) that makes database access and persistence operations easier.

👉 In short:
➤ JPA = Specification (interfaces & annotations, no implementation).
➤ Hibernate = Implementation of JPA.
➤ Spring Data JPA = Abstraction layer that makes working with JPA implementations (like Hibernate) much easier.

🔹 Why Spring Data JPA?
Without it, you’d need to write a lot of boilerplate DAO code like this:

public class EmployeeRepository {
    @PersistenceContext
    private EntityManager em;

    public void save(Employee emp) {
        em.persist(emp);
    }

    public Employee findById(Long id) {
        return em.find(Employee.class, id);
    }
}

With Spring Data JPA, this becomes:
public interface EmployeeRepository extends JpaRepository<Employee, Long> {
}
✅ Done. Spring auto-generates the implementation at runtime.

🌟 Key Features
🔄 Repository Abstractions
➤ Provides ready-made repository interfaces:
  🔗 CrudRepository<T, ID> → basic CRUD.
  🔗 JpaRepository<T, ID> → CRUD + pagination + sorting.
➤ No need to implement DAO manually.

🔄 Derived Query Methods
Spring parses method names and generates SQL automatically.

Example:
List<Employee> findByDepartment(String department);
List<Employee> findBySalaryGreaterThan(double salary);
👉 These automatically generate SELECT queries.

🔄 Custom Queries with JPQL / Native SQL
➤ Use @Query annotation for custom queries:
@Query("SELECT e FROM Employee e WHERE e.salary > :salary")
List<Employee> findHighEarners(@Param("salary") double salary);

➤ Native SQL also supported:
@Query(value = "SELECT * FROM employee WHERE department = :dept", nativeQuery = true)
List<Employee> findByDept(@Param("dept") String dept);

🔄 Pagination and Sorting
➤ Built-in support:
Page<Employee> findAll(Pageable pageable);
List<Employee> findAll(Sort sort);

🔄 Transaction Management
➤ Integrated with Spring’s @Transactional.
➤ Spring handles opening, committing, rolling back transactions automatically.

🔄 Auditing
➤ Track createdBy, createdDate, lastModifiedBy, lastModifiedDate with annotations:
@CreatedDate
private LocalDateTime createdAt;

⚡ How it Works Behind the Scenes
➤ You declare a repository interface (e.g., EmployeeRepository extends JpaRepository<Employee, Long>).
➤ At runtime, Spring Data JPA creates a proxy implementation of this interface.
➤ The proxy internally uses EntityManager (from JPA) → which is backed by Hibernate (default in Spring Boot).
➤ SQL queries are generated based on:
  🔗 Method name conventions (e.g., findByName).
  🔗 @Query annotations.
  🔗 Default CRUD methods from JpaRepository.

📌 Repository Layer in Spring Boot
➤ The Repository Layer in Spring Boot is the layer that interacts with the database.
➤ It provides predefined methods to perform CRUD (Create, Read, Update, Delete) operations without writing SQL queries.
➤ It is built on Spring Data JPA, which internally uses Hibernate (by default) for ORM.

⚡ How It Works
➤ Instead of writing your own DAO (Data Access Object) classes with JDBC/Hibernate queries,
you just create an interface that extends one of Spring Data JPA’s repository interfaces.
➤ Spring Boot automatically creates the implementation at runtime.

Example:
public interface EmployeeRepository extends JpaRepository<Employee, Integer> {
}
Here:
Employee → Entity class
Integer → Primary Key type

🔄 Common Utility Methods
Repository interfaces provide many ready-made methods, such as:

🔧 save(entity) → Insert or update entity in DB
🔧 findById(id) → Retrieve entity by primary key
🔧 findAll() → Get all records
🔧 delete(entity) → Delete a record
🔧 deleteById(id) → Delete by primary key
🔧 count() → Count total records

🔄 Custom Query Methods
You can also define custom finder methods just by following naming conventions.

Example:
List<Employee> findByName(String name);
List<Employee> findBySalaryGreaterThan(float salary);
👉 Spring Data JPA automatically generates queries for these methods.

🔄 Industry-level Use
➤ In enterprise applications, Repository Layer is where all database interaction is isolated.
➤ The Service Layer calls the Repository Layer, and repository handles DB operations.
➤ This ensures separation of concerns and clean architecture.  

📌 Dependency Injection (DI) in Spring Boot➤ 
➤ Dependency Injection (DI) is a design pattern where an object’s dependencies (other objects it needs to work) are provided (injected) by the Spring Framework instead of the class creating them manually.
➤ Spring Boot manages the creation, configuration, and lifecycle of these dependencies at runtime.

🔄 Analogy
👉 Think of building a house:
You need bricks, cement, wood.
Instead of making these materials yourself, you ask suppliers to provide them.

Similarly, your class does not create its required objects itself; Spring provides them automatically.

🔄 Why Use DI?
✅ Loose Coupling
➤ Classes do not depend on how objects are created, only on what they can do.
➤ Easier to swap implementations (e.g., change from MySQL DB to MongoDB without modifying business logic).

✅ Automatic Lifecycle Management
➤ Spring controls the object creation, initialization, and destruction.
➤ You don’t need to manually manage memory or cleanup.

🔄 Improved Testability
Since dependencies are injected, you can easily mock objects for unit testing.

🔄 Types of Dependency Injection in Spring Boot
📝 Constructor Injection ✅ (Most recommended in modern Spring Boot)

@Service
public class EmployeeService {
    private final EmployeeRepository employeeRepository;

    // Constructor Injection
    public EmployeeService(EmployeeRepository employeeRepository) {
        this.employeeRepository = employeeRepository;
    }
}

📝 Setter Injection
@Service
public class EmployeeService {
    private EmployeeRepository employeeRepository;

    @Autowired
    public void setEmployeeRepository(EmployeeRepository employeeRepository) {
        this.employeeRepository = employeeRepository;
    }
}

📝 Field Injection ❌ (Not recommended for large apps, but commonly seen in small projects)
@Service
public class EmployeeService {
    @Autowired
    private EmployeeRepository employeeRepository;
}

🔄 How DI Works in Spring Boot
➤ Spring Boot scans the project for classes annotated with @Component, @Service, @Repository, @Controller, etc.
➤ It creates objects (called Spring Beans) of these classes.
➤ Whenever another class requires these objects, Spring injects them automatically (instead of you writing new).

Example:
@RestController
public class EmployeeController {

    private final EmployeeService employeeService;

    // Constructor Injection
    public EmployeeController(EmployeeService employeeService) {
        this.employeeService = employeeService;
    }

    @GetMapping("/employees")
    public List<Employee> getAllEmployees() {
        return employeeService.getEmployees();
    }
}

👉 Here:
➤ EmployeeController depends on EmployeeService.
➤ Spring Boot automatically injects an instance of EmployeeService.

🌱 Spring IoC (Inversion of Control)
➤ IoC (Inversion of Control) is the principle where the control of object creation and management is transferred from the developer to the Spring IoC Container.
➤ In simple words: You don’t control the objects, Spring does.

🔄 Spring IoC Container
➤ Core of the Spring Framework.
➤ Responsible for:
  🔗 Creating objects (beans)
  🔗 Configuring them
  🔗 Injecting dependencies (DI)
  🔗 Managing their lifecycle

🔄 How It Works
➤ You annotate/configure classes with @Component, @Service, @Repository, @Controller etc.
➤ Spring IoC Container scans the project, finds these beans, and creates objects automatically.
➤ Dependencies between beans are resolved using Dependency Injection (DI).

🔄 Advantages
➤ Promotes loose coupling (objects don’t create their dependencies).
➤ Makes applications modular and testable.
➤ Simplifies configuration and lifecycle management.

🔄 Analogy
👉 Think of a restaurant:
➤ You don’t cook yourself; you just order.
➤ The kitchen (IoC Container) manages all cooking, preparation, and delivery.
➤ Similarly, you just define what you need, and Spring IoC takes care of how it’s created and managed.

🌀 Spring Bean Lifecycle
📝 Lifecycle Stages
➤ Bean Creation
  🔗 Spring IoC creates the bean object.
  🔗 Example: using @Component or configuration class.

➤ Dependency Injection
Dependencies are injected (e.g., using @Autowired or constructor injection).

➤ Initialization (Optional Hooks)
If the bean implements InitializingBean or has @PostConstruct method → executed here.

➤ Execution (In Use)
The bean is ready to be used by the application.

➤ Destruction
  🔗 When the application context shuts down, Spring destroys the bean.
  🔗 Example: @PreDestroy method or DisposableBean interface.

✔️ Diagram (Flow)
Bean Instantiation 
       ↓
Dependencies Injection (@Autowired)
       ↓
Initialization (@PostConstruct, afterPropertiesSet)
       ↓
Bean is Ready (used by app)
       ↓
Destruction (@PreDestroy, destroy())

Example
@Component
public class MyBean implements InitializingBean, DisposableBean {

    @Override
    public void afterPropertiesSet() {
        System.out.println("Bean is initialized");
    }

    @Override
    public void destroy() {
        System.out.println("Bean is destroyed");
    }
}

✅ JUnit in Spring Boot (Unit Testing)
➤ JUnit is a testing framework used in Java to perform unit testing.
➤ In unit testing (white-box testing), we test individual pieces of code (methods, classes) rather than the whole application.
➤ Spring Boot projects by default include the JUnit library, so you don’t need to add it manually.

⚡ Important Annotations in JUnit
🔄 @Test
➤ Marks a method as a test case.
➤ JUnit will execute this method and report PASS / FAIL based on output or assertions.
➤ Multiple @Test methods can exist in one class, each runs independently.

🔄 @BeforeEach
➤ Runs before every @Test method.
➤ Usually used for setting up resources or initialization.

🔄 @AfterEach
➤ Runs after every @Test method.
➤ Used for cleanup activities (e.g., closing DB connections).

🔄 @BeforeAll
➤ Runs once before all tests in the class.
➤ Must be static.
➤ Used for global setup (e.g., starting an in-memory database).

🔄 @AfterAll
➤ Runs once after all tests in the class.
➤ Must be static.
➤ Used for global cleanup (e.g., stopping server, closing shared resources).

🖥️ Example Code
package com.demo1;

import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class Demo1ApplicationTests {

    // This runs ONCE before any test method
    @BeforeAll
    public static void beforeAll() {
        System.out.println(">>> Before All - Runs only once before all tests");
    }

    // This runs BEFORE EACH test method
    @BeforeEach
    public void beforeTest() {
        System.out.println(">>> Before Each - Runs before every test case");
    }

    // Test case 1
    @Test
    void test1() {
        System.out.println(">>> Executing Test 1");
    }

    // Test case 2
    @Test
    void test2() {
        System.out.println(">>> Executing Test 2");
    }

    // This runs AFTER EACH test method
    @AfterEach
    public void afterTest() {
        System.out.println(">>> After Each - Runs after every test case");
    }

    // This runs ONCE after all test methods have executed
    @AfterAll
    public static void afterAll() {
        System.out.println(">>> After All - Runs only once after all tests");
    }
}

📌 Expected Execution Flow
When you run the test class, JUnit will call methods in the following order:

>>> Before All - Runs only once before all tests
>>> Before Each - Runs before every test case
>>> Executing Test 1
>>> After Each - Runs after every test case
>>> Before Each - Runs before every test case
>>> Executing Test 2
>>> After Each - Runs after every test case
>>> After All - Runs only once after all tests


✅ What is SessionFactory in Hibernate?
➤ SessionFactory is a core interface in Hibernate.
➤ It is responsible for establishing database connections and creating Session objects.
➤ It is thread-safe (can be shared across threads) and is usually created once per application.

🔑 Key Responsibilities of SessionFactory
➤ Database Connection Management
✔️ Reads the configuration (hibernate.cfg.xml or persistence.xml).
✔️ Creates a connection pool internally.

➤ Session Creation
Creates Session objects, which are lightweight, non-thread-safe objects used for CRUD operations.

➤ Caching
Provides first-level cache (Session) and optional second-level cache (SessionFactory scope).

➤ Metadata Storage
Stores mapping metadata of entities (@Entity classes ↔ DB tables).

🔷Difference between Session and SessionFactory
| Feature       | SessionFactory                         | Session                       |
| ------------- | -------------------------------------- | ----------------------------- |
| Creation Cost | Heavyweight (expensive to create)      | Lightweight                   |
| Thread-Safe   | ✅ Yes                                  | ❌ No                          |
| Lifetime      | Application-level (one per DB)         | Request/transaction level     |
| Purpose       | Manages connections + creates sessions | Performs CRUD operations      |
| Caching Scope | 2nd level cache (shared)               | 1st level cache (per session) |

🧠 If asked "How many SessionFactory objects should an application have?" Answer: Only one per database (singleton).
Because it is a heavyweight object and creating multiple instances can slow down performance.


🔷 Optional Class
➤ Optional<T> is a container object introduced in Java 8.
➤ It may or may not contain a non-null value.
➤ It is an alternative to null checks and helps avoid NullPointerException (NPE).

🔑 Why Optional?
➤ Traditionally, developers used null values to represent "no result".
➤ This often caused NullPointerExceptions if we forgot to check null.
➤ Optional provides a safe, expressive, and functional way to represent an absent value.


🛠 Common Methods in Optional
👉 Creating Optional Objects
✅Code Example: 
Optional<String> emptyOpt = Optional.empty();              // Empty Optional
Optional<String> valueOpt = Optional.of("Hello");          // Must not be null
Optional<String> nullableOpt = Optional.ofNullable(null);  // Can be null

👉 Checking Value
✅Code Example: 
if (valueOpt.isPresent()) {
    System.out.println(valueOpt.get()); // Safe to call get()
}

👉 Default Value Handling
✅Code Example: 
String result = nullableOpt.orElse("Default Value");
System.out.println(result);

👉 Lazy Default Value
✅Code Example: 
String result = nullableOpt.orElseGet(() -> "Generated Default");

👉 Throw Exception if Empty
✅Code Example: 
String result = nullableOpt.orElseThrow(() -> new RuntimeException("Value not present"));

👉 Functional Style (map, filter, ifPresent)
✅Code Example: 
Optional<String> nameOpt = Optional.of("Ankur");

nameOpt
    .filter(name -> name.startsWith("A"))
    .map(String::toUpperCase)
    .ifPresent(System.out::println); // Output: ANKUR

⚡ Example Use Case in Repository Layer (Spring Boot)
❌ Instead of:
User user = userRepository.findById(1);
if (user != null) {
    System.out.println(user.getName());
}

✅ We use:
Optional<User> userOpt = userRepository.findById(1);
userOpt.ifPresent(user -> System.out.println(user.getName()));
➤ This avoids NullPointerException if the user is not found.   

🆚 Key Difference: null vs Optional
| Feature     | null                                  | Optional                            |
| ----------- | ------------------------------------- | ----------------------------------- |
| Meaning     | Absence of value                      | Explicit container for absent value |
| Safety      | Prone to NPE                          | Safe API methods                    |
| Readability | Requires many `if (x != null)` checks | Cleaner, expressive                 |
| Usage       | Legacy style                          | Modern (Java 8+)                    |


💡 Tip:
If asked "Is Optional a replacement for null?"
Say:
👉 No, it’s not a complete replacement. It is a wrapper to handle null values safely in functional style, especially useful in APIs and return types.



🔷 Perform CRUD Operation using Hibernate in Spring Boot

🟢 Step 1: Database Configuration (application.properties)
spring.datasource.url=jdbc:mysql://localhost:3306/database_name (use snake casing for the DB name)
spring.datasource.username=root (username)
spring.datasource.password=test (password)

➤ Hibernate DDL (Data Definition Language) options:
  ✔️ create  → Drops table if exists, creates a new one every time project restarts
  ✔️ update  → Creates table if not exists, else updates schema without dropping data
spring.jpa.hibernate.ddl-auto=update

🟢 Step 2: Entity Class Explanation (Hibernate + Spring Boot)
package com.democrud.entity;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;

@Entity
@Table(name="employees")
public class Employee {
	
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY) 
	private long id;
	
	@Column(name = "first_name", nullable = false, length = 45)
	private String firstName;
	
	@Column(name = "last_name", nullable = false, length = 45)
	private String lastName;
	
	@Column(name = "email_id", nullable = false, length = 256, unique = true)
	private String emailId;
	
	@Column(name="mobile", nullable = false, unique = true)
	private String mobile;

    // Getters & Setters ...
}

🔄 Annotations
🔗 @Entity
➤ Marks this class as an Entity → Hibernate will map it to a database table.
➤ Without this, Hibernate will ignore the class.

🔗 @Table(name="employees")
➤ Specifies the table name in the database.
➤ If you don’t use it → Hibernate will create a table with default name = class name (Employee).
➤ Here, it will create/use a table called employees.

🔗 @Id
➤ Defines the Primary Key of the entity.
➤ Every entity must have one @Id field.

🔗 @GeneratedValue(strategy = GenerationType.IDENTITY)
➤ Tells Hibernate how to generate the primary key values.
➤ IDENTITY → Database will auto-generate the ID using auto-increment (common in MySQL, PostgreSQL).

Alternative strategies:
➤ AUTO → Hibernate chooses best strategy automatically.
➤ SEQUENCE → Uses DB sequence (common in Oracle).
➤ TABLE → Uses a special table to generate IDs.

🔗 @Column
➤ Maps a class field to a specific column in the DB.
➤ Attributes:
  ✔️ name → Column name in DB (different from field name).
  ✔️ nullable = false → Cannot be NULL in DB.
  ✔️ length → Defines max length of VARCHAR.
  ✔️ unique = true → Makes column values unique.

✅ Examples here:
➤ firstName → first_name VARCHAR(45) NOT NULL
➤ lastName → last_name VARCHAR(45) NOT NULL
➤ emailId → email_id VARCHAR(256) UNIQUE NOT NULL
➤ mobile → mobile VARCHAR(?) UNIQUE NOT NULL


🟢 Step 3: Repository Layer Explanation
package com.democrud.repository;

import org.springframework.data.repository.CrudRepository;
import com.democrud.entity.Employee;

public interface EmployeeRepository extends CrudRepository<Employee, Long> {
}

🔎 Breakdown:
⚡ EmployeeRepository
➤ An interface, not a class.
➤ Extends CrudRepository<Employee, Long>

⚡ CrudRepository<T, ID>
➤ A Spring Data JPA interface that provides ready-made CRUD methods.
➤ Here:
  ✔️ T = Employee → Entity type
  ✔️ ID = Long → Primary key type

⚡ No need to implement methods
➤ Spring Data JPA automatically generates implementations for you at runtime.
➤ So you don’t have to write SQL/JPQL manually for basic operations.


🟢 Step 4: Service Layer Explanation (Performing Unit Test)
package com.democrud;

import java.util.Optional;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import com.democrud.entity.Employee;
import com.democrud.repository.EmployeeRepository;

@SpringBootTest
class DemocrudApplicationTests {
	
	
	@Autowired
	private EmployeeRepository employeeRepository;

	@Test
	void saveRecord() {
		Employee emp = new Employee();
		emp.setFirstName("adam");
		emp.setLastName("a");
		emp.setEmailId("adam@gmail.com");
		emp.setMobile("9632629455");
		employeeRepository.save(emp);
	}

➤ Creates a new Employee object.
➤ Calls save().
📌 Hibernate generates:
🔗 INSERT INTO employees (first_name, last_name, email_id, mobile) 
VALUES ('adam', 'a', 'adam@gmail.com', '9632629455');

	@Test
	void deleteRecord() {
		employeeRepository.deleteById(3L);
	}

➤ Deletes row with ID = 3.
📌 Hibernate generates:
🔗 DELETE FROM employees WHERE id = 3;

	@Test
	void getRecordById() {
		Optional<Employee> opEmp = employeeRepository.findById(1L);
		if(opEmp.isPresent()) {
			Employee employee = opEmp.get();
			System.out.println(employee.getId());
			System.out.println(employee.getFirstName());
			System.out.println(employee.getLastName());
			System.out.println(employee.getEmailId());
		}else {
			System.out.println("No record Found");
		}
	}

➤ Fetches record with ID = 1.
➤ Uses Optional to avoid NullPointerException.
📌 Hibernate generates:
🔗 SELECT * FROM employees WHERE id = 1;
	
	@Test
	void getRecords() {
		Iterable<Employee> itrEmp = employeeRepository.findAll();
		for (Employee employee: itrEmp) {
			System.out.println(employee.getId());
			System.out.println(employee.getFirstName());
			System.out.println(employee.getLastName());
			System.out.println(employee.getEmailId());
		}
	}

➤ Fetches all employees.
📌 Hibernate generates:
🔗 SELECT * FROM employees;
	
	
	@Test
	void countRecords() {
		long count = employeeRepository.count();
		System.out.println(count);
	}
}

➤ Counts total rows in table.
📌 Hibernate generates:
🔗 SELECT COUNT(*) FROM employees;

✅ What This Unit Test Class Does
➤ This class (DemocrudApplicationTests) is testing your repository layer using Spring Boot + JUnit.
➤ @SpringBootTest → Boots the entire Spring context, loads beans (EmployeeRepository) so you can use dependency injection.
➤ @Autowired EmployeeRepository → Injects repository so tests can directly call CRUD methods.

👉 Pro tip: If you want to actually see SQL queries in the console, add this to your application.properties:
✔️ spring.jpa.show-sql=true
✔️ spring.jpa.properties.hibernate.format_sql=true


🔷 Finder Methods in Hibernate (Spring Data JPA)
➤ Finder methods are custom query methods that you define inside your repository interface.
➤ They allow you to fetch data based on specific conditions without writing SQL or JPQL manually.
➤ Spring Data JPA derives the query automatically by analyzing the method name.

✅ How Hibernate Works Behind the Scenes
➤ For each finder method:
  ✔️ Spring Data JPA parses the method name.
  ✔️ Converts it into a JPQL query.
  ✔️ Hibernate translates JPQL → SQL and executes it.

✅ Why Finder Methods are Useful
➤ No need to write SQL / JPQL queries manually.
➤ Easy to read and maintain.
➤ Spring Data JPA + Hibernate auto-generates queries → saves development time.
➤ Makes your repository layer clean and declarative.  

📌 Rules & Keywords for Writing Finder Methods in Spring Data JPA
⚡ Start with a Recognized Prefix
➤ Every finder method must start with one of these prefixes:
🔗 findBy... → fetch data
🔗 readBy... → alias of findBy
🔗 queryBy... → alias of findBy
🔗 getBy... → alias of findBy
🔗 countBy... → count records matching condition
🔗 existsBy... → check if record exists
🔗 deleteBy... / removeBy... → delete records

✅Example:
Optional<Employee> findByEmailId(String email);
long countByLastName(String lastName);
boolean existsByMobile(String mobile);

⚡ Use Property Names Exactly
➤ After the prefix, write your entity field name (case-sensitive with camelCase).
➤ Must match the Java property in the Entity, not the column name in DB.

✅ Example (Entity field = firstName)
List<Employee> findByFirstName(String firstName);
❌ Wrong: findByfirst_name (uses DB column name).

⚡ Combine Multiple Conditions with Keywords
You can combine fields with:
  ✔️  And
  ✔️  Or

✅ Examples:
List<Employee> findByFirstNameAndLastName(String first, String last);
List<Employee> findByFirstNameOrLastName(String first, String last);

👉 Generated JPQL:
SELECT e FROM Employee e WHERE e.firstName = ? AND e.lastName = ?;

⚡ Use Comparison Keywords
➤ Spring Data JPA supports many keywords after field names:
🔗 Is, Equals → exact match
🔗 Not → not equal
🔗 LessThan, GreaterThan, Between → comparisons
🔗 Like, Containing, StartingWith, EndingWith → pattern matching
🔗 In → matches in a list
🔗 True, False → for boolean fields

✅Example:
List<Employee> findBySalaryGreaterThan(double salary);
List<Employee> findByFirstNameContaining(String keyword);
List<Employee> findByFirstNameStartingWith(String prefix);
List<Employee> findByFirstNameEndingWith(String suffix);
List<Employee> findByIdIn(List<Long> ids);
List<Employee> findByActiveTrue();   // only active employees

⚡ Order the Results
➤ Add OrderBy keyword followed by field name + direction (Asc / Desc).

✅ Example:
List<Employee> findByLastNameOrderByFirstNameAsc(String lastName);

👉 SQL:
SELECT * FROM employees WHERE last_name=? ORDER BY first_name ASC;

🔄 Return Types
➤ Finder methods can return:
  ✔️ Single entity (Employee)
  ✔️ Optional<Employee> (preferred for safety)
  ✔️ List/Collection (List<Employee>)
  ✔️ Page<Employee> or Slice<Employee> (for pagination)
  ✔️ Stream<Employee>

✅ Repository 
package com.democrud.repository;

import java.util.List;
import java.util.Optional;

import org.springframework.data.repository.CrudRepository;

import com.democrud.entity.Employee;

public interface EmployeeRepository extends CrudRepository<Employee, Long> {

    // Exact matches
    Optional<Employee> findByEmailId(String email);
    Optional<Employee> findByMobile(String mobile);

    // Existence checks
    boolean existsByEmailId(String email);
    boolean existsByMobile(String mobile);

    // Count records
    long countByEmailId(String email);

    // Pattern matching
    List<Employee> findByFirstNameContaining(String keyword);   // anywhere
    List<Employee> findByFirstNameStartingWith(String prefix);  // starts with
    List<Employee> findByFirstNameEndingWith(String suffix);    // ends with

}

✅ Test Class
package com.democrud;

import java.util.List;
import java.util.Optional;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import com.democrud.entity.Employee;
import com.democrud.repository.EmployeeRepository;

@SpringBootTest
class DemocrudApplicationTests {

    @Autowired
    private EmployeeRepository employeeRepository;

    @Test
    void findByEmail() {
        employeeRepository.findByEmailId("adam@gmail.com").ifPresentOrElse(
            emp -> System.out.println("Found: " + emp.getFirstName()),
            () -> System.out.println("No record Found")
        );
    }

    @Test
    void findByMobile() {
        employeeRepository.findByMobile("9632629455").ifPresentOrElse(
            emp -> System.out.println("Found: " + emp.getFirstName()),
            () -> System.out.println("No record Found")
        );
    }

    @Test
    void existsByEmail() {
        System.out.println(employeeRepository.existsByEmailId("adam1@gmail.com")
            ? "Record exists" : "No record Found");
    }

    @Test
    void existsByMobile() {
        System.out.println(employeeRepository.existsByMobile("9632629455")
            ? "Record exists" : "No record Found");
    }

    @Test
    void countByEmail() {
        System.out.println("Count: " + employeeRepository.countByEmailId("adam@gmail.com"));
    }

    @Test
    void containingLetter() {
        List<Employee> employees = employeeRepository.findByFirstNameContaining("m");
        employees.forEach(e -> System.out.println(e.getFirstName()));
    }

    @Test
    void startingLetter() {
        List<Employee> employees = employeeRepository.findByFirstNameStartingWith("A");
        employees.forEach(e -> System.out.println(e.getFirstName()));
    }

    @Test
    void endingLetter() {
        List<Employee> employees = employeeRepository.findByFirstNameEndingWith("m");
        employees.forEach(e -> System.out.println(e.getFirstName()));
    }
}

⚡ Key Improvements made:
✅ Used ifPresentOrElse() (Java 9+) for cleaner Optional handling.
✅ Added System.out.println("...") confirmations after save/delete for clarity.
✅ Consistent method naming (startingLetter, not StaringLetter).
✅ Used lambda expressions for cleaner iteration.
✅ Added extra useful finder methods (And, In, OrderBy).


🔷 JPQL (Java Persistence Query Language)
➤ It is a object-oriented query language defined by JPA.
➤ It looks like SQL but operatres on entity classes and their properites, not on DB tables/columns.

✅ Example:
SELECT e FROM Employee e WHERE e.emailId = :emailId;
👉 Employee is the entity name and the emailId is the Java/property, not the table/column.

➤ The JPA provide(Hibernate) translates JPQL -> SQL using entity metadata and the configured SQL dialect, then executes it via JDBC.

🌟 @Query in Spring Data JPA uses JPQL
When you put @Query("...JPQL...") on a repository method, Spring Data:
  ✔️ Parses the JPQL string.
  ✔️ Builds a javax.persistence.Query/TypedQuery.
  ✔️ Binds parameters you provide (@Param or positional).
  ✔️ Lets Hibernate turn JPQL into SQL and run it.
This means your repository method runs a provider-generated query (no manual SQL needed).

✅Code Implementation:
public interface EmployeeRepository extends CrudRepository<Employee, Long> {

    @Query("select e from Employee e where e.emailId = :x")
    Optional<Employee> searchByEmail(@Param("x") String email);

    @Query("select e from Employee e where e.mobile = :m")
    Optional<Employee> searchByMobile(@Param("m") String mobile);

    // IMPORTANT: annotate both params or use positional parameters (?1, ?2)
    @Query("select e from Employee e where e.emailId = :x and e.mobile = :m")
    Optional<Employee> searchByEmailAndMobile(@Param("x") String email, @Param("m") String mobile);

    @Query("select e from Employee e where e.emailId = :x or e.mobile = :m")
    List<Employee> searchByEmailIdOrMobile(@Param("x") String email, @Param("m") String mobile);
}


⚡ JUnit Test on these methods
package com.democrud;

import java.util.List;
import java.util.Optional;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import com.democrud.entity.Employee;
import com.democrud.repository.EmployeeRepository;

@SpringBootTest
class DemocrudApplicationTests {

  @Autowired
	private EmployeeRepository employeeRepository;


  @Test
void searchByEmail() {
    employeeRepository.searchByEmail("adam@gmail.com")
        .ifPresentOrElse(
            e -> printEmployee(e),
            () -> System.out.println("No record Found")
        );
}

@Test
void searchByMobile() {
    employeeRepository.searchByMobile("9632629455")
        .ifPresentOrElse(
            e -> printEmployee(e),
            () -> System.out.println("No record Found")
        );
}

@Test
void getByEmailAndMobile() {
    employeeRepository.searchByEmailAndMobile("adam@gmail.com", "9632629455")
        .ifPresentOrElse(
            e -> printEmployee(e),
            () -> System.out.println("No record Found")
        );
}

@Test
void getByEmailOrMobile() {
    employeeRepository.searchByEmailIdOrMobile("adam@gmail.com", "9632629155")
        .stream()
        .map(Employee::getFirstName)
        .forEach(System.out::println);
}

// ✅ Helper method to avoid repetition
private void printEmployee(Employee e) {
    System.out.println(e.getId());
    System.out.println(e.getFirstName());
    System.out.println(e.getLastName());
    System.out.println(e.getEmailId());
}
}

🔑 Improvements:
➤ Replaced manual if(opEmp.isPresent()) with ifPresentOrElse.
➤ Used method reference + lambda for clean printing.
➤ Extracted duplicate print logic into printEmployee(Employee e).
➤ Used stream().map().forEach() for list iteration.

🌟 Method-by-method explanation
🔗 @Query("select e from Employee e where e.emailId = :x")
  ✔️ JPQL returns Employee entities where emailId equals :x.
  ✔️ Spring Data maps the result rows to Employee objects.
  ✔️ Return type = Optional<Employee>:
      ⚡ If no row → Optional.empty().
      ⚡ If exactly one row → Optional.of(entity).
      ⚡ If more than one row → exception (IncorrectResultSizeDataAccessException), because a single-result mapping is expected.

➤ searchByMobile(...) — same as above but checks mobile.
➤ searchByEmailAndMobile(...)
  ✔️ Matches both conditions (AND).
  ✔️ Use this when you expect at most one match (unique constraints ensure single result).

➤ searchByEmailIdOrMobile(...)
  ✔️ Uses OR and returns List<Employee>.
  ✔️ If zero results → empty list; if many → list of entities.

🌟 Named parameters vs positional
👉 Named: :x, :m + @Param("x") map method param to JPQL param. Preferred for readability.
👉 Positional: ?1, ?2 and method parameters are bound by index.
👉 Important: If you use named params, annotate method parameters with @Param (or ensure Java compiler parameter names are retained and Spring can detect them — but explicit @Param is safer).

🌟 JPQL → SQL mapping (example)
👉 JPQL:
select e from Employee e where e.emailId = :x

👉 Hibernate might generate SQL (approx):
select id, first_name, last_name, email_id, mobile
from employees
where email_id = ?

➤ Hibernate uses the entity → table and property → column mappings to produce proper SQL.

🌟 Return types and behavior
➤ Optional<T>: expect single or zero results.
➤ T (entity): expect exactly one result (exception if zero or many).
➤ List<T>: can return 0..N results (safe for multi-row results).
➤ Page<T> / Slice<T>: used with Pageable for pagination (JPQL works with pagination via Spring Data).

⚡ Safety & SQL injection
Parameter binding (:x, ?1) prevents SQL injection because parameters are bound, not concatenated.


📝 Using @Moodifying Annotation
UPDATE / DELETE JPQL: You can write bulk JPQL updates/deletes (requires @Modifying on the repo method when using Spring Data).

✅ Example:
@Modifying
@Query("update Employee e set e.lastName = :lname where e.id = :id")
int updateLastName(@Param("id") Long id, @Param("lname") String lname);

❗Common Pitfalls and Fixes
➤ Missing @Param when using named params → runtime error or wrong binding. Always annotate when using :name.
➤ Expecting single result but query returns many → exception. Use List<T> if multiple possible.
➤ Using column names in JPQL → wrong. Use entity property names.
➤ Entity name mismatch if @Entity(name="X") used — use that name in JPQL.

🆚 SQL VS JPQL Syntax
➤ In SQL, you query tables and columns:

SELECT * FROM employees WHERE email_id = ?;

✔️ * → means “all columns”.
✔️ employees → table name.
✔️ email_id → column name.

➤ In JPQL, you query entities and fields/properties:

SELECT e FROM Employee e WHERE e.emailId = :emailId

➤ Employee → entity class name, not a table.
➤ e → alias (like emp in SQL: SELECT * FROM employees emp).
➤ emailId → property name in the Employee class, not the DB column.

❓Why not SELECT * in JPQL?
➤ JPQL doesn’t deal with columns.
➤ It deals with objects (entities).
➤ So, instead of “all columns”, we fetch the whole entity object.
➤ SELECT e → fetch the entire Employee entity (all mapped fields).

➤ If you want only specific fields, you can write:

🔗 SELECT e.firstName, e.lastName FROM Employee e WHERE e.emailId = :emailId

➤ But then the result won’t be Employee objects; it’ll be an Object[] because we fetch only specific fields not the complete entity.


❓Why do we use alias e?
Aliases make queries shorter and cleaner.

✅ Example with alias:
🔗 SELECT e FROM Employee e WHERE e.emailId = :emailId

✅ Example without alias (legal but verbose):
🔗 SELECT Employee FROM Employee WHERE Employee.emailId = :emailId

In practice, we almost always use an alias (e, emp, etc.) like in SQL.


🔷 Native SQL Queries in Spring Data JPA

❓Why use Native SQL?
➤ JPQL works with entity objects and properties, not with actual table/column names.
➤ Sometimes you need database-specific functions or very complex queries → then nativeQuery = true is used.
➤ Here, Hibernate will run your raw SQL directly on the DB.


✅Code Implementation
public interface EmployeeRepository extends JpaRepository<Employee, Long> {

    // ✅ Native query by email
    @Query(value = "SELECT * FROM employees WHERE email_id = ?1", nativeQuery = true)
    Optional<Employee> findByEmailUsingSQl(String email);

    // ✅ Native query by mobile
    @Query(value = "SELECT * FROM employees WHERE mobile = ?1", nativeQuery = true)
    Optional<Employee> findByMobileUsingSQl(String mobile);

    // ✅ Native query by email + mobile
    @Query(value = "SELECT * FROM employees WHERE email_id = ?1 AND mobile = ?2", nativeQuery = true)
    Optional<Employee> findByEmailandMobileUsingSQl(String email, String mobile);
}


🔑 Key Points
nativeQuery = true → Tells Spring Data JPA that the query is raw SQL (not JPQL).
Table name (employees) and column names (email_id, mobile) must match your DB schema, not your entity fields.
Positional parameters → ?1, ?2 correspond to method arguments in order.
Can also use named parameters (safer & cleaner):

✅Code Implementation
@Query(value = "SELECT * FROM employees WHERE email_id = :email AND mobile = :mobile", nativeQuery = true)
Optional<Employee> findByEmailandMobileUsingSQL(@Param("email") String email, @Param("mobile") String mobile);


🔷 OneToMany Mapping and ManyToOne

🌟Unidirectional Mapping
🔹 Post.java
package demo.crud.entity;

@Entity
@Table(name="posts")
public class Post {

    @Id
    @GeneratedValue(strategy=GenerationType.IDENTITY)
    private Long id;

    private String title;

    // Unidirectional OneToMany
    @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.EAGER)
    @JoinColumn(name="post_id") // FK will be created in comments table
    private List<Comment> comments = new ArrayList<>();

    // getters and setters
    public Long getId() {
        return id;
    }
    public void setId(Long id) {
        this.id = id;
    }
    public String getTitle() {
        return title;
    }
    public void setTitle(String title) {
        this.title = title;
    }
    public List<Comment> getComments() {
        return comments;
    }
    public void setComments(List<Comment> comments) {
        this.comments = comments;
    }
}

🔹 Comment.java
package demo.crud.entity;

@Entity
@Table(name="comments")
public class Comment {

    @Id
    @GeneratedValue(strategy=GenerationType.IDENTITY)
    private Long id;

    private String content;

    // No reference to Post (unidirectional)

    // getters and setters
    public Long getId() {
        return id;
    }
    public void setId(Long id) {
        this.id = id;
    }
    public String getContent() {
        return content;
    }
    public void setContent(String content) {
        this.content = content;
    }
}

3️⃣ PostRepository.java(Same code in Bidirectional Mapping)
package demo.crud.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import demo.crud.entity.Post;

public interface PostRepository extends JpaRepository<Post, Long> {}


4️⃣ CommentRepository.java (Same code in Bidirectional Mapping)
package demo.crud.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import demo.crud.entity.Post;

public interface PostRepository extends JpaRepository<Post, Long> {}

5️⃣ Unit Test (savePostWithComments)
    @Autowired
    private PostRepository postRepository;

    @Test
    void savePostWithComments() {
        // Create a new Post
        Post post = new Post();
        post.setTitle("First post");

        // Create comments
        Comment c1 = new Comment();
        c1.setContent("First Comment");

        Comment c2 = new Comment();
        c2.setContent("Second Comment");

        // Add comments to post
        post.getComments().add(c1);
        post.getComments().add(c2);

        // Save post (cascade will save comments)
        postRepository.save(post);

        // Fetch and print post and comments
        Post savedPost = postRepository.findById(post.getId()).orElseThrow();
        System.out.println("Post Title: " + savedPost.getTitle());

        savedPost.getComments()
                 .forEach(c -> System.out.println("Comment: " + c.getContent()));
    }

✅ Explanation:

➤ Unidirectional OneToMany:
  ✔️ Only Post knows about Comment.
  ✔️ Comment has no reference to Post in Java.

➤ @JoinColumn(name="post_id"):
  ✔️ Creates post_id column in comments table as FK.
  ✔️ Hibernate automatically sets it when saving comments via post.

➤ FetchType.EAGER:
  ✔️ When a post is fetched, all comments are fetched immediately.

➤ Cascading:
  ✔️ CascadeType.ALL ensures saving/deleting post will automatically save/delete associated comments.

➤ Test method:
  ✔️ Creates a post and 2 comments.
  ✔️ Adds comments to post's list.
  ✔️ Saves the post → comments saved automatically.
  ✔️ Fetches post → prints title and all comments.

🌟 Bidirectional Mapping
➤ Post entity — parent (one post has many comments).
➤ Comment entity — child (many comments belong to one post).
➤ PostRepository and CommentRepository — Spring Data JPA repositories (CRUD).
➤ JUnit test savePostwithComments() annotated with @Transactional that creates a Post, creates two Comments, links them, saves the Post, then fetches and prints post + comments.

✅Code Example:

🔄 Post.java
package demo.crud.entity;

@Entity
@Table(name="posts")
public class Post {
@Id
@GeneratedValue(strategy=GenerationType.IDENTITY)
private long id;

private String title;

@OneToMany(mappedBy="post", cascade=CascadeType.ALL, orphanRemoval = true,fetch=FetchType.LAZY)
private List<Comment> comments=new ArrayList<>();


public long getId() {
	return id;
}

public void setId(long id) {
	this.id = id;
}

public String getTitle() {
	return title;
}

public void setTitle(String title) {
	this.title = title;
}

public List<Comment> getComments() {
	return comments;
}

public void setComments(List<Comment> comments) {
	this.comments = comments;
}
}

🔄 Comments.java
package demo.crud.entity;

@Entity
@Table(name="comments")
public class Comment {

@Id
@GeneratedValue(strategy=GenerationType.IDENTITY)
private long id;

private String content;

@ManyToOne(fetch=FetchType.LAZY)
@JoinColumn(name="post_id", nullable=false) //FK in comments table
private Post post;

public long getId() {
	return id;
}

public void setId(long id) {
	this.id = id;
}

public String getContent() {
	return content;
}

public void setContent(String content) {
	this.content = content;
}

public Post getPost() {
	return post;
}

public void setPost(Post post) {
	this.post = post;
}
}

🔄PostRepository Interface
package demo.crud.repository;

import org.springframework.data.jpa.repository.JpaRepository;

import demo.crud.entity.Post;

public interface PostRepository extends JpaRepository<Post, Long> {}

🔄 CommentRepository
package demo.crud.repository;

import org.springframework.data.jpa.repository.JpaRepository;

import demo.crud.entity.Comment;

public interface CommentRepository extends JpaRepository<Comment, Long> {}

🔄 Unit Testing
	@Test
  @Transactional
	void savePostwithComments() {
		Post post=new Post();
		post.setTitle("First post");
		
		Comment c1=new Comment();
		c1.setContent("First Comment");
		c1.setPost(post);
		
		Comment c2 = new Comment();
		c2.setContent("Second Comment");
		c2.setPost(post);
		
		post.getComments().add(c1);
		post.getComments().add(c2);
		
		postRepository.save(post);
		
		Post savedPost=postRepository.findById(post.getId()).orElseThrow();
		System.out.println("Post Title:" + savedPost.getTitle());
		
		savedPost.getComments().forEach(c -> System.out.println("Comments:"+ c.getContent()));
	}

1️⃣ @Transactional Annotation
➤ Starts a Spring-managed transaction for the duration of this test method.

➤ While the transaction is active, Spring keeps a JPA persistence context (Hibernate Session) open.

➤ Important for FetchType.LAZY — lazy associations can be loaded only while the session is open. Without @Transactional, accessing savedPost.getComments() would likely throw LazyInitializationException.

➤ In Spring tests, by default the transaction is rolled back after the test finishes (so DB state is not permanently changed).

2️⃣ Post post = new Post(); and post.setTitle("First post");
➤ You create a new Java object. At this point the object is transient: not known to Hibernate/JPA, no DB row yet.

3️⃣ Create Comment objects and c.setPost(post);
➤ Each Comment is transient after creation.

➤ c.setPost(post) sets the Comment.post reference to the same Post object. This is crucial for a bidirectional relationship because the child must know which parent it belongs to (this will determine the post_id FK value).

4️⃣ post.getComments().add(c1); post.getComments().add(c2);
➤ You add the comments to the Post collection. Now both sides are connected in memory:
  ✔️ post.comments contains c1 and c2
  ✔️ c1.post and c2.post point back to post
➤ This consistency is required when you manage the relationship manually (no helper methods). If you omit one side, the DB FK may be left NULL or cause errors.

5️⃣ postRepository.save(post);
What happens under the hood:
👉 Spring Data JPA calls EntityManager.persist(post) (because post.getId() is 0/null → new entity).

👉 Because Post.comments is configured with cascade = CascadeType.ALL, persist cascades to c1 and c2. So JPA will also persist the comments.

👉 With GenerationType.IDENTITY:

  ✔️ Hibernate must insert the post row first to let the database generate the post.id.
  🔗 INSERT INTO posts (title) VALUES ('First post');

  ➤ DB returns generated id (e.g., 1). Hibernate sets post.id = 1 on the Java object.

  ✔️ Hibernate then inserts each comment and sets post_id to the just-generated post.id:
  🔗 INSERT INTO comments (content, post_id) VALUES ('First Comment', 1);
  🔗 INSERT INTO comments (content, post_id) VALUES ('Second Comment', 1);

  ➤ All of this occurs inside the active transaction and the entities become persistent (managed) in the persistence context.


6️⃣ Post savedPost = postRepository.findById(post.getId()).orElseThrow();
➤ Since post is still in the same persistence context (we saved it and transaction is open), findById will typically return the same managed instance from the first-level cache rather than issuing a new SELECT.

➤ If for some reason the entity wasn't in the context, findById would issue:
🔗 SELECT * FROM posts WHERE id = 1;
➤ orElseThrow() just makes sure we get an entity or fail the test if absent.

7️⃣ System.out.println("Post Title:" + savedPost.getTitle());
Reads a field from the managed Post instance — no DB call needed.

8️⃣ savedPost.getComments().forEach(c -> System.out.println("Comments:"+ c.getContent()));
➤ Because comments is FetchType.LAZY, the list is not loaded automatically when the Post was loaded. Accessing the collection triggers Hibernate to fetch the comments on demand, but this can only happen while the persistence context is open (which it is because of @Transactional).

➤ The lazy fetch runs a SQL like:
🔗 SELECT id, content, post_id FROM comments WHERE post_id = 1;

➤ Then JPA maps those rows into Comment objects and you print their content.

🔄 Persistence states summary (transient → persistent → detached)
➤ Before save: post, c1, c2 are transient (plain Java objects).
➤ After save and inside transaction: they become persistent (managed) — Hibernate tracks changes and they are associated with the persistence context.
➤ After the test method ends (transaction rolled back & context closed), those objects become detached (no longer managed).

❓ Why both c.setPost(post) and post.getComments().add(c)?
➤ In a bidirectional mapping you must keep both sides consistent in memory.
➤ c.setPost(post) ensures the owning side (Comment.post) is set — the owning side is what JPA uses to set the foreign key post_id in the DB.
➤ post.getComments().add(c) updates the parent’s collection so your Java model is consistent and you can navigate from parent → child in memory.
➤ If you only add to post.getComments() but do not set c.setPost(post), JPA may not set post_id when persisting, leading to NULL FKs or constraint violations. Always set both sides (either manually or via helper).

🧠 Important configuration pieces that make this work
👉 @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name="post_id", nullable=false) on Comment — establishes the foreign key column in comments table.
👉 @OneToMany(mappedBy="post", cascade=CascadeType.ALL, orphanRemoval=true, fetch=FetchType.LAZY) on Post — tells JPA the relationship is bidirectional, child owns the FK, cascade persists/merges/removes children with parent, and orphanRemoval will delete children removed from the collection.
👉 @Transactional around the test — keeps session open for lazy loading and groups DB operations into one atomic unit.


❓Why use FetchType.LAZY and @Transactional?
✔️ LAZY prevents loading large collections automatically — better performance and less memory use.
✔️ @Transactional is required when you plan to access lazy associations inside the same method, because the persistence context (Hibernate session) must be open to perform the lazy query.


❓Why cascade = CascadeType.ALL and orphanRemoval = true?
✔️ cascade = ALL: saving or deleting the Post affects its Comment children automatically (no need to save comments separately).
✔️ orphanRemoval = true: when you remove a Comment from post.getComments() and save, JPA will delete that comment row from DB.


❗pitfalls & gotchas to watch for
✔️ Forgetting to set both sides (c.setPost(post) and add to list) → broken FK or orphaned data.
✔️ Not transactional + lazy fetch → LazyInitializationException.
✔️ Eager on large collections → can cause performance problems (N+1 queries, high memory).
✔️ Relying on post.getId() before save — it will be 0/null until the DB generates it at insert. After save, Hibernate populates it.


🔑 Rule of Thumb
➤ Owning side = the side that actually has the foreign key column in the database table.

➤ Non-owning side (inverse side) = the side that just "maps" the relationship but does not have the foreign key column.

⚡ Owning side → the side with @JoinColumn (here: Comment). 
⚡ Non-owning side → the side with mappedBy (here: Post).

❓ How can comment be owning side because if there is no post there is no existance of comments?
🔑 First, What Does Owning Side Mean in JPA?
➤ In real life logic:
  ✔️ You’re right 👉 A Comment cannot exist without a Post.
  ✔️ So conceptually, the Post feels like the parent.

➤ But in JPA technical terms:
  ✔️ Owning side ≠ parent/child relationship in real-world logic.
➤ It simply means:
  👉 The entity that actually has the foreign key column in its table is the owning side.

🧠 Final Understanding
➤ Logical Parent (Business Sense): Post → because a post can exist without comments, but not vice versa.
➤ Owning Side (JPA/DB Sense): Comment → because it holds the FK (post_id).
➤ Non-Owning Side: Post → it just uses mappedBy to say “my comments are mapped by the post field in Comment”.

🆚 Difference between Unidirectional and Bidirectional Mapping
| Feature            | Unidirectional               | Bidirectional                          |
| ------------------ | ---------------------------- | -------------------------------------- |
| Navigation         | Only Post → Comments         | Post → Comments **and** Comment → Post |
| Owning side        | Post (uses `@JoinColumn`)    | Comment (`@ManyToOne`)                 |
| mappedBy           | Not used                     | Used on Post side                      |
| Cascade operations | Works from Post side         | Works via owning side or both sides    |
| Database FK        | `post_id` in Comment table   | `post_id` in Comment table             |
| Java convenience   | Cannot get post from comment | Can get post from comment              |


🔷 ManyToMany Mapping

🔄 Bus entity
@Entity
@Table(name="bus")
public class Bus {
  @Id @GeneratedValue(strategy=GenerationType.IDENTITY)
  private Long id;
  private String busName;

// Owning side of ManyToMany
  @ManyToMany(fetch=FetchType.LAZY)
  @JoinTable(
    name = "bus_stop",
    joinColumns = @JoinColumn(name = "bus_id"),  // FK column for Bus
    inverseJoinColumns = @JoinColumn(name = "stop_id") // FK column for Stop
  )
  private List<Stop> stops = new ArrayList<>();
  // getters/setters
}

➤ @Entity / @Table("bus"): maps the class to the bus table.
➤ @Id @GeneratedValue(...): DB auto-generates the primary key when you insert a Bus.

➤ @ManyToMany(fetch=FetchType.LAZY): a bus can be associated with many stops and stops with many buses. The association is lazy — related stops are fetched only when you access bus.getStops().

➤ @JoinTable(...): defines the join table name (bus_stop) and the two FK columns:
  ✔️ bus_id (points to bus.id) — created from joinColumns
  ✔️ stop_id (points to stop.id) — created from inverseJoinColumns
➤ Because @JoinTable is on Bus.stops, Bus is the owning side of the relationship.

🔄 Stop entity
@Entity
@Table(name="stop")
public class Stop {
  @Id @GeneratedValue(strategy=GenerationType.IDENTITY)
  private Long id;
  private String stopName;

 // Inverse side (non-owning)
  @ManyToMany(mappedBy="stops")
  private List<Bus> buses = new ArrayList<>();
  // getters/setters
}
👉 mappedBy="stops": this tells JPA that Stop is the inverse side; the mapping is defined/owned by Bus.stops. Changes to the join table are driven by the owning side.

🔄 Repositories
public interface BusRepository extends JpaRepository<Bus, Long> {}
public interface StopRepository extends JpaRepository<Stop, Long> {}
➤ JpaRepository gives you CRUD, paging, sorting, and other convenience methods. No manual implementation needed.

🔄 Unit Test
Stop s1 = new Stop("Majestic"), s2 = new Stop("BTM"), s3 = new Stop("Electronic City");
stopRepo.saveAll(Arrays.asList(s1,s2,s3));         // (A)

Bus b1 = new Bus(); 
b1.setBusName("Bus 101"); 
b1.setStops(Arrays.asList(s1,s2));

Bus b2 = new Bus(); 
b2.setBusName("Bus 202"); 
b2.setStops(Arrays.asList(s2,s3));
busRepo.saveAll(Arrays.asList(b1,b2));             // (B)

//display each bus and its stops
 busRepo.findAll().forEach(bus -> {
            System.out.println("Bus: " + bus.getBusName());
            bus.getStops().forEach(stop ->
                System.out.println("   Stop: " + stop.getStopName())
            );
        });

Step-by-Step:
1️⃣ stopRepo.saveAll(...) — persists stops first. SQL roughly:
INSERT INTO stop (stop_name) VALUES ('Majestic');
INSERT INTO stop (stop_name) VALUES ('BTM Layout');
INSERT INTO stop (stop_name) VALUES ('Electronic City');
👉 After these, s1, s2, s3 have DB-generated ids (are managed entities).

2️⃣ Create buses and assign stops (b1.setStops(Arrays.asList(s1,s2)))
  ✔️ You give the Bus objects references to the already persisted managed Stop entities. They are not transient.

3️⃣ busRepo.saveAll(...) — saving the owning side (Bus). Hibernate will:
  ✔️ Insert bus rows:
INSERT INTO bus (bus_name) VALUES ('Bus 101');
INSERT INTO bus (bus_name) VALUES ('Bus 202');
👉 (DB assigns bus IDs)

  ✔️ Insert rows into the join table bus_stop for each association:
INSERT INTO bus_stop (bus_id, stop_id) VALUES (<b1_id>, <s1_id>);
INSERT INTO bus_stop (bus_id, stop_id) VALUES (<b1_id>, <s2_id>);
INSERT INTO bus_stop (bus_id, stop_id) VALUES (<b2_id>, <s2_id>);
INSERT INTO bus_stop (bus_id, stop_id) VALUES (<b2_id>, <s3_id>);

4️⃣ Fetch & print (busRepo.findAll())
➤ findAll() loads Bus entities.
➤ Because stops is LAZY, accessing bus.getStops() triggers a SELECT:

SELECT s.* FROM stop s
JOIN bus_stop bs ON s.id = bs.stop_id
WHERE bs.bus_id = <bus_id>;
👉 This occurs for each bus unless JPA optimizes with batch fetching or you use a fetch join.

🔄 Owning side vs inverse — why Bus is the owner
➤ The owning side is the side that JPA looks at to persist changes to the join table.
➤ You placed @JoinTable(...) on Bus.stops, so Bus owns the mapping.
➤ Stop uses mappedBy="stops", so it’s the inverse side. Changing stop.getBuses() alone does not update the join table — changes must be made on the owning side (bus.getStops()).

🔄 Important JPA rules

1️⃣ Persisting entities
➤ If a Stop is transient (not saved) and you call busRepo.save(bus) without cascade, JPA throws an exception like TransientPropertyValueException.
→ Either save stops first (stopRepo.save(...)) or add cascade = CascadeType.PERSIST on @ManyToMany if you want save to cascade from Bus to Stop.

2️⃣ Transactions & LAZY
➤ ManyToMany default fetch is LAZY. You used fetch=FetchType.LAZY. That means bus.getStops() will only load when called inside an open persistence context (transaction).

➤ In tests, either annotate the test method with @Transactional (keeps session open), or use a fetch join query, or set fetch = EAGER (not recommended for many-to-many due to performance).

3️⃣ Cascade REMOVE — be careful
Do not set cascade = CascadeType.REMOVE on ManyToMany unless you want removing a Bus to delete Stop rows (shared entity) — usually undesirable because stops may be shared among buses.


🔄 Improvements 
➤ Prefer Set over List for many-to-many to avoid accidental duplicate link rows:
🔗 private Set<Stop> stops = new HashSet<>();

➤ Keep persistence consistent:
  ✔️ Save Stops first or configure cascade = {PERSIST, MERGE} if you want to persist stops from bus.

➤ Avoid CascadeType.REMOVE on ManyToMany — you don't want deleting one bus to delete shared stops
➤ Keep collections in sync if you rely on in-memory reads before reload. Either:
  ✔️ Use helper methods that update both sides:

🔗 public void addStop(Stop s) { 
  stops.add(s); 
  s.getBuses().add(this);
  }
  ✔️ Or accept that the inverse side (stop.getBuses()) will be empty until reloaded from DB.

➤ Be careful with JSON serialization (if later exposing entities via REST). Bidirectional relations cause infinite recursion — use DTOs or @JsonIgnore on one side.


🔷 One To One Relationship
One-to-One relationship: One entity is associated with exactly one instance of another entity.

Bidirectional: Both entities have references to each other.

🔄 User.Java
package demo.crud.entity;
import jakarta.persistence.*;

@Entity
@Table(name="user")
public class User {
@Id
@GeneratedValue(strategy=GenerationType.IDENTITY)
private Long id;
private String name;

public User() {}
public User(String name) {
	this.name=name;
}


public Long getId() {
	return id;
}

public String getName() {
	return name;
}
public void setName(String name) {
	this.name = name;
}

@OneToOne(cascade=CascadeType.ALL)
@JoinColumn(name="profile_id", unique=true)
private Profile profile;

public Profile getProfile() {
	return profile;
}
public void setProfile(Profile profile) {
	this.profile = profile;
}

@Override
public String toString() {
	 return "User{id=" + id + ", name='" + name + '\'' + '}';
}
}

🔄Profile.java
package demo.crud.entity;

import jakarta.persistence.*;

@Entity
@Table(name = "profiles")
public class Profile {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String bio;

    @OneToOne(mappedBy = "profile")
    private User user;

    public Profile() {}
    public Profile(String bio) { this.bio = bio; }

    // Getters / setters
    public Long getId() { return id; }
    public String getBio() { return bio; }
    public void setBio(String bio) { this.bio = bio; }

    public User getUser() { return user; }
    public void setUser(User user) { this.user = user; }

    @Override
    public String toString() {
        return "Profile{id=" + id + ", bio='" + bio + '\'' + '}';
    }
}

🔄Repository
import demo.crud.entity.User;
public interface UserRepository extends JpaRepository<User, Long> {}

import demo.crud.entity.Profile;
public interface ProfileRepository extends JpaRepository<Profile, Long> {}

🔄 Unit Test
@Test
	void saveUserWithProfile() {
		Profile profile=new Profile("Java Developer");
		User user=new User("Ankur");
		
		user.setProfile(profile);
		userRepo.save(user);
		
		 userRepo.findById(user.getId()).ifPresent(u -> {
	            System.out.println("Fetched user: " + u);
	            System.out.println("Associated profile (via user): " + u.getProfile());
	        });

	        // Fetch via profile -> user should be accessible (inverse side)
	        profileRepo.findById(profile.getId()).ifPresent(p -> {
	            System.out.println("Fetched profile: " + p);
	            System.out.println("Associated user (via profile): " + p.getUser());
	        });
	}

🔄 Owning vs. Inverse Side
➤ Owning Side: The entity that actually stores the foreign key column in its table.
  ✔️ In your code → User is owning side because it has @JoinColumn(name="profile_id").

➤ Inverse Side: Refers to the relationship but does not control it.
  ✔️ In your code → Profile is inverse side because of mappedBy="profile".
👉 Rule: Always perform save() on the owning side (here, User).  

🔄 User Entity
@OneToOne(cascade = CascadeType.ALL)
@JoinColumn(name="profile_id", unique=true)  // FK stored in user table
private Profile profile;

➤ cascade = CascadeType.ALL: Persisting/deleting a User will also persist/delete the associated Profile.
➤ @JoinColumn: Creates a foreign key column (profile_id) in user table.
➤ unique=true: Ensures one User maps to one Profile.

🔄 Profile Entity
@OneToOne(mappedBy = "profile")
private User user;

➤ mappedBy: Indicates this is the inverse side, relationship is managed by User.profile.
➤ No @JoinColumn here → avoids duplicate FK.

🔄 Unit Test 
Profile profile = new Profile("Java Developer");
User user = new User("Ankur");

user.setProfile(profile);
userRepo.save(user);   // Saves both User + Profile (Cascade)

✅ save(user) persists both because:
  ➤ CascadeType.ALL is active.
  ➤ User is owning side (so profile_id is inserted in user table)

🔄 Fetch Type
➤ Default for @OneToOne = EAGER (loads both entities together).
➤ Can set fetch = FetchType.LAZY → loads proxy until accessed (requires @Transactional to avoid LazyInitializationException).

🔄 Advantages
➤ Simple relationship when one entity truly depends on another (e.g., User ↔ Profile, Passport ↔ Person).
➤ Cascading simplifies persistence.

🔄 Disadvantages
➤ Tight coupling → both entities are dependent.
➤ Unnecessary Eager fetching can lead to performance issues if not controlled.
➤ Difficult to scale if relationship changes (e.g., one profile used by multiple users → must refactor to One-to-Many).

🔄 Summary
➤ User = owning side (FK).
➤ Profile = inverse side (mappedBy).
➤ CascadeType.ALL ensures both persist together.
➤ Fetch strategy impacts performance (EAGER vs LAZY).
➤ Best practice: keep @OneToOne unidirectional unless you really need both sides.


🔷 Hibernate Cache
➤ Hibernate cache = temporary in-memory storage used to reduce database round trips.
➤ It stores objects/entities so Hibernate doesn’t repeatedly query the DB for the same data.
➤ Goal = performance improvement → less SQL, lower latency, reduced DB load.

1️⃣ First-Level Cache (L1 Cache)
➤ Enabled by default – cannot be disabled.
➤ Scope: per Session object (lives as long as the Hibernate Session exists).
➤ Lifecycle: Cache is cleared once session is closed.
➤ Data locality: Same session → Hibernate won’t hit DB twice for the same entity.

✅Example:
Session session = sessionFactory.openSession();

User user1 = session.get(User.class, 1L);  // 🔴 Hits DB
User user2 = session.get(User.class, 1L);  // ✅ Served from L1 cache, no DB call

session.close();

❓ What happens here?
➤ First call → Hibernate queries DB (SELECT * FROM user WHERE id=1).
➤ Second call → Hibernate checks L1 cache (inside the session), finds user1, and reuses it.

⚡ Important: If you open a new session, cache is cleared → it will hit DB again.

2️⃣ Second-Level Cache (L2 Cache)
➤ Optional (must be enabled via configuration).
➤ Scope: Shared across multiple Sessions (SessionFactory level).
➤ Persists cached entities across different users and requests.
➤ Works with external caching providers (Ehcache, Infinispan, Caffeine, Redis).

✅Example:
//Session 1
Session session1 = sessionFactory.openSession();
User user1 = session1.get(User.class, 1L);  // 🔴 Hits DB, stores in L2 cache
session1.close();

// Session 2
Session session2 = sessionFactory.openSession();
User user2 = session2.get(User.class, 1L);  // ✅ Served from L2 cache (no DB hit)
session2.close();

❓ What happens here?
➤ First session queries DB and puts data in L2 cache.
➤ Second session → Hibernate checks L2 cache, finds entity, and skips DB.

📊 Key Differences: L1 vs L2 Cache
| Feature       | First-Level Cache (L1)                    | Second-Level Cache (L2)                                   |
| ------------- | ----------------------------------------- | --------------------------------------------------------- |
| Default       | Always enabled                            | Optional (must configure)                                 |
| Scope         | Per Session                               | Shared across Sessions                                    |
| Lifetime      | Ends when Session closes                  | Ends when SessionFactory closes                           |
| Use Case      | Prevent duplicate queries in same request | Prevent queries across multiple requests/users            |
| Providers     | Built-in Hibernate                        | Requires providers (Ehcache, Infinispan, Redis, Caffeine) |


⚙️ Configuring Second-Level Cache
✅ Example (Ehcache):
# application.properties
spring.jpa.properties.hibernate.cache.use_second_level_cache=true
spring.jpa.properties.hibernate.cache.region.factory_class=org.hibernate.cache.ehcache.EhCacheRegionFactory
spring.jpa.properties.javax.persistence.sharedCache.mode=ALL


🔄 Annotating entity for caching:
@Entity
@Cacheable
@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class User {
    @Id
    private Long id;
    private String name;
}

🚀 Benefits of Hibernate Caching
➤ Reduces DB load (fewer SQL queries).
➤ Improves response time and scalability.
➤ Especially helpful for read-heavy applications (profiles, product catalogs, dashboards).

⚠️ Limitations / Caveats
➤ Cache invalidation: Must keep cache in sync with DB (stale data risk).
➤ Not useful for write-heavy apps (frequent updates reduce caching efficiency).
➤ Needs careful configuration to avoid memory overhead.