==============
ğŸ”· SpringBoot
==============
â¤ SpringBoot is a framework that simplifies the development of Spring applications by providing a set of pre-configured features and tools.
â¤ SpringBoot=Spring - XML configuration.
â¤ It makes easy to create stand-alone, production-grade spring based application that you can just run.
â¤ SpringBoot is not a replacement for Spring Framework. It was developed on top of Spring Framework to provide a more simplified and efficient way to develop Spring applications.

ğŸ”„ Key Features
â¤ Auto-Configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Automatically configure Spring application based on dependencies in the classpath.
â¤ Starter Dependencies â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Predefined dependency sets (e.g., spring-boot-starter-web, spring-boot-starter-data-jpa) to reduce manual configuration.
â¤ Embedded Servers â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Comes with Tomcat, Jetty, Undertow embedded servers, so no need to deploy WAR files separately.
â¤ Production Ready â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Provides health checks, metrics, logging, and monitoring with Spring Boot Actuator.
â¤ Convention over Configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Focus more on logic, less on XML/bean configuration.


=============================================
ğŸ”· SpringBBoot Application Folder Structure
=============================================
â¤ src/main/java
â¤ src/main/resources
â¤ src/test/java
â¤ src/test/resources
â¤ target
â¤ pom.xml


===========================
ğŸ”· SpringBoot Main Method
===========================
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
â¤ It is enterpoint for boot application execution
â¤ @SpringBootApplication annotation is equal to 3 annotations:
    âœ”ï¸ @SpringBootConfiguration
    âœ”ï¸ @EnableAutoConfiguration
    âœ”ï¸ @ComponentScan
â¤ SpringBoot start class will act as a configuration class because of the @SpringBootConfiguration annotation.
â¤ @EnableAutoConfiguration annotation tells SpringBoot to auto-configure beans based on classpath dependencies.
â¤ @ComponentScan annotation scans the package (and sub-packages) of the class for components (@Component, @Service, @Repository, @Controller, etc.).

âš¡ Note:Package naming Convention will play a major role in compoenent scanning.
âœ…Example:  basePackage = com.tcs.vechiles
â¤ There should be one basePackage for all the packages, subpackages should be made inside this basePackage.
â¤ If we have multiple basePackage we have to manually tell the SpringBootApplication which package to scan by using @ComponentScan annotation and passing the array of basePackages.  


===================================
ğŸ”· SpringApplication.run() Method
===================================
â¤ It is used to start the Spring Boot application.
â¤ It takes 2 arguments:
    âœ”ï¸ Application class
    âœ”ï¸ Command-line arguments
â¤ SpringApplication.run() method takes care of configuring the embedded server and other necessary components.
â¤ It is the entry point for the Spring Boot application. This method will return reference of IOC.
â¤ It starts the Spring application context and also starts the embedded server.

âœ…Example:
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        ConfigurableApplicationContext context = SpringApplication.run(Application.class, args);
        System.out.println(context.getClass().getName());
    }
}

â¤ SpringApplication is a Predefined class and it will identify what type of application we have created based on dependencies added in pom.xml file:
    âœ”ï¸ standalone (spring-boot-starter)
        âš¡ ClassName: AnnotationConfigApplicationContext
    âœ”ï¸ web app (spring-boot-starter-web)
        âš¡ ClassName: AnnotationConfigServletWebServerApplicationContext
    âœ”ï¸ reactive-application (spring-boot-starter-webflux) etc.
        âš¡ ClassName: AnnotationConfigReactiveWebServerApplicationContext
ğŸ‘‰ If all there dependencies are added priority is given to web app.

â¤ If we want to remove the banner of the spring in application.properties file we can add:
ğŸ”— spring.main.banner-mode=off  â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ have 3 modes off, console, log

â¤ If we want to change the banner message we can add:
ğŸ”— spring.banner.image.location=classpath:banner.txt â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ will print the banner message from this file
â¤ Or we can put the banner.txt file inside the src/main/resources folder where out application.properties file is there.

URL is:  https://patorjk.com/software/taag/#p=display&f=ANSI%20Shadow&t=SpringBoot


=========================
ğŸ”· Runners In SpringBoot
=========================
â¤ When a Spring Boot application starts, sometimes you want to run custom logic â€” for example:
    âœ”ï¸ Loading initial data into the database
    âœ”ï¸ Sending a notification at startup
    âœ”ï¸ Checking configurations
    âœ”ï¸ Running background tasks
â¤ For this, Spring Boot provides two special interfaces:
ğŸ‘‰ CommandLineRunner
ğŸ‘‰ ApplicationRunner

ğŸ”„ CommandLineRunner
This interface lets you run code after the Spring context is loaded (i.e., after all beans are initialized).

âœ… Example
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

@Component
public class MyStartupRunner implements CommandLineRunner {

    @Override
    public void run(String... args) throws Exception {
        System.out.println("Application started! Running initial setup...");
        // You can call a service, load data, etc.
    }
}
â“ What happens here:
When your Spring Boot app starts,
It automatically calls the run() method after all beans are created and the application context is ready.

ğŸ”„ ApplicationRunner
This is almost identical to CommandLineRunner,
but it provides a more structured way to access application arguments via the ApplicationArguments object.

âœ… Example
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.stereotype.Component;

@Component
public class MyAppRunner implements ApplicationRunner {

    @Override
    public void run(ApplicationArguments args) throws Exception {
        System.out.println("ApplicationRunner executing...");
        if (args.containsOption("debug")) {
            System.out.println("Debug mode is enabled!");
        }
    }
}
âœ”ï¸ You can now start your app with:
java -jar myapp.jar --debug

âœ”ï¸ And it will print:
ApplicationRunner executing...
Debug mode is enabled!

ğŸ”„ Difference Between CommandLineRunner and ApplicationRunner
| Feature          | CommandLineRunner | ApplicationRunner                                         |
| ---------------- | ----------------- | --------------------------------------------------------- |
| Arguments Type   | `String... args`  | `ApplicationArguments`                                    |
| Argument Parsing | Manual            | Built-in support for options and non-option args          |
| Use Case         | Simple tasks      | When you need to access or parse command-line args easily |


ğŸ”„ Execution Order
â¤ If both CommandLineRunner and ApplicationRunner are defined, they will run in the order they are declared in the application context.
â¤ If you have multiple runners, you can control their order using the @Order annotation.

import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;
import org.springframework.boot.CommandLineRunner;

@Component
@Order(1)
public class FirstRunner implements CommandLineRunner {
    @Override
    public void run(String... args) {
        System.out.println("Runner 1 executed");
    }
}

@Component
@Order(2)
public class SecondRunner implements CommandLineRunner {
    @Override
    public void run(String... args) {
        System.out.println("Runner 2 executed");
    }
}
âœ… Output:
Runner 1 executed
Runner 2 executed

ğŸ”„ Use Cases
| Use Case                | Description                                      |
| ---------------------   | ------------------------------------------------ |
| âœ… Data Initialization | Insert default users, roles, or configurations   |
| âœ… Validation          | Check environment variables or configs           |
| âœ… Logging             | Log startup details                              |
| âœ… Integration         | Trigger background processes when the app starts |

â“ When is a Runner executed?
âœ… After the Spring ApplicationContext is fully initialized but before the application is ready to receive requests.


==================================
ğŸ”· @PostConstruct in Spring Boot
===================================
@PostConstruct is a lifecycle annotation used in Spring to execute a method after dependency injection is complete â€” but before the bean is put into service (i.e., before itâ€™s ready to handle requests).

ğŸ”„ Purpose
It is mainly used for initialization logic â€” tasks you want to run once right after the bean is created and dependencies are injected.

âœ… Example
@Component
public class DataLoader {

    @Autowired
    private UserRepository userRepository;

    @PostConstruct
    public void init() {
        System.out.println("Initializing data...");
        userRepository.save(new User("Ankur", "ankur@example.com"));
    }
}

ğŸ”„ What happens here:
    âœ”ï¸ Spring creates the DataLoader bean.
    âœ”ï¸ It injects the UserRepository dependency.
    âœ”ï¸ Then it automatically calls the init() method once.
    âœ”ï¸ This ensures your logic runs only after all beans and dependencies are ready.

â“ When is it Called?
â¤ Called after the bean is constructed and all dependencies are injected.
â¤ Runs before the @PreDestroy method (if any).
â¤ Executes only once per bean lifecycle.

ğŸ”„ Common Use Cases
âœ”ï¸  Loading initial data into the database
âœ”ï¸  Validating configuration after injection
âœ”ï¸  Establishing a connection or preloading cache
âœ”ï¸  Printing startup messages

âœ… Example with Logging and Config
@Component
public class AppStartup {

    @Value("${app.name}")
    private String appName;

    @PostConstruct
    public void onStart() {
        System.out.println("Application '" + appName + "' started successfully!");
    }
}

| Concept               | Description                                                                                       |
| --------------------- | ------------------------------------------------------------------------------------------------- |
| Annotation Source     | `jakarta.annotation.PostConstruct`                                                                |
| Runs When             | After dependency injection, before bean is used                                                   |
| Method Rules          | Must be `void`, no parameters, can throw exceptions                                               |
| Alternatives          | `InitializingBean.afterPropertiesSet()` or a custom `@EventListener(ApplicationReadyEvent.class)` |


ğŸ”„ Modern Alternative (Recommended in Spring Boot)
Instead of @PostConstruct, you can use an ApplicationListener or @EventListener(ApplicationReadyEvent.class) for cleaner startup logic:

@Component
public class StartupListener {

    @EventListener(ApplicationReadyEvent.class)
    public void onApplicationReady() {
        System.out.println("âœ… Application is fully started and ready!");
    }
}
ğŸ‘‰ This runs after the full Spring context is initialized (safer for web apps).

â“ Difference between @PostConstruct and Runners?
@PostConstruct: Runs right after bean initialization.
Runners: Run after the entire Spring context is initialized (i.e., all beans are ready).


===============================
ğŸ”· @PreDestroy in Spring Boot
===============================
â¤ @PreDestroy is a lifecycle callback annotation used to execute cleanup logic just before a Spring bean is destroyed.
â¤ Part of JSR-250 (jakarta.annotation)
â¤ Called when the Spring container is shutting down
â¤ Used to release resources gracefully
    import jakarta.annotation.PreDestroy;

ğŸ”„ When is @PreDestroy executed?
@PreDestroy method is invoked when:
    âœ”ï¸ Application is stopped
    âœ”ï¸ JVM receives SIGTERM (e.g. Ctrl + C)
    âœ”ï¸ Spring context is closed
    âœ”ï¸ Kubernetes / Docker sends termination signal
â¡ï¸ Runs before the bean is removed from memory

âœ… Example:
@Component
public class ResourceManager {

    @PreDestroy
    public void cleanup() {
        System.out.println("Releasing resources before shutdown...");
    }
}
ğŸ‘‰ Execution order:
1ï¸âƒ£ Spring starts shutdown
2ï¸âƒ£ @PreDestroy method runs
3ï¸âƒ£ Bean destroyed
4ï¸âƒ£ JVM exits


ğŸ”„ Common Use Cases
â¤ Closing database connections
â¤ Stopping background threads
â¤ Shutting down executors / schedulers
â¤ Flushing logs / buffers
â¤ Releasing file handles
â¤ Graceful shutdown of Kafka / RabbitMQ consumers


ğŸ”„ Important Rules for @PreDestroy
â¤ Method must be:
    âœ”ï¸ void return type
    âœ”ï¸ No arguments
â¤ Only one @PreDestroy method per bean
â¤ Method must not throw checked exceptions
â¤ Works only for Spring-managed beans
âŒ Not called if you use new keyword
    new ResourceManager(); // @PreDestroy will NOT run

@PreDestroy ğŸ†š @PostConstruct
| Annotation       | Purpose                          |
| ---------------- | -------------------------------- |
| `@PostConstruct` | Runs **after bean creation**     |
| `@PreDestroy`    | Runs **before bean destruction** |

ğŸ”„ @PreDestroy vs DisposableBean
Using DisposableBean
@Component
public class MyBean implements DisposableBean {

    @Override
    public void destroy() {
        System.out.println("Destroy method called");
    }
}

ğŸ”„ Why @PreDestroy is better?
â¤ No interface coupling
â¤ Cleaner and more readable
â¤ Annotation-based (preferred in modern Spring)

ğŸ”„ Multiple Shutdown Hooks â€“ Execution Order
â¤ @PreDestroy
â¤ DisposableBean.destroy()
â¤ Custom destroyMethod in @Bean

ğŸ”„ @PreDestroy with @Bean
@Configuration
public class AppConfig {

    @Bean
    public ExecutorService executorService() {
        return Executors.newFixedThreadPool(5);
    }

    @PreDestroy
    public void shutdownExecutor() {
        executorService().shutdown();
    }
}

âš ï¸ Cases Where @PreDestroy is NOT called
â¤ Application crashes (kill -9)
â¤ Bean scope is prototype
â¤ JVM forcefully terminated
â¤ Bean is not managed by Spring

âœ… Real-World Example (Production)
@Component
public class KafkaConsumerManager {

    @PreDestroy
    public void shutdown() {
        kafkaConsumer.wakeup();
        kafkaConsumer.close();
    }
}

========================================================================================
ğŸ”· Properties | YAML | How to pass command line arguments in spring boot application ?
========================================================================================
1ï¸âƒ£ application.properties
In Spring Boot, you can configure values in application.properties:
server.port=8081
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=root
spring.datasource.password=1234

2ï¸âƒ£ YAML
In Spring Boot, you can configure values in application.yml:
server:
  port: 8081

spring:
  datasource:
    url: jdbc:mysql://localhost:3306/mydb
    username: root
    password: 1234
ğŸ“Œ Both properties and yml are supported by default. Spring Boot prefers application.yml if both are present.


3ï¸âƒ£ Passing Command Line Arguments
Spring Boot allows overriding configuration from the command line.

âš¡ Syntax:
ğŸ”— java -jar myapp.jar --server.port=9090 --spring.datasource.username=ankur

Here:
ğŸ”— --server.port=9090 â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ overrides server.port
ğŸ”— --spring.datasource.username=ankur â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ overrides username

4ï¸âƒ£ Accessing Values Inside Code
You can fetch values in your beans with @Value or @ConfigurationProperties.

Using @Value:
@Value("${server.port}")
private int port;

Using @ConfigurationProperties:
@Component
@ConfigurationProperties(prefix = "spring.datasource")
public class DBConfig {
    private String url;
    private String username;
    private String password;

    // getters & setters
}

==================
ğŸ”· Project Lombok
==================
â¤ Lombok is a Java library that reduces boilerplate code by using annotations.
â¤ It generates common code like getters, setters, constructors, toString, equals, hashCode, builders, etc. at compile time.
â¤ Achieved via annotation processing â†’ IDE & compiler insert the code for you.

â“ Why use Lombok?
â¤ Saves time â†’ no need to manually write getters/setters.
â¤ Makes code cleaner & readable.
â¤ Reduces errors in repetitive boilerplate code.

ğŸ”„ Common Lombok Annotations
âœ”ï¸ @Getter / @Setter â†’ Generates getters & setters.
âœ”ï¸ @ToString â†’ Generates toString().
âœ”ï¸ @EqualsAndHashCode â†’ Generates equals() & hashCode().
âœ”ï¸ @NoArgsConstructor / @AllArgsConstructor â†’ Generates constructors.
âœ”ï¸ @Data â†’ Combines @Getter, @Setter, @ToString, @EqualsAndHashCode, @RequiredArgsConstructor.
âœ”ï¸ @Builder â†’ Provides builder pattern.
âœ”ï¸ @Slf4j â†’ Provides a ready-to-use logger.

âœ… Example Without Lombok
public class Student {
    private int id;
    private String name;

    public Student() {}
    public Student(int id, String name) { this.id = id; this.name = name; }

    public int getId() { return id; }
    public void setId(int id) { this.id = id; }
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    @Override
    public String toString() { return "Student{id=" + id + ", name='" + name + "'}"; }
}

âœ… Example With Lombok
import lombok.*;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class Student {
    private int id;
    private String name;
}
âœ… Generates all boilerplate automatically (getters, setters, constructors, toString, equals, hashCode).


=========================================================================
ğŸ”· Which Dependency Injection is Better â€” Field, Setter, or Constructor?
=========================================================================
â¤ Spring supports three main types of Dependency Injection (DI):
    âœ”ï¸ Field Injection
    âœ”ï¸ Setter Injection
    âœ”ï¸ Constructor Injection
1ï¸âƒ£ Field Injection (@Autowired directly on fields)
âœ… Example:
@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;

    public void getUser() {
        System.out.println(userRepository.findAll());
    }
}
âš™ï¸ How it works:
ğŸ‘‰ Spring uses reflection to set the dependency field directly, even if itâ€™s private.

âš ï¸ Disadvantages:
âŒ Not testable easily â€“ canâ€™t inject mock dependencies manually for unit testing.
âŒ Hidden dependencies â€“ dependencies arenâ€™t visible in the constructor.
âŒ No immutability â€“ dependencies canâ€™t be declared final.
âŒ Difficult for mandatory dependencies â€“ Spring doesnâ€™t enforce that the field must be set.

ğŸ‘‰ Field injection is considered the worst practice for maintainable and testable code.

2ï¸âƒ£ Setter Injection
âœ… Example:
@Service
public class UserService {

    private UserRepository userRepository;

    @Autowired
    public void setUserRepository(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public void getUser() {
        System.out.println(userRepository.findAll());
    }
}
âœ… Advantages:
â¤ Allows optional dependencies (useful if bean might not always be required).
â¤ Makes it easier to change dependencies later.

âš ï¸ Disadvantages:
â¤ Not suitable for mandatory dependencies.
â¤ Object can be created without a dependency, which can lead to NullPointerException.
â¤ Still not fully immutable.

3ï¸âƒ£ Constructor Injection (Recommended âœ…)
âœ… Example:
@Service
public class UserService {

    private final UserRepository userRepository;

    @Autowired  //----------â¤ Not required since Spring 4.3+
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public void getUser() {
        System.out.println(userRepository.findAll());
    }
}

âœ… Advantages:
ğŸ’ª Immutable dependencies â†’ mark fields as final.
ğŸ§  Clear dependencies â†’ visible in the constructor.
ğŸ§ª Best for testing â†’ easy to pass mock objects in unit tests.
ğŸ” Ensures all mandatory dependencies are available during bean creation.
ğŸ’¡ Recommended by Spring Team (and used by Spring itself internally).

â¤ From Spring Framework 4.3 onward, if a class has only one constructor, Spring automatically injects dependencies â€” no need for @Autowired.

ğŸ”„ Comparison
| Feature                    | Field Injection | Setter Injection | Constructor Injection |
| -------------------------- | --------------- | ---------------- | --------------------- |
| Visibility                 | Hidden          | Visible          | Visible               |
| Immutability               | âŒ No           | âŒ No           | âœ… Yes                |
| Testability                | âŒ Poor        | âš™ï¸ Medium        | âœ… Best               |
| Optional Dependencies      | âš™ï¸ Medium      | âœ… Yes           | âŒ No                 |
| Mandatory Dependencies     | âŒ Risky        | âš™ï¸ Medium       | âœ… Best               |
| Spring Recommendation      | âŒ No           | âš™ï¸ Sometimes    | âœ… Yes                |

â¤ Adding all 3 types of DI in one class is not a good practice. It creates confusion and makes the code hard to maintain.
â¤ Choose one type of DI per class, preferably constructor injection for better maintainability and testability.

==========================================
ğŸ”· @Component vs @Service in Spring Boot
==========================================
â¤ Both @Component and @Service are annotations used in Spring to define beans, but they serve different purposes and convey different semantics. 
| Annotation   | Description                                                                                                     |
| ------------ | --------------------------------------------------------------------------------------------------------------- |
| `@Component` | Generic stereotype annotation that marks a class as a Spring-managed bean.                                      |
| `@Service`   | A specialized type of `@Component used to mark classes that hold business logic or service-layer code.          |

ğŸ”„ What They Do Internally
âœ… Both @Component and @Service
â¤ Register the class as a bean in the Spring ApplicationContext
â¤ Enable dependency injection via @Autowired.

ğŸ‘‰ In short:
@Service = @Component + Semantic meaning (used for service/business layer)

ğŸ”„ Layer Meaning in Spring 
| Layer                | Annotation                        | Purpose                                   |
| -------------------- | --------------------------------- | ----------------------------------------- |
| Controller Layer     | `@Controller` / `@RestController` | Handles web requests (presentation layer) |
| Service Layer        | `@Service`                        | Contains business logic                   |
| Repository Layer     | `@Repository`                     | Deals with persistence (database access)  |
| Generic Bean         | `@Component`                      | Used for any other general-purpose bean   |

âœ… Example: Using @Component
@Component
public class EmailValidator {
    public boolean isValid(String email) {
        return email.contains("@");
    }
}
â¤ Registered as a Spring Bean.
â¤ Can be injected anywhere:
@Autowired
private EmailValidator validator;

âœ… Example: Using @Service
@Service
public class UserService {
    public void registerUser(User user) {
        // business logic for registration
    }
}
â¤ Also a Spring Bean.
â¤ But used to represent business logic layer.

ğŸ”„ Key Difference â€” Intent and Semantics
| Feature                               | `@Component`         | `@Service`                                             |
| ------------------------------------- | -------------------- | ------------------------------------------------------ |
| Purpose                               | Generic bean         | Business logic layer                                   |
| Spring Behavior                       | Registers bean       | Registers bean (same behavior)                         |
| Semantic Meaning                      | Can be used anywhere | Indicates service-level component                      |
| AOP (Aspect-Oriented Programming)     | No special behavior  | May be used by Spring for transactional or proxy logic |
| Readability                           | Less descriptive     | More expressive for business services                  |

ğŸ”„ AOP (Aspect-Oriented Programming) Note
â¤ Spring often applies aspects (like @Transactional, @Async, etc.) at the service layer.
So using @Service:
â¤ Helps Spring automatically detect it as a target for business logicâ€“related aspects.

======================
ğŸ”· @Value Annotation
======================
In Spring Boot, the @Value annotation is used to inject values into fields, method parameters, or constructor arguments directly from:
âœ”ï¸ application.properties / application.yml
âœ”ï¸ Environment variables
âœ”ï¸ System properties
âœ”ï¸ Expression Language (SpEL)

ğŸ”„ Syntax
@Value("${property.key}")
private String value;
ğŸ‘‰ Spring replaces ${property.key} with the actual value from application.properties (or other sources).

âœ… Example 1: Injecting from application.properties
ğŸ”— application.properties
app.name=WeatherApp
app.version=1.0.3

ğŸ”— Java Class
@Component
public class AppConfig {
    
    @Value("${app.name}")
    private String appName;

    @Value("${app.version}")
    private String version;

    public void printDetails() {
        System.out.println(appName + " - " + version);
    }
}
âœ… Output:
WeatherApp - 1.0.3


âœ… Example 2: Default Value
If the property doesnâ€™t exist, you can provide a default value:

@Value("${app.description:Default Description}")
private String description;

âœ… Example 3: Injecting System or Environment Variables
You can directly access environment/system variables:
@Value("${JAVA_HOME}")
private String javaHome;

âœ… Example 4: Using SpEL (Spring Expression Language)
You can perform calculations or logic:
@Value("#{2 * 10}")
private int value; // 20

@Value("#{systemProperties['user.home']}")
private String userHome;

âœ… Example 5: Injecting Lists or Arrays
ğŸ”— application.properties

app.cities=Delhi,Mumbai,Bangalore

ğŸ”— Java Class
@Value("${app.cities}")
private List<String> cities;

ğŸ”„ When to Use @Value
â¤ For simple property injection (like strings, numbers, or constants).
â¤ When you donâ€™t need a full configuration class.

ğŸ”„ Better Alternative for Multiple Values â†’ @ConfigurationProperties
For injecting multiple related properties, prefer:

@ConfigurationProperties(prefix = "app")
public class AppConfig {
    private String name;
    private String version;
    // getters & setters
}
âœ… Cleaner and easier to maintain for grouped properties.


==============================
ğŸ”· @Transactional Annotation
===============================
â¤ @Transactional in Spring marks a method (or class) so that database operations inside it run within a single transaction.
â¤ Either all succeed (commit) or all fail (rollback).
â¤ Ensures ACID properties (Atomicity, Consistency, Isolation, Durability).

âœ…Example:
@Service
public class PaymentService {

    @Autowired
    private OrderRepository orderRepo;

    @Autowired
    private PaymentRepository paymentRepo;

    @Transactional
    public void processPayment(Order order, Payment payment) {
        orderRepo.save(order);       // Step 1
        paymentRepo.save(payment);   // Step 2

        // If any exception occurs here, both saves will rollback
    }
}
ğŸ‘‰ Without @Transactional, if orderRepo.save() succeeds but paymentRepo.save() fails, youâ€™d get inconsistent data. With @Transactional, both operations succeed or both rollback.

It can be applied at:
1ï¸âƒ£ Method Level â†’ Only that method runs in a transaction.
2ï¸âƒ£ Class Level â†’ All public methods in the class run in transactions.

Key Features

1ï¸âƒ£ Rollback Rules
â¤ By default, rolls back on unchecked exceptions (RuntimeException, Error).
â¤ Checked exceptions donâ€™t trigger rollback unless configured.

@Transactional(rollbackFor = Exception.class)
public void doWork() { ... }

2ï¸âƒ£ Isolation Levels (how transactions interact with each other)
âœ”ï¸ READ_COMMITTED (default in most DBs)
âœ”ï¸ READ_UNCOMMITTED
âœ”ï¸ REPEATABLE_READ
âœ”ï¸ SERIALIZABLE

âœ… Example:
@Transactional(isolation = Isolation.SERIALIZABLE)

3ï¸âƒ£ Propagation (what happens if a method with a transaction calls another transactional method)
âœ”ï¸ REQUIRED (default) â†’ joins existing transaction or creates new one if none.
âœ”ï¸ REQUIRES_NEW â†’ always starts a new transaction.
âœ”ï¸ MANDATORY â†’ must run inside an existing transaction.
âœ”ï¸ SUPPORTS, NOT_SUPPORTED, NEVER, NESTED.

âœ… Example:
@Transactional(propagation = Propagation.REQUIRES_NEW)

4ï¸âƒ£ Read-Only Transactions
Optimizes performance for queries.

@Transactional(readOnly = true)


ğŸ”· application.properties vs application.yml in Spring Boot
1ï¸âƒ£ application.properties (Default format)
This is a key-value pair file.

âœ… Example:
# Server Configuration
server.port=8081

# Database Configuration
spring.datasource.url=jdbc:mysql://localhost:3306/testdb
spring.datasource.username=root
spring.datasource.password=1234

ğŸ§  Syntax Rules:
Each property is a key=value pair.
Hierarchical configs use dots (.).
Comments start with #.
Easy for simple configurations, but harder for nested data.

2ï¸âƒ£ application.yml ((Yet Another Markup Language)YAML format)
YAML is a human-readable hierarchical format (preferred for complex configs).

âœ… Example:
server:
  port: 8081

spring:
  datasource:
    url: jdbc:mysql://localhost:3306/testdb
    username: root
    password: 1234

ğŸ§  Syntax Rules:
Uses indentation (spaces, not tabs) to define hierarchy.
No = or : for nesting â€” just indentation.
Supports arrays/lists easily.

Example with list:
emails:
  - ankur@gmail.com
  - test@example.com

You can use both files together â€” Spring Boot automatically merges them.
Priority order:
application.properties (if defined later)
application.yml (if both exist, last loaded wins)

Properties files are used only in java language based projects.
YAML files can be used in any language based projects.


However, in real-world projects â€”
ğŸ‘‰ prefer YAML (.yml) for readability & structure,

ğŸ”„ Advantages of YAML over Properties:
| Feature            | `.properties` | `.yml`                      |
| ------------------ | ------------- | ------------------------    |
| Readability        | âŒ Average     | âœ… Excellent              |
| Hierarchical Data  | âŒ Complex     | âœ… Natural                |
| Array/List Support | âŒ Hard        | âœ… Easy                   |
| Structure          | Flat          | Nested                      |
| Popularity         | Legacy style  | Modern Spring Boot style    |
| Comments           | âœ… Supported   | âœ… Supported (`#`)        |


=======================
ğŸ”· Spring Profiles 
=======================
â¤ Spring Profiles allow you to activate or deactivate beans/configurations based on the current environment (like dev, test, prod).
â¤ You can control which beans load depending on the active profile.
â¤ You can create multiple versions of the same bean/class and Spring will only load the one matching the active profile.

ğŸ”„ Set Active Profile in application.properties
â¤ You can specify the active profile directly in your main configuration file:
# application.properties
spring.profiles.active=dev

â¤ This tells 
pring Boot to load all settings from application-dev.properties in addition to the default application.properties.

ğŸ”„ Create Profile-Specific Property Files
Each profile has its own file following this naming convention:
application-{profile}.properties

âœ… Example:
âœ”ï¸ application-dev.properties
server.port=8081
spring.datasource.url=jdbc:mysql://localhost:3306/devdb
spring.datasource.username=dev_user
spring.datasource.password=dev123

âœ”ï¸ application-prod.properties
server.port=8082
spring.datasource.url=jdbc:mysql://localhost:3306/proddb
spring.datasource.username=prod_user
spring.datasource.password=prod123

ğŸ”„ Activate Profile via Command Line
You can override the profile at runtime using the command line:

ğŸ”— java -jar myapp.jar --spring.profiles.active=prod
ğŸ‘‰ This overrides whatever is set in application.properties.


ğŸ”„ Using @Profile Annotation
You can annotate beans, components, or configuration classes to load only when a specific profile is active.

âœ… Example: â€” Service Classes
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Service;

@Service
@Profile("dev")
public class DevEmailService implements EmailService {
    @Override
    public void sendEmail(String msg) {
        System.out.println("DEV: Sending mock email â†’ " + msg);
    }
}

@Service
@Profile("prod")
public class ProdEmailService implements EmailService {
    @Override
    public void sendEmail(String msg) {
        System.out.println("PROD: Sending real email â†’ " + msg);
    }
}
ğŸ‘‰ If spring.profiles.active=dev, then only DevEmailService will be loaded.
ğŸ‘‰ If spring.profiles.active=prod, then only ProdEmailService will load.

ğŸ”„ Using @Profile in Configuration Classes
You can also restrict entire configuration classes:

@Configuration
@Profile("test")
public class TestDatabaseConfig {

    @Bean
    public DataSource dataSource() {
        System.out.println("Using TEST database configuration");
        return new HikariDataSource();
    }
}
So when the active profile is test, this config will be used.

ğŸ”„ Get Active Profile Programmatically
You can access the active profile from the Spring Contextâ€™s Environment.

âœ… Example:
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.stereotype.Component;

@Component
public class ActiveProfileLogger {

    @Autowired
    private ApplicationContext context;

    public void printActiveProfile() {
        String[] profiles = context.getEnvironment().getActiveProfiles();
        System.out.println("Active Profile: " + profiles[0]);
    }
}
âœ… Output:
Active Profile: dev

ğŸ”„ Use in Tests (JUnit + Profiles)
You can set a profile for tests using @ActiveProfiles:

@SpringBootTest
@ActiveProfiles("test")
public class UserServiceTest {

    @Autowired
    private ApplicationContext context;

    @Test
    void checkProfile() {
        System.out.println("Running under profile: "
            + context.getEnvironment().getActiveProfiles()[0]);
    }
}
âœ… Output:
Running under profile: test

ğŸ”„ Multiple Profiles at Once
You can activate more than one profile:
ğŸ‘‰ spring.profiles.active=dev,local
Spring will load all beans matching either dev or local.

You can also use logical negation:
@Profile("!prod")   // load this bean in all profiles except prod

ğŸ”„ Using Profiles with YAML
You can define multiple profiles within a single YAML file using ---:
server:
  port: 8080

spring:
  profiles:
    active: dev

spring:
  config:
    activate:
      on-profile: dev
server:
  port: 8081


spring:
  config:
    activate:
      on-profile: prod
server:
  port: 9090
ğŸ‘‰ Depending on which profile is active, the corresponding section will apply.

ğŸ”„ Checking Active Profile in Console (Quick Check)
In any Spring Boot class:
System.out.println(context.getEnvironment().getActiveProfiles()[0]);
ğŸ‘‰ Prints the current active profile â€” very useful for debugging or verifying environment setup.


ğŸ”· Spring MVC
Spring MVC (Model-View-Controller) is a web framework within the Spring Framework used to build web applications (both traditional and RESTful).

It follows the MVC design pattern, which separates the application into:
â¤ Model â†’ Data & Business logic
â¤ View â†’ User Interface
â¤ Controller â†’ Request handling

ğŸ§  Goal of Spring MVC
To separate concerns and make the application flexible, maintainable, and testable.

âš™ï¸ Architecture Overview
Client (Browser)
   â†“
DispatcherServlet  â†â”€â”€ Front Controller
   â†“
HandlerMapping
   â†“
Controller
   â†“
Service / DAO / Model
   â†“
ViewResolver
   â†“
View (HTML / JSP / Thymeleaf / JSON)
   â†“
Response to Client

1ï¸âƒ£ Client sends request
â¤ A user makes a request (e.g., /patients).
â¤ The request first reaches the DispatcherServlet, the Front Controller.

2ï¸âƒ£ DispatcherServlet
â¤ Itâ€™s the central controller of the Spring MVC framework.
â¤ It delegates the request to appropriate components.
â¤ Defined in web.xml or automatically configured in Spring Boot.

3ï¸âƒ£ HandlerMapping
â¤ Determines which controller should handle the incoming request.
â¤ Uses annotations like @RequestMapping, @GetMapping, etc.

4ï¸âƒ£ Controller
Contains request-handling methods (business logic triggers).

âœ… Example:

@Controller
public class PatientController {

    @GetMapping("/patients")
    public String getPatients(Model model) {
        List<Patient> list = patientService.getAllPatients();
        model.addAttribute("patients", list);
        return "patientsView"; // logical view name
    }
}

5ï¸âƒ£ Model
â¤ Represents data that will be displayed in the view.
â¤ Often filled by the controller (via Model, ModelMap, or ModelAndView).

6ï¸âƒ£ ViewResolver
Resolves the logical view name (like "patientsView") to an actual view (e.g., patientsView.jsp or patients.html).

âœ… Common examples:
InternalResourceViewResolver â†’ JSP
ThymeleafViewResolver â†’ HTML template

7ï¸âƒ£ View
â¤ The actual UI component (e.g., JSP, Thymeleaf, React frontend, etc.)
â¤ Displays the model data and sends the final HTML (or JSON) to the browser.

8ï¸âƒ£ Response to Client
The generated view is returned to the DispatcherServlet, which sends it back as an HTTP response.

ğŸŒŸ Client can send data to server in three ways:
1ï¸âƒ£ Query Parameters (?key=value)
â¤ Data is sent in the URL after a ?, as key-value pairs.
â¤ Often used for filtering, searching, or optional parameters.
â¤ Query parameters are only present at the end of the url.
â¤ Query parameters are less secure as they are visible in the URL.
 
âœ… Example URL:
GET /patients?age=30&gender=male

âœ… Example:
@GetMapping("/patients")
public List<Patient> getPatients(
        @RequestParam int age,
        @RequestParam String gender) {
    return patientService.getByAgeAndGender(age, gender);
}
â¤ Use @RequestParam annotation.
â¤ Works only with GET or DELETE (not ideal for POST).
â¤ Data visible in URL (less secure).
â¤ Great for filtering/sorting/pagination.

2ï¸âƒ£ Path Parameters (Dynamic Part of URL)
â¤ Data is part of the URI path itself.
â¤ Used to identify a specific resource.
â¤ Path parameters can be present anywhere in the url.

âœ… Example URL:
GET /patients/101

âœ… Example:
@GetMapping("/patients/{id}")
public Patient getPatientById(@PathVariable Long id) {
    return patientService.getPatient(id);
}
â¤ Use @PathVariable annotation.
â¤ Used for resource identification (like ID, username, etc.).
â¤ RESTful & clean URLs.
â¤ More semantic than query params for IDs.

3ï¸âƒ£ Request Body
â¤ Data is sent inside the HTTP request body, not in the URL.
â¤ Used to send complex objects, JSON, or large data (e.g., user info, forms).

âœ… Example Request:
POST /patients
Content-Type: application/json
{
  "name": "Ankur Verma",
  "age": 25,
  "gender": "Male"
}

âœ… Example:
@PostMapping("/patients")
public Patient createPatient(@RequestBody Patient patient) {
    return patientService.save(patient);
}
â¤ Use @RequestBody annotation.
â¤ Works with POST, PUT, PATCH.
â¤ Ideal for sending JSON/XML payloads.
â¤ Must set appropriate Content-Type (e.g., application/json).

Spring Web MVC module provide Form Tag library to simplify form handling.
<form:form/>
<form:input/>
<form:errors/>
<form:label/>
<form:select/>
<form:password/>

âœ…Example:

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
    <h2>Login Here...</h2>
    <form action="login" method="post">
        <label>Email: </label> <input type="text" name="email" /> <br /> <label>Password:
        </label> <input type="password" name="password" /> <br /> <input
            type="submit" value="login" />
    </form>
</body>
</html>

ğŸ”· H2 database
H2 Database is a lightweight, fast, open-source relational database written in Java. Itâ€™s often used for development, testing, and small-scale production applications, especially when you donâ€™t want to set up a full external database like MySQL or PostgreSQL.

âš™ï¸ Key Features
â¤ -memory & file-based modes:
    âœ”ï¸ In-memory mode: Data is stored in RAM (deleted when app stops).
    âœ”ï¸ File-based mode: Data is stored on disk (persistent).
â¤ Pure Java: Runs anywhere Java runs.
â¤ Embedded or Server mode:
    âœ”ï¸ Embedded: Runs inside your application.
    âœ”ï¸ Server: Can be accessed remotely via TCP.
â¤ Compatible with JDBC & SQL: Fully supports standard SQL syntax.
â¤ Browser-based console: Comes with an easy-to-use web UI at http://localhost:8082.

Very fast startup & execution speed.

ğŸ§© Common Use Case
â¤ In Spring Boot projects, H2 is used for:
â¤ Quickly testing your JPA or Hibernate code.
â¤ Running unit/integration tests without needing MySQL/PostgreSQL.
â¤ Prototyping new applications before connecting to a real database.

âœ… Example (Spring Boot Application)
application.properties

spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=
spring.h2.console.enabled=true

Now you can access the database console at:
ğŸ‘‰ http://localhost:8080/h2-console

ğŸ—ƒï¸ Example Query
CREATE TABLE users (
  id INT AUTO_INCREMENT PRIMARY KEY,
  name VARCHAR(50),
  email VARCHAR(50)
);

INSERT INTO users (name, email) VALUES ('Ankur', 'ankur@example.com');
SELECT * FROM users;

âš¡ Advantages
â¤ Extremely lightweight and fast.
â¤ No setup required.
â¤ Ideal for testing and development.
â¤ 
ğŸš« Limitations
â¤ Not designed for high concurrency or large-scale production.
â¤ Data in memory mode is temporary.
â¤ Limited performance compared to enterprise DBs like PostgreSQL or MySQL. 


ğŸ”· @Valid Annottion and Binding result in Spring Boot
To enable validation in our spring project we have to add dependency:
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>

â¤ @Valid is used to trigger validation on an object (usually a request body or form input) before it reaches your controller logic.
â¤ It works with Jakarta Bean Validation (JSR-380) â€” typically using annotations like:
âœ”ï¸ @NotNull
âœ”ï¸ @NotEmpty
âœ”ï¸ @Size
âœ”ï¸ @Email
âœ”ï¸ @Min, @Max, etc.

âœ… Example: Using @Valid in a Controller
import jakarta.validation.Valid;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/users")
public class UserController {

    @PostMapping("/register")
    public String registerUser(@Valid @RequestBody User user, BindingResult result) {
        if (result.hasErrors()) {
            return "Validation failed: " + result.getAllErrors();
        }
        return "User registered successfully!";
    }
}

ğŸ§± User Entity Example
import jakarta.validation.constraints.*;

public class User {

    @NotEmpty(message = "Name cannot be empty")
    private String name;

    @Email(message = "Invalid email format")
    private String email;

    @Min(value = 18, message = "Age must be at least 18")
    private int age;

    // Getters and Setters
}

ğŸ”„ BindingResult in Spring Boot
â¤ BindingResult is used right after the @Valid annotated object.
â¤ It captures validation errors detected during the validation process.
â¤ It must immediately follow the validated parameter in the method signature, or Spring will throw an exception.

âš ï¸ Example â€” Wrong Order (will not work)
// âŒ Incorrect
public String registerUser(BindingResult result, @Valid @RequestBody User user) { ... }


âœ… Correct Order:
public String registerUser(@Valid @RequestBody User user, BindingResult result) { ... }

ğŸ”„ What BindingResult Contains
ğŸ”— result.hasErrors() â†’ checks if there are validation errors
ğŸ”— result.getAllErrors() â†’ returns all validation messages
ğŸ”— result.getFieldErrors() â†’ returns only field-specific errors

ğŸ”„ Typical Use Case Flow
â¤ Client sends JSON data to endpoint
â¤ Spring validates it using @Valid and annotations in the DTO
â¤ If errors exist â†’ captured in BindingResult
â¤ Controller handles validation failure gracefully (instead of 400 Bad Request)

âœ… Example Output (if invalid data sent)
Request Body:
{
  "name": "",
  "email": "invalid",
  "age": 15
}

âœ… Response:
Validation failed: [Field error in object 'user' on field 'name': rejected value []; 
 message: Name cannot be empty,
 Field error in object 'user' on field 'email': rejected value [invalid]; 
 message: Invalid email format,
 Field error in object 'user' on field 'age': rejected value [15]; 
 message: Age must be at least 18]


â“ How to configure Jetty as embedded server?
Even if you remove the spring-boot-starter-tomact-dependency from pom.xml file it will still work.
for that we have to use exclusions

<exclusions>
  <exclusion>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-tomcat</artifactId>
  </exclusion>
</exclusions>

<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-jetty</artifactId>
</dependency> 

@RestController is used to send direct response to client without any view files.

=================================
ğŸ”· Payload and DTO in SpringBoot
=================================
â“ What is a Payload?
In Spring Boot (and in general web development), a payload is the data sent by the client (browser, Postman, frontend app) to the server in an HTTP request.

âœ… Example: When you fill a form and click Submit, all form fields (firstName, lastName, email, etc.) are sent as the payload of the HTTP request.

ğŸ”„ Types of Payload:
â¤ Form Data (like in your JSP form)
â¤ JSON/XML Payload (common in REST APIs)

ğŸ‘‰ In your example:
When the user submits the registration.jsp form, this data is sent as payload:

ğŸ”— Code Block (registration.jsp)
<body>
	<h2>Register here..</h2>
	<form action="saveReg" method="post">
		<pre>
			First Name   <input type="text" name="firstName"/>
			Last Name    <input type="text" name="lastName"/>
			Email Id     <input type="text" name="email"/>
			Mobile       <input type="text" name="mobile"/>
			City         <input type="text" name="city"/>
			State        <input type="text" name="state"/>
			Pincode      <input type="text" name="pinCode"/>
			Address Line <input type="text" name="addressLine"/>
			<input type="submit" value="Save"/>
		</pre>
	</form>
	${msg}
</body>

firstName=John
lastName=Doe
email=john@gmail.com
mobile=1234567890
city=Delhi
state=Delhi
pinCode=110001
addressLine=Street 5, XYZ
ğŸ‘‰ This is the request payload.

â“ What is a DTO (Data Transfer Object)?
A DTO is a Java class created to receive, hold, and transfer the payload data between different layers of the application.

ğŸ”„ Purpose:
â¤ Prevents direct use of Entity for input/output.
â¤ Provides loose coupling between database structure and client requests.
â¤ Helps with validation, security, and clean separation of concerns.

ğŸ‘‰ In your example:
The payload (form data) is mapped to EmployeeDto.java:

public class EmployeeDto {
    private String firstName;
    private String lastName;
    private String email;
    private String mobile;

    private String city;
    private String state;
    private int pinCode;
    private String addressLine;

    // getters and setters
}
ğŸ‘‰ When the user submits the form â†’ Spring automatically binds request payload â†’ this EmployeeDto object using @ModelAttribute.

â“ How Payload and DTO Work Together in above Example
Step 1ï¸âƒ£:  Payload Submission
User fills the form â†’ clicks Save â†’ Payload sent:
firstName=John&lastName=Doe&email=john@gmail.com&mobile=12345&city=Delhi&state=Delhi&pinCode=110001&addressLine=Street 5

Step2ï¸âƒ£: Controller Receives Payload via DTO
ğŸ”— EmployeeController.java
@Controller
public class EmployeeController {
	
	@Autowired
	private EmployeeService employeeService;

	@GetMapping("/view")
	public String viewRegisterPage() {
		return "employee";
	}
	
	@PostMapping("/saveReg")
	public String saveEmployee(@ModelAttribute EmployeeDto employeeDto, Model model) {
		employeeService.saveEmployeeDetails(employeeDto);
		model.addAttribute("msg", "Record is saved successfully!");
        return "employee";
	}
}
â¤ @ModelAttribute EmployeeDto employeeDto â†’ Spring automatically maps form fields (payload) to EmployeeDto fields.

âœ… Example:
    âœ”ï¸ firstName â†’ employeeDto.setFirstName("John")
    âœ”ï¸ city â†’ employeeDto.setCity("Delhi")

ğŸ”— Address.java (Entity)
package com.app.entity;

import jakarta.persistence.*;

@Entity
public class Address {
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private long id;

	private String city;
	private String state;
	private int pinCode;
	private String addressLine;

	// Getters & Setters
}

Step 3ï¸âƒ£: Service Converts DTO â†’ Entities
EmployeeService.java

@Service
public class EmployeeService {
	
	@Autowired
	private EmployeeRepository employeeRepository;
	
	@Autowired
	private AddressRepository addressRepository;
	
	public void saveEmployeeDetails(EmployeeDto employeeDto) {
		// Convert DTO â†’ Entity
		Employee emp = new Employee();
		BeanUtils.copyProperties(employeeDto, emp);
		employeeRepository.save(emp);
		
		Address address = new Address();
		BeanUtils.copyProperties(employeeDto, address);
		addressRepository.save(address);
	}
}
â¤ DTO is not directly saved in DB.
â¤ Instead:
    âœ”ï¸ Employee entity stores employee-specific info.
    âœ”ï¸ Address entity stores address info.
    âœ”ï¸ BeanUtils.copyProperties() copies data from DTO â†’ Entities.

â“ Why Not Use Entity Instead of DTO?
Imagine you bound form data directly to Employee entity:

public String saveEmployee(@ModelAttribute Employee employee) { ... }

â— Problems:
1ï¸âƒ£ Tight Coupling â†’ If DB schema changes, your form & API also break.
2ï¸âƒ£ Security Risk â†’ Someone could inject malicious values into DB-only fields (like id or roles).
3ï¸âƒ£ Validation â†’ DTO can have @NotNull, @Email annotations to validate payload before saving.
4ï¸âƒ£ Different Structures â†’ Payload structure (form/JSON) may not exactly match DB structure. DTO solves this mismatch.


==================================
ğŸ”· Interceptor in Spring Web MVC
===================================
An Interceptor in Spring MVC is a component that intercepts HTTP requests and responses â€”
before they reach the controller and after the controller has executed.

Think of it as a middleware that can:
â¤ Pre-process requests (like checking authentication)
â¤ Post-process responses (like adding custom headers)
â¤ Handle after-completion logic (like logging or cleanup)

ğŸ”„ Use Case of Interceptor
â¤ Calculate each request processing time
â¤ Log Request and Response details
â¤ Add custom headers to responses
â¤ Add analytics/tracking events

âœ… Example: Interceptor in Spring Boot
import org.springframework.web.servlet.HandlerInterceptor;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

public class LoggingInterceptor implements HandlerInterceptor {

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        System.out.println("â¡ï¸ Request URL: " + request.getRequestURL());
        return true; // continue to controller
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, 
                           Object handler, org.springframework.web.servlet.ModelAndView modelAndView) {
        System.out.println("âœ… Controller executed successfully.");
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, 
                                Object handler, Exception ex) {
        System.out.println("ğŸ Request completed.");
    }
}

ğŸ”„ Microservices / Spring Boot REST APIs
    âœ”ï¸ Interceptors are still used, but less often for security, because:
    âœ”ï¸ Authentication/authorization is usually handled by Spring Security filters (JWT, OAuth2).
    âœ”ï¸ Cross-cutting concerns may be handled by AOP (Aspects) or Filters.
However, interceptors are still useful for:
    âœ”ï¸ API request/response logging
    âœ”ï¸ Adding custom headers (e.g., trace ID for distributed tracing)
    âœ”ï¸ Request timing or rate-limiting hooks
    âœ”ï¸ Analytics/tracking events before controller execution

ğŸ”„ In modern alternatives (Reactive apps)
â¤ For Spring WebFlux (reactive), the equivalent concept is called a WebFilter, not an interceptor.
â¤ So if the app is reactive, youâ€™ll rarely see traditional interceptors.



ğŸ”· Exception Handling in Spring MVC
1ï¸âƒ£ Using @ExceptionHandler (Method-Level)
Used inside a specific controller to handle exceptions thrown only by that controller.

@Controller
public class UserController {

    @GetMapping("/user/{id}")
    public String getUser(@PathVariable int id) {
        if (id <= 0)
            throw new IllegalArgumentException("Invalid ID");
        return "user";
    }

    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<String> handleInvalidId(IllegalArgumentException ex) {
        return ResponseEntity.badRequest().body(ex.getMessage());
    }
}
ğŸ“Œ Use when you want controller-specific exception handling.

2ï¸âƒ£ Using @ControllerAdvice (Global Exception Handling) or using @RestControllerAdvice
A class annotated with @ControllerAdvice applies to all controllers globally.

@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(Exception.class)
    public ResponseEntity<String> handleAll(Exception ex) {
        return ResponseEntity
                .status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body("Something went wrong: " + ex.getMessage());
    }

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<String> handleNotFound(ResourceNotFoundException ex) {
        return ResponseEntity
                .status(HttpStatus.NOT_FOUND)
                .body(ex.getMessage());
    }
}
ğŸ“Œ Best practice for production apps â€” keeps controllers clean.

3ï¸âƒ£ Using @ResponseStatus on Custom Exceptions
Attach HTTP status directly to an exception class.

@ResponseStatus(HttpStatus.NOT_FOUND)
public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String msg) {
        super(msg);
    }
}
Now if you throw new ResourceNotFoundException("User not found"),
Spring automatically returns a 404 response.

4ï¸âƒ£ Using ResponseEntityExceptionHandler (Framework-Level)
You can extend this base class to override built-in exception handling (like MethodArgumentNotValidException, HttpRequestMethodNotSupportedException, etc.).

@ControllerAdvice
public class CustomRestExceptionHandler extends ResponseEntityExceptionHandler {

    @Override
    protected ResponseEntity<Object> handleMethodArgumentNotValid(
        MethodArgumentNotValidException ex,
        HttpHeaders headers,
        HttpStatus status,
        WebRequest request) {

        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getFieldErrors().forEach(error ->
            errors.put(error.getField(), error.getDefaultMessage())
        );

        return new ResponseEntity<>(errors, HttpStatus.BAD_REQUEST);
    }
}
ğŸ“Œ Use this when you want to customize Springâ€™s built-in validation error responses.

ğŸ”„Hierarchy of Handling
If multiple exception handlers match:
    âœ”ï¸ Method-level @ExceptionHandler (highest priority)
    âœ”ï¸ @ControllerAdvice (global)
    âœ”ï¸ Default Spring error page (if not caught above)

âš¡ Example Flow
â¤ If /user/0 is requested:
    âœ”ï¸ IllegalArgumentException is thrown
    âœ”ï¸ Handled by either:
        â¤ @ExceptionHandler in UserController, OR
        â¤ global @ControllerAdvice, OR
        â¤ default Spring error JSON if none found



ğŸ”· Spring Batch
â¤ Spring Batch is a lightweight, robust, and scalable batch processing framework built on top of the Spring framework.
â¤ It is used for automating large-volume, repetitive, or scheduled data processing tasks â€” such as reading data from a database or file, processing it, and writing the output elsewhere.

â¤ â€œSpring Batch is used to handle large amounts of data in batch jobs â€” with features like transaction management, chunk processing, job scheduling, and restart capabilities.â€


ğŸ”„ Why We Use Spring Batch
| Purpose                    | Explanation                                                             |
| -------------------------- | ----------------------------------------------------------------------- |
| **Automation**             | Run repetitive jobs (e.g., daily report generation, data cleanup).      |
| **Bulk Processing**        | Process millions of records efficiently.                                |
| **Transaction Management** | Each chunk is processed transactionally â€” rollback if any failure.      |
| **Restart Capability**     | Resume job from where it failed.                                        |
| **Scalability**            | Supports multi-threaded and parallel processing.                        |
| **Integration**            | Works easily with Spring Boot, Spring Data, JPA, JDBC, etc.             |
| **Monitoring**             | Tracks job metadata (start time, end time, status, etc.) automatically. |

ğŸ”„ Real-World Use Cases
| Use Case                       | Example                                                |
| ------------------------------ | ------------------------------------------------------ |
| Data migration                 | Migrate records from one database to another.          |
| ETL (Extract, Transform, Load) | Extract data from CSV, transform it, and load into DB. |
| Report generation              | Generate PDF/Excel reports daily.                      |
| Log processing                 | Process and summarize server logs.                     |
| Invoice generation             | Generate bills for customers periodically.             |

ğŸ”„ Key Concepts in Spring Batch
| Concept           | Description                                                         |
| ----------------- | ------------------------------------------------------------------- |
| **Job**           | Represents the entire batch process (contains one or more steps).   |
| **Step**          | A single phase of the job â€” e.g., read â†’ process â†’ write.           |
| **ItemReader**    | Reads data (from file, DB, API, etc.).                              |
| **ItemProcessor** | Processes/transforms the data (e.g., filtering, mapping).           |
| **ItemWriter**    | Writes data to a destination (DB, file, etc.).                      |
| **JobRepository** | Stores metadata about job execution (status, start/end time, etc.). |
| **JobLauncher**   | Used to start the batch job.                                        |
| **JobParameters** | External inputs to a batch job (e.g., file path, date).             |

ğŸ”„ How Spring Batch Works (Flow Diagram)
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚         JobLauncher         â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                (launch job)
                      â†“
             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
             â”‚       Job         â”‚
             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚                   â”‚
          Step 1              Step 2
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚ ItemReader     â”‚   â”‚ ItemReader     â”‚
     â”‚ ItemProcessor  â”‚   â”‚ ItemProcessor  â”‚
     â”‚ ItemWriter     â”‚   â”‚ ItemWriter     â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ”„ Spring Batch Workflow in Simple Terms
â¤ JobLauncher starts the Job.
â¤ A Job consists of one or more Steps.
â¤ Each Step performs:
    âœ”ï¸ Read â†’ Process â†’ Write.
â¤ Metadata is saved in JobRepository.
â¤ If a job fails midway, you can restart from the last checkpoint.


ğŸ”„ Chunk-Oriented Processing
One of the key concepts in Spring Batch.
Data is processed in small "chunks" instead of all at once â€” improving memory efficiency.

âœ… Example:
chunk-size: 10

ğŸ‘‰ Process flow:
Read 10 items â†’ Process â†’ Write â†’ Commit Transaction â†’ Repeat

ğŸ‘‰ If something fails in that chunk, only that chunk rolls back.


ğŸ”„ Spring Batch Example
1ï¸âƒ£ Add Dependencies (Maven)
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-batch</artifactId>
</dependency>

<dependency>
    <groupId>org.hsqldb</groupId>
    <artifactId>hsqldb</artifactId>
    <scope>runtime</scope>
</dependency>


2ï¸âƒ£ Define a Batch Configuration
@Configuration
@EnableBatchProcessing
public class BatchConfig {

    @Autowired
    private JobBuilderFactory jobBuilderFactory;

    @Autowired
    private StepBuilderFactory stepBuilderFactory;

    @Bean
    public ItemReader<String> reader() {
        return new ListItemReader<>(List.of("A", "B", "C", "D"));
    }

    @Bean
    public ItemProcessor<String, String> processor() {
        return item -> item.toLowerCase(); // Convert to lowercase
    }

    @Bean
    public ItemWriter<String> writer() {
        return items -> items.forEach(System.out::println);
    }

    @Bean
    public Step step() {
        return stepBuilderFactory.get("step1")
                .<String, String>chunk(2)
                .reader(reader())
                .processor(processor())
                .writer(writer())
                .build();
    }

    @Bean
    public Job job() {
        return jobBuilderFactory.get("myJob")
                .start(step())
                .build();
    }
}


3ï¸âƒ£Run the Batch
ğŸ‘‰ You can trigger it:
â¤ Automatically at startup (default)
â¤ Programmatically using JobLauncher

@Autowired
private JobLauncher jobLauncher;

@Autowired
private Job job;

@PostConstruct
public void runJob() throws Exception {
    JobParameters params = new JobParametersBuilder()
            .addLong("time", System.currentTimeMillis())
            .toJobParameters();

    jobLauncher.run(job, params);
}


ğŸ”„ Advanced Features
| Feature                      | Description                                                  |
| ---------------------------- | ------------------------------------------------------------ |
| **Job Restartability**       | Resume job from last successful step using job metadata.     |
| **Job Scheduling**           | Combine with Spring Scheduler / Quartz to run periodically.  |
| **Parallel Steps**           | Run multiple steps in parallel threads.                      |
| **Partitioning**             | Split data into multiple partitions for parallel processing. |
| **Skip and Retry Logic**     | Skip or retry items that fail processing.                    |
| **Listeners**                | Hook into lifecycle events (before/after job or step).       |
| **Database-backed Metadata** | Stores job execution data in DB via `JobRepository`.         |


ğŸ”· Reactive Programming
Reactive Programming is a programming paradigm that focuses on asynchronous data streams and non-blocking communication.

Instead of executing tasks sequentially and blocking threads (like traditional Spring MVC), it works by reacting to events (like incoming data, user requests, or errors).


ğŸ”„ Traditional vs Reactive Thinking
| Type             | Traditional (Imperative)       | Reactive (Declarative)                 |
| ---------------- | ------------------------------ | -------------------------------------- |
| **Thread Model** | One thread per request         | Few threads handle many requests       |
| **I/O Calls**    | Blocking (waits for response)  | Non-blocking (reacts when ready)       |
| **Processing**   | Sequential                     | Event-driven & Stream-based            |
| **Example**      | Waiting for DB query to finish | Subscribes to DB result when available |

ğŸ”„ Why Reactive Programming?
Reactive programming helps when your system:
    âœ”ï¸ Handles a large number of concurrent requests (like Netflix, LinkedIn, etc.)
    âœ”ï¸ Waits a lot on I/O operations (DB, REST APIs, file reads, etc.)
    âœ”ï¸ Needs to be scalable with minimal resource usage
    âœ”ï¸ Requires streaming data processing (live dashboards, event processing)


ğŸ”„ Core Concepts of Reactive Programming 
| Concept          | Description                                    | Analogy                         |
| ---------------- | ---------------------------------------------- | ------------------------------- |
| **Publisher**    | Emits data asynchronously (like a data source) | â€œPerson who speaksâ€             |
| **Subscriber**   | Listens to data from Publisher                 | â€œPerson who listensâ€            |
| **Subscription** | Connection between Publisher & Subscriber      | â€œPhone call between two peopleâ€ |
| **Backpressure** | Mechanism to control data flow rate            | â€œListener says â€“ speak slower!â€ |

ğŸ”„ Reactive Streams Specification (4 Interfaces)
Spring implements Reactive Streams, which has four interfaces:
    âœ”ï¸ Publisher â†’ Emits data
    âœ”ï¸ Subscriber â†’ Consumes data
    âœ”ï¸ Subscription â†’ Controls data request/cancel
    âœ”ï¸ Processor â†’ Acts as both publisher and subscriber

ğŸ”„ Reactive in Spring Boot â€” The Spring WebFlux Module
Spring Boot provides Spring WebFlux â€” a reactive alternative to Spring MVC.

| Framework          | Type         | I/O Model    |
| ------------------ | ------------ | ------------ |
| **Spring MVC**     | Synchronous  | Blocking     |
| **Spring WebFlux** | Asynchronous | Non-Blocking |

ğŸ‘‰ WebFlux is built on:
â¤ Project Reactor â†’ core reactive library used internally.
â¤ Netty / Undertow â†’ non-blocking servers (instead of Tomcat).

Core Types in Project Reactor
| Type        | Description                                   | Example      |
| ----------- | --------------------------------------------- | ------------ |
| **Mono<T>** | Emits **0 or 1** item (for single responses)  | `Mono<User>` |
| **Flux<T>** | Emits **0 or many** items (for streams/lists) | `Flux<User>` |
These replace the traditional User or List<User> in reactive code.

âœ… Example: Reactive Controller
@RestController
@RequestMapping("/users")
public class UserController {

    @Autowired
    private UserService userService;

    // Returns single user (Mono)
    @GetMapping("/{id}")
    public Mono<User> getUser(@PathVariable String id) {
        return userService.findById(id);
    }

    // Returns multiple users (Flux)
    @GetMapping
    public Flux<User> getAllUsers() {
        return userService.findAll();
    }
}
âœ”ï¸ No thread blocks waiting for DB or API responses â€” results are streamed asynchronously.

ğŸ”„ Reactive Repository
When using MongoDB or R2DBC, you can use Reactive Repositories:
public interface UserRepository extends ReactiveCrudRepository<User, String> {
    Flux<User> findByAgeGreaterThan(int age);
}

âœ”ï¸ ReactiveCrudRepository replaces JpaRepository
âœ”ï¸ Returns Mono or Flux

ğŸ”„ End-to-End Reactive Flow
Client â†’ Reactive Controller â†’ Reactive Service â†’ Reactive Repository â†’ DB/External API

âœ”ï¸ Each layer returns Mono or Flux
âœ”ï¸ Execution is non-blocking
âœ”ï¸ Uses event loop threads (like Netty)

ğŸ”„ Advantages
| Advantage                         | Explanation                                                  |
| --------------------------------- | ------------------------------------------------------------ |
| ğŸš€ **High Scalability**           | Handles thousands of concurrent connections with few threads |
| âš¡ **Better Resource Utilization** | No blocking â†’ less thread overhead                           |
| ğŸ”„ **Asynchronous**               | Data flows as streams, not as fixed responses                |
| ğŸ“¡ **Streaming Data Support**     | Perfect for real-time dashboards, notifications, etc.        |
| âš™ï¸ **Resilient Systems**          | Built-in error handling and backpressure support             |

ğŸ”„Limitations / When Not to Use
â¤ When application is CPU-bound (heavy computation, not I/O waiting)
â¤ When integrating with legacy blocking APIs
â¤ Learning curve â€” debugging reactive flows can be tricky
â¤ For small, simple apps â€” traditional Spring MVC is enough


ğŸ”„ Integration with Other Modules
| Integration                      | Example                                                 |
| -------------------------------- | ------------------------------------------------------- |
| **Spring Data R2DBC**            | Reactive DB access (MySQL, PostgreSQL)                  |
| **Spring Data MongoDB Reactive** | Non-blocking Mongo queries                              |
| **Reactive Kafka**               | Consuming Kafka streams reactively                      |
| **WebClient**                    | Non-blocking HTTP client (replacement for RestTemplate) |

âœ… Example with WebClient (Reactive REST Calls)
WebClient webClient = WebClient.create("https://api.github.com");

Flux<Repository> repos = webClient.get()
        .uri("/users/ankur-verma30/repos")
        .retrieve()
        .bodyToFlux(Repository.class);

âœ”ï¸ Non-blocking HTTP call
âœ”ï¸ WebClient replaces RestTemplate

ğŸ”„ Real-world Use Cases
â¤ Live chat systems
â¤ Real-time stock tickers or dashboards
â¤ Reactive microservices communicating via WebFlux + Kafka
â¤ IoT sensor data streaming
â¤ Notification systems
