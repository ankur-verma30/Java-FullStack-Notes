=====================
ğŸ”· Spring Security
=====================
Spring Security is a powerful and customizable security framework provided by the Spring ecosystem.
It is used to secure Java web applications, especially Spring Boot applications, by handling
âœ”ï¸ Authentication â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Who are you
âœ”ï¸ Authorization â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ What are you allowed to do?
ğŸ‘‰ Itâ€™s like a security guard that checks the identity of users and ensures they can only access what theyâ€™re permitted to.


ğŸ”„ Core Features of Spring Security
| Feature                 | Description                                                                   |
| ----------------------- | ----------------------------------------------------------------------------- |
| ğŸ”‘ Authentication      | Verifies the userâ€™s identity (e.g., via username/password, JWT, OAuth2, etc.) |
| ğŸ§¾ Authorization       | Controls access to specific endpoints or resources                            |
| ğŸ§± Session Management  | Handles login sessions, cookies, and logout behavior                          |
| ğŸ•µï¸ CSRF Protection     | Prevents Cross-Site Request Forgery attacks                                   |
| ğŸ›¡ï¸ CORS Handling       | Controls which front-end origins can access backend APIs                      |
| ğŸ”’ Password Encryption | Uses secure hashing (e.g., BCrypt) for passwords                              |
| ğŸŒ Integration Support | Works with JWT, OAuth2 etc.                                                   |


ğŸ”„ How Spring Security Works
1ï¸âƒ£ User sends a request
âœ… Example:
POST /login
{
  "username": "ankur",
  "password": "1234"
}

2ï¸âƒ£ Spring Security intercepts the request
It checks whether the request requires authentication or not.

3ï¸âƒ£ Authentication Manager verifies credentials
â¤ The AuthenticationManager delegates authentication to providers (like a DaoAuthenticationProvider).
â¤ It loads the user using a UserDetailsService from the database or in-memory storage.
â¤ Passwords are compared using a PasswordEncoder (e.g., BCrypt).

4ï¸âƒ£ If successful
â¤ Spring Security generates an Authentication object.
â¤ The userâ€™s details are stored in the SecurityContext.
â¤ The user gains access to secured endpoints.

5ï¸âƒ£ If failed
The framework automatically returns a 401 Unauthorized or 403 Forbidden response.


ğŸ”„ Key Components
| Component             | Description                                                              |
| ----------------------| ------------------------------------------------------------------------ |
| SecurityFilterChain   | Defines which routes are secured and what kind of authentication applies |
| AuthenticationManager | Core engine that performs authentication                                 |
| UserDetailsService    | Loads user info from DB or memory                                        |
| UserDetails           | Represents a single user                                                 |
| PasswordEncoder       | Encrypts and verifies passwords                                          |
| SecurityContextHolder | Stores the authenticated user details in current thread                  |

â¤ By default spring security gives password and after that the endpoints can be accessed by using:
âœ”ï¸ username: user
âœ”ï¸ password: <password given on console>

We can override the default behavior by using:
ğŸ”— spring.security.user.name=your-username
ğŸ”— spring.security.user.password=your-password
ğŸ‘‰ We do not need security for all the endpoints just some of it so we can configure it using configuration file of spring security.

âœ… Example (Modern Spring Boot 3+)
In Spring Boot 3, security configuration uses a bean instead of extending WebSecurityConfigurerAdapter (which is deprecated).

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable()) // disable CSRF for APIs
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/public/").permitAll()   // no auth required
                .requestMatchers("/api/admin/").hasRole("ADMIN") // only ADMIN
                .anyRequest().authenticated()                    // others need login
            )
            .httpBasic(Customizer.withDefaults()); // basic auth (username/password)
        return http.build();
    }

    @Bean
    public UserDetailsService userDetailsService() {
        UserDetails user = User.withUsername("ankur")
                .password(passwordEncoder().encode("1234"))
                .roles("USER")
                .build();

        UserDetails admin = User.withUsername("admin")
                .password(passwordEncoder().encode("admin"))
                .roles("ADMIN")
                .build();

        return new InMemoryUserDetailsManager(user, admin);
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
ğŸ‘‰ Now:
âœ”ï¸ /api/public/ â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ accessible to everyone
âœ”ï¸ /api/admin/ â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ accessible only to ADMIN
âœ”ï¸ /api/ â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ requires authentication


ğŸ”„ Types of Authentication Supported
| Type                 | Description                                                                     |
| ---------------------| ------------------------------------------------------------------------------- |
| Basic Auth           | Username and password in the request header (simple, but not very secure alone) |
| Form Login           | Traditional HTML login form                                                     |
| JWT (JSON Web Token) | Token-based authentication for REST APIs                                        |
| OAuth2 / SSO         | Login with Google, GitHub, etc.                                                 |
| LDAP                 | Enterprise authentication system                                                |


ğŸ”„ Spring Security + Microservices
â¤ In a microservice architecture:
    âœ”ï¸ API Gateway often handles authentication (via JWT).
    âœ”ï¸ Individual microservices use Spring Security to verify and authorize requests based on roles/claims inside the JWT.

â¤ Common pattern:
    âœ”ï¸ Gateway validates the token â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ passes user info in headers.
    âœ”ï¸ Downstream services apply @PreAuthorize or role-based access control.


=====================
ğŸ”· Role-Based Login
=====================
Role-Based Login (or Role-Based Access Control, RBAC) means:
â¤ Users have roles, e.g., USER, ADMIN.
â¤ Access to endpoints is restricted based on roles.
âœ… Example:
âœ”ï¸ /admin/ â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ only ADMIN can access
âœ”ï¸ /user/ â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ only USER or ADMIN can access
âœ”ï¸ /public/ â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ everyone can access

Spring Security makes this easy using:
â¤ hasRole("ROLE")
â¤ hasAuthority("AUTHORITY")
â¤ @PreAuthorize annotations


ğŸ”„ Create Security Configuration
Since WebSecurityConfigurerAdapter is deprecated, use SecurityFilterChain:

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable()) // for REST APIs
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/public/").permitAll()
                .requestMatchers("/api/user/").hasRole("USER")
                .requestMatchers("/api/admin/").hasRole("ADMIN")
                .anyRequest().authenticated()
            )
            .formLogin(Customizer.withDefaults()) // form-based login
            .httpBasic(Customizer.withDefaults()); // basic auth
        return http.build();
    }

    @Bean
    public UserDetailsService userDetailsService() {
        UserDetails user = User.withUsername("ankur")
                .password(passwordEncoder().encode("1234"))
                .roles("USER") // ROLE_USER
                .build();

        UserDetails admin = User.withUsername("admin")
                .password(passwordEncoder().encode("admin"))
                .roles("ADMIN") // ROLE_ADMIN
                .build();

        return new InMemoryUserDetailsManager(user, admin);
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
ğŸ‘‰ roles("USER") automatically adds ROLE_ prefix internally.
ğŸ‘‰ hasRole("USER") checks for ROLE_USER.
ğŸ‘‰ formLogin() enables login page, httpBasic() allows basic auth for APIs


ğŸ”„ Using @PreAuthorize for Method-Level Security
You can secure individual methods instead of entire paths:

@RestController
@RequestMapping("/api")
public class RoleController {

    @PreAuthorize("hasRole('USER')")
    @GetMapping("/user/home")
    public String userHome() {
        return "Welcome User!";
    }

    @PreAuthorize("hasRole('ADMIN')")
    @GetMapping("/admin/home")
    public String adminHome() {
        return "Welcome Admin!";
    }
}

ğŸ‘‰ Enable method-level security:
@EnableMethodSecurity // // Enables @PreAuthorize, @PostAuthorize, @Secured
@Configuration
public class MethodSecurityConfig {}
âœ”ï¸ Spring does not enable method-level security by default.
âœ”ï¸ So you need to explicitly tell Spring: â€œHey, look for method-level security annotations.â€


ğŸ”„ Password Encoding
Spring Security requires encoded passwords.
Using BCryptPasswordEncoder ensures passwords are safely hashed.

@Bean
public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
}


ğŸ”„ JDBC Authentication
â¤ Spring Security loads users and their roles from a relational database.
â¤ Instead of in-memory users, credentials (username, password, roles) are stored in tables.
â¤ Spring Security queries the DB using SQL queries or default table structures.

1ï¸âƒ£ Database Setup
Spring Security expects a user table and an authority/role table. Default schema:
ğŸ‘‰ users table
| Column   | Type    | Description      |
| -------- | ------- | ---------------- |
| username | VARCHAR | User login       |
| password | VARCHAR | Encoded password |
| enabled  | BOOLEAN | Is user active?  |

ğŸ‘‰ authorities table
| Column   | Type    | Description      |
| -------- | ------- | ---------------- |
| username | VARCHAR | User login       |
| authority| VARCHAR | User authority   |

âœ… Example SQL for H2/SQL:
CREATE TABLE users (
    username VARCHAR(50) PRIMARY KEY,
    password VARCHAR(100) NOT NULL,
    enabled BOOLEAN NOT NULL
);

CREATE TABLE authorities (
    username VARCHAR(50) NOT NULL,
    authority VARCHAR(50) NOT NULL,
    FOREIGN KEY (username) REFERENCES users(username)
);

INSERT INTO users VALUES ('ankur', '$2a$10$AqHq0Yc0p8Uov7E1dQJ6Bu4rF2EvzpYH7QvZ.3pFZ9/V36q3Yd4xi', true);
-- password=1234 (BCrypt)

INSERT INTO authorities VALUES ('ankur', 'ROLE_USER');
âš¡ Note: Passwords must be encoded (BCrypt, for example).


2ï¸âƒ£ Spring Security Configuration for JDBC Authentication

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Autowired
    private DataSource dataSource;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/public/").permitAll()
                .requestMatchers("/user/").hasRole("USER")
                .requestMatchers("/admin/").hasRole("ADMIN")
                .anyRequest().authenticated()
            )
            .formLogin(Customizer.withDefaults())
            .httpBasic(Customizer.withDefaults());
        return http.build();
    }

    @Bean
    public UserDetailsService users() {
        JdbcUserDetailsManager manager = new JdbcUserDetailsManager(dataSource);
        return manager;
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
â¤ DataSource â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Spring Boot automatically configures this if you set database properties in application.properties.

ğŸ”— application.properties:
spring.datasource.url=jdbc:mysql://localhost:3306/springsecurity
spring.datasource.username=root
spring.datasource.password=yourpassword
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.jpa.hibernate.ddl-auto=none

â¤ JdbcUserDetailsManager â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Loads user credentials and roles from the DB.
    âœ”ï¸ Uses default queries:
        ğŸ”— SELECT username, password, enabled FROM users WHERE username = ?
        ğŸ”— SELECT username, authority FROM authorities WHERE username = ?

    âœ”ï¸ Can be customized using:
        ğŸ”— manager.setUsersByUsernameQuery("custom query");
        ğŸ”— manager.setAuthoritiesByUsernameQuery("custom query");

â¤ PasswordEncoder â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Passwords in the DB must be encoded (BCrypt recommended).
â¤ Roles â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Must start with ROLE_ if using hasRole() in SecurityFilterChain.


3ï¸âƒ£ How It Works at Runtime
â¤ User hits /login endpoint.
â¤ Spring Security uses JdbcUserDetailsManager to:
    âœ”ï¸ Query user credentials
    âœ”ï¸ Load roles/authorities
â¤ Checks password using PasswordEncoder.
â¤ If successful, user is authenticated and roles are applied for authorization.


===========
ğŸ”· OAuth2
===========
â¤ OAuth2 (Open Authorization 2.0) is a framework for authorization â€” not authentication.
â¤ It allows an app (Client) to securely access resources (like user data) from another service (Resource Server) without sharing credentials (like passwords).

âœ… Example
â¤ You click â€œLogin with Googleâ€ on Spotify:
â¤ Google authenticates you (proves your identity)
â¤ Spotify receives limited access (like your email)
â¤ You never give Spotify your Google password.
â¤ Thatâ€™s OAuth2 in action.

ğŸ”„ Key Roles in OAuth2
| Role                 | Description                               | Example               |
| ---------------------| ----------------------------------------- | --------------------- |
| Resource Owner       | The user who owns the data                | You                   |
| Client               | The app that wants access                 | Spotify               |
| Authorization Server | Issues access tokens after verifying user | Google                |
| Resource Server      | Hosts protected APIs or data              | Googleâ€™s userinfo API |


ğŸ”„ OAuth2 Grant Types (Flows)
Each â€œflowâ€ defines how tokens are issued. Spring Security supports all major ones.

| Grant Type           | Use Case                                     | Who Uses It        |
| ---------------------| -------------------------------------------- | ------------------ |
| Authorization Code   | Server-side web apps (secure, uses redirect) | Login with Google  |
| Implicit             | Deprecated (for SPAs, not secure)            | Old JS apps        |
| Password Credentials | User directly gives username/password        | Internal apps only |
| Client Credentials   | Service-to-service (no user involved)        | Microservices      |
| Refresh Token        | Used to renew access tokens                  | All apps           |

ğŸ”„ Tokens in OAuth2
| Token Type                | Purpose                           | Example                   |
| --------------------------| --------------------------------- | ------------------------- |
| Access Token              | Grants access to resource         | `ya29.a0AfH6S...`         |
| Refresh Token             | Used to get a new access token    | `1//0gLqF7L5...`          |
| ID Token (OpenID Connect) | Contains user identity info (JWT) | `eyJhbGciOiJIUzI1NiIs...` |
ğŸ‘‰ ID Token = only when OAuth2 + OpenID Connect (OIDC) used â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ gives authentication info.


ğŸ”„ OAuth2 Flow in Steps (Authorization Code Grant)
1ï¸âƒ£ User clicks â€œLogin with Googleâ€

ğŸ‘‰ Spring redirects to:
https://accounts.google.com/o/oauth2/auth?
 client_id=xyz
 &redirect_uri=http://localhost:8080/login/oauth2/code/google
 &scope=email profile
 &response_type=code


2ï¸âƒ£ Google shows consent screen
ğŸ‘‰ User grants access.


3ï¸âƒ£ Google redirects back with code
http://localhost:8080/login/oauth2/code/google?code=abc123


4ï¸âƒ£ Spring exchanges code for tokens
ğŸ‘‰ Spring Security automatically calls Google token endpoint to get:
{
 "access_token": "ya29.a0AfH6S...",
 "id_token": "eyJhbGciOiJIUzI1NiIs..."
}

Step 5ï¸âƒ£ Spring fetches user info from Google
ğŸ‘‰ User info API: https://www.googleapis.com/oauth2/v3/userinfo


6ï¸âƒ£ User authenticated
Spring Security creates a OAuth2AuthenticationToken and logs the user in.


7ï¸âƒ£ Basic Configuration in Spring Boot
Dependencies (pom.xml):

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-oauth2-client</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>


ğŸ”— application.yml
spring:
  security:
    oauth2:
      client:
        registration:
          google:
            client-id: YOUR_GOOGLE_CLIENT_ID
            client-secret: YOUR_GOOGLE_CLIENT_SECRET
            scope:
              - email
              - profile
âœ”ï¸ Spring Security auto-configures /oauth2/authorization/google and /login/oauth2/code/google.


ğŸ”„ Security Configuration
@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/", "/home").permitAll()
                .anyRequest().authenticated()
            )
            .oauth2Login(Customizer.withDefaults())  // enable login with Google
            .logout(logout -> logout
                .logoutSuccessUrl("/").permitAll()
            );
        return http.build();
    }
}
âœ”ï¸ Spring handles all redirections, token exchanges, and user info retrieval automatically.


8ï¸âƒ£ How Spring Security Manages OAuth2
When user logs in:
â¤ Spring fetches the tokens and stores them in a SecurityContext.
â¤ It creates:
    âœ”ï¸ OAuth2User â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ contains user info (email, name, picture)
    âœ”ï¸ OAuth2AuthenticationToken â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ represents logged-in session

â¤ You can access them in controller:
@GetMapping("/user")
public Map<String, Object> user(@AuthenticationPrincipal OAuth2User principal) {
    return principal.getAttributes();
}


9ï¸âƒ£ Role of OAuth2 in Microservices
In microservices, OAuth2 is often used for:
âœ… Single Sign-On (SSO) â€” one login for multiple apps.
âœ… Service-to-Service authentication (client credentials flow).
âœ… API Gateway security â€” verifying access tokens at gateway.
âœ”ï¸ Usually implemented with Keycloak, Auth0, or Spring Authorization Server.


ğŸ”„Spring Authorization Server
â¤ If you want your own Google-like login system, use:
<dependency>
    <groupId>org.springframework.security</groupId>
    <artifactId>spring-authorization-server</artifactId>
</dependency>
ğŸ‘‰ It lets you:
    âœ”ï¸ Issue JWTs
    âœ”ï¸ Manage client apps
    âœ”ï¸ Implement all OAuth2 flows
ğŸ‘‰ Used in microservices as a central auth service.


4ï¸âƒ£ OAuth2 in Microservices Architecture
Typical layout:
[Auth Server] â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ issues JWT access tokens
   â†“
[API Gateway] â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ validates JWT before forwarding
   â†“
[Microservices] â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ act as Resource Servers
ğŸ‘‰ Each microservice:
    âœ”ï¸ doesnâ€™t handle login directly
    âœ”ï¸ just validates the JWT â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ ensures scalability and central security.


ğŸ”· If want to configure OAuth with Github.com
1ï¸âƒ£ You can use the following dependency:
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-oauth2-client</artifactId>
</dependency>


2ï¸âƒ£ Register Your App on GitHub
â¤ Go to https://github.com/settings/developers
â¤ Click â€œNew OAuth Appâ€
â¤ Fill out the form:
    âœ”ï¸ Application name: SpringBoot GitHub OAuth
    âœ”ï¸ Homepage URL: http://localhost:8080
    âœ”ï¸ Authorization callback URL: http://localhost:8080/login/oauth2/code/github
        This callback URL must exactly match your Spring Boot redirect URI.
â¤ Once created, youâ€™ll get:
    âœ”ï¸ Client ID
    âœ”ï¸ Client Secret
ğŸ‘‰ Keep these safe â€” youâ€™ll use them in your application.yml.


3ï¸âƒ£ Configure application.yml
ğŸ‘‰ Create src/main/resources/application.yml and add:
spring:
  security:
    oauth2:
      client:
        registration:
          github:
            client-id: your_client_id_here
            client-secret: your_client_secret_here
            scope: user:email
            redirect-uri: "{baseUrl}/login/oauth2/code/{registrationId}"
            client-name: GitHub
            client-authentication-method: client_secret_basic
            authorization-grant-type: authorization_code
        provider:
          github:
            authorization-uri: https://github.com/login/oauth/authorize
            token-uri: https://github.com/login/oauth/access_token
            user-info-uri: https://api.github.com/user
            user-name-attribute: login
server:
  port: 8080

ğŸ‘‰ Explanation:
â¤ registration.github â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ defines the OAuth app registration (client details).
â¤ provider.github â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ defines GitHub-specific OAuth endpoints.
â¤ redirect-uri â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ must match what you registered in GitHub Developer settings.


4ï¸âƒ£ Create Security Configuration
ğŸ‘‰ Spring Boot can automatically configure OAuth2 login, but for more control, define a SecurityConfig:

package com.example.security;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/", "/login").permitAll()
                .anyRequest().authenticated()
            )
            .oauth2Login(oauth -> oauth
                .loginPage("/login")
            )
            .logout(logout -> logout
                .logoutSuccessUrl("/")
                .permitAll()
            );

        return http.build();
    }
}
ğŸ‘‰ Explanation:
âœ”ï¸ /login â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ public route for manual login.
âœ”ï¸ All other routes require authentication.
âœ”ï¸ .oauth2Login() automatically configures the OAuth2 flow.

5ï¸âƒ£ Create a Controller
package com.example.controller;

import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.core.user.OAuth2User;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;

@Controller
public class HomeController {

    @GetMapping("/")
    public String home() {
        return "index";
    }

    @GetMapping("/user")
    public String user(@AuthenticationPrincipal OAuth2User user, Model model) {
        model.addAttribute("name", user.getAttribute("name"));
        model.addAttribute("login", user.getAttribute("login"));
        model.addAttribute("avatar", user.getAttribute("avatar_url"));
        return "user";
    }
}


=====================
ğŸ”· JWT + SpringBoot
=====================
JWT (JSON Web Token) is a compact, URL-safe way to represent claims (user data or permissions) between two parties â€” typically client and server â€” in a secure and stateless way.

â¤ JWT is a string-based token.
â¤ Itâ€™s digitally signed using HMAC (symmetric) or RSA (asymmetric) algorithms.
â¤ It helps the server authenticate and authorize users without maintaining sessions.


2ï¸âƒ£ Structure of a JWT
A JWT has 3 parts, separated by dots (.):
ğŸ”— xxxxx.yyyyy.zzzzz

â¤ Header â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ metadata
â¤ Payload â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ actual user data
â¤ Signature â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ to verify integrity

âœ… Example:
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.      â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Header (Base64)
eyJzdWIiOiJhbmF1ciIsImlhdCI6MTY3NDAxMzM1NSwiZXhwIjoxNjc0MDEzNjU1fQ.  â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Payload (Base64)
OHkHac4ZsnbnT7dbDLyJo4sP0wvZ6Oey_cwe5UB0kX8  â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Signature

3ï¸âƒ£ Whatâ€™s Inside?
â¤ Header (JSON)
{
  "alg": "HS256",
  "typ": "JWT"
}

â¤ Payload (JSON)
{
  "sub": "ankur",
  "role": "ADMIN",
  "iat": 1731018800,
  "exp": 1731022400
}
| Field  | Meaning                   |
| ------ | ------------------------- |
| `sub`  | Subject (user identifier) |
| `role` | Userâ€™s role               |
| `iat`  | Issued at (timestamp)     |
| `exp`  | Expiration time           |

â¤ Signature
ğŸ‘‰ Created by signing the header + payload using a secret key:
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  secret
)


4ï¸âƒ£ Why Use JWT?
| Feature          | Explanation                                           |
| ---------------  | ----------------------------------------------------- |
| âœ… Stateless     | Server doesnâ€™t store sessions; token carries all info |
| âœ… Scalable      | Ideal for microservices and distributed systems       |
| âœ… Secure        | Signed (and optionally encrypted)                     |
| âœ… Interoperable | JSON-based, used across languages                     |

ğŸ”„ JWT Flow in Spring Boo
Hereâ€™s how JWT authentication works inside SpringBoot:

     +------------+         +-----------------+
     |   Client   |  --->   |  /login (Auth)  |
     +------------+         +-----------------+
             |                      |
             |   POST credentials   |
             |--------------------->|
             |                      |
             |   JWT issued         |
             |<---------------------|
             |                      |
             |   Send JWT in Header |
             |--------------------->|
             |   Access /api/...    |
             |                      |
ğŸ‘‰ Steps:
â¤ User sends username/password to /authenticate endpoint.
â¤ Server validates credentials.
â¤ Server creates a JWT token signed with a secret key.
â¤ Token is sent back to client.
â¤ For every next request â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ client includes JWT in the Authorization header:
    ğŸ”— Authorization: Bearer <token>
â¤ Server verifies signature â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ grants access.


6ï¸âƒ£ Implementation in Spring Boot
1ï¸âƒ£ Add Dependencies
ğŸ‘‰ Add to pom.xml:

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>

<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-api</artifactId>
    <version>0.11.5</version>
</dependency>

<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-impl</artifactId>
    <version>0.11.5</version>
    <scope>runtime</scope>
</dependency>

<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-jackson</artifactId>
    <version>0.11.5</version>
    <scope>runtime</scope>
</dependency>


2ï¸âƒ£ JWT Utility Class
import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import java.util.*;
import java.security.Key;
import org.springframework.stereotype.Component;

@Component
public class JwtUtil {
    private static final String SECRET_KEY = "mysecretkey1234567890mysecretkey";

    private Key getSigningKey() {
        return Keys.hmacShaKeyFor(SECRET_KEY.getBytes());
    }

    public String generateToken(String username) {
        return Jwts.builder()
                .setSubject(username)
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + 1000 * 60 * 60)) // 1 hour
                .signWith(getSigningKey(), SignatureAlgorithm.HS256)
                .compact();
    }

    public boolean validateToken(String token) {
        try {
            Jwts.parserBuilder().setSigningKey(getSigningKey()).build().parseClaimsJws(token);
            return true;
        } catch (JwtException ex) {
            return false;
        }
    }

    public String extractUsername(String token) {
        return Jwts.parserBuilder()
                .setSigningKey(getSigningKey())
                .build()
                .parseClaimsJws(token)
                .getBody()
                .getSubject();
    }
}

3ï¸âƒ£ Authentication Filter
import jakarta.servlet.*;
import jakarta.servlet.http.*;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import java.io.IOException;
import lombok.RequiredArgsConstructor;

@Component
@RequiredArgsConstructor
public class JwtAuthFilter extends OncePerRequestFilter {

    private final JwtUtil jwtUtil;
    private final UserDetailsService userDetailsService;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        final String authHeader = request.getHeader("Authorization");
        String username = null;
        String token = null;

        if (authHeader != null && authHeader.startsWith("Bearer ")) {
            token = authHeader.substring(7);
            username = jwtUtil.extractUsername(token);
        }

        if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {
            var userDetails = userDetailsService.loadUserByUsername(username);
            if (jwtUtil.validateToken(token)) {
                var authToken = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
                authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                SecurityContextHolder.getContext().setAuthentication(authToken);
            }
        }

        filterChain.doFilter(request, response);
    }
}

4ï¸âƒ£ Security Configuration
import org.springframework.context.annotation.*;
import org.springframework.security.authentication.*;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import lombok.RequiredArgsConstructor;

@Configuration
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final JwtAuthFilter jwtAuthFilter;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.csrf(csrf -> csrf.disable())
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/authenticate").permitAll()
                .anyRequest().authenticated()
            )
            .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);
        return http.build();
    }

    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}

5ï¸âƒ£ Authentication Controller
import org.springframework.web.bind.annotation.*;
import org.springframework.security.authentication.*;
import org.springframework.security.core.userdetails.UserDetailsService;
import lombok.RequiredArgsConstructor;

@RestController
@RequiredArgsConstructor
public class AuthController {

    private final AuthenticationManager authManager;
    private final JwtUtil jwtUtil;


    @PostMapping("/authenticate")
    public String authenticate(@RequestParam String username, @RequestParam String password) {
        authManager.authenticate(new UsernamePasswordAuthenticationToken(username, password));
        return jwtUtil.generateToken(username);
    }
}

