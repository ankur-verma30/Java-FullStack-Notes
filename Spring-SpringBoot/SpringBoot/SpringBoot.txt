==============
ğŸ”· SpringBoot
==============
â¤ SpringBoot is a framework that simplifies the development of Spring applications by providing a set of pre-configured features and tools.
â¤ SpringBoot=Spring - XML configuration.
â¤ It makes easy to create stand-alone, production-grade spring based application that you can just run.
â¤ SpringBoot is not a replacement for Spring Framework. It was developed on top of Spring Framework to provide a more simplified and efficient way to develop Spring applications.

ğŸ”„ Key Features
â¤ Auto-Configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Automatically configure Spring application based on dependencies in the classpath.
â¤ Starter Dependencies â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Predefined dependency sets (e.g., spring-boot-starter-web, spring-boot-starter-data-jpa) to reduce manual configuration.
â¤ Embedded Servers â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Comes with Tomcat, Jetty, Undertow embedded servers, so no need to deploy WAR files separately.
â¤ Production Ready â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Provides health checks, metrics, logging, and monitoring with Spring Boot Actuator.
â¤ Convention over Configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Focus more on logic, less on XML/bean configuration.


===================
ğŸ”· Spring Modules
===================
1ï¸âƒ£ Spring Core
â¤ It is the fundamental module of the Spring framework. 
â¤ It  is all about managing dependencies among the classes with loosely coupling.
â¤ It provides the basic features of the Spring framework:
    âœ”ï¸ Inversion of Control (IoC) 
    âœ”ï¸ Dependency Injection (DI).
    âœ”ï¸ Bean Life cycles
    âœ”ï¸ Bean Scopes
    âœ”ï¸ Autowiring etc..
In project we will develop serveral classes. All those classes we can catergorize into 3 types:
    ğŸ“ POJO (Plain Old Java Object) Classes: These classes will contain only properties and their getters and setters(ordinary java class).
    ğŸ“ Java Bean Classes: Any class that follows bean specification rules.
    ğŸ”„ Rules of bean specification:
        ğŸ‘‰ It should have a public no-argument constructor.
        ğŸ‘‰ Properties should be private with public getters and setters.
        ğŸ‘‰ It should be serializable (implements Serializable interface).
        âš¡ Notes: 
            1ï¸âƒ£ All Java Beans are POJOs but all POJOs are not Java Beans.
            2ï¸âƒ£ Bean classes are used to write business logic and to store and retrieve data.

    ğŸ“ Component Classes: Java class which contains business Classes logic and annotated with @Component annotation.
        ğŸ‘‰ It is a special type of bean class.
        ğŸ‘‰ It is used to define various layers of an application like Controller, Service, Repository etc..
        ğŸ‘‰ Controller classes will have logic to deal with request and response.
        ğŸ‘‰ Service classes will have business logic of out project.
        ğŸ‘‰ DAO classes will contain the logic to communicate with database.


2ï¸âƒ£ Spring Context
â¤ It is built on top of the Spring Core module.
â¤ It uses the concept of ApplicationContext which is a central interface to provide configuration for an application.
â¤ It provides support for internationalization (i18n), event propagation, resource loading, and application-layer specific contexts such as WebApplicationContext for web applications.


3ï¸âƒ£ Spring JDBC
â¤ It provides a simplified approach to interact with relational databases using JDBC (Java Database Connectivity).
â¤ It handles the creation and release of resources, which helps to avoid common errors such as forgetting to close database connections.
â¤ It provides a JdbcTemplate class that simplifies the execution of SQL queries, updates, and stored procedures.

âŒ Problems with JDBC:In java JDBC, developers often have to write a lot of boilerplate code for tasks like opening/closing connections, handling exceptions, and managing transactions. This can lead to repetitive and error-prone code. Spring JDBC addresses these issues by providing a higher-level abstraction that simplifies database interactions.


4ï¸âƒ£ Spring AOP (Aspect Oriented Programming)
â¤ It provides support for aspect-oriented programming, allowing the separation of cross-cutting concerns or secondary logic (like logging, security, and transaction management) from the main business logic.
Example: Security, Logging, Transaction, Exception Handling etc..

âŒ Problems with AOP: If we combine business logic and cross-cutting concerns in the same class, it can lead to code that is hard to read and maintain. AOP helps to separate these concerns, making the code cleaner and more modular.


5ï¸âƒ£ Spring Web MVC
â¤ It provides a set of tools for building web applications and Distributed Applications using the Model-View-Controller (MVC) architectural pattern.
    âœ”ï¸  Applications: Applications which are developed using web technologies like HTML, CSS, JavaScript etc.. and run on web browsers.For Example: Gmail, Facebook, Amazon etc..
    âœ”ï¸ Distributed Applications: Applications which are developed in a distributed environment. For Example: IRCTC communicates with MakeMyTrip, Paytm etc.. to book tickets.
â¤ It supports RESTful web services and provides features like data binding, validation, and view resolution.


6ï¸âƒ£ Spring ORM
â¤ It provides integration with popular Object-Relational Mapping (ORM) frameworks like Hibernate, JPA (Java Persistence API), and MyBatis.
â¤ It simplifies the configuration and management of ORM frameworks, allowing developers to focus on writing business logic rather than boilerplate code. 
Note: JDBC will represent data in text format whereases ORM will represent data in object format.


7ï¸âƒ£ Spring security
â¤ It provides a comprehensive security framework for Java applications, including authentication, authorization, and protection against common security threats.
â¤ It supports various authentication mechanisms, including form-based login, HTTP Basic authentication, and OAuth2.0


8ï¸âƒ£ Spring Batch
â¤ It provides support for batch processing, allowing the execution of large volumes of data in a reliable and efficient manner.
â¤ It provides features like chunk-based processing, transaction management, and job scheduling.
â¤ It simplifies the development of batch applications, making it easier to handle complex data processing tasks.


9ï¸âƒ£ Spring Test
â¤ It provides tools for testing Spring applications, including unit tests, integration tests, and end-to-end tests.
â¤ It supports various testing frameworks like JUnit, Mockito, and TestNG.


1ï¸âƒ£0ï¸âƒ£ Spring Cloud
â¤ It provides tools for building cloud-native applications, including service discovery, load balancing, and distributed configuration management.
â¤ It simplifies the development of microservices-based architectures, making it easier to build and deploy scalable and resilient applications.
â¤ It provides monitoring facilities, circuit breakers, and retry mechanisms to handle failures gracefully. 
â¤ Distributed Messaging: It supports various messaging systems like RabbitMQ, Kafka, and ActiveMQ, allowing microservices to communicate asynchronously.
â¤ Routing and Load Balancing: It provides tools for routing requests to different microservices and load balancing traffic to ensure high availability and performance.

ğŸ‘‰ Spring is a flexible framework. It will not force to use all the modules. Based on requirements we can pickup particular modules and we can use it.
ğŸ‘‰ Spring is a versatile framework(Easily it can be integerated with other frameworks).


==================================
ğŸ”· Work Flow of Spring Framework
==================================
â¤ Developer will write the code using POJO classes, Bean classes and Component classes.
â¤ Spring Container will create the objects of POJO classes, Bean classes and Component classes.

ğŸ”„ In a project multiple classes will be dependent on each other.
âœ… For Example:
â¤ Controller class is dependent on Service class.
â¤ Service class is dependent on DAO class.
â¤ DAO class is dependent on Database.

ğŸ”„ In Java one class can communicate with another class in 2 ways:
1. Inheritance(Is-A Relationship)
2. Composition or Object Reference(Has-A Relationship)


=============================================
ğŸ”· SpringBBoot Application Folder Structure
=============================================
â¤ src/main/java
â¤ src/main/resources
â¤ src/test/java
â¤ src/test/resources
â¤ target
â¤ pom.xml


===========================
ğŸ”· SpringBoot Main Method
===========================
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
â¤ It is enterpoint for boot application execution
â¤ @SpringBootApplication annotation is equal to 3 annotations:
    âœ”ï¸ @SpringBootConfiguration
    âœ”ï¸ @EnableAutoConfiguration
    âœ”ï¸ @ComponentScan
â¤ SpringBoot start class will act as a configuration class because of the @SpringBootConfiguration annotation.
â¤ @EnableAutoConfiguration annotation tells SpringBoot to auto-configure beans based on classpath dependencies.
â¤ @ComponentScan annotation scans the package (and sub-packages) of the class for components (@Component, @Service, @Repository, @Controller, etc.).

âš¡ Note:Package naming Convention will play a major role in compoenent scanning.
âœ…Example:  basePackage = com.tcs.vechiles
â¤ There should be one basePackage for all the packages, subpackages should be made inside this basePackage.
â¤ If we have multiple basePackage we have to manually tell the SpringBootApplication which package to scan by using @ComponentScan annotation and passing the array of basePackages.  


===================================
ğŸ”· SpringApplication.run() Method
===================================
â¤ It is used to start the Spring Boot application.
â¤ It takes 2 arguments:
    âœ”ï¸ Application class
    âœ”ï¸ Command-line arguments
â¤ SpringApplication.run() method takes care of configuring the embedded server and other necessary components.
â¤ It is the entry point for the Spring Boot application. This method will return reference of IOC.
â¤ It starts the Spring application context and also starts the embedded server.

âœ…Example:
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        ConfigurableApplicationContext context = SpringApplication.run(Application.class, args);
        System.out.println(context.getClass().getName());
    }
}

â¤ SpringApplication is a Predefined class and it will identify what type of application we have created based on dependencies added in pom.xml file:
    âœ”ï¸ standalone (spring-boot-starter)
        âš¡ ClassName: AnnotationConfigApplicationContext
    âœ”ï¸ web app (spring-boot-starter-web)
        âš¡ ClassName: AnnotationConfigServletWebServerApplicationContext
    âœ”ï¸ reactive-application (spring-boot-starter-webflux) etc.
        âš¡ ClassName: AnnotationConfigReactiveWebServerApplicationContext
ğŸ‘‰ If all there dependencies are added priority is given to web app.

â¤ If we want to remove the banner of the spring in application.properties file we can add:
ğŸ”— spring.main.banner-mode=off  â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ have 3 modes off, console, log

â¤ If we want to change the banner message we can add:
ğŸ”— spring.banner.image.location=classpath:banner.txt â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ will print the banner message from this file
â¤ Or we can put the banner.txt file inside the src/main/resources folder where out application.properties file is there.

URL is:  https://patorjk.com/software/taag/#p=display&f=ANSI%20Shadow&t=SpringBoot


=========================
ğŸ”· Runners In SpringBoot
=========================
â¤ When a Spring Boot application starts, sometimes you want to run custom logic â€” for example:
    âœ”ï¸ Loading initial data into the database
    âœ”ï¸ Sending a notification at startup
    âœ”ï¸ Checking configurations
    âœ”ï¸ Running background tasks
â¤ For this, Spring Boot provides two special interfaces:
ğŸ‘‰ CommandLineRunner
ğŸ‘‰ ApplicationRunner

ğŸ”„ CommandLineRunner
This interface lets you run code after the Spring context is loaded (i.e., after all beans are initialized).

âœ… Example
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

@Component
public class MyStartupRunner implements CommandLineRunner {

    @Override
    public void run(String... args) throws Exception {
        System.out.println("Application started! Running initial setup...");
        // You can call a service, load data, etc.
    }
}
â“ What happens here:
When your Spring Boot app starts,
It automatically calls the run() method after all beans are created and the application context is ready.

ğŸ”„ ApplicationRunner
This is almost identical to CommandLineRunner,
but it provides a more structured way to access application arguments via the ApplicationArguments object.

âœ… Example
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.stereotype.Component;

@Component
public class MyAppRunner implements ApplicationRunner {

    @Override
    public void run(ApplicationArguments args) throws Exception {
        System.out.println("ApplicationRunner executing...");
        if (args.containsOption("debug")) {
            System.out.println("Debug mode is enabled!");
        }
    }
}
âœ”ï¸ You can now start your app with:
java -jar myapp.jar --debug

âœ”ï¸ And it will print:
ApplicationRunner executing...
Debug mode is enabled!

ğŸ”„ Difference Between CommandLineRunner and ApplicationRunner
| Feature          | CommandLineRunner | ApplicationRunner                                         |
| ---------------- | ----------------- | --------------------------------------------------------- |
| Arguments Type   | `String... args`  | `ApplicationArguments`                                    |
| Argument Parsing | Manual            | Built-in support for options and non-option args          |
| Use Case         | Simple tasks      | When you need to access or parse command-line args easily |


ğŸ”„ Execution Order
â¤ If both CommandLineRunner and ApplicationRunner are defined, they will run in the order they are declared in the application context.
â¤ If you have multiple runners, you can control their order using the @Order annotation.

import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;
import org.springframework.boot.CommandLineRunner;

@Component
@Order(1)
public class FirstRunner implements CommandLineRunner {
    @Override
    public void run(String... args) {
        System.out.println("Runner 1 executed");
    }
}

@Component
@Order(2)
public class SecondRunner implements CommandLineRunner {
    @Override
    public void run(String... args) {
        System.out.println("Runner 2 executed");
    }
}
âœ… Output:
Runner 1 executed
Runner 2 executed

ğŸ”„ Use Cases
| Use Case                | Description                                      |
| ---------------------   | ------------------------------------------------ |
| âœ… Data Initialization | Insert default users, roles, or configurations   |
| âœ… Validation          | Check environment variables or configs           |
| âœ… Logging             | Log startup details                              |
| âœ… Integration         | Trigger background processes when the app starts |

â“ When is a Runner executed?
âœ… After the Spring ApplicationContext is fully initialized but before the application is ready to receive requests.


==================================
ğŸ”· @PostConstruct in Spring Boot
===================================
@PostConstruct is a lifecycle annotation used in Spring to execute a method after dependency injection is complete â€” but before the bean is put into service (i.e., before itâ€™s ready to handle requests).

ğŸ”„ Purpose
It is mainly used for initialization logic â€” tasks you want to run once right after the bean is created and dependencies are injected.

âœ… Example
@Component
public class DataLoader {

    @Autowired
    private UserRepository userRepository;

    @PostConstruct
    public void init() {
        System.out.println("Initializing data...");
        userRepository.save(new User("Ankur", "ankur@example.com"));
    }
}

ğŸ”„ What happens here:
    âœ”ï¸ Spring creates the DataLoader bean.
    âœ”ï¸ It injects the UserRepository dependency.
    âœ”ï¸ Then it automatically calls the init() method once.
    âœ”ï¸ This ensures your logic runs only after all beans and dependencies are ready.

â“ When is it Called?
â¤ Called after the bean is constructed and all dependencies are injected.
â¤ Runs before the @PreDestroy method (if any).
â¤ Executes only once per bean lifecycle.

ğŸ”„ Common Use Cases
âœ”ï¸  Loading initial data into the database
âœ”ï¸  Validating configuration after injection
âœ”ï¸  Establishing a connection or preloading cache
âœ”ï¸  Printing startup messages

âœ… Example with Logging and Config
@Component
public class AppStartup {

    @Value("${app.name}")
    private String appName;

    @PostConstruct
    public void onStart() {
        System.out.println("Application '" + appName + "' started successfully!");
    }
}

| Concept               | Description                                                                                       |
| --------------------- | ------------------------------------------------------------------------------------------------- |
| Annotation Source     | `jakarta.annotation.PostConstruct`                                                                |
| Runs When             | After dependency injection, before bean is used                                                   |
| Method Rules          | Must be `void`, no parameters, can throw exceptions                                               |
| Alternatives          | `InitializingBean.afterPropertiesSet()` or a custom `@EventListener(ApplicationReadyEvent.class)` |


ğŸ”„ Modern Alternative (Recommended in Spring Boot)
Instead of @PostConstruct, you can use an ApplicationListener or @EventListener(ApplicationReadyEvent.class) for cleaner startup logic:

@Component
public class StartupListener {

    @EventListener(ApplicationReadyEvent.class)
    public void onApplicationReady() {
        System.out.println("âœ… Application is fully started and ready!");
    }
}
ğŸ‘‰ This runs after the full Spring context is initialized (safer for web apps).

â“ Difference between @PostConstruct and Runners?
@PostConstruct: Runs right after bean initialization.
Runners: Run after the entire Spring context is initialized (i.e., all beans are ready).


===============================
ğŸ”· @PreDestroy in Spring Boot
===============================
â¤ @PreDestroy is a lifecycle callback annotation used to execute cleanup logic just before a Spring bean is destroyed.
â¤ Part of JSR-250 (jakarta.annotation)
â¤ Called when the Spring container is shutting down
â¤ Used to release resources gracefully
    import jakarta.annotation.PreDestroy;

ğŸ”„ When is @PreDestroy executed?
@PreDestroy method is invoked when:
    âœ”ï¸ Application is stopped
    âœ”ï¸ JVM receives SIGTERM (e.g. Ctrl + C)
    âœ”ï¸ Spring context is closed
    âœ”ï¸ Kubernetes / Docker sends termination signal
â¡ï¸ Runs before the bean is removed from memory

âœ… Example:
@Component
public class ResourceManager {

    @PreDestroy
    public void cleanup() {
        System.out.println("Releasing resources before shutdown...");
    }
}
ğŸ‘‰ Execution order:
1ï¸âƒ£ Spring starts shutdown
2ï¸âƒ£ @PreDestroy method runs
3ï¸âƒ£ Bean destroyed
4ï¸âƒ£ JVM exits


ğŸ”„ Common Use Cases
â¤ Closing database connections
â¤ Stopping background threads
â¤ Shutting down executors / schedulers
â¤ Flushing logs / buffers
â¤ Releasing file handles
â¤ Graceful shutdown of Kafka / RabbitMQ consumers


ğŸ”„ Important Rules for @PreDestroy
â¤ Method must be:
    âœ”ï¸ void return type
    âœ”ï¸ No arguments
â¤ Only one @PreDestroy method per bean
â¤ Method must not throw checked exceptions
â¤ Works only for Spring-managed beans
âŒ Not called if you use new keyword
    new ResourceManager(); // @PreDestroy will NOT run

@PreDestroy ğŸ†š @PostConstruct
| Annotation       | Purpose                          |
| ---------------- | -------------------------------- |
| `@PostConstruct` | Runs **after bean creation**     |
| `@PreDestroy`    | Runs **before bean destruction** |

ğŸ”„ @PreDestroy vs DisposableBean
Using DisposableBean
@Component
public class MyBean implements DisposableBean {

    @Override
    public void destroy() {
        System.out.println("Destroy method called");
    }
}

ğŸ”„ Why @PreDestroy is better?
â¤ No interface coupling
â¤ Cleaner and more readable
â¤ Annotation-based (preferred in modern Spring)

ğŸ”„ Multiple Shutdown Hooks â€“ Execution Order
â¤ @PreDestroy
â¤ DisposableBean.destroy()
â¤ Custom destroyMethod in @Bean

ğŸ”„ @PreDestroy with @Bean
@Configuration
public class AppConfig {

    @Bean
    public ExecutorService executorService() {
        return Executors.newFixedThreadPool(5);
    }

    @PreDestroy
    public void shutdownExecutor() {
        executorService().shutdown();
    }
}

âš ï¸ Cases Where @PreDestroy is NOT called
â¤ Application crashes (kill -9)
â¤ Bean scope is prototype
â¤ JVM forcefully terminated
â¤ Bean is not managed by Spring

âœ… Real-World Example (Production)
@Component
public class KafkaConsumerManager {

    @PreDestroy
    public void shutdown() {
        kafkaConsumer.wakeup();
        kafkaConsumer.close();
    }
}

========================================================================================
ğŸ”· Properties | YAML | How to pass command line arguments in spring boot application ?
========================================================================================
1ï¸âƒ£ application.properties
In Spring Boot, you can configure values in application.properties:
server.port=8081
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=root
spring.datasource.password=1234

2ï¸âƒ£ YAML
In Spring Boot, you can configure values in application.yml:
server:
  port: 8081

spring:
  datasource:
    url: jdbc:mysql://localhost:3306/mydb
    username: root
    password: 1234
ğŸ“Œ Both properties and yml are supported by default. Spring Boot prefers application.yml if both are present.


3ï¸âƒ£ Passing Command Line Arguments
Spring Boot allows overriding configuration from the command line.

âš¡ Syntax:
ğŸ”— java -jar myapp.jar --server.port=9090 --spring.datasource.username=ankur

Here:
ğŸ”— --server.port=9090 â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ overrides server.port
ğŸ”— --spring.datasource.username=ankur â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ overrides username

4ï¸âƒ£ Accessing Values Inside Code
You can fetch values in your beans with @Value or @ConfigurationProperties.

Using @Value:
@Value("${server.port}")
private int port;

Using @ConfigurationProperties:
@Component
@ConfigurationProperties(prefix = "spring.datasource")
public class DBConfig {
    private String url;
    private String username;
    private String password;

    // getters & setters
}

==================
ğŸ”· Project Lombok
==================
â¤ Lombok is a Java library that reduces boilerplate code by using annotations.
â¤ It generates common code like getters, setters, constructors, toString, equals, hashCode, builders, etc. at compile time.
â¤ Achieved via annotation processing â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ IDE & compiler insert the code for you.

â“ Why use Lombok?
â¤ Saves time â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ no need to manually write getters/setters.
â¤ Makes code cleaner & readable.
â¤ Reduces errors in repetitive boilerplate code.

ğŸ”„ Common Lombok Annotations
âœ”ï¸ @Getter / @Setter â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Generates getters & setters.
âœ”ï¸ @ToString â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Generates toString().
âœ”ï¸ @EqualsAndHashCode â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Generates equals() & hashCode().
âœ”ï¸ @NoArgsConstructor / @AllArgsConstructor â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Generates constructors.
âœ”ï¸ @Data â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Combines @Getter, @Setter, @ToString, @EqualsAndHashCode, @RequiredArgsConstructor.
âœ”ï¸ @Builder â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Provides builder pattern.
âœ”ï¸ @Slf4j â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Provides a ready-to-use logger.

âœ… Example Without Lombok
public class Student {
    private int id;
    private String name;

    public Student() {}
    public Student(int id, String name) { this.id = id; this.name = name; }

    public int getId() { return id; }
    public void setId(int id) { this.id = id; }
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    @Override
    public String toString() { return "Student{id=" + id + ", name='" + name + "'}"; }
}

âœ… Example With Lombok
import lombok.*;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class Student {
    private int id;
    private String name;
}
âœ… Generates all boilerplate automatically (getters, setters, constructors, toString, equals, hashCode).


=========
ğŸ”· Bean 
=========
â¤ A Bean is an object that is created, managed, initialized, and destroyed by the Spring IoC Container.
â¤ In Spring Boot, most beans are created automatically using auto-configuration.

ğŸ”„ Management of Bean
Spring IoC Container
â¤ ApplicationContext (most commonly used)
â¤ Responsible for:
    âœ”ï¸ Object creation
    âœ”ï¸ Dependency Injection
    âœ”ï¸ Lifecycle management
    âœ”ï¸ Scope handling


ğŸ”„ Ways to Create Beans
1ï¸âƒ£ Using @Component (Most Common)
@Component
public class UserService {}

2ï¸âƒ£ Stereotype Annotations
| Annotation        | Use            |
| ----------------- | -------------- |
| `@Component`      | Generic        |
| `@Service`        | Business logic |
| `@Repository`     | DAO layer      |
| `@Controller`     | MVC Controller |
| `@RestController` | REST APIs      |


3ï¸âƒ£ Using @Bean (Java Config)
@Configuration
public class AppConfig {

    @Bean
    public EmailService emailService() {
        return new EmailService();
    }
}
ğŸ‘‰ Used when:
â¤ Third-party class
â¤ Need control over object creation

â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ When same object Bean is made through component and through Bean annotation inside the configuration class, Bean annotated object will be used.


==================
ğŸ”· Bean Lifecycle
==================
ğŸ”„ Bean Lifecycle Flow
1ï¸âƒ£ Bean Definition Loaded
2ï¸âƒ£ Bean Instantiation
3ï¸âƒ£ Dependency Injection
4ï¸âƒ£ Aware Interfaces
5ï¸âƒ£ BeanPostProcessor (Before Init)
6ï¸âƒ£ Initialization (@PostConstruct)
7ï¸âƒ£ BeanPostProcessor (After Init)
8ï¸âƒ£ Bean Ready for Use
9ï¸âƒ£ Container Shutdown
1ï¸âƒ£0ï¸âƒ£ Destruction (@PreDestroy)

ğŸ”„ Step-by-Step Lifecycle
1ï¸âƒ£ Bean Definition
âœ”ï¸ Spring scans classes
âœ”ï¸ Creates BeanDefinition
âœ”ï¸ Stores metadata (scope, class, dependencies)
ğŸ‘‰ Happens during context startup

2ï¸âƒ£ Bean Instantiation
Spring creates object using:
âœ”ï¸ Default constructor OR
âœ”ï¸ Parameterized constructor (DI)

@Component
public class OrderService {
    public OrderService() {
        System.out.println("Constructor called");
    }
}


3ï¸âƒ£ Dependency Injection
Dependencies injected via:
âœ”ï¸ Constructor Injection (BEST)
âœ”ï¸ Setter Injection
âœ”ï¸ Field Injection (NOT recommended)

@Component
public class PaymentService {

    private final OrderService orderService;

    public PaymentService(OrderService orderService) {
        this.orderService = orderService;
    }
}

4ï¸âƒ£ Aware Interfaces
Spring injects internal objects:
| Interface                 | Injected Object    |
| ------------------------- | ------------------ |
| `BeanNameAware`           | Bean name          |
| `BeanFactoryAware`        | BeanFactory        |
| `ApplicationContextAware` | ApplicationContext |
@Component
public class DemoBean implements BeanNameAware {

    @Override
    public void setBeanName(String name) {
        System.out.println("Bean Name: " + name);
    }
}
ğŸ‘‰ Used rarely, but interview favorite.


5ï¸âƒ£ BeanPostProcessor (Before Init)
postProcessBeforeInitialization()

ğŸ‘‰ Used by Spring internally:
    âœ”ï¸ @Autowired
    âœ”ï¸ @Value
    âœ”ï¸ @PostConstruct
AOP proxy creation


6ï¸âƒ£ Initialization Phase (3 Ways)
1ï¸âƒ£ @PostConstruct (Recommended)
@PostConstruct
public void init() {
    System.out.println("Bean Initialized");
}

2ï¸âƒ£ InitializingBean
@Component
public class DemoBean implements InitializingBean {

    @Override
    public void afterPropertiesSet() {
        System.out.println("afterPropertiesSet()");
    }
}

3ï¸âƒ£ initMethod in @Bean
@Bean(initMethod = "start")
public Server server() {
    return new Server();
}

ğŸ‘‰ Priority Order: @PostConstruct â†’ InitializingBean â†’ initMethod


7ï¸âƒ£ BeanPostProcessor (After Init)
postProcessAfterInitialization()
ğŸ‘‰ Used for:
    âœ”ï¸ AOP proxies
    âœ”ï¸ Security
    âœ”ï¸ Transaction management

8ï¸âƒ£ Bean Ready to Use 
Bean is:
    âœ”ï¸ Fully initialized
    âœ”ï¸ Injected
    âœ”ï¸ Proxied (if required)

9ï¸âƒ£ Application Shutdown
Triggered by:
    âœ”ï¸ JVM shutdown
    âœ”ï¸ context.close()
    âœ”ï¸ SIGTERM


1ï¸âƒ£0ï¸âƒ£ Destruction Phase (3 ways )
1ï¸âƒ£ @PreDestroy (Recommended)
@PreDestroy
public void cleanup() {
    System.out.println("Bean Destroyed");
}

2ï¸âƒ£ DisposableBean
@Override
public void destroy() {}

3ï¸âƒ£ destroyMethod
@Bean(destroyMethod = "stop")
ğŸ‘‰ Order: @PreDestroy â†’ DisposableBean â†’ destroyMethod


ğŸ”„ Bean Scopes
| Scope         | Description                          |
| ------------- | ------------------------------------ |
| `singleton`   | One instance per container (DEFAULT) |
| `prototype`   | New instance every time              |
| `request`     | One per HTTP request                 |
| `session`     | One per HTTP session                 |
| `application` | One per ServletContext               |

@Scope("prototype")
@Component
public class MyBean {
}
ğŸ‘‰ Prototype beans are NOT destroyed by Spring


ğŸ”„ Lazy vs Eager Initialization
1ï¸âƒ£ Eager (Default)
Created at startup
Beans with singleton scope are eager by default

2ï¸âƒ£ Lazy
@Lazy
@Component
public class LazyBean {}
ğŸ‘‰ Improves startup time


ğŸ”„ Bean Lifecycle Diagram
Constructor
 â†“
Dependency Injection
 â†“
@PostConstruct
 â†“
BeanPostProcessor
 â†“
Business Logic
 â†“
@PreDestroy


========================================================================
ğŸ”· Two @Bean Methods Returning the Same Type in a @Configuration Class
========================================================================
Case 1ï¸âƒ£: Two @Bean Methods, SAME Return Type, DIFFERENT NAMES
@Configuration
public class AppConfig {

    @Bean
    public UserService userService1() {
        return new UserService();
    }

    @Bean
    public UserService userService2() {
        return new UserService();
    }
}

âœ… What happens?
â¤ Spring creates TWO different beans
â¤ Both are of type UserService
â¤ Bean names:
    âœ”ï¸ userService1
    âœ”ï¸ userService2
ğŸ‘‰ No conflict at creation time

âŒ Where conflict happens?
@Autowired
private UserService userService;

âŒ Spring throws: NoUniqueBeanDefinitionException
ğŸ‘‰ Because Spring finds 2 beans of same type and doesn't know which one to inject.


ğŸ”„ Fixing
1ï¸âƒ£ Use @Qualifier
@Autowired
@Qualifier("userService1")
private UserService userService;

2ï¸âƒ£ Use @Primary
@Bean
@Primary
public UserService userService1() {
    return new UserService();
}


Case 2ï¸âƒ£: Same Object Instance Returned by Two @Bean Methods
@Bean
public UserService userService1() {
    return new UserService();
}

@Bean
public UserService userService2() {
    return userService1();
}

â“ Does Spring create two objects?
âŒ NO


â“ Why?
â¤ @Configuration class is CGLIB proxied
â¤ Spring intercepts method calls
â¤ Ensures singleton behavior
âœ”ï¸ Only ONE object is created
âœ”ï¸ Both bean names point to same instance
ğŸ‘‰ This happens ONLY if class is annotated with @Configuration


Case 3ï¸âƒ£: Using @Component instead of @Configuration
@Component
public class AppConfig {

    @Bean
    public UserService userService1() {
        return new UserService();
    }

    @Bean
    public UserService userService2() {
        return userService1();
    }
}

âŒ What happens?
â¤ Spring does NOT proxy the class
â¤ userService1() is a normal method call
â¤ TWO different objects are created
âš ï¸ This is a huge trap


Case 4ï¸âƒ£: Same Bean Name (Hard Conflict)
@Bean("userService")
public UserService userService1() {
    return new UserService();
}

@Bean("userService")
public UserService userService2() {
    return new UserService();
}

âŒ Result: BeanDefinitionOverrideException
ğŸš« Application fails at startup


=========================================================================
ğŸ”· Which Dependency Injection is Better â€” Field, Setter, or Constructor?
=========================================================================
â¤ Spring supports three main types of Dependency Injection (DI):
    âœ”ï¸ Field Injection
    âœ”ï¸ Setter Injection
    âœ”ï¸ Constructor Injection

1ï¸âƒ£ Field Injection (@Autowired directly on fields)
âœ… Example:
@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;

    public void getUser() {
        System.out.println(userRepository.findAll());
    }
}
âš™ï¸ How it works:
ğŸ‘‰ Spring uses reflection to set the dependency field directly, even if itâ€™s private.

âš ï¸ Disadvantages:
âŒ Not testable easily â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ canâ€™t inject mock dependencies manually for unit testing.
âŒ Hidden dependencies â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ dependencies arenâ€™t visible in the constructor.
âŒ No immutability â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ dependencies canâ€™t be declared final.
âŒ Difficult for mandatory dependencies â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Spring doesnâ€™t enforce that the field must be set.

ğŸ‘‰ Field injection is considered the worst practice for maintainable and testable code.


2ï¸âƒ£ Setter Injection
âœ… Example:
@Service
public class UserService {

    private UserRepository userRepository;

    @Autowired
    public void setUserRepository(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public void getUser() {
        System.out.println(userRepository.findAll());
    }
}

âœ… Advantages:
â¤ Allows optional dependencies (useful if bean might not always be required).
â¤ Makes it easier to change dependencies later.

âš ï¸ Disadvantages:
â¤ Not suitable for mandatory dependencies.
â¤ Object can be created without a dependency, which can lead to NullPointerException.
â¤ Still not fully immutable.

3ï¸âƒ£ Constructor Injection (Recommended âœ…)
âœ… Example:
@Service
public class UserService {

    private final UserRepository userRepository;

    @Autowired  â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Not required since Spring 4.3+
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public void getUser() {
        System.out.println(userRepository.findAll());
    }
}

âœ… Advantages:
ğŸ’ª Immutable dependencies â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ mark fields as final.
ğŸ§  Clear dependencies â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ visible in the constructor.
ğŸ§ª Best for testing â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ easy to pass mock objects in unit tests.
ğŸ” Ensures all mandatory dependencies are available during bean creation.
ğŸ’¡ Recommended by Spring Team (and used by Spring itself internally).

â¤ From Spring Framework 4.3 onward, if a class has only one constructor, Spring automatically injects dependencies â€” no need for @Autowired.

ğŸ”„ Comparison
| Feature                    | Field Injection | Setter Injection | Constructor Injection |
| -------------------------- | --------------- | ---------------- | --------------------- |
| Visibility                 | Hidden          | Visible          | Visible               |
| Immutability               | âŒ No           | âŒ No           | âœ… Yes                |
| Testability                | âŒ Poor        | âš™ï¸ Medium        | âœ… Best               |
| Optional Dependencies      | âš™ï¸ Medium      | âœ… Yes           | âŒ No                 |
| Mandatory Dependencies     | âŒ Risky        | âš™ï¸ Medium       | âœ… Best               |
| Spring Recommendation      | âŒ No           | âš™ï¸ Sometimes    | âœ… Yes                |

â¤ Adding all 3 types of DI in one class is not a good practice. It creates confusion and makes the code hard to maintain.
â¤ Choose one type of DI per class, preferably constructor injection for better maintainability and testability.


==================================
ğŸ”· Scope vs Bean Scope in Spring
==================================
Scope defines the lifetime and visibility of an object.

In Spring:
â“ Scope answers HOW MANY objects?
â“ Scope answers HOW LONG does the object live?
â“ Scope answers WHO can access it?

ğŸ”„ Bean Scope
Bean Scope defines the lifecycle and visibility of a Spring Bean inside the IoC container.
ğŸ‘‰ It tells Spring:
    âœ”ï¸ Whether to create one instance or multiple
    âœ”ï¸ When to create it
    âœ”ï¸ When to destroy it


ğŸ”„ Default Bean Scope
âœ… singleton (DEFAULT)
@Component
public class UserService {}

âœ”ï¸ Only ONE instance per Spring container
âœ”ï¸ Shared across the entire application
âš ï¸ Not JVM-wide, only container-wide

ğŸ”„ Types of Bean Scopes in Spring Boot
1ï¸âƒ£ Singleton Scope
@Scope("singleton")
@Component
public class SingletonBean {
}

ğŸ” Characteristics
â¤ One object per container
â¤ Created at startup (eager)
â¤ Thread-safe design required

ğŸ” Use Cases
â¤ Services
â¤ Repositories
â¤ Controllers


2ï¸âƒ£ Prototype Scope
@Scope("prototype")
@Component
public class PrototypeBean {}

ğŸ” Characteristics
â¤ New object for every request
â¤ Spring manages creation only
âŒ No destruction callback

ğŸ” Use Cases
â¤ Stateful beans
â¤ Temporary objects
âš ï¸ Trap: @PreDestroy will NOT be called


3ï¸âƒ£ Request Scope (Web)
@Scope(value = WebApplicationContext.SCOPE_REQUEST)
@Component
public class RequestBean {}

ğŸ” Characteristics
â¤ One object per HTTP request
â¤ Destroyed after request ends

ğŸ” Use Cases
â¤ Request metadata
â¤ Correlation ID
â¤ Request logging

ProxyMode allows a request-scoped bean to be safely injected into a singleton bean by using a proxy object.

ğŸ”„ Why is ProxyMode Needed?
â¤ @RequestScope beans live per HTTP request
â¤ @Service / @Component beans are singleton
â¤ Singleton beans are created at startup
â¤ Request beans exist only during a request
âŒ Direct injection causes lifecycle mismatch


ğŸ”„ Solution: proxyMode
@Scope(
  value = WebApplicationContext.SCOPE_REQUEST,
  proxyMode = ScopedProxyMode.TARGET_CLASS
)
@Component
public class RequestData {
}


ğŸ”„ How It Works (Internally)
Singleton Bean
     â†“
Injected Proxy (fake object)
     â†“
Actual Request Bean (created per request)

â¤ Spring injects a proxy
â¤ Proxy finds the correct request object at runtime

ğŸ”„ Types of ProxyMode
| Mode           | Used When                       |
| -------------- | ------------------------------- |
| `TARGET_CLASS` | Class-based beans (most common) |
| `INTERFACES`   | Interface-based beans           |


4ï¸âƒ£ Session Scope (Web)
@Scope(value = WebApplicationContext.SCOPE_SESSION)
@Component
public class SessionBean {}

ğŸ” Characteristics
â¤ One object per HTTP session
â¤ Destroyed when session expires

ğŸ” Use Cases
â¤ User preferences
â¤ Login state


5ï¸âƒ£ Application Scope
@Scope(value = WebApplicationContext.SCOPE_APPLICATION)
@Component
public class AppBean {}

ğŸ” Characteristics
â¤ One object per ServletContext
â¤ Shared across sessions

ğŸ” Use Cases
â¤ Application-level caches
â¤ Configuration holders

6ï¸âƒ£ WebSocket Scope (Advanced)
@Scope("websocket")
ğŸ‘‰ Used in real-time apps


======================================
ğŸ”· @ConditionalOnProperty Annotation
======================================
â¤ A Spring Boot conditional annotation
â¤ Controls bean creation based on the presence and value of a configuration property
â¤ Bean will be registered only if the condition evaluates to TRUE

ğŸ‘‰ It is evaluated at startup time, during bean definition phase

ğŸ”„ Why does this annotation exist?
Problem it solves:
    âœ”ï¸ Enable / disable features without code changes
    âœ”ï¸ Environment-based behavior (dev / test / prod)
    âœ”ï¸ Feature toggles (turn functionality ON/OFF)

Without it:
    âœ”ï¸ Youâ€™d need if-else logic inside beans
    âœ”ï¸ Beans would still be created â†’ wasted memory
    âœ”ï¸ Hard to maintain


ğŸ”„ Where is it used?
â¤ @Configuration classes
â¤ @Bean methods
â¤ @Component classes

Mainly used in:
    âœ”ï¸ Auto-configuration
    âœ”ï¸ Feature flags
    âœ”ï¸ Third-party integrations (Kafka, Redis, Mail, etc.)


ğŸ”„ Package & Declaration
org.springframework.boot.autoconfigure.condition.ConditionalOnProperty

ğŸ”„ Basic Syntax
@ConditionalOnProperty(
    name = "feature.enabled",
    havingValue = "true"
)
ğŸ‘‰ Bean is created only if: feature.enabled=true


ğŸ”„ Attributes
1ï¸âƒ£ name (or value)
â¤ Property key to check
â¤ Mandatory
name = "app.cache.enabled"


2ï¸âƒ£ havingValue
â¤ Required value for the condition to pass
â¤ Compared as String
â¤ Optional
havingValue = "true"

âœ”ï¸ Case-sensitive
âœ”ï¸ "true" â‰  "TRUE"


3ï¸âƒ£ matchIfMissing
â¤ Default: false
â¤ If true â†’ condition passes even if property is not present
matchIfMissing = true
ğŸ‘‰ Useful for default ON behavior


4ï¸âƒ£ prefix
â¤ Common prefix for property keys
â¤ Cleaner configuration

prefix = "app.feature",
name = "enabled"

Matches: app.feature.enabled=true

ğŸ”„ All Variants of Usage
âœ… Case 1ï¸âƒ£: Property exists and matches value
@ConditionalOnProperty(name = "payment.enabled", havingValue = "true")
âœ”ï¸ Created when: payment.enabled=true


âŒ Case 2ï¸âƒ£: Property exists but value mismatch
payment.enabled=false
â¡ï¸ Bean NOT created


âŒ Case 3ï¸âƒ£: Property missing (default behavior)
matchIfMissing = false
â¡ï¸ Bean NOT created


âœ… Case 4ï¸âƒ£: Property missing but allowed
@ConditionalOnProperty(
    name = "payment.enabled",
    havingValue = "true",
    matchIfMissing = true
)
â¡ï¸ Bean created even if property missing


ğŸ”„ Applying on @Bean Method
@Bean
@ConditionalOnProperty(name = "cache.enabled", havingValue = "true")
public CacheService cacheService() {
    return new CacheService();
}
ğŸ‘‰ Only this bean is conditional
ğŸ‘‰ Other beans in config are unaffected


ğŸ”„ Applying on @Configuration Class
@Configuration
@ConditionalOnProperty(name = "kafka.enabled", havingValue = "true")
public class KafkaConfig {
}
ğŸ“Œ ALL beans inside this class become conditional


ğŸ”„ Multiple Properties Condition
@ConditionalOnProperty(
    name = {"feature.a", "feature.b"},
    havingValue = "true"
)
âœ”ï¸ BOTH must be:
feature.a=true
feature.b=true
â¡ï¸ Logical AND


ğŸ”„ What happens internally?
@ConditionalOnProperty uses: OnPropertyCondition

ğŸŒŸ Evaluation Steps:
1ï¸âƒ£ Reads Environment
2ï¸âƒ£ Checks property existence
3ï¸âƒ£ Compares string value
4ï¸âƒ£ Applies matchIfMissing
5ï¸âƒ£ Returns TRUE / FALSE
6ï¸âƒ£ BeanDefinition registered or skipped
ğŸ‘‰ Happens before bean instantiation


ğŸ”„ Property Sources Checked
Spring checks properties in this order:
1ï¸âƒ£ Command-line arguments
2ï¸âƒ£ application.properties
3ï¸âƒ£ application.yml
4ï¸âƒ£ OS environment variables
5ï¸âƒ£ JVM system properties


ğŸ”„ Difference: @Value vs @ConditionalOnProperty
| Aspect        | `@Value`     | `@ConditionalOnProperty` |
| ------------- | ------------ | ------------------------ |
| Purpose       | Inject value | Control bean creation    |
| Bean created? | Always       | Conditional              |
| Runtime logic | Yes          | No                       |
| Memory usage  | More         | Optimized                |


ğŸ”„ Real-World Use Cases
1ï¸âƒ£ Enable Kafka only in prod
kafka.enabled=true

2ï¸âƒ£ Toggle new feature rollout
feature.new-dashboard=true

3ï¸âƒ£ Conditional Email Service
mail.enabled=false


ğŸ”„ Common Traps âš ï¸
âŒ Trap 1ï¸âƒ£: Case sensitivity
feature.enabled=TRUE âŒ

âŒ Trap 2ï¸âƒ£: Property missing unexpectedly
Forgot matchIfMissing=true

âŒ Trap 3ï¸âƒ£: Using with @ComponentScan
Condition applies after scanning, not during scanning


ğŸ”„ When NOT to use it
â¤ Runtime decision making
â¤ Per-request logic
â¤ User-based conditions
ğŸ‘‰ Itâ€™s startup-time only


ğŸ”„ Best Practices âœ…
â¤ Use clear property names
â¤ Combine with @Configuration
â¤ Avoid complex conditions
â¤ Document default behavior
â¤ Prefer matchIfMissing carefully


==========================================
ğŸ”· @Component vs @Service in Spring Boot
==========================================
â¤ Both @Component and @Service are annotations used in Spring to define beans, but they serve different purposes and convey different semantics.
| Annotation   | Description                                                                                                     |
| ------------ | --------------------------------------------------------------------------------------------------------------- |
| `@Component` | Generic stereotype annotation that marks a class as a Spring-managed bean.                                      |
| `@Service`   | A specialized type of `@Component used to mark classes that hold business logic or service-layer code.          |

ğŸ”„ What They Do Internally
âœ… Both @Component and @Service
â¤ Register the class as a bean in the Spring ApplicationContext
â¤ Enable dependency injection via @Autowired.

ğŸ‘‰ In short:
@Service = @Component + Semantic meaning (used for service/business layer)

ğŸ”„ Layer Meaning in Spring 
| Layer                | Annotation                        | Purpose                                   |
| -------------------- | --------------------------------- | ----------------------------------------- |
| Controller Layer     | `@Controller` / `@RestController` | Handles web requests (presentation layer) |
| Service Layer        | `@Service`                        | Contains business logic                   |
| Repository Layer     | `@Repository`                     | Deals with persistence (database access)  |
| Generic Bean         | `@Component`                      | Used for any other general-purpose bean   |

âœ… Example: Using @Component
@Component
public class EmailValidator {
    public boolean isValid(String email) {
        return email.contains("@");
    }
}
â¤ Registered as a Spring Bean.
â¤ Can be injected anywhere:
@Autowired
private EmailValidator validator;

âœ… Example: Using @Service
@Service
public class UserService {
    public void registerUser(User user) {
        // business logic for registration
    }
}
â¤ Also a Spring Bean.
â¤ But used to represent business logic layer.

ğŸ”„ Key Difference â€” Intent and Semantics
| Feature                               | `@Component`         | `@Service`                                             |
| ------------------------------------- | -------------------- | ------------------------------------------------------ |
| Purpose                               | Generic bean         | Business logic layer                                   |
| Spring Behavior                       | Registers bean       | Registers bean (same behavior)                         |
| Semantic Meaning                      | Can be used anywhere | Indicates service-level component                      |
| AOP (Aspect-Oriented Programming)     | No special behavior  | May be used by Spring for transactional or proxy logic |
| Readability                           | Less descriptive     | More expressive for business services                  |


======================================
ğŸ”· AOP (Aspect-Oriented Programming)
======================================
â¤ Aspect-Oriented Programming (AOP) is a programming paradigm used to separate cross-cutting concerns from business logic.
â¤ Cross-cutting concerns = logic that is required in multiple places across an application but is not part of core business logic.

Examples of cross-cutting concerns
â¤ Logging
â¤ Security / Authorization
â¤ Transaction management
â¤ Performance monitoring
â¤ Exception handling
â¤ Auditing
â¤ Caching
âš¡ Without AOP, this code gets repeated everywhere, making the application hard to maintain.

ğŸ”„ Why AOP is Needed (Problem Without AOP)
âŒ Without AOP
public void transferMoney() {
    log.info("Method started");
    checkSecurity();
    try {
        // business logic
    } catch (Exception e) {
        log.error(e);
    }
    log.info("Method ended");
}
Now imagine this in 100+ services ğŸ˜µ
â¡ï¸ Code duplication
â¡ï¸ Tight coupling
â¡ï¸ Hard to change logging/security rules

âœ… With AOP
public void transferMoney() {
    // pure business logic only
}
â¤ All logging, security, transactions are handled outside the method using AOP.

ğŸ”„ Core Purpose of AOP
âœ”ï¸ Separate business logic from infrastructure logic
âœ”ï¸ Improve code readability & maintainability
âœ”ï¸ Follow Single Responsibility Principle (SRP)
âœ”ï¸ Apply logic centrally instead of repeating
âœ”ï¸ Cleaner & more professional enterprise-level code


ğŸ”„ Key AOP Terminologies 
ğŸŒŸ Aspect
A module/class that contains cross-cutting logic.

@Aspect
@Component
public class LoggingAspect {
}

ğŸŒŸ Join Point
A point during program execution where advice can be applied.
ğŸ‘‰ In Spring AOP: Method execution only

Example:
@Around("execution(* com.app.service.*.*(..))")
public void logAround(ProceedingJoinPoint joinPoint) throws Throwable {
    System.out.println("Method started");
    Object result = joinPoint.proceed(); â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Before this line is the code that runs before the matching pointcut method execution and after this line is the code that runs after the matching pointcut method execution
    System.out.println("Method ended");
}


ğŸŒŸ Advice
Actual code that runs at a join point.
| Advice Type       | When it Runs                      |
| ----------------- | --------------------------------- |
| `@Before`         | Before method execution           |
| `@After`          | After method (success or failure) |
| `@AfterReturning` | After successful return           |
| `@AfterThrowing`  | After exception                   |
| `@Around`         | Before + After (most powerful)     |


ğŸŒŸ Pointcut
In Spring AOP, pointcuts define where an advice should be applied.
Types of Pointcuts in Spring AOP:

1ï¸âƒ£ Execution Pointcut
â¤ Matches method execution
â¤ Most commonly used in real projects

âœ”ï¸ Syntax
execution(modifiers? returnType declaringType? methodName(params))

ğŸ”„ Wildcards in Pointcut
1ï¸âƒ£ * (Single-level wildcard): Matches any one thing.
âœ”ï¸ï¸ Any return type: execution(* com.app.service.UserService.save(..))
2ï¸âƒ£ .. (Multi-level / any arguments wildcard): Matches any number of things.
âœ”ï¸ï¸ Any number of parameters: execution(* com.app.service.UserService.save(..))

âœ… Example
execution(* com.app.service.*.*(..))

âœ”ï¸ Any return type
âœ”ï¸ Any method
âœ”ï¸ Any parameters
âœ”ï¸ All classes in service package

2ï¸âƒ£ Within Pointcut
â¤ Matches all methods inside a class or package
â¤ No method-level control

âœ… Example: within(com.app.service.*)
âœ”ï¸ All methods in service package


ğŸ†š Difference from execution:
â¤ within â†’ class/package scope
â¤ execution â†’ method-level control


3ï¸âƒ£ Args Pointcut
Matches methods based on runtime argument types

âœ… Example: args(String, int)
âœ”ï¸ Methods with (String, int) parameters


4ï¸âƒ£ Annotation-based Pointcuts
1ï¸âƒ£ @annotation: Matches methods with a specific annotation
ğŸ”— @annotation(org.springframework.transaction.annotation.Transactional)

2ï¸âƒ£ @within: Matches all methods in classes annotated with a specific annotation
ğŸ”— @within(org.springframework.stereotype.Service)

3ï¸âƒ£ @target: Matches methods where the target object has an annotation
ğŸ”— @target(org.springframework.stereotype.Repository)

4ï¸âƒ£ @args: Matches any method with particular parameters and that parameter class is annotated with particular annotation
ğŸ”— @Before("@args(org.springframework.stereotype.Service)")

 
5ï¸âƒ£ This Pointcut
Matches based on proxy type
this(com.app.service.UserService)
ğŸ‘‰ Rarely used

6ï¸âƒ£ Target Pointcut
Matches based on target object type of class/interface
target(com.app.service.UserService)


ğŸ†š Difference:
â¤ this â†’ proxy object
â¤ target â†’ actual object

7ï¸âƒ£ Bean Pointcut (Spring-Specific)
Matches based on Spring bean name
bean(userService)

âš¡ Combining two pointcuts using &&(boolean and) and ||(boolean or)
âœ…Example:
ğŸ”— @Before("execution(* com.app.service.*.*(..)) && bean(userService)")
ğŸ”— @Before("execution(* com.app.service.*.*(..)) || bean(userService)")


ğŸ”„ Named Pointcut
@Pointcut("execution(* com.app.service.*.*(..))")
public void allServiceMethods() {} â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ should not have a method body 

@Before("allServiceMethods()")
public void logBefore() {
    System.out.println("Method started");
}


ğŸŒŸ Target Object
The actual business class being advised.

ğŸŒŸ Proxy
Spring creates a proxy object that wraps the target and applies AOP logic.
JDK Dynamic Proxy (Interfaces)
CGLIB Proxy (Classes)

ğŸ”„ How AOP Works Internally
When Application startup happens
        |
        |1ï¸âƒ£ â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Looks for @Aspect annotation classes
        |
        |2ï¸âƒ£ â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Parse the Pointcut Expressions
        |              |â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Done by PointcutParser.java class
        |
        |3ï¸âƒ£ â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Stored in an efficient data structure or cache after parsing
        |
        |4ï¸âƒ£ â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Looks for @Component @Service @Controller etc. annotation classes
        |
        |5ï¸âƒ£ â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ For each class if its eligible for interception based on pointcuts Expression
        |              |â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Done by AbstractAutoProxyCreator.java class
        |
        |6ï¸âƒ£ â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶1ï¸âƒ£ If yes, creates a Proxy using JDK Dynamic proxy or CGLIB(Code Generation Library) proxy
        |              2ï¸âƒ£ JDK Dynamic Proxy is used when matching class is already child of an interface then it will create a new proxy child class with injected code to execute the advice
        |              3ï¸âƒ£ CGLIB Proxy is used when matching class is the parent class so it will create a new proxy sub class with injected code to execute the advice
        |              4ï¸âƒ£ This proxy class, has code, which executes advice before the method, then method execution happens and after than advice if any.
âš¡Spring never directly calls your service method â€” it goes via a proxy.

ğŸ”„ How to Use AOP in Spring Boot
1ï¸âƒ£ Dependency (Auto included in spring-boot-starter)
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-aop</artifactId>
</dependency>

2ï¸âƒ£ Create an Aspect (Logging Example)
@Aspect
@Component
public class LoggingAspect {

    @Before("execution(* com.app.service.*.*(..))")
    public void logBefore() {
        System.out.println("Method started");
    }

    @After("execution(* com.app.service.*.*(..))")
    public void logAfter() {
        System.out.println("Method ended");
    }
}

3ï¸âƒ£ Business Service (Clean Code)
@Service
public class UserService {
    public void registerUser() {
        System.out.println("Registering user...");
    }
}

ğŸ”„ @Around Advice (MOST USED IN REAL PROJECTS)
@Around("execution(* com.app.service.*.*(..))")
public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {
    long start = System.currentTimeMillis();

    Object result = joinPoint.proceed(); // call actual method

    long end = System.currentTimeMillis();
    System.out.println("Time taken: " + (end - start));

    return result;
}
âœ”ï¸ï¸ Controls method execution
âœ”ï¸ï¸ Can modify return value
âœ”ï¸ï¸ Used for performance monitoring & transactions

ğŸ”„ Real-World Use Cases of AOP
âœ… Logging
â¤ Request/Response logging
â¤ Debugging production issues

âœ… Security
@Before("@annotation(RequiresRole)")

â¤ Role-based access control
â¤ Authorization checks

âœ… Transactions
@Transactional
ğŸ‘‰ Internally implemented using AOP

âœ… Exception Handling
â¤ Centralized error logging
â¤ Consistent exception response

âœ… Auditing
â¤ Track who changed what & when
â¤ Used in banking & enterprise systems

âœ… Performance Monitoring
â¤ Measure API latency
â¤ Identify slow methods


ğŸ”„ Why We Use AOP Instead of Filters / Interceptors?
| Feature                   | AOP            | Filter        | Interceptor      |
| ------------------------- | -------------- | ------------- | ---------------- |
| Layer                     | Service/Method | Servlet       | Controller       |
| Granularity               | Method-level   | Request-level | Controller-level |
| Reusability               | Very High      | Medium        | Medium           |
| Business logic separation | âœ… Best         | âŒ             | âŒ                |


ğŸ”„ Benefits of AOP 
âœ”ï¸ï¸ No code duplication
âœ”ï¸ï¸ Clean business logic
âœ”ï¸ï¸ Centralized cross-cutting concerns
âœ”ï¸ Easy to modify behavior globally
âœ”ï¸ Better scalability
âœ”ï¸ Enterprise-ready architecture
âœ”ï¸ Improves testability


ğŸ”„ Common Interview Traps âš ï¸
âŒ AOP does NOT work on:
    âœ”ï¸ Private methods
    âœ”ï¸ Final methods
    âœ”ï¸ Internal method calls (this.method())
ğŸ‘‰  Because proxy is bypassed

ğŸ”„ When NOT to Use AOP
âŒ Simple applications
âŒ Overuse leads to debugging complexity
âŒ Logic tightly coupled to business flow


=============================================
ğŸ”· Convert Request Data Into Custom Objects
=============================================
Spring MVC can automatically bind simple types:
    âœ”ï¸ String
    âœ”ï¸ int
    âœ”ï¸ long
    âœ”ï¸ boolean
âŒ But it cannot directly convert request data into custom objects.

âŒ Example (Without PropertyEditor)
@GetMapping("/user")
public String getUser(User user) {  // âŒ how will Spring create User?
    return "ok";
}

Spring does not know: How to convert request data â†’ User object
â¡ï¸ Solution: PropertyEditor


ğŸ”„ PropertyEditor
PropertyEditor is a Spring mechanism used to convert String-based request values into custom Java objects.
ğŸ‘‰ It works during data binding phase.


ğŸ”„ Real World Scenario
Request: GET /order?product=101

ğŸ‘‰ Goal:
Convert "101" into Product object


ğŸ”„ Step-by-Step Implementation

1ï¸âƒ£ Custom Domain Object
public class Product {
    private int id;
    private String name;

    // getters & setters
}


2ï¸âƒ£ Create Custom PropertyEditor
import java.beans.PropertyEditorSupport;

public class ProductEditor extends PropertyEditorSupport {

    @Override
    public void setAsText(String text) throws IllegalArgumentException {
        int productId = Integer.parseInt(text);

        Product product = new Product();
        product.setId(productId);
        product.setName("Sample Product");

        setValue(product);
    }
}
ğŸ‘‰ Key method: setAsText(String text) â†’ conversion logic lives here

3ï¸âƒ£ Register PropertyEditor using @InitBinder
@RestController
public class OrderController {

    @InitBinder
    public void initBinder(WebDataBinder binder) {
        binder.registerCustomEditor(Product.class, new ProductEditor());
    }

    @GetMapping("/order")
    public String placeOrder(Product product) {
        return "Product ID: " + product.getId();
    }
}


ğŸ”„ How Binding Happens (Internals)
Request Parameter (String)
        â†“
PropertyEditor
        â†“
Custom Object
        â†“
Controller Parameter

Spring:
1ï¸âƒ£ Reads request param
2ï¸âƒ£ Finds registered PropertyEditor
3ï¸âƒ£ Calls setAsText()
4ï¸âƒ£ Injects converted object

âœ… Example Request: GET /order?product=101
â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Controller Receives: Product{id=101, name="Sample Product"}


ğŸ”„ Passing Custom Object using @RequestParam
@GetMapping("/order")
public String placeOrder(@RequestParam Product product) {
    return "success";
}
ğŸ‘‰ Works because PropertyEditor handles conversion


ğŸ”„ Important Rules & Traps âš ï¸
âŒ PropertyEditor is:
    âœ”ï¸ NOT thread-safe
    âœ”ï¸ Old mechanism
â¤ Scope:
    âœ”ï¸ Controller-level (via @InitBinder)
    âœ”ï¸ Global (via ControllerAdvice)


ğŸ”„ Global PropertyEditor (Best Practice)
@ControllerAdvice
public class GlobalBinder {

    @InitBinder
    public void initBinder(WebDataBinder binder) {
        binder.registerCustomEditor(Product.class, new ProductEditor());
    }
}
ğŸ‘‰ Applies to all controllers

ğŸ”„ When to Use PropertyEditor?
âœ… Legacy Spring MVC apps
âŒ New applications (use Converter)


=============
ğŸ”· Converter
=============
â¤ A Converter is a type-safe, thread-safe mechanism in Spring used to convert one object type into another.
â¤ It is part of Springâ€™s Conversion Service, and it replaces PropertyEditor in modern applications.


ğŸ”„ Converter (Problem with PropertyEditor)
| Problem in PropertyEditor | How Converter Solves     |
| ------------------------- | ---------------------    |
| âŒ Not thread-safe         | âœ… Thread-safe         |
| âŒ Controller-scoped       | âœ… Global              |
| âŒ String â†’ Object only    | âœ… Any type â†’ Any type |
| âŒ Old Java Beans API      | âœ… Spring-native       |
| âŒ Hard to test            | âœ… Easy to test        |
ğŸ‘‰ Converter is the industry standard now.


ğŸ”„ Where Converter Is Used Internally
Spring uses Converter in:
    âœ”ï¸ Controller request binding
    âœ”ï¸ @RequestParam
    âœ”ï¸ @PathVariable
    âœ”ï¸ @ModelAttribute
    âœ”ï¸ Spring Data JPA
    âœ”ï¸ Spring Security
    âœ”ï¸ WebFlux


ğŸ”„ Core Interface
public interface Converter<S, T> {
    T convert(S source);
}
âœ”ï¸ S â†’ Source type
âœ”ï¸ T â†’ Target type


ğŸ”„ Real-World Problem (Same as PropertyEditor Example)
Request: GET /order?product=101
Goal: String "101" â†’ Product object


ğŸ”„ Step-by-Step Implementation
1ï¸âƒ£ Domain Object
public class Product {
    private int id;
    private String name;

    // getters & setters
}


2ï¸âƒ£ Create Custom Converter
@Component
public class StringToProductConverter implements Converter<String, Product> {

    @Override
    public Product convert(String source) {

        int id = Integer.parseInt(source);

        Product product = new Product();
        product.setId(id);
        product.setName("Sample Product");

        return product;
    }
}
âœ”ï¸ Thread-safe
âœ”ï¸ No shared state
âœ”ï¸ Reusable everywhere


ğŸ”„ 3ï¸âƒ£ Use in Controller (Nothing Special Required)
@GetMapping("/order")
public String placeOrder(Product product) {
    return "Product ID: " + product.getId();
}
âœ”ï¸ Spring auto-detects the converter
âœ”ï¸ Automatically converts request parameter


ğŸ”„ How Conversion Happens Internally 
HTTP Request (String)
        â†“
ConversionService
        â†“
Matching Converter
        â†“
Target Object
        â†“
Controller Parameter
âœ”ï¸ Spring Boot auto-configures: FormattingConversionService


ğŸ”„ Converter vs Formatter
| Feature        | Converter          | Formatter                 |
| -------------- | ------------------ | ------------------------- |
| Direction      | Object â†’ Object    | Object â†” String           |
| Use case       | General conversion | Formatting (Date, Number) |
| Locale support | âŒ                 | âœ…                         |
| Example        | String â†’ User      | Date â†’ String             |
âœ”ï¸ Formatter is built on top of Converter


ğŸ”„ Registering Converter (When @Component Is Not Enough)
1ï¸âƒ£ Using WebMvcConfigurer
@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addFormatters(FormatterRegistry registry) {
        registry.addConverter(new StringToProductConverter());
    }
}

2ï¸âƒ£ Global Registration
âœ”ï¸ Applies to all controllers
âœ”ï¸ Clean architecture

ğŸ”„ Converter for @PathVariable
@GetMapping("/order/{product}")
public String getOrder(@PathVariable Product product) {
    return product.getName();
}
âœ”ï¸ Works automatically


ğŸ”„ Converter in Spring Data JPA
Used for:
    âœ”ï¸ Enum mapping
    âœ”ï¸ ID mapping
    âœ”ï¸ Custom types

@Converter
public class StatusConverter implements AttributeConverter<Status, String> {}
ğŸ‘‰ Different Converter interface (JPA)


ğŸ”„ Common Traps âš ï¸
âŒ Thinking Converter works only for Controller
âŒ Confusing JPA Converter with Spring Converter
âŒ Forgetting thread-safety benefit


ğŸ”„ PropertyEditor vs Converter
| Feature     | PropertyEditor | Converter |
| ----------- | -------------- | --------- |
| Thread-safe | âŒ             | âœ…       |
| Scope       | Controller     | Global    |
| Modern      | âŒ             | âœ…       |
| Recommended | âŒ             | âœ…       |


ğŸ”„ When Should You Use Converter?
âœ”ï¸ Custom object binding
âœ”ï¸ ID â†’ Entity mapping
âœ”ï¸ Clean REST APIs
âœ”ï¸ Modern Spring Boot apps


======================
ğŸ”· @Value Annotation
======================
In Spring Boot, the @Value annotation is used to inject values into fields, method parameters, or constructor arguments directly from:
âœ”ï¸ application.properties / application.yml
âœ”ï¸ Environment variables
âœ”ï¸ System properties
âœ”ï¸ Expression Language (SpEL)

ğŸ”„ Syntax
@Value("${property.key}")
private String value;
ğŸ‘‰ Spring replaces ${property.key} with the actual value from application.properties (or other sources).

âœ… Example 1: Injecting from application.properties
ğŸ”— application.properties
app.name=WeatherApp
app.version=1.0.3

ğŸ”— Java Class
@Component
public class AppConfig {
    
    @Value("${app.name}")
    private String appName;

    @Value("${app.version}")
    private String version;

    public void printDetails() {
        System.out.println(appName + " - " + version);
    }
}
âœ… Output:
WeatherApp - 1.0.3


âœ… Example 2: Default Value
If the property doesnâ€™t exist, you can provide a default value:

@Value("${app.description:Default Description}")
private String description;

âœ… Example 3: Injecting System or Environment Variables
You can directly access environment/system variables:
@Value("${JAVA_HOME}")
private String javaHome;

âœ… Example 4: Using SpEL (Spring Expression Language)
You can perform calculations or logic:
@Value("#{2 * 10}")
private int value; â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ 20

@Value("#{systemProperties['user.home']}")
private String userHome;

âœ… Example 5: Injecting Lists or Arrays
ğŸ”— application.properties

app.cities=Delhi, Mumbai, Bangalore

ğŸ”— Java Class
@Value("${app.cities}")
private List<String> cities;

ğŸ”„ When to Use @Value
â¤ For simple property injection (like strings, numbers, or constants).
â¤ When you donâ€™t need a full configuration class.

ğŸ”„ Better Alternative for Multiple Values â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ @ConfigurationProperties
For injecting multiple related properties, prefer:

@ConfigurationProperties(prefix = "app")
public class AppConfig {
    private String name;
    private String version;
    // getters & setters
}
âœ… Cleaner and easier to maintain for grouped properties.


==============================
ğŸ”· @Transactional Annotation 
===============================
â¤ @Transactional in Spring marks a method (or class) so that database operations inside it run within a single transaction.
â¤ Either all succeed (commit) or all fail (rollback).
â¤ Ensures ACID properties (Atomicity, Consistency, Isolation, Durability).

âœ…Example:
@Service
public class PaymentService {

    @Autowired
    private OrderRepository orderRepo;

    @Autowired
    private PaymentRepository paymentRepo;

    @Transactional
    public void processPayment(Order order, Payment payment) {
        orderRepo.save(order);       // Step 1
        paymentRepo.save(payment);   // Step 2

        // If any exception occurs here, both saves will rollback
    }
}
ğŸ‘‰ Without @Transactional, if orderRepo.save() succeeds but paymentRepo.save() fails, youâ€™d get inconsistent data. With @Transactional, both operations succeed or both rollback.

It can be applied at:
1ï¸âƒ£ Method Level â†’ Only that method runs in a transaction.
2ï¸âƒ£ Class Level â†’ All public methods in the class run in transactions.


ğŸ”„ Key Features
1ï¸âƒ£ Rollback Rules
â¤ By default, rolls back on unchecked exceptions (RuntimeException, Error).
â¤ Checked exceptions donâ€™t trigger rollback unless configured.

@Transactional(rollbackFor = Exception.class)
public void doWork() { ... }


ğŸ”„ Classic Read Problem
1ï¸âƒ£ Dirty Read
â¤ A transaction reads data written by another transaction that has NOT yet committed
â¤ If the other transaction rolls back, the read data becomes invalid (dirty)

âœ… Example
â¤ T1 updates balance from 100 â†’ 200 (not committed)
â¤ T2 reads balance = 200
â¤ T1 rolls back
â¤ T2 used wrong data

â— Why dangerous?
â¤ Reading uncommitted data
â¤ Breaks consistency badly


2ï¸âƒ£ Non-Repeatable Read
â¤ Same row is read twice in the same transaction
â¤ Value changes because another transaction commits an update in between

âœ… Example
â¤ T1 reads salary = 50k
â¤ T2 updates salary to 60k and commits
â¤ T1 reads salary again â†’ 60k

â— Why dangerous?
â¤ Same query returns different results
â¤ Violates consistency within a transaction


3ï¸âƒ£ Phantom Read
â¤ A transaction re-executes a range query
â¤ Another transaction inserts or deletes rows
â¤ New rows appear or disappear (phantoms)

âœ… Example
â¤ T1 reads employees with salary > 50k â†’ 5 rows
â¤ T2 inserts new employee with salary 70k
â¤ T1 runs same query again â†’ 6 rows

â— Why dangerous?
â¤ Row count changes
â¤ Happens with range queries, not single rows

2ï¸âƒ£ Isolation Levels â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ It tells, how the changes made by one transaction are visible to another transaction running in parallel
âœ”ï¸ READ_COMMITTED (default in most DBs, but depends on DB we are using).
âœ”ï¸ READ_UNCOMMITTED
âœ”ï¸ REPEATABLE_COMMITTED
âœ”ï¸ SERIALIZABLE

âœ… Example:
@Transactional(isolation = Isolation.SERIALIZABLE)


ğŸ”„ Isolation Levels vs Problems
| Isolation Level      | Dirty Read    | Non-Repeatable Read  | Phantom Read   |
| -------------------- | -----------   | -------------------  | ------------   |
| **READ UNCOMMITTED** | âŒ Possible  | âŒ Possible          | âŒ Possible   |
| **READ COMMITTED**   | âœ… Prevented | âŒ Possible          | âŒ Possible   |
| **REPEATABLE READ**  | âœ… Prevented | âœ… Prevented         | âŒ Possible   |
| **SERIALIZABLE**     | âœ… Prevented | âœ… Prevented         | âœ… Prevented  |


ğŸ”„ How Each Isolation Level Works
1ï¸âƒ£ READ UNCOMMITTED
â¤ Lowest isolation
â¤ No locks
â¤ Reads uncommitted data
âœ”ï¸ Read: No Lock acquired
âœ”ï¸ Write: No Lock acquired
ğŸ‘‰ Rarely used:
    âœ”ï¸ Only in Read Applications
ğŸ‘‰ High concurrency but unsafe


2ï¸âƒ£ READ COMMITTED
â¤ Reads only committed data put read shared lock
â¤ Prevents dirty reads
â¤ Allows data to change between reads
âœ”ï¸ Read: Shared lock acquired and released as soon as read is done
âœ”ï¸ Write: Exclusive lock acquired and keep till the end of the transaction
ğŸ‘‰ Default in:
    âœ”ï¸ PostgreSQL
    âœ”ï¸ Oracle
    âœ”ï¸ SQL Server


3ï¸âƒ£ REPEATABLE READ
â¤ Same row read multiple times â†’ same value
â¤ Uses row-level locks
â¤ New rows can still appear
âœ”ï¸ Read: Shared lock acquired and released only at the end of the transaction
âœ”ï¸ Write: Exclusive lock acquired and keep till the end of the transaction
ğŸ‘‰ Default in:
    âœ”ï¸ MySQL (InnoDB)


4ï¸âƒ£ SERIALIZABLE
â¤ Highest isolation
â¤ Transactions behave as if executed one by one
â¤ Range locks + strict locking
âœ”ï¸ Same as Repeatable Read Locking Stragegy + apply Range Lock and lock is released only at the end of the transaction
ğŸ‘‰ Safest
ğŸ‘‰ Slowest


ğŸ”„ Propagation (what happens if a method with a transaction calls another transactional method)
âœ”ï¸ REQUIRED (default) â†’ joins existing transaction or creates new one if none.
âœ”ï¸ REQUIRES_NEW â†’ always starts a new transaction.
âœ”ï¸ MANDATORY â†’ must run inside an existing  parent transaction if present else throw exception.
âœ”ï¸ SUPPORTS â†’ if parent transaction exists, joins it or execute the method without any transaction.
âœ”ï¸ NOT_SUPPORTED â†’ if parent transaction is present suspend the parent transaction and execute the method without any transaction. and resume the parent transaction or if not parent transaction is present execute the method without any transaction.
âœ”ï¸ NEVER â†’ if parent transaction is present throw exception, if not present execute the method without any transaction.

âœ… Example:
@Transactional(propagation = Propagation.REQUIRES_NEW)

4ï¸âƒ£ Read-Only Transactions
Optimizes performance for queries.

@Transactional(readOnly = true)

================================================================
ğŸ”· application.properties vs application.yml in Spring Boot
================================================================
1ï¸âƒ£ application.properties (Default format)
This is a key-value pair file.

âœ… Example:
# Server Configuration
server.port=8081

# Database Configuration
spring.datasource.url=jdbc:mysql://localhost:3306/testdb
spring.datasource.username=root
spring.datasource.password=1234

ğŸ§  Syntax Rules:
â¤ Each property is a key=value pair.
â¤ Hierarchical configs use dots (.).
â¤ Comments start with #.
â¤ Easy for simple configurations, but harder for nested data.

2ï¸âƒ£ application.yml ((Yet Another Markup Language)YAML format)
YAML is a human-readable hierarchical format (preferred for complex configs).

âœ… Example:
server:
  port: 8081

spring:
  datasource:
    url: jdbc:mysql://localhost:3306/testdb
    username: root
    password: 1234

ğŸ§  Syntax Rules:
Uses indentation (spaces, not tabs) to define hierarchy.
No = or : for nesting â€” just indentation.
Supports arrays/lists easily.

Example with list:
emails:
  - ankur@gmail.com
  - test@example.com

â¤ You can use both files together â€” Spring Boot automatically merges them.
â¤ application.properties has higher precedence than application.yml.
â¤ If the same property is defined in both, application.properties wins.

â¤ Properties files are used only in java language based projects.
â¤ YAML files can be used in any language based projects.
â¤ However, in real-world projects â€” prefer YAML (.yml) for readability & structure,


ğŸ”„ Advantages of YAML over Properties:
| Feature            | `.properties`   | `.yml`                      |
| ------------------ | -------------   | ------------------------    |
| Readability        | âŒ Average     | âœ… Excellent                |
| Hierarchical Data  | âŒ Complex     | âœ… Natural                  |
| Array/List Support | âŒ Hard        | âœ… Easy                     |
| Structure          | Flat            | Nested                      |
| Popularity         | Legacy style    | Modern Spring Boot style    |


==========================================
ğŸ”· Spring Profiles (@Profile Annotation)
==========================================
â¤ Spring Profiles allow you to activate or deactivate beans/configurations based on the current environment (like dev, test, prod).
â¤ You can control which beans load depending on the active profile.
â¤ You can create multiple versions of the same bean/class and Spring will only load the one matching the active profile.

ğŸ”„ Set Active Profile in application.properties
â¤ You can specify the active profile directly in your main configuration file:
# application.properties
spring.profiles.active=dev

â¤ This tells 
pring Boot to load all settings from application-dev.properties in addition to the default application.properties.

ğŸ”„ Create Profile-Specific Property Files
Each profile has its own file following this naming convention:
application-{profile}.properties

âœ… Example:
âœ”ï¸ application-dev.properties
server.port=8081
spring.datasource.url=jdbc:mysql://localhost:3306/devdb
spring.datasource.username=dev_user
spring.datasource.password=dev123

âœ”ï¸ application-prod.properties
server.port=8082
spring.datasource.url=jdbc:mysql://localhost:3306/proddb
spring.datasource.username=prod_user
spring.datasource.password=prod123

ğŸ”„ Activate Profile via Command Line
You can override the profile at runtime using the command line:

ğŸ”— java -jar myapp.jar --spring.profiles.active=prod
ğŸ‘‰ This overrides whatever is set in application.properties.


ğŸ”„ Using @Profile Annotation
You can annotate beans, components, or configuration classes to load only when a specific profile is active.

âœ… Example: â€” Service Classes
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Service;

@Service
@Profile("dev")
public class DevEmailService implements EmailService {
    @Override
    public void sendEmail(String msg) {
        System.out.println("DEV: Sending mock email â†’ " + msg);
    }
}

@Service
@Profile("prod")
public class ProdEmailService implements EmailService {
    @Override
    public void sendEmail(String msg) {
        System.out.println("PROD: Sending real email â†’ " + msg);
    }
}
ğŸ‘‰ If spring.profiles.active=dev, then only DevEmailService will be loaded.
ğŸ‘‰ If spring.profiles.active=prod, then only ProdEmailService will load.

ğŸ”„ Using @Profile in Configuration Classes
You can also restrict entire configuration classes:

@Configuration
@Profile("test")
public class TestDatabaseConfig {

    @Bean
    public DataSource dataSource() {
        System.out.println("Using TEST database configuration");
        return new HikariDataSource();
    }
}
So when the active profile is test, this config will be used.

ğŸ”„ Get Active Profile Programmatically
You can access the active profile from the Spring Contextâ€™s Environment.

âœ… Example:
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.stereotype.Component;

@Component
public class ActiveProfileLogger {

    @Autowired
    private ApplicationContext context;

    public void printActiveProfile() {
        String[] profiles = context.getEnvironment().getActiveProfiles();
        System.out.println("Active Profile: " + profiles[0]);
    }
}
âœ… Output:
Active Profile: dev

ğŸ”„ Use in Tests (JUnit + Profiles)
You can set a profile for tests using @ActiveProfiles:

@SpringBootTest
@ActiveProfiles("test")
public class UserServiceTest {

    @Autowired
    private ApplicationContext context;

    @Test
    void checkProfile() {
        System.out.println("Running under profile: "
            + context.getEnvironment().getActiveProfiles()[0]);
    }
}
âœ… Output:
Running under profile: test


ğŸ”„ Multiple Profiles at Once
You can activate more than one profile:
ğŸ‘‰ spring.profiles.active=dev,local
Spring will load all beans matching either dev or local.

You can also use logical negation:
@Profile("!prod")   // load this bean in all profiles except prod

ğŸ”„ Using Profiles with YAML
You can define multiple profiles within a single YAML file using ---:
server:
  port: 8080

spring:
  profiles:
    active: dev

spring:
  config:
    activate:
      on-profile: dev
server:
  port: 8081


spring:
  config:
    activate:
      on-profile: prod
server:
  port: 9090
ğŸ‘‰ Depending on which profile is active, the corresponding section will apply.


ğŸ”„ Checking Active Profile in Console (Quick Check)
In any Spring Boot class:
System.out.println(context.getEnvironment().getActiveProfiles()[0]);
ğŸ‘‰ Prints the current active profile â€” very useful for debugging or verifying environment setup.


================
ğŸ”· Spring MVC
================
Spring MVC (Model-View-Controller) is a web framework within the Spring Framework used to build web applications (both traditional and RESTful).

It follows the MVC design pattern, which separates the application into:
â¤ Model â†’ Data & Business logic
â¤ View â†’ User Interface
â¤ Controller â†’ Request handling

ğŸ§  Goal of Spring MVC
To separate concerns and make the application flexible, maintainable, and testable.

âš™ï¸ Architecture Overview
Client (Browser)
   â†“
DispatcherServlet  â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Front Controller
   â†“
HandlerMapping
   â†“
Controller
   â†“
Service / DAO(Data Access Object) / Model
   â†“
ViewResolver
   â†“
View (HTML / JSP / Thymeleaf / JSON)
   â†“
Response to Client

1ï¸âƒ£ Client sends request
â¤ A user makes a request (e.g., /patients).
â¤ The request first reaches the DispatcherServlet, the Front Controller.

2ï¸âƒ£ DispatcherServlet
â¤ Itâ€™s the central controller of the Spring MVC framework.
â¤ It delegates the request to appropriate components.
â¤ Defined in web.xml or automatically configured in Spring Boot.

3ï¸âƒ£ HandlerMapping
â¤ Determines which controller should handle the incoming request.
â¤ Uses annotations like @RequestMapping, @GetMapping, etc.

4ï¸âƒ£ Controller
Contains request-handling methods (business logic triggers).


âœ… Example:
@Controller
public class PatientController {

    @GetMapping("/patients")
    public String getPatients(Model model) {
        List<Patient> list = patientService.getAllPatients();
        model.addAttribute("patients", list);
        return "patientsView"; // logical view name
    }
}

5ï¸âƒ£ Model
â¤ Represents data that will be displayed in the view.
â¤ Often filled by the controller (via Model, ModelMap, or ModelAndView).

6ï¸âƒ£ ViewResolver
Resolves the logical view name (like "patientsView") to an actual view (e.g., patientsView.jsp or patients.html).

âœ… Common examples:
InternalResourceViewResolver â†’ JSP
ThymeleafViewResolver â†’ HTML template

7ï¸âƒ£ View
â¤ The actual UI component (e.g., JSP, Thymeleaf, React frontend, etc.)
â¤ Displays the model data and sends the final HTML (or JSON) to the browser.

8ï¸âƒ£ Response to Client
The generated view is returned to the DispatcherServlet, which sends it back as an HTTP response.

ğŸŒŸ Client can send data to server in three ways:
1ï¸âƒ£ Query Parameters (?key=value)
â¤ Data is sent in the URL after a ?, as key-value pairs.
â¤ Often used for filtering, searching, or optional parameters.
â¤ Query parameters are only present at the end of the url.
â¤ Query parameters are less secure as they are visible in the URL.
 
âœ… Example URL:
GET /patients?age=30&gender=male

âœ… Example:
@GetMapping("/patients")
public List<Patient> getPatients(
        @RequestParam int age,
        @RequestParam String gender) {
    return patientService.getByAgeAndGender(age, gender);
}
â¤ Use @RequestParam annotation.
â¤ Works only with GET or DELETE (not ideal for POST).
â¤ Data visible in URL (less secure).
â¤ Great for filtering/sorting/pagination.

2ï¸âƒ£ Path Parameters (Dynamic Part of URL)
â¤ Data is part of the URI path itself.
â¤ Used to identify a specific resource.
â¤ Path parameters can be present anywhere in the url.

âœ… Example URL:
GET /patients/101

âœ… Example:
@GetMapping("/patients/{id}")
public Patient getPatientById(@PathVariable Long id) {
    return patientService.getPatient(id);
}
â¤ Use @PathVariable annotation.
â¤ Used for resource identification (like ID, username, etc.).
â¤ RESTful & clean URLs.
â¤ More semantic than query params for IDs.

3ï¸âƒ£ Request Body
â¤ Data is sent inside the HTTP request body, not in the URL.
â¤ Used to send complex objects, JSON, or large data (e.g., user info, forms).

âœ… Example Request:
POST /patients
Content-Type: application/json
{
  "name": "Ankur Verma",
  "age": 25,
  "gender": "Male"
}

âœ… Example:
@PostMapping("/patients")
public Patient createPatient(@RequestBody Patient patient) {
    return patientService.save(patient);
}
â¤ Use @RequestBody annotation.
â¤ Works with POST, PUT, PATCH.
â¤ Ideal for sending JSON/XML payloads.
â¤ Must set appropriate Content-Type (e.g., application/json).

Spring Web MVC module provide Form Tag library to simplify form handling.
<form:form/>
<form:input/>
<form:errors/>
<form:label/>
<form:select/>
<form:password/>

âœ…Example:

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
    <h2>Login Here...</h2>
    <form action="login" method="post">
        <label>Email: </label> <input type="text" name="email" /> <br /> <label>Password:
        </label> <input type="password" name="password" /> <br /> <input
            type="submit" value="login" />
    </form>
</body>
</html>


===============
ğŸ”· H2 database
===============
H2 Database is a lightweight, fast, open-source relational database written in Java. Itâ€™s often used for development, testing, and small-scale production applications, especially when you donâ€™t want to set up a full external database like MySQL or PostgreSQL.

âš™ï¸ Key Features
â¤ -memory & file-based modes:
    âœ”ï¸ In-memory mode: Data is stored in RAM (deleted when app stops).
    âœ”ï¸ File-based mode: Data is stored on disk (persistent).
â¤ Pure Java: Runs anywhere Java runs.
â¤ Embedded or Server mode:
    âœ”ï¸ Embedded: Runs inside your application.
    âœ”ï¸ Server: Can be accessed remotely via TCP.
â¤ Compatible with JDBC & SQL: Fully supports standard SQL syntax.
â¤ Browser-based console: Comes with an easy-to-use web UI at http://localhost:8082.

Very fast startup & execution speed.

ğŸ§© Common Use Case
â¤ In Spring Boot projects, H2 is used for:
â¤ Quickly testing your JPA or Hibernate code.
â¤ Running unit/integration tests without needing MySQL/PostgreSQL.
â¤ Prototyping new applications before connecting to a real database.


âœ… Example
application.properties

spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=
spring.h2.console.enabled=true

Now you can access the database console at: http://localhost:8080/h2-console

ğŸ—ƒï¸ Example Query
CREATE TABLE users (
  id INT AUTO_INCREMENT PRIMARY KEY,
  name VARCHAR(50),
  email VARCHAR(50)
);

INSERT INTO users (name, email) VALUES ('Ankur', 'ankur@example.com');
SELECT * FROM users;

âš¡ Advantages
â¤ Extremely lightweight and fast.
â¤ No setup required.
â¤ Ideal for testing and development.


ğŸš« Limitations
â¤ Not designed for high concurrency or large-scale production.
â¤ Data in memory mode is temporary.
â¤ Limited performance compared to enterprise DBs like PostgreSQL or MySQL. 

=======================================================
ğŸ”· @Valid Annottion and Binding result in Spring Boot
=======================================================
To enable validation in our spring project we have to add dependency:
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>

â¤ @Valid is used to trigger validation on an object (usually a request body or form input) before it reaches your controller logic.
â¤ It works with Jakarta Bean Validation (JSR-380) â€” typically using annotations like:
âœ”ï¸ @NotNull
âœ”ï¸ @NotEmpty
âœ”ï¸ @Size
âœ”ï¸ @Email
âœ”ï¸ @Min, @Max, etc.

âœ… Example: Using @Valid in a Controller
import jakarta.validation.Valid;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/users")
public class UserController {

    @PostMapping("/register")
    public String registerUser(@Valid @RequestBody User user, BindingResult result) {
        if (result.hasErrors()) {
            return "Validation failed: " + result.getAllErrors();
        }
        return "User registered successfully!";
    }
}

ğŸ§± User Entity Example
import jakarta.validation.constraints.*;

public class User {

    @NotEmpty(message = "Name cannot be empty")
    private String name;

    @Email(message = "Invalid email format")
    private String email;

    @Min(value = 18, message = "Age must be at least 18")
    private int age;

    // Getters and Setters
}

ğŸ”„ BindingResult in Spring Boot
â¤ BindingResult is used right after the @Valid annotated object.
â¤ It captures validation errors detected during the validation process.
â¤ It must immediately follow the validated parameter in the method signature, or Spring will throw an exception.

âš ï¸ Example â€” Wrong Order (will not work)
// âŒ Incorrect
public String registerUser(BindingResult result, @Valid @RequestBody User user) { ... }


âœ… Correct Order:
public String registerUser(@Valid @RequestBody User user, BindingResult result) { ... }

ğŸ”„ What BindingResult Contains
ğŸ”— result.hasErrors() â†’ checks if there are validation errors
ğŸ”— result.getAllErrors() â†’ returns all validation messages
ğŸ”— result.getFieldErrors() â†’ returns only field-specific errors

ğŸ”„ Typical Use Case Flow
â¤ Client sends JSON data to endpoint
â¤ Spring validates it using @Valid and annotations in the DTO
â¤ If errors exist â†’ captured in BindingResult
â¤ Controller handles validation failure gracefully (instead of 400 Bad Request)

âœ… Example Output (if invalid data sent)
Request Body:
{
  "name": "",
  "email": "invalid",
  "age": 15
}

âœ… Response:
Validation failed: [Field error in object 'user' on field 'name': rejected value []; 
 message: Name cannot be empty,
 Field error in object 'user' on field 'email': rejected value [invalid]; 
 message: Invalid email format,
 Field error in object 'user' on field 'age': rejected value [15]; 
 message: Age must be at least 18]

========================================
ğŸ”· Configuring Jetty as Embedded Server
========================================
Even if you remove the spring-boot-starter-tomact-dependency from pom.xml file it will still work.
for that we have to use exclusions

<exclusions>
  <exclusion>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-tomcat</artifactId>
  </exclusion>
</exclusions>

<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-jetty</artifactId>
</dependency> 


=================================
ğŸ”· Payload and DTO in SpringBoot
=================================
â“ What is a Payload?
In Spring Boot (and in general web development), a payload is the data sent by the client (browser, Postman, frontend app) to the server in an HTTP request.
âœ… Example: When you fill a form and click Submit, all form fields (firstName, lastName, email, etc.) are sent as the payload of the HTTP request.

ğŸ”„ Types of Payload:
â¤ Form Data (like in your JSP form)
â¤ JSON/XML Payload (common in REST APIs)

ğŸ‘‰ In your example: When the user submits the registration.jsp form, this data is sent as payload:

ğŸ”— Code Block (registration.jsp)
<body>
	<h2>Register here..</h2>
	<form action="saveReg" method="post">
		<pre>
			First Name   <input type="text" name="firstName"/>
			Last Name    <input type="text" name="lastName"/>
			Email Id     <input type="text" name="email"/>
			Mobile       <input type="text" name="mobile"/>
			City         <input type="text" name="city"/>
			State        <input type="text" name="state"/>
			Pincode      <input type="text" name="pinCode"/>
			Address Line <input type="text" name="addressLine"/>
			<input type="submit" value="Save"/>
		</pre>
	</form>
	${msg}
</body>

firstName=John
lastName=Doe
email=john@gmail.com
mobile=1234567890
city=Delhi
state=Delhi
pinCode=110001
addressLine=Street 5, XYZ
ğŸ‘‰ This is the request payload.

â“ What is a DTO (Data Transfer Object)?
A DTO is a Java class created to receive, hold, and transfer the payload data between different layers of the application.

ğŸ”„ Purpose:
â¤ Prevents direct use of Entity for input/output.
â¤ Provides loose coupling between database structure and client requests.
â¤ Helps with validation, security, and clean separation of concerns.

ğŸ‘‰ In your example:
The payload (form data) is mapped to EmployeeDto.java:

public class EmployeeDto {
    private String firstName;
    private String lastName;
    private String email;
    private String mobile;

    private String city;
    private String state;
    private int pinCode;
    private String addressLine;

    // getters and setters
}
ğŸ‘‰ When the user submits the form â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Spring automatically binds request payload â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ this EmployeeDto object using @ModelAttribute.

â¤ DTO is not directly saved in DB.
â¤ Instead:
    âœ”ï¸ Employee entity stores employee-specific info.
    âœ”ï¸ Address entity stores address info.
    âœ”ï¸ BeanUtils.copyProperties() copies data from DTO â†’ Entities.


â“ Why Not Use Entity Instead of DTO?
Imagine you bound form data directly to Employee entity:

public String saveEmployee(@ModelAttribute Employee employee) { ... }

â— Problems:
1ï¸âƒ£ Tight Coupling â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ If DB schema changes, your form & API also break.
2ï¸âƒ£ Security Risk â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Someone could inject malicious values into DB-only fields (like id or roles).
3ï¸âƒ£ Validation â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ DTO can have @NotNull, @Email annotations to validate payload before saving.
4ï¸âƒ£ Different Structures â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Payload structure (form/JSON) may not exactly match DB structure. DTO solves this mismatch.


==================================
ğŸ”· Interceptor in Spring Web MVC
===================================
A Spring MVC Interceptor intercepts requests between DispatcherServlet and Controller.
An Interceptor in Spring MVC is a component that intercepts HTTP requests and responses â€” before they reach the controller and after the controller has executed.

ğŸ”— Package: org.springframework.web.servlet.HandlerInterceptor

ğŸ”„ Lifecycle Methods
preHandle()      // before controller
postHandle()     // after controller, before view
afterCompletion()// after request completion

Think of it as a middleware that can:
â¤ Pre-process requests (like checking authentication)
â¤ Post-process responses (like adding custom headers)
â¤ Handle after-completion logic (like logging or cleanup)

ğŸ”„ Typical Use Cases
â¤ Logging controller execution
â¤ Locale / Theme change
â¤ Performance monitoring
â¤ User session validation
â¤ Modifying ModelAndView

âœ… Example
public class LoggingInterceptor implements HandlerInterceptor {
    public boolean preHandle(...) {
        return true;
    }
}


ğŸ”„ Creating Custom Interceptor
import org.springframework.web.servlet.HandlerInterceptor;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

@Component
public class LoggingInterceptor implements HandlerInterceptor {

    â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Will be run before controller, if return false, next filter and controller won't be executed
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        System.out.println("â¡ï¸ Request URL: " + request.getRequestURL());
        return true; // continue to controller
    }
    
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Post will be run after success of controller execution
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, 
                           Object handler, org.springframework.web.servlet.ModelAndView modelAndView) {
        System.out.println("âœ… Controller executed successfully.");
    }

    â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Will be run after controller execution even if controller throws exception similar to finally in Java
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, 
                                Object handler, Exception ex) {
        System.out.println("ğŸ Request completed.");
    }
}


ğŸ”„ Adding Interceptors to Spring Boot
@Configuration
public class AppConfig implements WebMvcConfigurer {
    
    @Autowired
    private LoggingInterceptor loggingInterceptor;
    
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(loggingInterceptor1)
        .addPathPatterns("/**") â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Apply to these URL Patterns
        .excludePathPatterns("/static/**"); â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Exclude these URL Patterns
    }

    registry.addInterceptor(loggingInterceptor2)
    .addPathPatterns("/**")
    .excludePathPatterns("/static/**");   
}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ same sequence will be followed by all interceptors as it was added in the code 


ğŸ”„ Microservices / Spring Boot REST APIs
    âœ”ï¸ Interceptors are still used, but less often for security, because:
    âœ”ï¸ Authentication/authorization is usually handled by Spring Security filters (JWT, OAuth2).
    âœ”ï¸ Cross-cutting concerns may be handled by AOP (Aspects) or Filters.
However, interceptors are still useful for:
    âœ”ï¸ API request/response logging
    âœ”ï¸ Adding custom headers (e.g., trace ID for distributed tracing)
    âœ”ï¸ Request timing or rate-limiting hooks
    âœ”ï¸ Analytics/tracking events before controller execution

ğŸ”„ In modern alternatives (Reactive apps)
â¤ For Spring WebFlux (reactive), the equivalent concept is called a WebFilter, not an interceptor.
â¤ So if the app is reactive, youâ€™ll rarely see traditional interceptors.


============
ğŸ”· Filters
============
A Servlet Filter is part of the Servlet API and intercepts requests before they reach Spring.

ğŸ”— Package: javax.servlet.Filter

ğŸ‘‰ Runs:
    âœ”ï¸ Before DispatcherServlet
    âœ”ï¸ After response leaves Spring


ğŸ”„ Typical Use Cases
â¤ Authentication
â¤ Authorization
â¤ Request/Response logging
â¤ CORS
â¤ Compression
â¤ XSS protection


ğŸ”„ Creating Custom Filter
1ï¸âƒ£ Implement Filter Interface
import jakarta.servlet.*;

public class CustomFilter implements Filter {

    @Override
    public void init(FilterConfig filterConfig) {
        // runs once when filter is created
    }

    @Override
    public void doFilter(ServletRequest request,
                         ServletResponse response,
                         FilterChain chain)
                         throws IOException, ServletException {

        System.out.println("Request intercepted by Filter");

        â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ pass request to next filter / servlet
        chain.doFilter(request, response);

        System.out.println("Response intercepted by Filter");
    }

    @Override
    public void destroy() {
        // cleanup logic
    }
}


2ï¸âƒ£ Register Filter in Spring Boot
âœ… Option 1ï¸âƒ£: Using @Component (Simplest)
@Component
public class CustomFilter implements Filter {
}
ğŸ‘‰ Applies to all URLs


Option 2ï¸âƒ£: Using FilterRegistrationBean (Recommended)
@Configuration
public class FilterConfig {

    @Bean
    public FilterRegistrationBean<CustomFilter> customFilter() {
        FilterRegistrationBean<CustomFilter> bean = new FilterRegistrationBean<>();
        bean.setFilter(new CustomFilter());
        bean.addUrlPatterns("/api/*");
        bean.setOrder(1);
        return bean;
    }
}
âœ”ï¸ URL-based
âœ”ï¸ Order control

ğŸ”„ Authentication Filter Example (Real-World)
public class AuthFilter implements Filter {

    @Override
    public void doFilter(ServletRequest req,
                         ServletResponse res,
                         FilterChain chain)
                         throws IOException, ServletException {

        HttpServletRequest request = (HttpServletRequest) req;

        String token = request.getHeader("Authorization");

        if (token == null) {
            throw new RuntimeException("Unauthorized");
        }

        chain.doFilter(req, res);
    }
}


ğŸ”„ Filter Lifecycle Methods
â¤ init() â†’ called once
â¤ doFilter() â†’ called for every request
â¤ destroy() â†’ called when app shuts down

â¤ Order of Multiple Filters
bean.setOrder(1); // lower value = higher priority


ğŸ”„ Important Rules & Traps âš ï¸
âŒ Filter cannot access:
    âœ”ï¸ Controller method name
    âœ”ï¸ Request mapping
    âœ”ï¸ Spring beans directly (unless managed)
âŒ Filter is NOT Spring MVC specific

â¤ Filter runs even for:
    âœ”ï¸ Static resources
    âœ”ï¸ Errors
    âœ”ï¸ Non-Spring endpoints


ğŸ”„ When NOT to Use Filters
âŒ Business logic
âŒ Method-level logic
âŒ Controller-specific logic
â¡ï¸ Use Interceptor or AOP instead

===========================
ğŸ”· Filters ğŸ†š Interceptors
===========================
â¤ Both Filters and Interceptors are used to intercept requests, but they work at different layers and serve different purposes.
â¤ Filter works at Servlet container level, while Interceptor works at Spring MVC level.


ğŸ”„ Execution Flow
Client
  â†“
Filter
  â†“
DispatcherServlet â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Java class, which accepts the incoming request and process it and return the response
  â†“
Interceptor (preHandle)
  â†“
Controller
  â†“
Interceptor (postHandle)
  â†“
Interceptor (afterCompletion)
  â†“
Filter
  â†“
Client


ğŸ”„ Comparison between Filter and Interceptor
| Feature                   | Filter                           | Interceptor       |
| ------------------------- | -------------------------------- | ----------------- |
| Layer                     | Servlet container                | Spring MVC        |
| API                       | Servlet API                      | Spring Framework  |
| Executes                  | Before DispatcherServlet         | Before Controller |
| Aware of Spring Beans     | âŒ                                | âœ…                 |
| Access to Controller info | âŒ                                | âœ…                 |
| Can modify ModelAndView   | âŒ                                | âœ…                 |
| Configuration             | web.xml / FilterRegistrationBean | WebMvcConfigurer  |
| Framework dependent       | âŒ                                | âœ…                 |


ğŸ”„ Filter vs Interceptor vs AOP
| Feature               | Filter         | Interceptor | AOP                    |
| --------------------- | -------------- | ----------- | ---------------------- |
| Level                 | Request        | Controller  | Method                 |
| Scope                 | Global         | MVC         | Business logic         |
| Access to method args | âŒ              | âŒ           | âœ…                      |
| Best for              | Security, CORS | MVC logic   | Cross-cutting concerns |


ğŸ”„ Use Filter when
â¤ You want framework-independent logic
â¤ You need request preprocessing
â¤ You want to intercept all requests

ğŸ”„ Use Interceptor when
â¤ You need Spring context
â¤ You need controller-level logic
â¤ You want to access handler details

âŒ Donâ€™t use either when:
Logic is business-related â¡ï¸ Use AOP


âš ï¸ Common Traps âš ï¸
âŒ â€œInterceptor is replacement of Filterâ€
âŒ â€œFilter can access controllerâ€
âŒ â€œInterceptor works before DispatcherServletâ€


==================================
ğŸ”· Creation of Custom Annotation
===================================
A custom annotation is a user-defined metadata that provides additional information to:
    âœ”ï¸ Compiler
    âœ”ï¸ JVM
    âœ”ï¸ Frameworks (Spring, Hibernate, AOP)
ğŸ‘‰  Annotations do not contain business logic, only metadata.


ğŸ”„ Why We Create Custom Annotations?
â¤ Clean & readable code
â¤ Remove repetitive logic
â¤ Centralize cross-cutting concerns
â¤ Used with AOP, Reflection, Validation
â¤ Improve maintainability


ğŸ”„ Syntax to Create a Custom Annotation
public @interface AnnotationName {
}


ğŸ”„ Creation Step 
1ï¸âƒ£ Define the Annotation
public @interface LogExecution {}
ğŸ‘‰ This alone is not enough.

ğŸ”„ Meta-Annotations(Annotations used over annotations)
| Annotation    | Purpose                 |
| ------------- | ----------------------- |
| `@Target`     | Where it can be used    |
| `@Retention`  | Lifecycle               |
| `@Documented` | Appears in Javadoc      |
| `@Inherited`  | Inherited by subclasses |


2ï¸âƒ£ @Target â€“ Where Annotation Can Be Used
â¤ Defines where the annotation can be applied.
@Target(ElementType.METHOD)

â¤ Common ElementType values:
    âœ”ï¸ TYPE â†’ class, interface
    âœ”ï¸ METHOD â†’ methods
    âœ”ï¸ FIELD â†’ variables
    âœ”ï¸ PARAMETER â†’ method parameters
    âœ”ï¸ CONSTRUCTOR
    âœ”ï¸ ANNOTATION_TYPE


3ï¸âƒ£ @Retention â€“ How Long Annotation Exists 
@Retention(RetentionPolicy.RUNTIME)

Retention Types:
| Policy    |                                         Available At                                                     |
| --------- | ---------------------------------------------------------------------------------------------------------|
| `SOURCE`  | Compile time only, It will be discarded by compiler itself and its not even recored in .class file       |
| `CLASS`   | Will be recorded in .class file but ignored by JVM duirng runtime                                        |
| `RUNTIME` | Recorded in .class file and available at runtime (Reflection, AOP)                                       |
ğŸ‘‰ Spring & AOP need RUNTIME retention


4ï¸âƒ£ Complete Custom Annotation Example
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface LogExecution {
}


ğŸ”„ Using Custom Annotation
@Service
public class UserService {

    @LogExecution
    public void registerUser() {
        // business logic
    }
}

ğŸ”„ Important Rules for Annotation Attributes
â¤ No parameters
â¤ Return types allowed:
        âœ”ï¸ Primitive
        âœ”ï¸ String
        âœ”ï¸ Class
        âœ”ï¸ Enum
        âœ”ï¸ Annotation
        âœ”ï¸ Array of above
âŒ No null
âŒ No method body


ğŸ”„ Custom Annotation with Attributes
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface TrackTime {
    String value() default "";
    boolean enabled() default true;
}


ğŸ”„ Usage
@TrackTime(value = "User Registration", enabled = true)
public void registerUser() {
}


ğŸ”„ Reading Custom Annotation (Reflection)
Method method = UserService.class.getMethod("registerUser");

TrackTime annotation = method.getAnnotation(TrackTime.class);

System.out.println(annotation.value());


ğŸ”„ Custom Annotation with AOP (REAL PROJECT USE)
1ï¸âƒ£ Annotation
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Loggable {
}

2ï¸âƒ£ Aspect
@Aspect
@Component
public class LoggingAspect {

    @Around("@annotation(Loggable)")
    public Object log(ProceedingJoinPoint joinPoint) throws Throwable {
        System.out.println("Before method");
        Object result = joinPoint.proceed();
        System.out.println("After method");
        return result;
    }
}

3ï¸âƒ£ Usage
@Loggable
public void placeOrder() {
}
â¤ Clean
â¤ Reusable
â¤ No duplicate code

âš ï¸ Common  Traps
âŒ Forgetting @Retention(RUNTIME)
âŒ Expecting annotation to execute logic
âŒ Using annotation without processor (AOP / reflection)


ğŸ”„ Real-World Examples
â¤ @Transactional
â¤ @Cacheable
â¤ @PreAuthorize
â¤ @NotNull
â¤ @RestController
ğŸ‘‰ All are custom annotations internally.


====================
ğŸ”· Async Annotation
====================
@Async allows a method to run in a separate thread, so the caller does not wait for its completion.

âœ”ï¸ Improves performance
âœ”ï¸ Frees up request threads
âœ”ï¸ Enables background processing

ğŸ”„ Why Do We Need @Async?
âŒ Synchronous Execution (Problem)
sendEmail();   // takes 5 seconds
processOrder(); // blocked

âœ”ï¸ Request thread is blocked
âœ”ï¸ Poor scalability

âœ… Asynchronous Execution (Solution)
sendEmailAsync(); // runs in background
processOrder();  // continues immediately


ğŸ”„ How @Async Works Internally 
â¤ Spring creates a proxy for the bean
â¤ Method call intercepted
â¤ Task submitted to Executor (thread pool)
â¤ Method executes in different thread
ğŸ‘‰ Uses AOP + Proxying


ğŸ”„ Condition for @Async Annotation to work properly?
1ï¸âƒ£ Different Class â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ If @Async annotation is applied to the method within the same class, from which it is being called, then Proxy mechanism is skipped because internal methods are not intercepted
ğŸš« Self Invocation
this.asyncMethod(); // âŒ DOES NOT WORK

â“ Why?
âœ”ï¸ Proxy is bypassed
âœ”ï¸ Must be called from another bean


2ï¸âƒ£ Public Method â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Method annotated with @Async must be public. And again, AOP interception works only on public methods.
ğŸš« Private Methods
@Async
private void method() { } // âŒ
âœ”ï¸ Only public methods work

ğŸš« Final Methods
Cannot be proxied


ğŸ”„ Enabling @Async
@EnableAsync
@SpringBootApplication
public class MyApp {
}
âš ï¸ Without this, @Async will NOT work


ğŸ”„ Basic Usage
@Service
public class EmailService {

    @Async
    public void sendEmail() {
        System.out.println(Thread.currentThread().getName());
    }
}
âœ”ï¸ Runs in background thread
âœ”ï¸ Caller does not wait


ğŸ”„ Return Types of @Async Methods
1ï¸âƒ£ void (Fire-and-Forget)
@Async
public void logActivity() {
}
âœ”ï¸ No result
âœ”ï¸ Exceptions are not propagated

2ï¸âƒ£ Future<T> (Old)
@Async
public Future<String> task() {
    return new AsyncResult<>("done");
}

3ï¸âƒ£ CompletableFuture<T> (BEST PRACTICE)
@Async
public CompletableFuture<String> task() {
    return CompletableFuture.completedFuture("done");
}
âœ”ï¸ Non-blocking
âœ”ï¸ Modern
âœ”ï¸ Chainable


ğŸ”„ Exception Handling in @Async
1ï¸âƒ£ in void Methods
â¤ Exceptions thrown in void @Async methods are lost.
âœ… Solution: AsyncUncaughtExceptionHandler
1ï¸âƒ£ Async Configuration (Exception Handler Wiring)
package com.example.asyncdemo.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.AsyncConfigurer;
import org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler;
import org.springframework.beans.factory.annotation.Autowired;

@Configuration
public class AsyncConfig implements AsyncConfigurer {

    @Autowired
    private CustomAsyncExceptionHandler customAsyncExceptionHandler;

    @Override
    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
        return customAsyncExceptionHandler;
    }
}


3ï¸âƒ£ Custom Async Exception Handler
package com.example.asyncdemo.config;

import org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler;
import org.springframework.stereotype.Component;

import java.lang.reflect.Method;

@Component
public class CustomAsyncExceptionHandler implements AsyncUncaughtExceptionHandler {

    @Override
    public void handleUncaughtException(
            Throwable ex,
            Method method,
            Object... params) {

        System.out.println("âŒ Exception in @Async void method");
        System.out.println("Method Name: " + method.getName());
        System.out.println("Exception Message: " + ex.getMessage());
    }
}

4ï¸âƒ£ Async Service (VOID METHOD THROWING EXCEPTION)
package com.example.asyncdemo.service;

import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;

@Service
public class AsyncService {

    @Async
    public void processAsyncTask() {
        System.out.println("Async task started by thread: "
                + Thread.currentThread().getName());

        // âŒ Exception thrown
        throw new RuntimeException("Something went wrong in async void method");
    }
}

5ï¸âƒ£ Controller to Trigger Async Method
package com.example.asyncdemo.controller;

import com.example.asyncdemo.service.AsyncService;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class AsyncController {

    private final AsyncService asyncService;

    public AsyncController(AsyncService asyncService) {
        this.asyncService = asyncService;
    }

    @GetMapping("/start")
    public String startAsync() {
        asyncService.processAsyncTask();
        return "Async task triggered";
    }
}

6ï¸âƒ£ Expected Output
ğŸ”— When you hit: GET http://localhost:8080/start

Console Output:
Async task started by thread: SimpleAsyncTaskExecutor-1
âŒ Exception in @Async void method
Method Name: processAsyncTask
Exception Message: Something went wrong in async void method


âœ”ï¸ Exception is NOT lost
âœ”ï¸ Handled by AsyncUncaughtExceptionHandler
âœ”ï¸ Application does NOT crash

2ï¸âƒ£ in Future/CompletableFuture Methods
â¤ Exceptions are captured in the Future.
âœ… Solution: Use CompletableFuture.exceptionally()



ğŸ”„ Custom Thread Pool
âŒ Default Executor
â¤ SimpleAsyncTaskExecutor
â¤ Unlimited threads
â¤ NOT production safe
â¤ Always create a custom thread pool for real apps.


âœ… Custom Executor (Recommended)
@Bean("taskExecutor")
public Executor taskExecutor() {

    ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
    executor.setCorePoolSize(5);
    executor.setMaxPoolSize(10);
    executor.setQueueCapacity(100);
    executor.setThreadNamePrefix("Async-");
    executor.initialize();

    return executor;
}

Use Executor in @Async
@Async("taskExecutor")
public void asyncTask() {
}


ğŸ”„ @Async at Class Level
@Async
@Service
public class NotificationService {
}
âœ”ï¸ All public methods become async



ğŸ”„ @Async vs @Transactional
âš ï¸ Order matters
1ï¸âƒ£ @Async
2ï¸âƒ£ @Transactional
public void process() { }
âœ”ï¸ Transaction exists inside async thread
âŒ Transaction Context do not transfer from caller thread to new thread which got created by @Async. So if any error happens in async method transaction will not be rolled back for that caller thread.

â¤ Use Transaction inside @Async method for creating a single transactional thread.

 
ğŸ”„ Real-World Use Cases
| Use Case               | Why Async    |
| ---------------------- | ------------ |
| Email sending          | Slow IO      |
| SMS/Push notifications | Background   |
| Audit logging          | Non-critical |
| Report generation      | Long-running |
| External API calls     | Latency      |


ğŸ”„ @Async vs CompletableFuture vs WebFlux
| Feature         | @Async | CompletableFuture | WebFlux |
| --------------- | ------ | ----------------- | ------- |
| Thread-based    | âœ…     | âœ…               | âŒ      |
| Non-blocking IO | âŒ     | âŒ               | âœ…      |
| Simplicity      | High   | Medium            | Low     |


======================================
ğŸ”· Exception Handling in Spring MVC
======================================
1ï¸âƒ£ Using @ExceptionHandler (Method-Level)
Used inside a specific controller to handle exceptions thrown only by that controller.

@Controller
public class UserController {

    @GetMapping("/user/{id}")
    public String getUser(@PathVariable int id) {
        if (id <= 0)
            throw new IllegalArgumentException("Invalid ID");
        return "user";
    }

    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<String> handleInvalidId(IllegalArgumentException ex) {
        return ResponseEntity.badRequest().body(ex.getMessage());
    }
}
ğŸ“Œ Use when you want controller-specific exception handling.

2ï¸âƒ£ Using @ControllerAdvice (Global Exception Handling) or using @RestControllerAdvice
A class annotated with @ControllerAdvice applies to all controllers globally.

@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(Exception.class)
    public ResponseEntity<String> handleAll(Exception ex) {
        return ResponseEntity
                .status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body("Something went wrong: " + ex.getMessage());
    }

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<String> handleNotFound(ResourceNotFoundException ex) {
        return ResponseEntity
                .status(HttpStatus.NOT_FOUND)
                .body(ex.getMessage());
    }
}
ğŸ“Œ Best practice for production apps â€” keeps controllers clean.

3ï¸âƒ£ Using @ResponseStatus on Custom Exceptions
Attach HTTP status directly to an exception class.

@ResponseStatus(HttpStatus.NOT_FOUND)
public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String msg) {
        super(msg);
    }
}
Now if you throw new ResourceNotFoundException("User not found"),
Spring automatically returns a 404 response.

4ï¸âƒ£ Using ResponseEntityExceptionHandler (Framework-Level)
You can extend this base class to override built-in exception handling (like MethodArgumentNotValidException, HttpRequestMethodNotSupportedException, etc.).

@ControllerAdvice
public class CustomRestExceptionHandler extends ResponseEntityExceptionHandler {

    @Override
    protected ResponseEntity<Object> handleMethodArgumentNotValid(
        MethodArgumentNotValidException ex,
        HttpHeaders headers,
        HttpStatus status,
        WebRequest request) {

        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getFieldErrors().forEach(error ->
            errors.put(error.getField(), error.getDefaultMessage())
        );

        return new ResponseEntity<>(errors, HttpStatus.BAD_REQUEST);
    }
}
ğŸ“Œ Use this when you want to customize Springâ€™s built-in validation error responses.

ğŸ”„Hierarchy of Handling
If multiple exception handlers match:
    âœ”ï¸ Method-level @ExceptionHandler (highest priority)
    âœ”ï¸ @ControllerAdvice (global)
    âœ”ï¸ Default Spring error page (if not caught above)

âš¡ Example Flow
â¤ If /user/0 is requested:
    âœ”ï¸ IllegalArgumentException is thrown
    âœ”ï¸ Handled by either:
        â¤ @ExceptionHandler in UserController, OR
        â¤ global @ControllerAdvice, OR
        â¤ default Spring error JSON if none found


=================
ğŸ”· Spring Batch
=================
â¤ Spring Batch is a lightweight, robust, and scalable batch processing framework built on top of the Spring framework.
â¤ It is used for automating large-volume, repetitive, or scheduled data processing tasks â€” such as reading data from a database or file, processing it, and writing the output elsewhere.

â¤ â€œSpring Batch is used to handle large amounts of data in batch jobs â€” with features like transaction management, chunk processing, job scheduling, and restart capabilities.â€


ğŸ”„ Why We Use Spring Batch
| Purpose                    | Explanation                                                             |
| -------------------------- | ----------------------------------------------------------------------- |
| **Automation**             | Run repetitive jobs (e.g., daily report generation, data cleanup).      |
| **Bulk Processing**        | Process millions of records efficiently.                                |
| **Transaction Management** | Each chunk is processed transactionally â€” rollback if any failure.      |
| **Restart Capability**     | Resume job from where it failed.                                        |
| **Scalability**            | Supports multi-threaded and parallel processing.                        |
| **Integration**            | Works easily with Spring Boot, Spring Data, JPA, JDBC, etc.             |
| **Monitoring**             | Tracks job metadata (start time, end time, status, etc.) automatically. |


ğŸ”„ Real-World Use Cases
| Use Case                       | Example                                                |
| ------------------------------ | ------------------------------------------------------ |
| Data migration                 | Migrate records from one database to another.          |
| ETL (Extract, Transform, Load) | Extract data from CSV, transform it, and load into DB. |
| Report generation              | Generate PDF/Excel reports daily.                      |
| Log processing                 | Process and summarize server logs.                     |
| Invoice generation             | Generate bills for customers periodically.             |


ğŸ”„ Key Concepts in Spring Batch
| Concept           | Description                                                         |
| ----------------- | ------------------------------------------------------------------- |
| **Job**           | Represents the entire batch process (contains one or more steps).   |
| **Step**          | A single phase of the job â€” e.g., read â†’ process â†’ write.           |
| **ItemReader**    | Reads data (from file, DB, API, etc.).                              |
| **ItemProcessor** | Processes/transforms the data (e.g., filtering, mapping).           |
| **ItemWriter**    | Writes data to a destination (DB, file, etc.).                      |
| **JobRepository** | Stores metadata about job execution (status, start/end time, etc.). |
| **JobLauncher**   | Used to start the batch job.                                        |
| **JobParameters** | External inputs to a batch job (e.g., file path, date).             |


ğŸ”„ How Spring Batch Works (Flow Diagram)
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚         JobLauncher         â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                (launch job)
                      â†“
             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
             â”‚       Job        â”‚
             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚                   â”‚
          Step 1              Step 2
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚ ItemReader    â”‚   â”‚ ItemReader    â”‚
     â”‚ ItemProcessor â”‚   â”‚ ItemProcessor â”‚
     â”‚ ItemWriter    â”‚   â”‚ ItemWriter    â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ”„ Spring Batch Workflow in Simple Terms
â¤ JobLauncher starts the Job.
â¤ A Job consists of one or more Steps.
â¤ Each Step performs:
    âœ”ï¸ Read â†’ Process â†’ Write.
â¤ Metadata is saved in JobRepository.
â¤ If a job fails midway, you can restart from the last checkpoint.


ğŸ”„ Chunk-Oriented Processing
One of the key concepts in Spring Batch.
Data is processed in small "chunks" instead of all at once â€” improving memory efficiency.

âœ… Example:
chunk-size: 10

ğŸ‘‰ Process flow:
Read 10 items â†’ Process â†’ Write â†’ Commit Transaction â†’ Repeat

ğŸ‘‰ If something fails in that chunk, only that chunk rolls back.


ğŸ”„ Spring Batch Example
1ï¸âƒ£ Add Dependencies (Maven)
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-batch</artifactId>
</dependency>

<dependency>
    <groupId>org.hsqldb</groupId>
    <artifactId>hsqldb</artifactId>
    <scope>runtime</scope>
</dependency>


2ï¸âƒ£ Define a Batch Configuration
@Configuration
@EnableBatchProcessing
public class BatchConfig {

    @Autowired
    private JobBuilderFactory jobBuilderFactory;

    @Autowired
    private StepBuilderFactory stepBuilderFactory;

    @Bean
    public ItemReader<String> reader() {
        return new ListItemReader<>(List.of("A", "B", "C", "D"));
    }

    @Bean
    public ItemProcessor<String, String> processor() {
        return item -> item.toLowerCase(); // Convert to lowercase
    }

    @Bean
    public ItemWriter<String> writer() {
        return items -> items.forEach(System.out::println);
    }

    @Bean
    public Step step() {
        return stepBuilderFactory.get("step1")
                .<String, String>chunk(2)
                .reader(reader())
                .processor(processor())
                .writer(writer())
                .build();
    }

    @Bean
    public Job job() {
        return jobBuilderFactory.get("myJob")
                .start(step())
                .build();
    }
}


3ï¸âƒ£Run the Batch
ğŸ‘‰ You can trigger it:
â¤ Automatically at startup (default)
â¤ Programmatically using JobLauncher

@Autowired
private JobLauncher jobLauncher;

@Autowired
private Job job;

@PostConstruct
public void runJob() throws Exception {
    JobParameters params = new JobParametersBuilder()
            .addLong("time", System.currentTimeMillis())
            .toJobParameters();

    jobLauncher.run(job, params);
}


ğŸ”„ Advanced Features
| Feature                      | Description                                                  |
| ---------------------------- | ------------------------------------------------------------ |
| **Job Restartability**       | Resume job from last successful step using job metadata.     |
| **Job Scheduling**           | Combine with Spring Scheduler / Quartz to run periodically.  |
| **Parallel Steps**           | Run multiple steps in parallel threads.                      |
| **Partitioning**             | Split data into multiple partitions for parallel processing. |
| **Skip and Retry Logic**     | Skip or retry items that fail processing.                    |
| **Listeners**                | Hook into lifecycle events (before/after job or step).       |
| **Database-backed Metadata** | Stores job execution data in DB via `JobRepository`.         |


=========================
ğŸ”· Reactive Programming
=========================
Reactive Programming is a programming paradigm that focuses on asynchronous data streams and non-blocking communication.
Instead of executing tasks sequentially and blocking threads (like traditional Spring MVC), it works by reacting to events (like incoming data, user requests, or errors).

ğŸ”„ Traditional vs Reactive Thinking
| Type             | Traditional (Imperative)       | Reactive (Declarative)                 |
| ---------------- | ------------------------------ | -------------------------------------- |
| **Thread Model** | One thread per request         | Few threads handle many requests       |
| **I/O Calls**    | Blocking (waits for response)  | Non-blocking (reacts when ready)       |
| **Processing**   | Sequential                     | Event-driven & Stream-based            |
| **Example**      | Waiting for DB query to finish | Subscribes to DB result when available |

ğŸ”„ Why Reactive Programming?
Reactive programming helps when your system:
    âœ”ï¸ Handles a large number of concurrent requests (like Netflix, LinkedIn, etc.)
    âœ”ï¸ Waits a lot on I/O operations (DB, REST APIs, file reads, etc.)
    âœ”ï¸ Needs to be scalable with minimal resource usage
    âœ”ï¸ Requires streaming data processing (live dashboards, event processing)


ğŸ”„ Core Concepts of Reactive Programming 
| Concept          | Description                                    | Analogy                         |
| ---------------- | ---------------------------------------------- | ------------------------------- |
| **Publisher**    | Emits data asynchronously (like a data source) | â€œPerson who speaksâ€             |
| **Subscriber**   | Listens to data from Publisher                 | â€œPerson who listensâ€            |
| **Subscription** | Connection between Publisher & Subscriber      | â€œPhone call between two peopleâ€ |
| **Backpressure** | Mechanism to control data flow rate            | â€œListener says â€“ speak slower!â€ |

ğŸ”„ Reactive Streams Specification (4 Interfaces)
Spring implements Reactive Streams, which has four interfaces:
    âœ”ï¸ Publisher â†’ Emits data
    âœ”ï¸ Subscriber â†’ Consumes data
    âœ”ï¸ Subscription â†’ Controls data request/cancel
    âœ”ï¸ Processor â†’ Acts as both publisher and subscriber

ğŸ”„ Reactive in Spring Boot â€” The Spring WebFlux Module
Spring Boot provides Spring WebFlux â€” a reactive alternative to Spring MVC.

| Framework          | Type         | I/O Model    |
| ------------------ | ------------ | ------------ |
| **Spring MVC**     | Synchronous  | Blocking     |
| **Spring WebFlux** | Asynchronous | Non-Blocking |

ğŸ‘‰ WebFlux is built on:
â¤ Project Reactor â†’ core reactive library used internally.
â¤ Netty / Undertow â†’ non-blocking servers (instead of Tomcat).

Core Types in Project Reactor
| Type        | Description                                   | Example      |
| ----------- | --------------------------------------------- | ------------ |
| **Mono<T>** | Emits **0 or 1** item (for single responses)  | `Mono<User>` |
| **Flux<T>** | Emits **0 or many** items (for streams/lists) | `Flux<User>` |
These replace the traditional User or List<User> in reactive code.

âœ… Example: Reactive Controller
@RestController
@RequestMapping("/users")
public class UserController {

    @Autowired
    private UserService userService;

    // Returns single user (Mono)
    @GetMapping("/{id}")
    public Mono<User> getUser(@PathVariable String id) {
        return userService.findById(id);
    }

    // Returns multiple users (Flux)
    @GetMapping
    public Flux<User> getAllUsers() {
        return userService.findAll();
    }
}
âœ”ï¸ No thread blocks waiting for DB or API responses â€” results are streamed asynchronously.

ğŸ”„ Reactive Repository
When using MongoDB or R2DBC, you can use Reactive Repositories:
public interface UserRepository extends ReactiveCrudRepository<User, String> {
    Flux<User> findByAgeGreaterThan(int age);
}

âœ”ï¸ ReactiveCrudRepository replaces JpaRepository
âœ”ï¸ Returns Mono or Flux

ğŸ”„ End-to-End Reactive Flow
Client â†’ Reactive Controller â†’ Reactive Service â†’ Reactive Repository â†’ DB/External API

âœ”ï¸ Each layer returns Mono or Flux
âœ”ï¸ Execution is non-blocking
âœ”ï¸ Uses event loop threads (like Netty)

ğŸ”„ Advantages
| Advantage                         | Explanation                                                  |
| --------------------------------- | ------------------------------------------------------------ |
| ğŸš€ **High Scalability**           | Handles thousands of concurrent connections with few threads |
| âš¡ **Better Resource Utilization** | No blocking â†’ less thread overhead                           |
| ğŸ”„ **Asynchronous**               | Data flows as streams, not as fixed responses                |
| ğŸ“¡ **Streaming Data Support**     | Perfect for real-time dashboards, notifications, etc.        |
| âš™ï¸ **Resilient Systems**          | Built-in error handling and backpressure support             |

ğŸ”„Limitations / When Not to Use
â¤ When application is CPU-bound (heavy computation, not I/O waiting)
â¤ When integrating with legacy blocking APIs
â¤ Learning curve â€” debugging reactive flows can be tricky
â¤ For small, simple apps â€” traditional Spring MVC is enough


ğŸ”„ Integration with Other Modules
| Integration                      | Example                                                 |
| -------------------------------- | ------------------------------------------------------- |
| **Spring Data R2DBC**            | Reactive DB access (MySQL, PostgreSQL)                  |
| **Spring Data MongoDB Reactive** | Non-blocking Mongo queries                              |
| **Reactive Kafka**               | Consuming Kafka streams reactively                      |
| **WebClient**                    | Non-blocking HTTP client (replacement for RestTemplate) |

âœ… Example with WebClient (Reactive REST Calls)
WebClient webClient = WebClient.create("https://api.github.com");

Flux<Repository> repos = webClient.get()
        .uri("/users/ankur-verma30/repos")
        .retrieve()
        .bodyToFlux(Repository.class);

âœ”ï¸ Non-blocking HTTP call
âœ”ï¸ WebClient replaces RestTemplate

ğŸ”„ Real-world Use Cases
â¤ Live chat systems
â¤ Real-time stock tickers or dashboards
â¤ Reactive microservices communicating via WebFlux + Kafka
â¤ IoT sensor data streaming
â¤ Notification systems
 