ğŸ”· Distributed Application
A distributed application is an application where components are spread across multiple computers (nodes) connected through a network, but they work together as a single system.
â¤ They are used for Business to Business commnication unlike web applciaton communicate with Business to Client (C2B).

âš™ï¸ Key Idea:
Instead of all logic running on one server (like in a monolithic app), different parts â€” frontend, backend, databases, microservices, etc. â€” run on different machines or locations and communicate via network protocols (like HTTP, RPC, or gRPC).

âœ… Example: E-commerce Application
â¤ Frontend (React app) â†’ runs on userâ€™s browser.
â¤ Backend API (Spring Boot) â†’ runs on AWS server.
â¤ Database (MySQL) â†’ runs on a separate database server.
â¤ Payment service (third-party) â†’ hosted externally.

All these parts interact to form one working e-commerce platform â€” thatâ€™s a distributed application.

ğŸ”„ Characteristics:
â¤ Multiple independent nodes (different machines).
â¤ Communication over network (e.g., REST, gRPC).
â¤ Data sharing and synchronization between components.
â¤ Scalability â€“ you can scale specific services independently.
â¤ Fault tolerance â€“ if one node fails, others can still run.

ğŸ§± Architecture Examples:
â¤ Clientâ€“Server (basic distributed system)
â¤ 3-Tier Architecture (UI, Application Server, Database)
â¤ Microservices Architecture (each service deployed independently)
â¤ Cloud-Native Applications (services running across data centers)

ğŸ§° Technologies Used:
â¤ APIs / REST / gRPC for communication
â¤ Message Queues (Kafka, RabbitMQ) for async communication
â¤ Databases like MongoDB, Cassandra (distributed data)
â¤ Load Balancers for traffic distribution
â¤ Containers / Kubernetes for deployment

ğŸ” Another Scenario of Distributed Application
âœ…Example:MMT â†” IRCTC â€” A Real Distributed Interaction Example
â¤ Both MMT (MakeMyTrip) and IRCTC are independent distributed systems,
but they interact with each other over a network to complete a single user request.
â¤ That interaction itself makes the overall system â€” the combination of MMT + IRCTC + users â€” a larger distributed ecosystem.
â¤ MMT doesnâ€™t own the train data â€” it connects to IRCTCâ€™s distributed system through APIs.
â¤ Both systems communicate and cooperate over the internet, while users experience it as one smooth platform.
â¤ XML and JSON data will be used as mediaters to transfer data between MMT and IRCTC.


ğŸ”· Intereoperability
â¤ The term interoperability refers to the ability of two or more systems to work together, even if they are not built for the same purpose or use the same architecture.
â¤ It is a way to ensure that different systems can communicate and exchange data with each other, even if they are built using different technologies or have different interfaces.


ğŸ”· XML
XML (eXtensible Markup Language) is a markup language used to store and transport data in a structured, human-readable, and machine-readable format.

âœ… Example:
<Student>  -------------> compound eleement containing other elements
    <Name>Ankur Verma</Name>--------> simple element
    <RollNo>101</RollNo>
    <Branch>Information Technology</Branch>
</Student>
ğŸ‘‰ This stores structured data about a student â€” not for displaying (like HTML), but for data exchange.

ğŸ”„ Key Features:
â¤ Self-descriptive â€“ Tags describe the data.
â¤ Custom tags â€“ You can define your own (unlike HTMLâ€™s fixed tags).
â¤ Platform-independent â€“ Works across systems and languages.
â¤ Hierarchical structure â€“ Data stored in parentâ€“child format.
â¤ Supports validation â€“ You can define structure rules using:
â¤ DTD (Document Type Definition)
â¤ XSD (XML Schema Definition)

ğŸ”„ Common Uses:
â¤ Configuration files (e.g., web.xml in Java web apps)
â¤ Data exchange between systems (SOAP APIs, web services)
â¤ Document storage (e.g., Office files internally use XML)
â¤Serialization (saving objects in XML format)


ğŸ”· JAXB (Java Architecture for XML Binding) â€” also called JAX-B API
âœ”ï¸ JAXB is a Java API that allows you to convert Java objects into XML (marshalling) and XML back into Java objects (unmarshalling) easily.

âœ”ï¸ Itâ€™s part of the Jakarta / Java EE (formerly JAX-B) stack and simplifies XML handling in Java applications â€” no manual parsing required.

Upto Java 1.8 JAXB was part of the Java SE platform but removed from Java 1.9 version if you want to use should have a jax-b dependency.

ğŸ”„ Core Operations:
1ï¸âƒ£ Marshalling: Converts Java objects into XML.
2ï¸âƒ£ Unmarshalling: Converts XML into Java objects.
3ï¸âƒ£ Binding: Maps Java classes to XML elements and attributes.
4ï¸âƒ£ Validation: Validates XML against a schema.
5ï¸âƒ£ Schema Generation: Generates XML schemas from Java classes.

âœ… Example: 1ï¸âƒ£ Create a java class
import jakarta.xml.bind.annotation.XmlElement;
import jakarta.xml.bind.annotation.XmlRootElement;

@XmlRootElement(name = "student")
public class Student {
    private String name;
    private int rollNo;

    // Default constructor (required by JAXB)
    public Student() {}

    public Student(String name, int rollNo) {
        this.name = name;
        this.rollNo = rollNo;
    }

    @XmlElement
    public String getName() {
        return name;
    }

    @XmlElement
    public int getRollNo() {
        return rollNo;
    }
}

2ï¸âƒ£ Marshalling(Java --> XML)
import jakarta.xml.bind.JAXBContext;
import jakarta.xml.bind.Marshaller;

public class MarshallExample {
    public static void main(String[] args) throws Exception {
        Student s = new Student("Ankur Verma", 101);
        JAXBContext context = JAXBContext.newInstance(Student.class);
        Marshaller marshaller = context.createMarshaller();
        marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
        marshaller.marshal(s, System.out); // prints XML to console
    }
}
âœ… Output XML:
<student>
    <name>Ankur Verma</name>
    <rollNo>101</rollNo>
</student>

3ï¸âƒ£ Unmarshalling(XML --> Java)
import jakarta.xml.bind.Unmarshaller;
import java.io.File;

public class UnmarshallExample {
    public static void main(String[] args) throws Exception {
        JAXBContext context = JAXBContext.newInstance(Student.class);
        Unmarshaller unmarshaller = context.createUnmarshaller();
        Student s = (Student) unmarshaller.unmarshal(new File("student.xml"));
        System.out.println(s.getName() + " - " + s.getRollNo());
    }
}
âœ… Output:
Ankur Verma - 101

ğŸ”„ Real-World Use Cases:
â¤ Converting XML payloads in SOAP web services
â¤ Reading/writing config files in XML
â¤ Data exchange between Java systems via XML
â¤ Used in Spring Boot (for XML-based request/response mapping)


ğŸ”· JSON (JavaScript Object Notation)
JSON is a lightweight data-interchange format used to store and exchange data between a client and a server.

Itâ€™s language-independent, but easily readable by both humans and machines.

âœ… Example:
{
  "name": "Ankur Verma",
  "rollNo": 101,
  "branch": "Information Technology"
}

ğŸ”„ Key Features of JSON:
â¤ Lightweight â€“ smaller and faster than XML
â¤ Easy to parse â€“ simple key-value structure
â¤ Language-independent
â¤ Key-value pair format
â¤ Used widely in REST APIs
â¤ Supports basic data types: string, number, boolean, array, object, null

ğŸ”„JSON in Java (Working & Usage)
Java doesnâ€™t have built-in JSON support, but several popular libraries make it easy to convert between Java objects and JSON:

Common libraries:
â¤ Jackson (most popular, used by Spring Boot)
â¤ Gson (by Google)
â¤ org.json

1ï¸âƒ£ Using Jackson Library (Most Common in Spring Boot)
âœ… Example of Java Class:
public class Student {
    private String name;
    private int rollNo;

    public Student() {}
    public Student(String name, int rollNo) {
        this.name = name;
        this.rollNo = rollNo;
    }

    // Getters and setters
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public int getRollNo() { return rollNo; }
    public void setRollNo(int rollNo) { this.rollNo = rollNo; }
}

ğŸŒ€ Object â†’ JSON (Serialization)
import com.fasterxml.jackson.databind.ObjectMapper;

public class ObjectToJson {
    public static void main(String[] args) throws Exception {
        Student s = new Student("Ankur Verma", 101);
        ObjectMapper mapper = new ObjectMapper();

        String jsonString = mapper.writeValueAsString(s);
        // for adding the json to a file
        // mapper.writeValue(new File("student.json"), s);
        System.out.println(jsonString);
    }
}

âœ… Output:
{"name":"Ankur Verma","rollNo":101}

ğŸ” JSON â†’ Object (Deserialization)
public class JsonToObject {
    public static void main(String[] args) throws Exception {
        String jsonString = "{\"name\":\"Ankur Verma\",\"rollNo\":101}";
        ObjectMapper mapper = new ObjectMapper();

        Student s = mapper.readValue(jsonString, Student.class);
        System.out.println(s.getName() + " - " + s.getRollNo());
    }
}
âœ… Output:
Ankur Verma - 101

2ï¸âƒ£ Using Gson Library (Alternative)
import com.google.gson.Gson;

public class GsonExample {
    public static void main(String[] args) {
        Student s = new Student("Ankur", 101);
        Gson gson = new Gson();

        // Object â†’ JSON
        String json = gson.toJson(s);
        System.out.println(json);

        // JSON â†’ Object
        Student obj = gson.fromJson(json, Student.class);
        System.out.println(obj.getName());
    }
}

Spring Boot automatically uses Jackson internally for JSON conversion.

ğŸ”„ Real-World Use Cases:
â¤ Reading/writing config files in JSON
â¤ Data exchange between Java systems via JSON


ğŸ”· HTTP protocol
â¤ HTTP (HyperText Transfer Protocol) is a client-server communication protocol used for transmitting data over the web.
â¤ It defines how messages are formatted and transmitted, and how web servers and browsers should respond to various commands.
â¤ It is a stateless protocol. It will treat each request independently.


â“How It Works
â¤ Client sends a request â†’ (e.g., a web browser or REST client sends an HTTP request to the server).
â¤ Server processes the request â†’ The web server receives the request, processes it, and prepares a response.
â¤ Server sends back a response â†’ The server returns an HTTP response (status code + data).
â¤ Connection may close (in HTTP/1.1 or remain open for HTTP/2 and HTTP/3).

ğŸŒŸ Basic Structure
1ï¸âƒ£ HTTP Request Structure
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Chrome/108.0
Accept: text/html


2ï¸âƒ£ HTTP Response Structure
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 1234

<html>
<body>Hello, World!</body>
</html>

ğŸ”„ Common HTTP Methods
| Method     | Description                                       |
| ---------- | ------------------------------------------------- |
| GET    | Retrieve data from the server (no body).          |
| POST   | Send data to the server (used for creating data). |
| PUT    | Update existing resource completely.              |
| PATCH  | Update part of a resource.                        |
| DELETE | Delete a resource.                                |
| HEAD   | Same as GET but returns only headers.             |

=====================
ğŸ”¹ HTTP Status Codes
======================

â¤ An HTTP status code is a three-digit numeric code returned by a web server as parto of the response to an HTTP request made by a client.
â¤ These status codes are used to convey information about the result or status of the requested operation.
â¤ HTTP status codes are grouped into five categories based on the first digit of the code:
1ï¸âƒ£ 1xx (Informational): These status codes indicate that the request was received and understood, and the server is continuing to process it.
These are typically used for informational purposes and are not commonly seen in everyday web interactions.

2ï¸âƒ£ 2xx (Successful): These status codes indicate that the request was successfully received, understood, and accepted by the server.
  âœ”ï¸ 200 OK: The request has been successfully processed, and the server is returning the requested resource.
  âœ”ï¸ 201 Created: The request has been fulfilled, resulting in the creation of a new resource.
  âœ”ï¸ 204 No Content: The request has been fulfilled, but there is no response body(typically used for operation that don't return data, like a DELETE request).

3ï¸âƒ£ 3xx (Redirection): These status codes indicate that further action is needed to complete the request. These are used when the client needs to take additional steps to access the requested resource.
  âœ”ï¸ 301 Moved Permanently: The requested resource has been permanently moved to a new URL.
  âœ”ï¸ 302 Found: The requested resource is temporarily located at a different URL.When server sends a response with a 302 status code, it typically includes a Location header that specifies the new URL where the resource can be found. The client is expected to make a new request to this URL to access the resource.
  âœ”ï¸ 304 Not Modified: The resource has not been modified since the last request. The client can use its cached version.

4ï¸âƒ£ 4xx (Client Error): It indicates that there was an error on the client's side, such as malformed request or authentication issues.
  âœ”ï¸ 400 Bad Request: The server cannot process the request due to client error (e.g., malformed request syntax).
  âœ”ï¸ 401 Unauthorized: Authentication is required and has failed or has not yet been provided.
  âœ”ï¸ 403 Forbidden: The server understands the request but refuses to authorize it.
  âœ”ï¸ 404 Not Found: The requested resource could not be found on the server.

5ï¸âƒ£ 5xx (Server Error): The server failed to fulfill a valid request.
  âœ”ï¸ 500 Internal Server Error: A generic error message indicating that the server encountered an unexpected condition.
  âœ”ï¸ 502 Bad Gateway: The server received an invalid response from an inbound server while acting as a gateway or proxy.
  âœ”ï¸ 503 Service Unavailable: The server is currently unable to handle the request due to temporary overload or maintenance.

| Code Range | Meaning       | Example                        |
| ---------- | ------------- | ------------------------------ |
| 1xx    | Informational | 100 Continue                   |
| 2xx    | Success       | 200 OK, 201 Created            |
| 3xx    | Redirection   | 301 Moved Permanently          |
| 4xx    | Client Error  | 400 Bad Request, 404 Not Found |
| 5xx    | Server Error  | 500 Internal Server Error      |

ğŸ”„ Features
â¤ Stateless: Each request is independent; no session info is stored by default.
â¤ Text-based: Human-readable request and response format.
â¤ Extensible: Supports custom headers, cookies, and authentication.
â¤ Uses TCP (Port 80) or HTTPS (Port 443) for secure communication.


ğŸ”· HTTP Request and HTTP Response
1ï¸âƒ£ HTTP Request
An HTTP request is a message sent by the client (like a browser or app) to ask the server to perform an action â€” such as fetching data, submitting a form, or deleting a record.

ğŸ”„ Structure of an HTTP Request
Method  URL  Protocol-Version
Headers
(blank line)
Body (optional)

âœ… Example:
GET /users?id=10 HTTP/1.1
Host: example.com
User-Agent: Chrome/121.0
Accept: application/json

ğŸ”„ Main Components:
â¤ Request Line
    âœ”ï¸ Includes HTTP method, URL, and HTTP version.
    âœ… Example: GET /home HTTP/1.1
â¤ Headers
    âœ”ï¸ Provide additional info like content type, authentication, etc.
    âœ… Example:
            Content-Type: application/json
            Authorization: Bearer token123
â¤ Body (Optional)
    âœ”ï¸ Carries data with requests like POST, PUT, or PATCH.
    âœ… Example:
        {
          "name": "Ankur",
          "email": "ankur@gmail.com"
        }

2ï¸âƒ£ HTTP Response
An HTTP response is the message sent by the server back to the client after processing the request.



ğŸ”· Headers in HTTP
â¤ HTTP Headers are key-value pairs sent between the client and server in an HTTP request or response.
â¤ They carry metadata about the request/response â€” such as content type, authorization token, user agent, etc.

âœ… Example of Common HTTP Headers
GET /api/weather HTTP/1.1
Host: api.weatherstack.com
Authorization: Bearer abc123
Content-Type: application/json
User-Agent: PostmanRuntime/7.32.2

ğŸ‘‰ Here:
    âœ”ï¸ Authorization â†’ carries credentials or API keys
    âœ”ï¸ Content-Type â†’ tells the server the data format (JSON, XML, etc.)
    âœ”ï¸ User-Agent â†’ describes the client making the request

ğŸ”· Pass Headers in Code (Spring Boot using RestTemplate)
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

@Service
public class WeatherService {

    private static final String API = "https://api.weatherstack.com/current?access_key={key}&query={city}";

    private final RestTemplate restTemplate = new RestTemplate();

    public WeatherResponse getWeather(String apiKey, String city) {

        // 1ï¸âƒ£ Create headers
        HttpHeaders headers = new HttpHeaders();
        headers.set("Accept", "application/json"); // tells server to respond in JSON
        headers.set("User-Agent", "SpringBootApp");
        headers.set("Authorization", "Bearer some_token_here"); // example of passing token

        // 2ï¸âƒ£ Build HttpEntity (headers + body)
        HttpEntity<String> entity = new HttpEntity<>(headers);

        // 3ï¸âƒ£ Send request
        ResponseEntity<WeatherResponse> response = restTemplate.exchange(
                API,
                HttpMethod.GET,
                entity,                // includes headers
                WeatherResponse.class,
                apiKey, city           // replaces placeholders in URL
        );

        // 4ï¸âƒ£ Return only body
        return response.getBody();
    }
}


ğŸ”„ Sending Headers + Body in a POST request
String url = "https://api.example.com/users";

// 1ï¸âƒ£ Create headers
HttpHeaders headers = new HttpHeaders();
headers.setContentType(MediaType.APPLICATION_JSON);
headers.set("Authorization", "Bearer xyz123");

// 2ï¸âƒ£ Create request body
User user = new User("Ankur", "ankur@example.com");

// 3ï¸âƒ£ Combine headers and body
HttpEntity<User> entity = new HttpEntity<>(user, headers);

// 4ï¸âƒ£ Make POST request
ResponseEntity<String> response = restTemplate.exchange(
        url,
        HttpMethod.POST,
        entity,
        String.class
);

ğŸ”„ Key Classes for HTTP Headers in Spring
| Class                   | Description                                        |
| ----------------------- | -------------------------------------------------- |
| `HttpHeaders            | Represents HTTP header values                      |
| `HttpEntity<T           | Represents request entity (headers + body)         |
| `ResponseEntity<T       | Represents the response (status, headers, body)    |
| `MediaType              | Helps specify content type like `application/json` |


ğŸ”„ Common HTTP Headers and Their Purposes
| Header          | Purpose                                                           |
| --------------- | ----------------------------------------------------------------- |
| `Content-Type`  | Tells server what type of data is being sent (`application/json`) |
| `Accept`        | Tells server what response format client expects                  |
| `Authorization` | Sends tokens, API keys, or credentials                            |
| `User-Agent`    | Identifies client making the request                              |
| `Cache-Control` | Caching policies                                                  |
| `Custom-Header` | You can define your own headers                                   |


ğŸ”„ Structure of an HTTP Response
Protocol-Version Status-Code Status-Message
Headers
(blank line)
Body (optional)

âœ… Example:
HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 47
{
  "id": 10,
  "name": "Ankur",
  "email": "ankur@gmail.com"
}

ğŸ”„ Main Components:
â¤ Status Line
âœ… Example: HTTP/1.1 200 OK
    ğŸ”— Includes:
        âœ”ï¸ HTTP version (HTTP/1.1)
        âœ”ï¸ Status code (200)
        âœ”ï¸ Status message (OK)
â¤ Headers
    âœ”ï¸ Give info about the response.
    âœ… Example:
        Content-Type: text/html
        Cache-Control: no-cache
â¤ Body (Optional)
    âœ”ï¸ Contains the actual data (HTML, JSON, XML, etc.)

ğŸ”„ Requestâ€“Response Flow Example
ğŸ”— Client (Browser):
    GET /products HTTP/1.1
    Host: www.shop.com

ğŸ”— Server (Response):
    HTTP/1.1 200 OK
    Content-Type: application/json
    [{"id":1,"name":"Laptop","price":50000}]


ğŸ”· Media Types in Rest API
â¤ A Media Type (or MIME type) tells the format of data being sent or received in an HTTP message.
â¤ It helps the client and server understand how to interpret the request or response body.

ğŸ’¡ Syntax: type/subtype

âœ… Examples:
| Media Type            | Description           |
| --------------------- | --------------------- |
| `application/json`    | JSON data             |
| `application/xml`     | XML data              |
| `text/html`           | HTML content          |
| `text/plain`          | Plain text            |
| `multipart/form-data` | Used for file uploads |
| `application/pdf`     | PDF file              |


1ï¸âƒ£ Media Type in HTTP Request
When a client sends data (like in a POST or PUT request), it uses the Content-Type header to specify the format.
âœ… Example:
POST /api/users HTTP/1.1
Content-Type: application/json

{
  "name": "Ankur",
  "email": "ankur@gmail.com"
}
â¡ï¸ This tells the server that the body is in JSON format.

2ï¸âƒ£ Media Type in HTTP Response
The server uses the Content-Type header to tell the client what type of data itâ€™s returning.
âœ… Example:
HTTP/1.1 200 OK
Content-Type: application/json

{
  "status": "success",
  "id": 101
}
â¡ï¸ This tells the client that the response body is JSON.

3ï¸âƒ£ Content Negotiation in REST APIs
In REST, the client can tell the server which format it accepts using the Accept header.
âœ… Example:
GET /api/users HTTP/1.1
Accept: application/json
âœ”ï¸ The client says: â€œI want the response in JSON.â€
âœ”ï¸ The server will then return data in JSON format (if supported).

â¤ If the client instead says:
Accept: application/xml

â¤ The server can respond with:
Content-Type: application/xml


4ï¸âƒ£ Media Types in Spring Boot REST APIs
In Spring Boot, you can specify media types using:
â¤ @RequestMapping, @PostMapping, @GetMapping etc.
@RestController
@RequestMapping("/api")
public class UserController {

    @PostMapping(
        value = "/users",
        consumes = "application/json",     // Request body format 
        produces = "application/json"      // Response format
    )
    // can provide multiple values for the consumes and produces
    public ResponseEntity<User> addUser(@RequestBody User user) {
        return ResponseEntity.ok(user);
    }
}

âœ… consumes â†’ tells what type of input the API accepts
âœ… produces â†’ tells what type of output the API returns

ğŸ“‹ Common Media Types in REST APIs
| Media Type                          | Use                            |
| ----------------------------------- | ------------------------------ |
| `application/json`                  | Most common for REST APIs      |
| `application/xml`                   | Used in SOAP or XML-based APIs |
| `text/plain`                        | Simple text data               |
| `multipart/form-data`               | File uploads (e.g. image, PDF) |
| `application/x-www-form-urlencoded` | HTML form submissions          |


âš¡ Real-World Example
âœ… Request:
POST /upload HTTP/1.1
Content-Type: multipart/form-data
Accept: application/json

âœ… Response:
HTTP/1.1 200 OK
Content-Type: application/json
{"message": "File uploaded successfully!"}



ğŸ”· Rest Client Development
A REST Client is a tool, library, or component that allows you to send HTTP requests (GET, POST, PUT, DELETE, etc.) to a REST API and receive responses â€” typically used to test, consume, or interact with RESTful web services.

A REST Client acts as a consumer of REST APIs.
It sends HTTP requests to the server (REST API endpoint) and reads the HTTP responses returned.

In springboot we can develop REST Client using 3 ways:
1ï¸âƒ£ Using RestTemplate (Synchrnous Communication: sending request and wating for response then processing other requests)
2ï¸âƒ£ Using WebClient (Synchrnous + Asynchrnous Communication)
3ï¸âƒ£ Using Feign

ğŸ”„ Example in Real Life
â¤ When you use Postman, youâ€™re using a REST Client application to test APIs.
â¤ When a frontend app (React, Angular, Flutter) calls an API using fetch() or axios, those are REST Client libraries making HTTP calls.

âœ… Example - Java REST Client Using RestTemplate
import org.springframework.web.client.RestTemplate;
import org.springframework.http.ResponseEntity;


ğŸ”„ Working of RestTemplate
â¤ RestTemplate is a class provided by Spring Framework that acts as a synchronous REST client.
â¤ It allows your Spring application to make HTTP requests (GET, POST, PUT, DELETE) to consume REST APIs.

â¤ Think of it as your Java-based Postman â€” but used inside your application code.


2ï¸âƒ£ When to Use It
â¤ You use RestTemplate when:
    âœ”ï¸ Your Spring app wants to call another REST API (either external or internal).
    âœ”ï¸ You need to integrate multiple microservices.
    âœ”ï¸ You want to send or receive JSON data programmatically


3ï¸âƒ£ How It Works Internally
Hereâ€™s the internal flow:

[Your Spring App] â†’ (RestTemplate) â†’ [HTTP Request] â†’ [Target REST API] 
â†’ [Response] â†’ (RestTemplate parses it) â†’ [Java Object or String]


âœ… Example Flow:
You call:
restTemplate.getForObject("https://jsonplaceholder.typicode.com/posts/1", Post.class);
â†’ It makes a GET request to that URL
â†’ Gets the JSON response
â†’ Converts it automatically into a Post Java object using Jackson JSON Mapper


âœ… Example:
Let's say we have StudentService and a client Service that calls it.

ğŸ”— StudentController.java (Server/API Provider)
package com.example.demo.controller;

import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/students")
public class StudentController {

    @GetMapping("/{id}")
    public Student getStudent(@PathVariable int id) {
        return new Student(id, "Ankur Verma", "IT");
    }
}

ğŸ”— StudentService.java 
package com.example.demo.request;
@Data
class Student {
    private int id;
    private String name;
    private String department;
}


@Configuration
public class RestTemplateConfig {
    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}


ğŸ”„ If we want to set timeouts
@Configuration
public class RestTemplateConfig {

@Bean
public RestTemplate restTemplate() {
    SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory();
    factory.setConnectTimeout(5000); // 5 seconds
    factory.setReadTimeout(5000);    // 5 seconds
    return new RestTemplate(factory);
    }
}


ğŸ”— StudentClient.java (Consumer using RestTemplate)
package com.example.demo.client;

import org.springframework.http.ResponseEntity;
import org.springframework.web.client.RestTemplate;
import org.springframework.stereotype.Component;

@Component
public class StudentClient {

    private final RestTemplate restTemplate = new RestTemplate();

    public void getStudentDetails() {
        String url = "http://localhost:8080/api/students/1";

        // Make GET request and receive response as Student object
        ResponseEntity<Student> response = restTemplate.getForEntity(url, Student.class);

        // Print response
        System.out.println("Status Code: " + response.getStatusCode());
        System.out.println("Student Details:");
        System.out.println("ID: " + response.getBody().getId());
        System.out.println("Name: " + response.getBody().getName());
        System.out.println("Department: " + response.getBody().getDepartment());
    }
}


// Student model (same structure as in API)
@Data
class Student {
    private int id;
    private String name;
    private String department;
}


ğŸ”„ Running the Example
â¤ Run the StudentController application (port 8080).
â†’ It exposes an endpoint:
GET http://localhost:8080/api/students/1

â¤ Run StudentClient class (it can be in another app or in same app).
â†’ It makes a GET call using RestTemplate.


âœ… Youâ€™ll see output like:
Status Code: 200 OK
Student Details:
ID: 1
Name: Ankur Verma
Department: IT


ğŸ”„ Commonly Used RestTemplate Methods
| Method                            | Purpose                                                  | Example                                                   |
| --------------------------------- | -------------------------------------------------------- | --------------------------------------------------------- |
| `getForObject(url, class)`        | GET request and returns object directly                  | `restTemplate.getForObject(url, Student.class)`           |
| `getForEntity(url, class)`        | GET request and returns `ResponseEntity` (status + body) | `restTemplate.getForEntity(url, Student.class)`           |
| `postForObject(url, body, class)` | POST request and returns created object                  | `restTemplate.postForObject(url, student, Student.class)` |
| `postForEntity(url, body, class)` | POST request returning full response                     | `restTemplate.postForEntity(url, student, Student.class)` |
| `put(url, body)`                  | PUT request (no return)                                  | `restTemplate.put(url, student)`                          |
| `delete(url)`                     | DELETE request                                           | `restTemplate.delete(url)`                                |


ğŸ”„ Limitations of RestTemplate 
1ï¸âƒ£ There are so many overloaed methods which create confusion and so its hard to remember and maintain.
2ï¸âƒ£ It was build before cocepts like Retry, circuit breaker etc. so adding support means more overloaded methods and not user friendly.
3ï¸âƒ£ It is a blocking client which means each request will block the thread until response is received. This can lead to thread exhaustion under high load.


===============
ğŸ”· RestClient
===============
â¤ RestClient is a modern, synchronous (blocking) HTTP client
â¤ Introduced in Spring Framework 6
â¤ Designed as a replacement for RestTemplate
â¤ Provides a fluent(chaining of methods), readable, and type-safe API
â¤ Built on top of Springâ€™s HTTP infrastructure


ğŸ”„ Why Spring Introduced RestClient
Problems with RestTemplate
    âœ”ï¸ Old, imperative API
    âœ”ï¸ Verbose
    âœ”ï¸ Hard to customize
    âœ”ï¸ No future enhancements planned

Problems with WebClient
    âœ”ï¸ Reactive programming overhead
    âœ”ï¸ Mono / Flux learning curve
    âœ”ï¸ Overkill for simple MVC apps

Solution â†’ RestClient
    âœ”ï¸ Blocking (simple mental model)
    âœ”ï¸ Fluent API
    âœ”ï¸ Future-proof
    âœ”ï¸ Clean error handling


ğŸ”„ Positioning in Spring REST Clients
RestTemplate   âŒ (legacy, blocking)
RestClient     âœ… (modern, blocking)
WebClient      âš¡ (reactive, non-blocking)
Feign          ğŸ§© (declarative abstraction)


ğŸ”„ Core Characteristics
â¤ Blocking I/O
â¤ Synchronous request-response
â¤ Fluent builder pattern
â¤ Strong typing
â¤ Integrated with Spring ecosystem
â¤ Supports interceptors, error handlers, timeouts


ğŸ”„ Creating a RestClient
1ï¸âƒ£ Simple Creation
@Bean
public RestClient restClient() {
        return RestClient.create();
}

2ï¸âƒ£ Recommended (Bean Configuration)
@Bean
public RestClient restClient() {
    return RestClient.builder()
            .baseUrl("https://api.example.com")
            .defaultHeader("Content-Type", "application/json")
            .build();
}
ğŸ‘‰ Best practice: Define as a singleton bean


ğŸ”„ Basic HTTP Operations
âœ… GET Request
User user = restClient
        .get()
        .uri("/users/{id}", 1)
        .retrieve()
        .body(User.class);


âœ… POST Request
UserResponse response = restClient
        .post()
        .uri("/users")
        .body(userRequest)
        .retrieve()
        .body(UserResponse.class);


âœ… PUT Request
restClient.put()
        .uri("/users/{id}", 1)
        .body(updateRequest)
        .retrieve()
        .toBodilessEntity();


âœ… DELETE Request
restClient.delete()
        .uri("/users/{id}", 1)
        .retrieve()
        .toBodilessEntity();


ğŸ”„ Response Handling
â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Read Full Response
ResponseEntity<User> response =
        restClient.get()
        .uri("/users/{id}", 1)
        .retrieve()
        .toEntity(User.class);

â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ No Response Body
restClient.post()
        .uri("/users")
        .body(request)
        .retrieve()
        .toBodilessEntity();


ğŸ”„ Error Handling
restClient.get()
    .uri("/users/{id}", 1)
    .retrieve()
    .onStatus(HttpStatusCode::is4xxClientError,
        (req, res) -> {
            throw new RuntimeException("Client error");
        })
    .onStatus(HttpStatusCode::is5xxServerError,
        (req, res) -> {
            throw new RuntimeException("Server error");
        })
    .body(User.class);

âœ… Cleaner than RestTemplate exception handling


ğŸ”„ Headers & Authentication
Custom Headers
restClient.get()
    .uri("/users")
    .header("Authorization", "Bearer token")
    .retrieve()
    .body(List.class);

Default Headers (Global)
RestClient.builder()
    .defaultHeader("Authorization", "Bearer token")
    .build();


ğŸ”„ Path Variables & Query Params
1ï¸âƒ£ Path Variables
.uri("/users/{id}", id)

2ï¸âƒ£ Query Parameters
.uri(uriBuilder ->
    uriBuilder
        .path("/users")
        .queryParam("active", true)
        .build()
)


ğŸ”„ Interceptors (Cross-Cutting Concerns)
1ï¸âƒ£ Inside the Builder  
RestClient.builder()
    .requestInterceptor((request, body, execution) -> {
        System.out.println("Request URL: " + request.getURI());
        return execution.execute(request, body);
    })
    .build();
Use cases:
    âœ”ï¸ Logging
    âœ”ï¸ Authentication
    âœ”ï¸ Tracing
    âœ”ï¸ Metrics


2ï¸âƒ£ Can create seperate Interceptor class
public class LoggingInterceptor implements ClientHttpRequestInterceptor {
    @Override
    public ClientHttpResponse intercept(
            HttpRequest request,
            byte[] body,
            ClientHttpRequestExecution execution) throws IOException {
        System.out.println("Request URL: " + request.getURI());
        return execution.execute(request, body);
    }
}

Then register it:
@Configuration
public class RestClientConfig {
    @Bean
    public RestClient restClientInstance() {
        return RestClient.builder()
                .interceptor(new LoggingInterceptor())
                .build();
    }
}


ğŸ”„ Timeouts & HTTP Client
RestClient uses:
â¤ ClientHttpRequestFactory
â¤ Backed by:
    âœ”ï¸ JDK HttpClient
    âœ”ï¸ Apache HttpClient
    âœ”ï¸ OkHttp

âœ… Example:
HttpComponentsClientHttpRequestFactory factory =
        new HttpComponentsClientHttpRequestFactory();

factory.setConnectTimeout(5000);
factory.setReadTimeout(5000);

RestClient.builder()
    .requestFactory(factory)
    .build();


ğŸ”„ RestClient vs RestTemplate
| Feature        | RestTemplate | RestClient |
| -------------- | ------------ | ---------- |
| API Style      | Imperative   | Fluent     |
| Future Support | âŒ            | âœ…          |
| Error Handling | Weak         | Strong     |
| Configuration  | Hard         | Easy       |
| Spring Boot 3  | âŒ            | âœ…          |


==============
ğŸ”· WebClient
==============
â¤ WebClient is part of Spring WebFlux, a reactive web framework introduced in Spring 5.
â¤ It is used to make asynchronous, non-blocking HTTP requests to REST APIs.

ğŸ‘‰ Think of it as:
A reactive, lightweight, and flexible version of RestTemplate


ğŸ”„ Why WebClient Was Introduced
â¤ RestTemplate (older client) works in a blocking manner â€”
that means each thread waits for the response before continuing.
â¤ In contrast, WebClient is non-blocking â€”
it can handle many requests concurrently with fewer threads, improving performance and scalability.


ğŸ”„ Key Features of WebClient
| Feature                      | Description                                                               |
| ---------------------------- | ------------------------------------------------------------------------- |
| Reactive (Non-blocking)  | Uses Project Reactor (`Mono` and `Flux`) for async programming.           |
| Lightweight              | Doesnâ€™t depend on Servlet API. Works in both Spring MVC and WebFlux apps. |
| Supports Streaming       | Can handle continuous data streams (e.g., SSE, WebSockets).               |
| Functional API           | Fluent builder-style syntax for constructing requests.                    |
| Can Replace RestTemplate | Fully supports GET, POST, PUT, DELETE, etc.                               |


ğŸ”„ When to Use WebClient
âœ”ï¸ When building reactive or high-performance applications.
âœ”ï¸ When handling multiple concurrent API calls.
âœ”ï¸ When you need to stream data (e.g., continuous updates).
âœ”ï¸ When youâ€™re using Spring WebFlux or microservices.


ğŸ”„ Basic Syntax
WebClient webClient = WebClient.create("http://localhost:8080");

Mono<Student> studentMono = webClient.get()
    .uri("/api/students/1")
    .retrieve()
    .bodyToMono(Student.class);
Mono<Student> is a reactive type that represents one asynchronous result (like a Future<Student>).


ğŸ”„ WebClient vs RestTemplate
| Feature                   | `RestTemplate`                  | `WebClient`                 |
| ------------------------- | ------------------------------- | --------------------------- |
| Introduced In         | Spring 3                        | Spring 5 (WebFlux)          |
| Type                  | Synchronous (Blocking)          | Asynchronous (Non-blocking) |
| Performance           | Slower (one thread per request) | Faster (reactive model)     |
| Reactive Support      | âŒ No                            | âœ… Yes                       |
| Streaming Support     | âŒ No                            | âœ… Yes                       |
| Recommended By Spring | Deprecated (for new apps)       | âœ… Official Replacement      |


ğŸ”„ Maven dependency for WebClient:
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-webflux</artifactId>
</dependency>

â¤ spring-boot-starter-web --> class
â¤ spring-boot-starter-webflux --> interface


ğŸ”„ Reactive Concepts Used
1ï¸âƒ£ Mono<T> â†’ represents 0 or 1 asynchronous result (like one Student).
2ï¸âƒ£ Flux<T> â†’ represents 0 or many asynchronous results (like list of Students).

âœ… Example:
Flux<Student> students = webClient.get()
    .uri("/api/students")
    .retrieve()
    .bodyToFlux(Student.class);

ğŸ”„ Real-World Use Case Example
Letâ€™s say you have a Student Service that needs to call another Course Service.

@Service
public class StudentService {

    private final WebClient webClient = WebClient.create("http://course-service:8081");

    public Mono<Course> getCourseDetails(int studentId) {
        return webClient.get()
                .uri("/api/courses/student/{id}", studentId)
                .retrieve()
                .bodyToMono(Course.class);
    }
}
âœ… Non-blocking, so the thread doesnâ€™t wait for the response â€”
it can handle hundreds of concurrent API calls efficiently.


ğŸ”· Spring Data REST
â¤ Spring Data REST is a module of the Spring Data project that automatically exposes RESTful APIs for your Spring Data Repositories â€” without writing any controller code.

â¤ If you already have a JpaRepository, Spring Data REST will automatically create REST endpoints (GET, POST, PUT, DELETE) for you.

ğŸ”„ How It Works
When you include the dependency spring-boot-starter-data-rest, Spring Boot:
â¤ Scans your repositories (like StudentRepository).
â¤ Automatically creates REST endpoints under /entities or your custom path.
â¤ Converts Java entities to JSON responses.
â¤ Handles CRUD operations and pagination by default.

ğŸ”„ What to Add while making project:
â¤ Spring Data JPA
â¤ Rest Repositories
â¤ MySQL Driver

ğŸ”„ Dependency
ğŸ‘‰ Add this dependency in your pom.xml:

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-rest</artifactId>
</dependency>
âš¡ (You must also have spring-boot-starter-data-jpa and a database driver like mysql-connector-java.)

âœ… Example: Exposing Student Repository as REST API
1ï¸âƒ£ Entity Class
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;

@Entity
public class Student {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private String course;

    // getters and setters
}

2ï¸âƒ£ Repository Interface
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.rest.core.annotation.RepositoryRestResource;

@RepositoryRestResource(path = "students")
public interface StudentRepository extends JpaRepository<Student, Long> {
}
âœ… The @RepositoryRestResource(path = "students") annotation tells Spring Data REST to expose this repository as a REST resource under /students.

3ï¸âƒ£ Run the Application
When you start your Spring Boot app, Spring Data REST automatically generates endpoints like:
| HTTP Method | Endpoint         | Description                        |
| ----------- | ---------------- | ---------------------------------- |
| GET     | `/students`      | Get all students (with pagination) |
| GET     | `/students/{id}` | Get student by ID                  |
| POST    | `/students`      | Create a new student               |
| PUT     | `/students/{id}` | Update an existing student         |
| DELETE  | `/students/{id}` | Delete student by ID               |

âœ… Example Request & Response
ğŸ‘‰ POST Request:
POST /students
Content-Type: application/json
{
  "name": "Ankur Verma",
  "course": "B.Tech IT"
}

ğŸ‘‰ Response:
{
  "id": 1,
  "name": "Ankur Verma",
  "course": "B.Tech IT"
}

ğŸ”„ Customization Options
| Annotation                               | Purpose                                                               |
| ---------------------------------------- | --------------------------------------------------------------------- |
| `@RepositoryRestResource`                | Customize path, collection name, and relation name.                   |
| `@RestResource`                          | Customize endpoint exposure for specific methods.                     |
| `@Projection`                            | Control what fields are shown in REST responses.                      |
| `@ExcerptProjection`                     | Show summarized data when listing entities.                           |
| `@HandleBeforeSave` / `@HandleAfterSave` | Add custom logic (like events) before or after repository operations. |


âœ… Example of Customization
@RepositoryRestResource(collectionResourceRel = "learners", path = "students")
public interface StudentRepository extends JpaRepository<Student, Long> {

    @RestResource(path = "byName", rel = "byName")
    List<Student> findByNameContaining(@Param("name") String name);
}
ğŸ‘‰ Now you can access:
For findBy queries we have to add /search to the path, for example:
GET /students/search/byName?name=Ankur

ğŸ”„ Internals & Concepts
â¤ Spring Data REST uses HAL (Hypertext Application Language) format by default for HATEOAS links.
â¤ Uses Spring MVC under the hood, but you donâ€™t need to write controllers.
â¤ Itâ€™s built on Spring Data Repositories, so all query methods automatically become endpoints.

ğŸ”„ Advantages
âœ… No need to write boilerplate controller code.
âœ… Automatic CRUD and pagination.
âœ… HATEOAS support for navigable APIs.
âœ… Integrates easily with JPA, MongoDB, Neo4j, etc.
âœ… Easy to customize endpoints and data projections.

ğŸ”„ When Not to Use
â¤ If your API requires complex business logic or custom response structures.
â¤ If you need authentication, role-based access, or API versioning â€” then youâ€™d better write custom controllers.

ğŸ”„ Goal
Restrict or disable specific HTTP methods (like POST, PUT, or DELETE) for certain entities when using Spring Data REST.

1ï¸âƒ£ Create Configuration Class
Youâ€™ll use RepositoryRestConfigurer to customize repository exposure.

package com.example.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.data.rest.core.config.RepositoryRestConfiguration;
import org.springframework.data.rest.webmvc.config.RepositoryRestConfigurer;
import org.springframework.http.HttpMethod;

import com.example.entity.Student;

@Configuration
public class RestRepositoryConfig implements RepositoryRestConfigurer {

    @Override
    public void configureRepositoryRestConfiguration(RepositoryRestConfiguration config) {

        // Disable HTTP methods for Student entity: PUT, POST, DELETE
        HttpMethod[] unsupportedActions = {HttpMethod.PUT, HttpMethod.POST, HttpMethod.DELETE};

        // Apply restrictions
        config.getExposureConfiguration()
                .forDomainType(Student.class)
                .withItemExposure((metadata, httpMethods) ->
                        httpMethods.disable(unsupportedActions))
                .withCollectionExposure((metadata, httpMethods) ->
                        httpMethods.disable(unsupportedActions));
    }
}


ğŸ”„ Apply Restrictions to Multiple Entities
You can restrict multiple repositories easily:

config.getExposureConfiguration()
        .forDomainType(Student.class)
        .withItemExposure((metadata, httpMethods) -> httpMethods.disable(unsupportedActions))
        .withCollectionExposure((metadata, httpMethods) -> httpMethods.disable(unsupportedActions));

config.getExposureConfiguration()
        .forDomainType(Course.class)
        .withItemExposure((metadata, httpMethods) -> httpMethods.disable(unsupportedActions))
        .withCollectionExposure((metadata, httpMethods) -> httpMethods.disable(unsupportedActions));

ğŸ”„ Optional â€” Expose Entity IDs in JSON
By default, Spring Data REST hides entity IDs.
You can expose them in the same config class:

config.exposeIdsFor(Student.class);


=========================================================
ğŸ”· MongoTemplate, Criteria, and Query in Spring Boot
==========================================================
â¤ MongoTemplate is a core class in Spring Data MongoDB that provides:
    âœ”ï¸ Fine-grained control over queries,
    âœ”ï¸ Custom query building (beyond @Query or repository methods),
    âœ”ï¸ Access to MongoDBâ€™s full query and aggregation power.
ğŸ‘‰ Itâ€™s similar to how JdbcTemplate works for relational databases.

âœ… Example:
  @Autowired
    private MongoTemplate mongoTemplate;

    public List<User> getUserForSentimentAnalysis() {
        Query query = new Query();
        query.addCriteria(Criteria.where("userName").is("Ram"));
        return mongoTemplate.find(query, User.class);

    }

â¤ MongoTemplate is auto-configured by Spring Boot if MongoDB connection details exist in application.properties.
â¤ Using @Autowired injects the template, allowing you to directly interact with the MongoDB database.

Query query = new Query();
ğŸ‘‰ Creates a blank query object that can be configured with filters, sort, projection, etc.

query.addCriteria(Criteria.where("userName").is("Ram"));
ğŸ‘‰ Builds a filter condition using Criteria.

This is equivalent to MongoDBâ€™s JSON query:
{ "userName": "Ram" }
ğŸ‘‰ You can chain multiple criteria using .and(), .orOperator(), .gt(), etc.

return mongoTemplate.find(query, User.class);
â¤ Executes the query on the User collection (Spring automatically maps the class to the MongoDB collection).
â¤ Converts each matching MongoDB document into a User Java object.
â¤ Returns a List<User>

âœ… Extended Examples: Find by multiple fields:
Query query = new Query();
query.addCriteria(Criteria.where("userName").is("Ram").and("age").gte(25));
List<User> users = mongoTemplate.find(query, User.class);

âœ… Example: Using OR condition
Query query = new Query();
query.addCriteria(new Criteria().orOperator(
    Criteria.where("userName").is("Ram"),
    Criteria.where("email").is("ram@ram")
));
List<User> users = mongoTemplate.find(query, User.class);

â“ Why Use MongoTemplate Instead of MongoRepository?
| Use Case                                        | Prefer            |
| ----------------------------------------------- | ----------------- |
| Simple CRUD, auto queries                       | `MongoRepository` |
| Complex filters, dynamic criteria, aggregations | `MongoTemplate`   |


ğŸ”· REST API Exception handling
In springboot we can handle exception in 2 ways:
| Type                         | Description                                                                 | Scope               |
| ---------------------------- | --------------------------------------------------------------------------- | ------------------- |
| Global Exception Handler | Handles exceptions across all controllers using `@RestControllerAdvice` | Application-wide    |
| Local Exception Handler  | Handles exceptions within a single controller using `@ExceptionHandler` | Controller-specific |

ğŸ”„ Steps:
â¤ Create User Defined Exception class
â¤ Create ExceptionInfo binding class
â¤ Create Rest Controller Advice to handle global exceptions in our application.

Step 1ï¸âƒ£ Create User-Defined Exception Class
This is your custom business exception â€” for example, when a student is not found.

package com.example.exception;

public class StudentNotFoundException extends RuntimeException {
    public StudentNotFoundException(String message) {
        super(message);
    }
}

2ï¸âƒ£ Create ExceptionInfo (Response Model) Class
This class represents the structure of the error response returned to the client.

package com.example.exception;

import java.time.LocalDateTime;
import lombok.AllArgsConstructor;
import lombok.Data;

@AllArgsConstructor
@Data
public class ExceptionInfo {
    private String message;
    private String path;
    private LocalDateTime timestamp;
    private String errorCode;
    
}

ğŸŒ 3ï¸âƒ£ Global Exception Handler â€” @RestControllerAdvice
This handles exceptions for the entire Spring Boot application.
package com.example.exception;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.context.request.WebRequest;

@RestControllerAdvice
public class GlobalExceptionHandler {

    // Handle specific exception
    @ExceptionHandler(StudentNotFoundException.class)
    public ResponseEntity<ExceptionInfo> handleStudentNotFound(StudentNotFoundException ex, WebRequest request) {
        ExceptionInfo info = new ExceptionInfo(
                ex.getMessage(),
                request.getDescription(false),
                "STUDENT_NOT_FOUND"
        );
        return new ResponseEntity<>(info, HttpStatus.NOT_FOUND);
    }

    // Handle all other exceptions (fallback)
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ExceptionInfo> handleGeneralException(Exception ex, WebRequest request) {
        ExceptionInfo info = new ExceptionInfo(
                ex.getMessage(),
                request.getDescription(false),
                "INTERNAL_SERVER_ERROR"
        );
        return new ResponseEntity<>(info, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
ğŸ‘‰ What Happens Here:
â¤ Whenever StudentNotFoundException is thrown in any controller, this advice class catches it.
â¤ It returns a JSON response with details like timestamp, error message, and URL


ğŸ”„ Local Exception Handler (Controller-Specific)
This handles exceptions inside a specific controller only.

package com.example.controller;

import com.example.exception.StudentNotFoundException;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/students")
public class StudentController {

    @GetMapping("/{id}")
    public String getStudent(@PathVariable int id) {
        if (id != 1) {
            throw new StudentNotFoundException("Student with ID " + id + " not found!");
        }
        return "Student Found: Ankur";
    }

    // Local handler â€” only works inside this controller
    @ExceptionHandler(StudentNotFoundException.class)
    public String handleLocalException(StudentNotFoundException ex) {
        return "âš  Local Handler: " + ex.getMessage();
    }
}
ğŸ‘‰ What Happens:
âœ”ï¸ When /api/students/5 is called, it throws StudentNotFoundException.
âœ”ï¸ The local exception handler catches it first (if available).
âœ”ï¸ If not defined locally, then the global handler catches it.

ğŸ§¾ 5ï¸âƒ£ Sample JSON Response (From Global Handler)
{
  "message": "Student with ID 10 not found!",
  "path": "uri=/api/students/10",
  "timestamp": "2025-11-04T15:12:40.305",
  "errorCode": "STUDENT_NOT_FOUND"
}


ğŸ”· DIFFERENCE BETWEEN @ControllerAdvice AND @RestControllerAdvice
Annotation              | Description / Behavior
---------------------------------------------------------------------------------------
@ControllerAdvice        | Used to handle exceptions globally across controllers.
                         | Returns a view name (HTML/JSP) by default.
                         | Typically used in web MVC applications (non-REST).
                         | Must use @ResponseBody on methods to return JSON.
                         | Combines well with @ExceptionHandler, @ModelAttribute, etc.
                         | Example: returns "error-page" view template.

@RestControllerAdvice    | Introduced as a specialized version of @ControllerAdvice.
                         | It combines @ControllerAdvice + @ResponseBody.
                         | All handler methods return JSON or XML automatically.
                         | Ideal for REST APIs (Spring Boot RESTful services).
                         | No need to explicitly add @ResponseBody on methods.
                         | Example: returns JSON error response instead of a view.

---------------------------------------------------------------------------------------

âœ… Example 1 â€” Using @ControllerAdvice (Web MVC)
@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(Exception.class)
    public ModelAndView handleException(Exception ex) {
        ModelAndView mav = new ModelAndView("error");
        mav.addObject("message", ex.getMessage());
        return mav;
    }
}
ğŸ”„ Explanation:
â¤ Used in normal Spring MVC web apps.
â¤ Returns a view page (e.g., error.html or error.jsp).
â¤ If you want JSON, you must manually add @ResponseBody to the method.


âœ… Example 2 â€” Using @RestControllerAdvice (REST API)
@RestControllerAdvice
public class GlobalRestExceptionHandler {

    @ExceptionHandler(Exception.class)
    public ResponseEntity<Map<String, String>> handleAll(Exception ex) {
        Map<String, String> error = new HashMap<>();
        error.put("error", ex.getMessage());
        error.put("status", "500");
        return ResponseEntity.status(500).body(error);
    }
}
ğŸ”„ Explanation:
â¤ Used for REST controllers.
â¤ Automatically converts return values to JSON (no need for @ResponseBody).
â¤ Cleaner and preferred for Spring Boot RESTful APIs.


ğŸ”· REST(Representation State Transfer) Architecture Principles 
1ï¸âƒ£ Client-Server Architecture  
â¤ Separation of concerns between client (frontend/UI) and server (backend).  
â¤ Client handles UI and user interaction; server handles data storage and logic.  
â¤ Enables scalability, modularity, and independent development.

2ï¸âƒ£ Statelessness  
â¤ Each request from client to server must contain all required information.  
â¤ Server does not store any client session data.  
â¤ Improves reliability and scalability since each request is independent.

3ï¸âƒ£ Cacheability  
â¤ Responses must define themselves as cacheable or non-cacheable.  
â¤ Reduces client-server interactions, improves performance.  
â¤ Example: HTTP headers like Cache-Control, ETag.

4ï¸âƒ£ Uniform Interface  
â¤ Common standard way to communicate between client and server.  
â¤ Core of REST design â€” ensures simplicity and decoupling.  
â¤ Includes:
    âœ”ï¸ Resource Identification (using URIs)
    âœ”ï¸ Manipulation of Resources through representations (JSON/XML)
    âœ”ï¸ Self-descriptive messages (metadata in headers)
    âœ”ï¸ HATEOAS (Hypermedia as the Engine of Application State)

5ï¸âƒ£ Layered System  
â¤ Architecture composed of hierarchical layers (client, API gateway, server, DB).  
â¤ Each layer has a specific function and does not need to know othersâ€™ details.  
â¤ Improves scalability and security through load balancers, proxies, etc.

6ï¸âƒ£ Code-on-Demand (Optional)  
â¤ Allows server to send executable code (like JavaScript) to client for execution.  
â¤ Adds flexibility, but rarely used due to security concerns.


ğŸ”· HATEOAS (Hypermedia As The Engine Of Application State)
â¤ HATEOAS is a REST principle that allows a client to dynamically navigate a REST API using hyperlinks provided in the responses.  
â¤ It means that each response from the server includes links (URLs) to related actions or resources â€” guiding the client on what can be done next.

2ï¸âƒ£ Purpose  
â¤ Makes REST APIs more discoverable and self-descriptive.  
â¤ Client does not need hard-coded knowledge of API routes.  
â¤ Reduces coupling between client and server.  
â¤ Enables API evolution without breaking clients.

âœ… Example  
   â¤ Without HATEOAS:
       {
         "id": 1,
         "name": "Ankur",
         "department": "IT"
       }

   â¤ With HATEOAS:
       {
         "id": 1,
         "name": "Ankur",
         "department": "IT",
         "_links": {
           "self": { "href": "http://localhost:8080/api/students/1" },
           "all_students": { "href": "http://localhost:8080/api/students" },
           "update": { "href": "http://localhost:8080/api/students/1" },
           "delete": { "href": "http://localhost:8080/api/students/1" }
         }
       } 
ğŸ”— _links.self â†’ shows the current resource link
ğŸ”— _links.update â†’ tells where to send a PUT request to update
ğŸ”— _links.delete â†’ tells where to send a DELETE request
ğŸ”— _links.all-students â†’ provides link to fetch all students


4ï¸âƒ£ Key Components  
â¤ Resource Representation â†’ The actual data (like student details).  
â¤ Hypermedia Links â†’ Embedded links to related resources/actions.  
â¤ Relation Types â†’ Describe purpose of each link (self, update, delete, etc.)

5ï¸âƒ£ Implementation In Spring Boot  
â¤ Spring provides support via `spring-hateoas` library.  
â¤ You can use classes like:
         âœ”ï¸ EntityModel<T> : wraps a resource and adds links.
         âœ”ï¸ WebMvcLinkBuilder : used to build links to controller methods.

âœ… Example:
         Student student = new Student(1, "Ankur");
         EntityModel<Student> model = EntityModel.of(student);
         model.add(linkTo(methodOn(StudentController.class)
             .getStudentById(1)).withSelfRel());
         model.add(linkTo(methodOn(StudentController.class)
             .getAllStudents()).withRel("all_students"));


ğŸ”„ Benefits of HATEOAS
1ï¸âƒ£ Discoverability
â¤ Clients can discover available actions dynamically through links in the response.
â¤ No need for clients to hardcode URLs â€” they just follow links provided by the server.

2ï¸âƒ£ Reduced Coupling
â¤ Client and server are loosely coupled.
â¤ If server endpoints change, clients still work as long as links in responses are updated.
â¤ Makes APIs easier to evolve without breaking old clients.

3ï¸âƒ£ Self-Descriptive APIs
â¤ Each response contains both data and the available next actions.
â¤ Clients can understand what to do next without additional documentation.

4ï¸âƒ£ Easier Navigation
â¤ Just like browsing a website, the client navigates the API using provided links.
â¤ Example: From a student resource, client can directly get links to update or delete that student.

5ï¸âƒ£ Better Maintainability
â¤ Since clients depend on links, not hardcoded URIs, server changes cause minimal impact.
â¤ Makes long-term maintenance and versioning simpler.

6ï¸âƒ£ Improved Usability
â¤ Helps build intelligent clients that can automatically discover and consume new features.
â¤ Especially useful for large-scale or evolving APIs.


ğŸ”· working of HATEOAS with REST API in springboot

Dependency for HATEOAS project:
spring data jpa
lombok
MySQL Driver
Spring HATEOAS

ğŸ”„ Add Dependency
Add this to your pom.xml:

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-hateoas</artifactId>
</dependency>

ğŸ”„ Create a Simple Entity (Example: Student) Work without extending RepresentationModel class
public class Student {
    private Long id;
    private String name;
    private String course;

    // Constructors, Getters, Setters
}

ğŸ”„ Create a JpaRepository 
package com.example.spring_rest_demo.repository;

import com.example.spring_rest_demo.entity.Student;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.rest.core.annotation.RepositoryRestResource;


@RepositoryRestResource(collectionResourceRel = "students", path = "students")
public interface StudentRepository extends JpaRepository<Student, Long> {}

ğŸ”„ Create a Controller with HATEOAS Support
package com.example.spring_rest_demo.controller;

import com.example.spring_rest_demo.entity.Student;
import com.example.spring_rest_demo.repository.StudentRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.hateoas.EntityModel;
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
@RequestMapping("/students")
@RequiredArgsConstructor
public class StudentController {
    
    private final StudentRepository studentRepository;
    
    @GetMapping("/{id}")
    public EntityModel<Student> getStudents(@PathVariable Long id){
        Student student = studentRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Student not found"));
        EntityModel<Student> studentEntityModel = EntityModel.of(student);


        //Add a self link
        studentEntityModel.add(WebMvcLinkBuilder.linkTo(
                WebMvcLinkBuilder.methodOn(StudentController.class)
                        .getStudents(id)).
                        withSelfRel());

        studentEntityModel.add(WebMvcLinkBuilder.linkTo(WebMvcLinkBuilder.methodOn(
                StudentController.class
        ).
                getAllStudents()).withRel("all-students"));

        return studentEntityModel;
    }

    @GetMapping
    public List<Student> getAllStudents(){
        return studentRepository.findAll();
    }
}


âœ… Example JSON Response
When you hit
ğŸ‘‰ GET http://localhost:8080/students/1

Youâ€™ll get this:

{
    "id": 1,
    "name": "Ankur",
    "course": "Java",
    "_links": {
        "self": {
            "href": "http://localhost:8080/students/1"
        },
        "all-students": {
            "href": "http://localhost:8080/students"
        }
    }
}

ğŸ”„ What Happened Here
â¤ EntityModel<Student> wraps your Student object.
â¤ _links section shows possible navigation options (self, all-students).
â¤ Client doesnâ€™t need to know URL structure â€” it just follows these links.



==================================
ğŸ”· Logging in Spring Boot: SLF4J
==================================
â¤ Logging is an essential aspect of the application development that allows developers to monitor and troubleshoot their applications.

â¤ Spring Boot supports various logging frameworks, such as Logback, Log4J2, and Java Util Logging (JUL) out of the box.

ğŸ”„ understanding frameworks:
1ï¸âƒ£ Logback: A popular logging framework that serves as default in many SpringBoot applications. It offers a flexible configuration and good performance.

2ï¸âƒ£ Log4J2: A logging framework similar to Logback with features such as asynchronous logging and support various output formats.

3ï¸âƒ£ Java Util Logging (JUL): A logging framework that is a part of the Java platform. While it's less feature rich than some third-party frameworks, it is straightforward to use.

4ï¸âƒ£ Log Monitoring Tools
1. Putty -- CLI tool
2. WinScp -- GUI tool
   â¤ Using WinScp we can upload and download files from windows to linux or vice versa using the file explorer.
3. ELK -- GUI tool
    â¤ E = Elasticsearch, L = Logstash, K = Kibana     
4. Splunk(Licensed) -- GUI tool

ğŸ”„ How to Connect to Putty
1ï¸âƒ£ Open Putty CLI in your machine
2ï¸âƒ£ Enter the IP address of your server
4ï¸âƒ£ Enter the port number
5ï¸âƒ£ Enter the username
6ï¸âƒ£ Enter the password
7ï¸âƒ£ Connect
 
Enter the keypair file in Auth --> Credentials and enter the username and password for authentication on linux server and access the log file.

âœ”ï¸ Spring Boot uses Logback as the default logging framework provides a good balance between simplicity and performance.
âœ”ï¸ The default configuration is embedded within the Spring Boot libraries, and it may not be visible in your application's source code.
âœ”ï¸ If you want to customize the logging configuration, you can create your own logback-spring.xml or logback.xml file in the src/main/resources directory.
âœ”ï¸ When SpringBoot detects this file in your project, it will use it instead of the default configuration.

ğŸ”„ Logging Levels
Spring Boot supports the following logging levels:
| Level     | Description             | Example                |
| --------- | ----------------------- | ---------------------- |
| TRACE     | Detailed debugging info | Fine-grained flow logs |
| DEBUG     | Useful for debugging    | Dev-time logs          |
| INFO      | General app flow        | Startup, shutdown      |
| WARN      | Potential issues        | Deprecated method used |
| ERROR     | Errors & exceptions     | DB connection failed   |
| OFF       | Turns off logging       | â€”                      |

We can set the desired logging levels for specific packages or classes, allowing them to control the amount of information logged at runtime.

Spring Boot provides annotations like @Slf4j and @Log4j2 to help with logging, that can be used to automatically inject logger instance


ğŸ”· SLF4J
â¤ SLF4J (Simple Logging Facade for Java) is a logging abstraction layer.
â¤ It provides a common interface for various logging frameworks (Logback, Log4j2, JUL, etc.).
â¤ Spring Boot internally uses SLF4J + Logback by default.
â¤ Think of SLF4J as a â€œuniversal adapterâ€ that lets you switch logging backends easily without changing your application code.

â“ Why Use SLF4J 
â¤ Abstraction layer: decouples logging framework from code.
â¤ Better performance: lazy evaluation of log messages ({} placeholders).
â¤ Integration: widely supported in Spring, Hibernate, etc.
â¤ Flexibility: easily switch from Logback â†’ Log4j2 without code changes.

â“ How Logging Works in Spring Boot
â¤ By defaultSLF4J API is used in code.
â¤ Logback is the underlying implementation.
â¤ Configurations are auto-loaded from:
  âœ”ï¸ application.properties or
  âœ”ï¸ logback-spring.xml

âœ…Example:
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

@Service
public class UserService {
    private static final Logger logger = LoggerFactory.getLogger(UserService.class);

    public void createUser(String name) {
        logger.info("Creating user: {}", name); 
        logger.debug("Debug info while creating user");
        logger.warn("This is a warning message");
        logger.error("Error occurred while creating user");
    }
}
âœ… Output:
Creating user: Mike
Debug info while creating user
This is a warning message
Error occurred while creating user

ğŸ§  Why {} ?
Because SLF4J supports parameterized logging â€” efficient and avoids string concatenation.

ğŸ‘‰ We have to write:
 private static final Logger logger = LoggerFactory.getLogger(UserService.class);
 to use this line of code for every class for logging in Spring Boot.
 âš¡ We have to write log instead of logger in the code as well

 instead of this we can use:
 @Slf4j // annotation provided by lambok library
 @Service
 public class UserService {
     public void createUser(String name) {
         log.info("Creating user: {}", name);
         log.debug("Debug info while creating user");
         log.warn("This is a warning message");
         log.error("Error occurred while creating user");
     }
 }

ğŸ”„ Configure Logging in application.properties

ğŸ”— Code Example:
# Root logging level
logging.level.root=INFO 
ğŸ‘‰ this gives logs for all packages and classes of level info or severe than info i.e trace and debug will never get printed.

# Package-specific level
logging.level.net.engineeringdigest.journalApp=DEBUG

# Log file output
logging.file.name=app.log
logging.file.path=logs/

# Pattern for console output
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n

ğŸ”„ Logging with Profiles
You can set different logging levels for each Spring profile:

ğŸ”— Code Example:
# application-dev.properties
logging.level.root=DEBUG

# application-prod.properties
logging.level.root=ERROR

And activate profile:
spring.profiles.active=dev

ğŸ”„  Access Logs in Code
You can print the active profile in your logs:

ğŸ”— Code Example:
import org.springframework.core.env.Environment;
import org.springframework.beans.factory.annotation.Autowired;

@Autowired
private Environment env;

@PostConstruct
public void init() {
    String activeProfile = env.getActiveProfiles()[0];
    logger.info("Active profile: {}", activeProfile);
}

ğŸ”„ Logback Architecture (Default in Spring Boot)
ğŸ”— Logger â†’ Appender â†’ Layout â†’ Destination

â¤ Logger: The entry point in your code (LoggerFactory.getLogger(...))
â¤ Appender: Defines where to send logs (console, file, socket)
â¤ Layout / Encoder: Defines how the log message looks
â¤ Destination: Final output (file, stdout,+ Database etc.)

ğŸ”„ Configure in logback-spring.xml (Advanced)
When we have application.properties, we should use logback-spring.xml for logging configuration specifically.

ğŸ”— Code Example:
<configuration>

ğŸ‘‰ Console Appender 
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder> // encoder is a formatter for the output 
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger - %msg%n</pattern>
        </encoder>
    </appender>

ğŸ‘‰ File appender
    <appender name="FILE" class="ch.qos.logback.core.FileAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
        <file>PAth_of_the_file</file>
    </appender>
ğŸ‘‰  Database appender use jdbcAppender

ğŸ‘‰ Set the root level and attach the console appender
    <root level="INFO">
        <appender-ref ref="CONSOLE"/>
        <appender-ref ref="FILE"/>
    </root>

ğŸ‘‰ Set the log level for a specific package or classes
    <logger name="net.engineeringdigest.journalApp" level="DEBUG"/>

</configuration>

Understanding structure:
1ï¸âƒ£ <configuration>
<!-- Appender and Logger configuration go here -->
</configuration>
â¤ The <configuration> elements is the root element of the logback.xml file. All logback configuration is enclosed within this element.

ğŸ”„ Patter Syntax:
  âœ”ï¸ %d{yyyy-MM-dd HH:mm:ss} - date and time
  âœ”ï¸ [%thread] - thread name
  âœ”ï¸ %-5level - logging level(left justified text with atmost 5 characters)
  âœ”ï¸ %logger{36} - logger name upto 36 characters
  âœ”ï¸ %msg  %n - message and new line

ğŸ”„ Rolling FileAppender Based on Time
âœ…Example:

<configuration>
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>logs/application-%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>10</maxHistory>
        </rollingPolicy>
    </appender>
</configuration>


ğŸ”„ Rolling FileAppender Based on Size of File
âœ…Example:
<configuration>
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
        <rollingPolicy class="ch.qos.logback.core.rolling.SizeBasedRollingPolicy">
            <maxFileSize>10MB</maxFileSize>
            <maxHistory>10</maxHistory>
        </rollingPolicy>
    </appender>
</configuration>
ğŸ‘‰ Rolling based of size and time can be used at the same time whatever happens first will make logs accordingly.



ğŸ”· SpringBoot Acuators
Spring Boot Actuator is a module provided by Spring Boot that adds production-ready features to your application.
It allows you to monitor and manage your application by exposing endpoints that provide insights into:
âœ”ï¸ Application health
âœ”ï¸ Metrics (like memory usage, HTTP requests, database status)
âœ”ï¸ Environment properties
âœ”ï¸ Logging levels
âœ”ï¸ Thread dumps

Actuators help you observe and manage your Spring Boot application in production or development without writing additional monitoring code.


âš¡ Key Features of Actuator
1ï¸âƒ£ Health Checks
âœ”ï¸ /actuator/health endpoint tells whether the application is up or down.
âœ”ï¸ Can include custom checks (database connection, disk space, etc.).

2ï¸âƒ£ Metrics
âœ”ï¸ /actuator/metrics endpoint shows JVM stats, HTTP requests, memory usage, garbage collection, etc.
âœ”ï¸ Useful for performance monitoring.

3ï¸âƒ£ Environment Info
/actuator/env endpoint shows environment variables, system properties, and application configuration properties.

4ï¸âƒ£ Application Info
/actuator/info endpoint allows you to add custom metadata like version, description, or author.

5ï¸âƒ£ Loggers
/actuator/loggers endpoint lets you view and modify logging levels at runtime.

6ï¸âƒ£ Thread Dumps
/actuator/threaddump provides a thread dump of the JVM for debugging purposes.

7ï¸âƒ£ HTTP Tracing
Tracks recent HTTP requests and responses.

8ï¸âƒ£ Integration with Monitoring Tools
Works with Prometheus, Grafana, New Relic, or Spring Boot Admin for full monitoring dashboards.

âœ”ï¸ All these actuators endpoints are predefined and they are binded to HTTP GET requests.
âœ”ï¸ In Actuator we have a special endpoint called /shutdown which is used to shutdown the application.
âœ”ï¸ This endpoint is binded to HTTP POST requests.

ğŸ”„ Why Use Spring Boot Actuatorâ“
1ï¸âƒ£ Production-Ready Monitoring
Helps detect problems early in production.

2ï¸âƒ£ Simplifies Maintenance
No need to manually write monitoring code for common checks.

3ï¸âƒ£ Customizable
You can add your own health indicators, metrics, and info details.

4ï¸âƒ£ Secure
Endpoints can be restricted using Spring Security.


ğŸ”„ How to Add Actuator to a Spring Boot Project
1ï¸âƒ£ Add Dependency in pom.xml:
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>

2ï¸âƒ£ Configure Endpoints (Optional)
By default, only a few endpoints are exposed (/health and /info).
You can expose more endpoints in application.properties or application.yml:

# Expose all actuator endpoints
management.endpoints.web.exposure.include=*

# Exclude health endpoint
management.endpoints.web.exposure.exclude=health

# Customize server port for actuator
management.server.port=8081

# Show detailed info in health endpoint
management.endpoint.health.show-details=always

# Enable shutdown endpoint
management.endpoint.shutdown.enabled=true


3ï¸âƒ£ Access Actuator Endpoints
| Endpoint               | Purpose                         |
| ---------------------- | ------------------------------- |
| `/actuator/health`     | Shows application health status |
| `/actuator/info`       | Shows custom app info           |
| `/actuator/metrics`    | Shows JVM and HTTP metrics      |
| `/actuator/env`        | Shows environment properties    |
| `/actuator/loggers`    | View/change log levels          |
| `/actuator/threaddump` | Thread dump of JVM              |
| `/actuator/httptrace`  | Recent HTTP requests            |


4ï¸âƒ£ Customizing Health Indicator
You can create a custom health check by implementing HealthIndicator:
import org.springframework.boot.actuate.health.Health;
import org.springframework.boot.actuate.health.HealthIndicator;
import org.springframework.stereotype.Component;

@Component
public class DatabaseHealthCheck implements HealthIndicator {

    @Override
    public Health health() {
        // Imagine checking database connection
        boolean dbUp = checkDatabaseConnection();
        if (dbUp) {
            return Health.up().withDetail("Database", "Available").build();
        } else {
            return Health.down().withDetail("Database", "Not Available").build();
        }
    }

    private boolean checkDatabaseConnection() {
        // Logic to check DB connectivity
        return true;
    }
}
Now, when you hit /actuator/health, it will show something like:
{
  "status": "UP",
  "components": {
    "db": {
      "status": "UP",
      "details": {
        "database": "MySQL",
        "validationQuery": "isValid()"
      }
    },
    "diskSpace": {
      "status": "UP",
      "details": {
        "total": 131071995904,
        "free": 104784420864,
        "threshold": 10485760,
        "path": "D:\\Microservices_practice\\.",
        "exists": true
      }
    },
    "ping": {
      "status": "UP"
    },
    "ssl": {
      "status": "UP",
      "details": {
        "validChains": [],
        "invalidChains": []
      }
    }
  }
}


5ï¸âƒ£ Security Consideration
â¤ Actuator endpoints are sensitive (they expose internal info).
â¤ Secure them using Spring Security:

# Require authentication for all actuator endpoints
management.endpoints.web.exposure.include=*

# Require authentication for health endpoint 
management.endpoint.health.show-details=when-authorized 
ğŸ‘‰ without adding security when we access /actuator/health we will only:
{
    status: "UP"
}

