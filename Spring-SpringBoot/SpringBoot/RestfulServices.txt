üî∑ Distributed Application
A distributed application is an application where components are spread across multiple computers (nodes) connected through a network, but they work together as a single system.
‚û§ They are used for Business to Business commnication unlike web applciaton communicate with Business to Client (C2B).

‚öôÔ∏è Key Idea:
Instead of all logic running on one server (like in a monolithic app), different parts ‚Äî frontend, backend, databases, microservices, etc. ‚Äî run on different machines or locations and communicate via network protocols (like HTTP, RPC, or gRPC).

‚úÖ Example: E-commerce Application
‚û§ Frontend (React app) ‚Üí runs on user‚Äôs browser.
‚û§ Backend API (Spring Boot) ‚Üí runs on AWS server.
‚û§ Database (MySQL) ‚Üí runs on a separate database server.
‚û§ Payment service (third-party) ‚Üí hosted externally.

All these parts interact to form one working e-commerce platform ‚Äî that‚Äôs a distributed application.

üîÑ Characteristics:
‚û§ Multiple independent nodes (different machines).
‚û§ Communication over network (e.g., REST, gRPC).
‚û§ Data sharing and synchronization between components.
‚û§ Scalability ‚Äì you can scale specific services independently.
‚û§ Fault tolerance ‚Äì if one node fails, others can still run.

üß± Architecture Examples:
‚û§ Client‚ÄìServer (basic distributed system)
‚û§ 3-Tier Architecture (UI, Application Server, Database)
‚û§ Microservices Architecture (each service deployed independently)
‚û§ Cloud-Native Applications (services running across data centers)

üß∞ Technologies Used:
‚û§ APIs / REST / gRPC for communication
‚û§ Message Queues (Kafka, RabbitMQ) for async communication
‚û§ Databases like MongoDB, Cassandra (distributed data)
‚û§ Load Balancers for traffic distribution
‚û§ Containers / Kubernetes for deployment

üîÅ Another Scenario of Distributed Application
‚úÖExample:MMT ‚Üî IRCTC ‚Äî A Real Distributed Interaction Example
‚û§ Both MMT (MakeMyTrip) and IRCTC are independent distributed systems,
but they interact with each other over a network to complete a single user request.
‚û§ That interaction itself makes the overall system ‚Äî the combination of MMT + IRCTC + users ‚Äî a larger distributed ecosystem.
‚û§ MMT doesn‚Äôt own the train data ‚Äî it connects to IRCTC‚Äôs distributed system through APIs.
‚û§ Both systems communicate and cooperate over the internet, while users experience it as one smooth platform.
‚û§ XML and JSON data will be used as mediaters to transfer data between MMT and IRCTC.


üî∑ Intereoperability
‚û§ The term interoperability refers to the ability of two or more systems to work together, even if they are not built for the same purpose or use the same architecture.
‚û§ It is a way to ensure that different systems can communicate and exchange data with each other, even if they are built using different technologies or have different interfaces.


üî∑ XML
XML (eXtensible Markup Language) is a markup language used to store and transport data in a structured, human-readable, and machine-readable format.

‚úÖ Example:
<Student>  -------------> compound eleement containing other elements
    <Name>Ankur Verma</Name>--------> simple element
    <RollNo>101</RollNo>
    <Branch>Information Technology</Branch>
</Student>
üëâ This stores structured data about a student ‚Äî not for displaying (like HTML), but for data exchange.

üîÑ Key Features:
‚û§ Self-descriptive ‚Äì Tags describe the data.
‚û§ Custom tags ‚Äì You can define your own (unlike HTML‚Äôs fixed tags).
‚û§ Platform-independent ‚Äì Works across systems and languages.
‚û§ Hierarchical structure ‚Äì Data stored in parent‚Äìchild format.
‚û§ Supports validation ‚Äì You can define structure rules using:
‚û§ DTD (Document Type Definition)
‚û§ XSD (XML Schema Definition)

üîÑ Common Uses:
‚û§ Configuration files (e.g., web.xml in Java web apps)
‚û§ Data exchange between systems (SOAP APIs, web services)
‚û§ Document storage (e.g., Office files internally use XML)
‚û§Serialization (saving objects in XML format)


üî∑ JAXB (Java Architecture for XML Binding) ‚Äî also called JAX-B API
‚úîÔ∏è JAXB is a Java API that allows you to convert Java objects into XML (marshalling) and XML back into Java objects (unmarshalling) easily.

‚úîÔ∏è It‚Äôs part of the Jakarta / Java EE (formerly JAX-B) stack and simplifies XML handling in Java applications ‚Äî no manual parsing required.

Upto Java 1.8 JAXB was part of the Java SE platform but removed from Java 1.9 version if you want to use should have a jax-b dependency.

üîÑ Core Operations:
1Ô∏è‚É£ Marshalling: Converts Java objects into XML.
2Ô∏è‚É£ Unmarshalling: Converts XML into Java objects.
3Ô∏è‚É£ Binding: Maps Java classes to XML elements and attributes.
4Ô∏è‚É£ Validation: Validates XML against a schema.
5Ô∏è‚É£ Schema Generation: Generates XML schemas from Java classes.

‚úÖ Example: 1Ô∏è‚É£ Create a java class
import jakarta.xml.bind.annotation.XmlElement;
import jakarta.xml.bind.annotation.XmlRootElement;

@XmlRootElement(name = "student")
public class Student {
    private String name;
    private int rollNo;

    // Default constructor (required by JAXB)
    public Student() {}

    public Student(String name, int rollNo) {
        this.name = name;
        this.rollNo = rollNo;
    }

    @XmlElement
    public String getName() {
        return name;
    }

    @XmlElement
    public int getRollNo() {
        return rollNo;
    }
}

2Ô∏è‚É£ Marshalling(Java --> XML)
import jakarta.xml.bind.JAXBContext;
import jakarta.xml.bind.Marshaller;

public class MarshallExample {
    public static void main(String[] args) throws Exception {
        Student s = new Student("Ankur Verma", 101);
        JAXBContext context = JAXBContext.newInstance(Student.class);
        Marshaller marshaller = context.createMarshaller();
        marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
        marshaller.marshal(s, System.out); // prints XML to console
    }
}
‚úÖ Output XML:
<student>
    <name>Ankur Verma</name>
    <rollNo>101</rollNo>
</student>

3Ô∏è‚É£ Unmarshalling(XML --> Java)
import jakarta.xml.bind.Unmarshaller;
import java.io.File;

public class UnmarshallExample {
    public static void main(String[] args) throws Exception {
        JAXBContext context = JAXBContext.newInstance(Student.class);
        Unmarshaller unmarshaller = context.createUnmarshaller();
        Student s = (Student) unmarshaller.unmarshal(new File("student.xml"));
        System.out.println(s.getName() + " - " + s.getRollNo());
    }
}
‚úÖ Output:
Ankur Verma - 101

üîÑ Real-World Use Cases:
‚û§ Converting XML payloads in SOAP web services
‚û§ Reading/writing config files in XML
‚û§ Data exchange between Java systems via XML
‚û§ Used in Spring Boot (for XML-based request/response mapping)


üî∑ JSON (JavaScript Object Notation)
JSON is a lightweight data-interchange format used to store and exchange data between a client and a server.

It‚Äôs language-independent, but easily readable by both humans and machines.

‚úÖ Example:
{
  "name": "Ankur Verma",
  "rollNo": 101,
  "branch": "Information Technology"
}

üîÑ Key Features of JSON:
‚û§ Lightweight ‚Äì smaller and faster than XML
‚û§ Easy to parse ‚Äì simple key-value structure
‚û§ Language-independent
‚û§ Key-value pair format
‚û§ Used widely in REST APIs
‚û§ Supports basic data types: string, number, boolean, array, object, null

üîÑJSON in Java (Working & Usage)
Java doesn‚Äôt have built-in JSON support, but several popular libraries make it easy to convert between Java objects and JSON:

Common libraries:
‚û§ Jackson (most popular, used by Spring Boot)
‚û§ Gson (by Google)
‚û§ org.json

1Ô∏è‚É£ Using Jackson Library (Most Common in Spring Boot)
‚úÖ Example of Java Class:
public class Student {
    private String name;
    private int rollNo;

    public Student() {}
    public Student(String name, int rollNo) {
        this.name = name;
        this.rollNo = rollNo;
    }

    // Getters and setters
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public int getRollNo() { return rollNo; }
    public void setRollNo(int rollNo) { this.rollNo = rollNo; }
}

üåÄ Object ‚Üí JSON (Serialization)
import com.fasterxml.jackson.databind.ObjectMapper;

public class ObjectToJson {
    public static void main(String[] args) throws Exception {
        Student s = new Student("Ankur Verma", 101);
        ObjectMapper mapper = new ObjectMapper();

        String jsonString = mapper.writeValueAsString(s);
        // for adding the json to a file
        // mapper.writeValue(new File("student.json"), s);
        System.out.println(jsonString);
    }
}

‚úÖ Output:
{"name":"Ankur Verma","rollNo":101}

üîÅ JSON ‚Üí Object (Deserialization)
public class JsonToObject {
    public static void main(String[] args) throws Exception {
        String jsonString = "{\"name\":\"Ankur Verma\",\"rollNo\":101}";
        ObjectMapper mapper = new ObjectMapper();

        Student s = mapper.readValue(jsonString, Student.class);
        System.out.println(s.getName() + " - " + s.getRollNo());
    }
}
‚úÖ Output:
Ankur Verma - 101

2Ô∏è‚É£ Using Gson Library (Alternative)
import com.google.gson.Gson;

public class GsonExample {
    public static void main(String[] args) {
        Student s = new Student("Ankur", 101);
        Gson gson = new Gson();

        // Object ‚Üí JSON
        String json = gson.toJson(s);
        System.out.println(json);

        // JSON ‚Üí Object
        Student obj = gson.fromJson(json, Student.class);
        System.out.println(obj.getName());
    }
}

Spring Boot automatically uses Jackson internally for JSON conversion.

üîÑ Real-World Use Cases:
‚û§ Reading/writing config files in JSON
‚û§ Data exchange between Java systems via JSON


üî∑ HTTP protocol
‚û§ HTTP (HyperText Transfer Protocol) is a client-server communication protocol used for transmitting data over the web.
‚û§ It defines how messages are formatted and transmitted, and how web servers and browsers should respond to various commands.
‚û§ It is a stateless protocol. It will treat each request independently.


‚ùìHow It Works
‚û§ Client sends a request ‚Üí (e.g., a web browser or REST client sends an HTTP request to the server).
‚û§ Server processes the request ‚Üí The web server receives the request, processes it, and prepares a response.
‚û§ Server sends back a response ‚Üí The server returns an HTTP response (status code + data).
‚û§ Connection may close (in HTTP/1.1 or remain open for HTTP/2 and HTTP/3).

üåü Basic Structure
1Ô∏è‚É£ HTTP Request Structure
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Chrome/108.0
Accept: text/html


2Ô∏è‚É£ HTTP Response Structure
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 1234

<html>
<body>Hello, World!</body>
</html>

üîÑ Common HTTP Methods
| Method     | Description                                       |
| ---------- | ------------------------------------------------- |
| GET    | Retrieve data from the server (no body).          |
| POST   | Send data to the server (used for creating data). |
| PUT    | Update existing resource completely.              |
| PATCH  | Update part of a resource.                        |
| DELETE | Delete a resource.                                |
| HEAD   | Same as GET but returns only headers.             |

=====================
üîπ HTTP Status Codes
======================

‚û§ An HTTP status code is a three-digit numeric code returned by a web server as parto of the response to an HTTP request made by a client.
‚û§ These status codes are used to convey information about the result or status of the requested operation.
‚û§ HTTP status codes are grouped into five categories based on the first digit of the code:
1Ô∏è‚É£ 1xx (Informational): These status codes indicate that the request was received and understood, and the server is continuing to process it.
These are typically used for informational purposes and are not commonly seen in everyday web interactions.

2Ô∏è‚É£ 2xx (Successful): These status codes indicate that the request was successfully received, understood, and accepted by the server.
  ‚úîÔ∏è 200 OK: The request has been successfully processed, and the server is returning the requested resource.
  ‚úîÔ∏è 201 Created: The request has been fulfilled, resulting in the creation of a new resource.
  ‚úîÔ∏è 204 No Content: The request has been fulfilled, but there is no response body(typically used for operation that don't return data, like a DELETE request).

3Ô∏è‚É£ 3xx (Redirection): These status codes indicate that further action is needed to complete the request. These are used when the client needs to take additional steps to access the requested resource.
  ‚úîÔ∏è 301 Moved Permanently: The requested resource has been permanently moved to a new URL.
  ‚úîÔ∏è 302 Found: The requested resource is temporarily located at a different URL.When server sends a response with a 302 status code, it typically includes a Location header that specifies the new URL where the resource can be found. The client is expected to make a new request to this URL to access the resource.
  ‚úîÔ∏è 304 Not Modified: The resource has not been modified since the last request. The client can use its cached version.

4Ô∏è‚É£ 4xx (Client Error): It indicates that there was an error on the client's side, such as malformed request or authentication issues.
  ‚úîÔ∏è 400 Bad Request: The server cannot process the request due to client error (e.g., malformed request syntax).
  ‚úîÔ∏è 401 Unauthorized: Authentication is required and has failed or has not yet been provided.
  ‚úîÔ∏è 403 Forbidden: The server understands the request but refuses to authorize it.
  ‚úîÔ∏è 404 Not Found: The requested resource could not be found on the server.

5Ô∏è‚É£ 5xx (Server Error): The server failed to fulfill a valid request.
  ‚úîÔ∏è 500 Internal Server Error: A generic error message indicating that the server encountered an unexpected condition.
  ‚úîÔ∏è 502 Bad Gateway: The server received an invalid response from an inbound server while acting as a gateway or proxy.
  ‚úîÔ∏è 503 Service Unavailable: The server is currently unable to handle the request due to temporary overload or maintenance.

| Code Range | Meaning       | Example                        |
| ---------- | ------------- | ------------------------------ |
| 1xx    | Informational | 100 Continue                   |
| 2xx    | Success       | 200 OK, 201 Created            |
| 3xx    | Redirection   | 301 Moved Permanently          |
| 4xx    | Client Error  | 400 Bad Request, 404 Not Found |
| 5xx    | Server Error  | 500 Internal Server Error      |

üîÑ Features
‚û§ Stateless: Each request is independent; no session info is stored by default.
‚û§ Text-based: Human-readable request and response format.
‚û§ Extensible: Supports custom headers, cookies, and authentication.
‚û§ Uses TCP (Port 80) or HTTPS (Port 443) for secure communication.


üî∑ HTTP Request and HTTP Response
1Ô∏è‚É£ HTTP Request
An HTTP request is a message sent by the client (like a browser or app) to ask the server to perform an action ‚Äî such as fetching data, submitting a form, or deleting a record.

üîÑ Structure of an HTTP Request
Method  URL  Protocol-Version
Headers
(blank line)
Body (optional)

‚úÖ Example:
GET /users?id=10 HTTP/1.1
Host: example.com
User-Agent: Chrome/121.0
Accept: application/json

üîÑ Main Components:
‚û§ Request Line
    ‚úîÔ∏è Includes HTTP method, URL, and HTTP version.
    ‚úÖ Example: GET /home HTTP/1.1
‚û§ Headers
    ‚úîÔ∏è Provide additional info like content type, authentication, etc.
    ‚úÖ Example:
            Content-Type: application/json
            Authorization: Bearer token123
‚û§ Body (Optional)
    ‚úîÔ∏è Carries data with requests like POST, PUT, or PATCH.
    ‚úÖ Example:
        {
          "name": "Ankur",
          "email": "ankur@gmail.com"
        }

2Ô∏è‚É£ HTTP Response
An HTTP response is the message sent by the server back to the client after processing the request.



üî∑ Headers in HTTP
‚û§ HTTP Headers are key-value pairs sent between the client and server in an HTTP request or response.
‚û§ They carry metadata about the request/response ‚Äî such as content type, authorization token, user agent, etc.

‚úÖ Example of Common HTTP Headers
GET /api/weather HTTP/1.1
Host: api.weatherstack.com
Authorization: Bearer abc123
Content-Type: application/json
User-Agent: PostmanRuntime/7.32.2

üëâ Here:
    ‚úîÔ∏è Authorization ‚Üí carries credentials or API keys
    ‚úîÔ∏è Content-Type ‚Üí tells the server the data format (JSON, XML, etc.)
    ‚úîÔ∏è User-Agent ‚Üí describes the client making the request

üî∑ Pass Headers in Code (Spring Boot using RestTemplate)
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

@Service
public class WeatherService {

    private static final String API = "https://api.weatherstack.com/current?access_key={key}&query={city}";

    private final RestTemplate restTemplate = new RestTemplate();

    public WeatherResponse getWeather(String apiKey, String city) {

        // 1Ô∏è‚É£ Create headers
        HttpHeaders headers = new HttpHeaders();
        headers.set("Accept", "application/json"); // tells server to respond in JSON
        headers.set("User-Agent", "SpringBootApp");
        headers.set("Authorization", "Bearer some_token_here"); // example of passing token

        // 2Ô∏è‚É£ Build HttpEntity (headers + body)
        HttpEntity<String> entity = new HttpEntity<>(headers);

        // 3Ô∏è‚É£ Send request
        ResponseEntity<WeatherResponse> response = restTemplate.exchange(
                API,
                HttpMethod.GET,
                entity,                // includes headers
                WeatherResponse.class,
                apiKey, city           // replaces placeholders in URL
        );

        // 4Ô∏è‚É£ Return only body
        return response.getBody();
    }
}


üîÑ Sending Headers + Body in a POST request
String url = "https://api.example.com/users";

// 1Ô∏è‚É£ Create headers
HttpHeaders headers = new HttpHeaders();
headers.setContentType(MediaType.APPLICATION_JSON);
headers.set("Authorization", "Bearer xyz123");

// 2Ô∏è‚É£ Create request body
User user = new User("Ankur", "ankur@example.com");

// 3Ô∏è‚É£ Combine headers and body
HttpEntity<User> entity = new HttpEntity<>(user, headers);

// 4Ô∏è‚É£ Make POST request
ResponseEntity<String> response = restTemplate.exchange(
        url,
        HttpMethod.POST,
        entity,
        String.class
);

üîÑ Key Classes for HTTP Headers in Spring
| Class                   | Description                                        |
| ----------------------- | -------------------------------------------------- |
| `HttpHeaders            | Represents HTTP header values                      |
| `HttpEntity<T           | Represents request entity (headers + body)         |
| `ResponseEntity<T       | Represents the response (status, headers, body)    |
| `MediaType              | Helps specify content type like `application/json` |


üîÑ Common HTTP Headers and Their Purposes
| Header          | Purpose                                                           |
| --------------- | ----------------------------------------------------------------- |
| `Content-Type`  | Tells server what type of data is being sent (`application/json`) |
| `Accept`        | Tells server what response format client expects                  |
| `Authorization` | Sends tokens, API keys, or credentials                            |
| `User-Agent`    | Identifies client making the request                              |
| `Cache-Control` | Caching policies                                                  |
| `Custom-Header` | You can define your own headers                                   |


üîÑ Structure of an HTTP Response
Protocol-Version Status-Code Status-Message
Headers
(blank line)
Body (optional)

‚úÖ Example:
HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 47
{
  "id": 10,
  "name": "Ankur",
  "email": "ankur@gmail.com"
}

üîÑ Main Components:
‚û§ Status Line
‚úÖ Example: HTTP/1.1 200 OK
    üîó Includes:
        ‚úîÔ∏è HTTP version (HTTP/1.1)
        ‚úîÔ∏è Status code (200)
        ‚úîÔ∏è Status message (OK)
‚û§ Headers
    ‚úîÔ∏è Give info about the response.
    ‚úÖ Example:
        Content-Type: text/html
        Cache-Control: no-cache
‚û§ Body (Optional)
    ‚úîÔ∏è Contains the actual data (HTML, JSON, XML, etc.)

üîÑ Request‚ÄìResponse Flow Example
üîó Client (Browser):
    GET /products HTTP/1.1
    Host: www.shop.com

üîó Server (Response):
    HTTP/1.1 200 OK
    Content-Type: application/json
    [{"id":1,"name":"Laptop","price":50000}]


üî∑ Media Types in Rest API
‚û§ A Media Type (or MIME type) tells the format of data being sent or received in an HTTP message.
‚û§ It helps the client and server understand how to interpret the request or response body.

üí° Syntax: type/subtype

‚úÖ Examples:
| Media Type            | Description           |
| --------------------- | --------------------- |
| `application/json`    | JSON data             |
| `application/xml`     | XML data              |
| `text/html`           | HTML content          |
| `text/plain`          | Plain text            |
| `multipart/form-data` | Used for file uploads |
| `application/pdf`     | PDF file              |


1Ô∏è‚É£ Media Type in HTTP Request
When a client sends data (like in a POST or PUT request), it uses the Content-Type header to specify the format.
‚úÖ Example:
POST /api/users HTTP/1.1
Content-Type: application/json

{
  "name": "Ankur",
  "email": "ankur@gmail.com"
}
‚û°Ô∏è This tells the server that the body is in JSON format.

2Ô∏è‚É£ Media Type in HTTP Response
The server uses the Content-Type header to tell the client what type of data it‚Äôs returning.
‚úÖ Example:
HTTP/1.1 200 OK
Content-Type: application/json

{
  "status": "success",
  "id": 101
}
‚û°Ô∏è This tells the client that the response body is JSON.

3Ô∏è‚É£ Content Negotiation in REST APIs
In REST, the client can tell the server which format it accepts using the Accept header.
‚úÖ Example:
GET /api/users HTTP/1.1
Accept: application/json
‚úîÔ∏è The client says: ‚ÄúI want the response in JSON.‚Äù
‚úîÔ∏è The server will then return data in JSON format (if supported).

‚û§ If the client instead says:
Accept: application/xml

‚û§ The server can respond with:
Content-Type: application/xml


4Ô∏è‚É£ Media Types in Spring Boot REST APIs
In Spring Boot, you can specify media types using:
‚û§ @RequestMapping, @PostMapping, @GetMapping etc.
@RestController
@RequestMapping("/api")
public class UserController {

    @PostMapping(
        value = "/users",
        consumes = "application/json",     // Request body format 
        produces = "application/json"      // Response format
    )
    // can provide multiple values for the consumes and produces
    public ResponseEntity<User> addUser(@RequestBody User user) {
        return ResponseEntity.ok(user);
    }
}

‚úÖ consumes ‚Üí tells what type of input the API accepts
‚úÖ produces ‚Üí tells what type of output the API returns

üìã Common Media Types in REST APIs
| Media Type                          | Use                            |
| ----------------------------------- | ------------------------------ |
| `application/json`                  | Most common for REST APIs      |
| `application/xml`                   | Used in SOAP or XML-based APIs |
| `text/plain`                        | Simple text data               |
| `multipart/form-data`               | File uploads (e.g. image, PDF) |
| `application/x-www-form-urlencoded` | HTML form submissions          |


‚ö° Real-World Example
‚úÖ Request:
POST /upload HTTP/1.1
Content-Type: multipart/form-data
Accept: application/json

‚úÖ Response:
HTTP/1.1 200 OK
Content-Type: application/json
{"message": "File uploaded successfully!"}



üî∑ Rest Client Development
A REST Client is a tool, library, or component that allows you to send HTTP requests (GET, POST, PUT, DELETE, etc.) to a REST API and receive responses ‚Äî typically used to test, consume, or interact with RESTful web services.

A REST Client acts as a consumer of REST APIs.
It sends HTTP requests to the server (REST API endpoint) and reads the HTTP responses returned.

In springboot we can develop REST Client using 3 ways:
1Ô∏è‚É£ Using RestTemplate (Synchrnous Communication: sending request and wating for response then processing other requests)
2Ô∏è‚É£ Using WebClient (Synchrnous + Asynchrnous Communication)
3Ô∏è‚É£ Using Feign

üîÑ Example in Real Life
‚û§ When you use Postman, you‚Äôre using a REST Client application to test APIs.
‚û§ When a frontend app (React, Angular, Flutter) calls an API using fetch() or axios, those are REST Client libraries making HTTP calls.

‚úÖ Example - Java REST Client Using RestTemplate
import org.springframework.web.client.RestTemplate;
import org.springframework.http.ResponseEntity;


üîÑ Working of RestTemplate
‚û§ RestTemplate is a class provided by Spring Framework that acts as a synchronous REST client.
‚û§ It allows your Spring application to make HTTP requests (GET, POST, PUT, DELETE) to consume REST APIs.

‚û§ Think of it as your Java-based Postman ‚Äî but used inside your application code.

2Ô∏è‚É£ When to Use It
‚û§ You use RestTemplate when:
    ‚úîÔ∏è Your Spring app wants to call another REST API (either external or internal).
    ‚úîÔ∏è You need to integrate multiple microservices.
    ‚úîÔ∏è You want to send or receive JSON data programmatically

3Ô∏è‚É£ How It Works Internally
Here‚Äôs the internal flow:

[Your Spring App] ‚Üí (RestTemplate) ‚Üí [HTTP Request] ‚Üí [Target REST API] 
‚Üí [Response] ‚Üí (RestTemplate parses it) ‚Üí [Java Object or String]

‚úÖ Example Flow:
You call:
restTemplate.getForObject("https://jsonplaceholder.typicode.com/posts/1", Post.class);
‚Üí It makes a GET request to that URL
‚Üí Gets the JSON response
‚Üí Converts it automatically into a Post Java object using Jackson JSON Mapper

‚úÖ Example:
Let's say we have StudentService and a client Service that calls it.

üîó StudentController.java (Server/API Provider)
package com.example.demo.controller;

import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/students")
public class StudentController {

    @GetMapping("/{id}")
    public Student getStudent(@PathVariable int id) {
        return new Student(id, "Ankur Verma", "IT");
    }
}

üîó StudentService.java 
package com.example.demo.request;
@Data
class Student {
    private int id;
    private String name;
    private String department;
}

üîó StudentClient.java (Consumer using RestTemplate)
package com.example.demo.client;

import org.springframework.http.ResponseEntity;
import org.springframework.web.client.RestTemplate;
import org.springframework.stereotype.Component;

@Component
public class StudentClient {

    private final RestTemplate restTemplate = new RestTemplate();

    public void getStudentDetails() {
        String url = "http://localhost:8080/api/students/1";

        // Make GET request and receive response as Student object
        ResponseEntity<Student> response = restTemplate.getForEntity(url, Student.class);

        // Print response
        System.out.println("Status Code: " + response.getStatusCode());
        System.out.println("Student Details:");
        System.out.println("ID: " + response.getBody().getId());
        System.out.println("Name: " + response.getBody().getName());
        System.out.println("Department: " + response.getBody().getDepartment());
    }
}

// Student model (same structure as in API)
@Data
class Student {
    private int id;
    private String name;
    private String department;
}

üîÑ Running the Example
‚û§ Run the StudentController application (port 8080).
‚Üí It exposes an endpoint:
GET http://localhost:8080/api/students/1

‚û§ Run StudentClient class (it can be in another app or in same app).
‚Üí It makes a GET call using RestTemplate.

‚úÖ You‚Äôll see output like:
Status Code: 200 OK
Student Details:
ID: 1
Name: Ankur Verma
Department: IT


Commonly Used RestTemplate Methods
| Method                            | Purpose                                                  | Example                                                   |
| --------------------------------- | -------------------------------------------------------- | --------------------------------------------------------- |
| `getForObject(url, class)`        | GET request and returns object directly                  | `restTemplate.getForObject(url, Student.class)`           |
| `getForEntity(url, class)`        | GET request and returns `ResponseEntity` (status + body) | `restTemplate.getForEntity(url, Student.class)`           |
| `postForObject(url, body, class)` | POST request and returns created object                  | `restTemplate.postForObject(url, student, Student.class)` |
| `postForEntity(url, body, class)` | POST request returning full response                     | `restTemplate.postForEntity(url, student, Student.class)` |
| `put(url, body)`                  | PUT request (no return)                                  | `restTemplate.put(url, student)`                          |
| `delete(url)`                     | DELETE request                                           | `restTemplate.delete(url)`                                |


üî∑ WebClient
‚û§ WebClient is part of Spring WebFlux, a reactive web framework introduced in Spring 5.
‚û§ It is used to make asynchronous, non-blocking HTTP requests to REST APIs.

üëâ Think of it as:
A reactive, lightweight, and flexible version of RestTemplate

üîÑ Why WebClient Was Introduced
‚û§ RestTemplate (older client) works in a blocking manner ‚Äî
that means each thread waits for the response before continuing.
‚û§ In contrast, WebClient is non-blocking ‚Äî
it can handle many requests concurrently with fewer threads, improving performance and scalability.

üîÑ Key Features of WebClient
| Feature                      | Description                                                               |
| ---------------------------- | ------------------------------------------------------------------------- |
| Reactive (Non-blocking)  | Uses Project Reactor (`Mono` and `Flux`) for async programming.           |
| Lightweight              | Doesn‚Äôt depend on Servlet API. Works in both Spring MVC and WebFlux apps. |
| Supports Streaming       | Can handle continuous data streams (e.g., SSE, WebSockets).               |
| Functional API           | Fluent builder-style syntax for constructing requests.                    |
| Can Replace RestTemplate | Fully supports GET, POST, PUT, DELETE, etc.                               |


üîÑ When to Use WebClient
‚úîÔ∏è When building reactive or high-performance applications.
‚úîÔ∏è When handling multiple concurrent API calls.
‚úîÔ∏è When you need to stream data (e.g., continuous updates).
‚úîÔ∏è When you‚Äôre using Spring WebFlux or microservices.

üîÑ Basic Syntax
WebClient webClient = WebClient.create("http://localhost:8080");

Mono<Student> studentMono = webClient.get()
    .uri("/api/students/1")
    .retrieve()
    .bodyToMono(Student.class);
Mono<Student> is a reactive type that represents one asynchronous result (like a Future<Student>).


üîÑ WebClient vs RestTemplate
| Feature                   | `RestTemplate`                  | `WebClient`                 |
| ------------------------- | ------------------------------- | --------------------------- |
| Introduced In         | Spring 3                        | Spring 5 (WebFlux)          |
| Type                  | Synchronous (Blocking)          | Asynchronous (Non-blocking) |
| Performance           | Slower (one thread per request) | Faster (reactive model)     |
| Reactive Support      | ‚ùå No                            | ‚úÖ Yes                       |
| Streaming Support     | ‚ùå No                            | ‚úÖ Yes                       |
| Recommended By Spring | Deprecated (for new apps)       | ‚úÖ Official Replacement      |


Maven dependency for WebClient:
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-webflux</artifactId>
</dependency>

‚û§ spring-boot-starter-web --> class
‚û§ spring-boot-starter-webflux --> interface

üîÑ Reactive Concepts Used
1Ô∏è‚É£ Mono<T> ‚Üí represents 0 or 1 asynchronous result (like one Student).
2Ô∏è‚É£ Flux<T> ‚Üí represents 0 or many asynchronous results (like list of Students).

‚úÖ Example:
Flux<Student> students = webClient.get()
    .uri("/api/students")
    .retrieve()
    .bodyToFlux(Student.class);

üîÑ Real-World Use Case Example
Let‚Äôs say you have a Student Service that needs to call another Course Service.

@Service
public class StudentService {

    private final WebClient webClient = WebClient.create("http://course-service:8081");

    public Mono<Course> getCourseDetails(int studentId) {
        return webClient.get()
                .uri("/api/courses/student/{id}", studentId)
                .retrieve()
                .bodyToMono(Course.class);
    }
}
‚úÖ Non-blocking, so the thread doesn‚Äôt wait for the response ‚Äî
it can handle hundreds of concurrent API calls efficiently.


üî∑ Spring Data REST
‚û§ Spring Data REST is a module of the Spring Data project that automatically exposes RESTful APIs for your Spring Data Repositories ‚Äî without writing any controller code.

‚û§ If you already have a JpaRepository, Spring Data REST will automatically create REST endpoints (GET, POST, PUT, DELETE) for you.

üîÑ How It Works
When you include the dependency spring-boot-starter-data-rest, Spring Boot:
‚û§ Scans your repositories (like StudentRepository).
‚û§ Automatically creates REST endpoints under /entities or your custom path.
‚û§ Converts Java entities to JSON responses.
‚û§ Handles CRUD operations and pagination by default.

üîÑ What to Add while making project:
‚û§ Spring Data JPA
‚û§ Rest Repositories
‚û§ MySQL Driver

üîÑ Dependency
üëâ Add this dependency in your pom.xml:

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-rest</artifactId>
</dependency>
‚ö° (You must also have spring-boot-starter-data-jpa and a database driver like mysql-connector-java.)

‚úÖ Example: Exposing Student Repository as REST API
1Ô∏è‚É£ Entity Class
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;

@Entity
public class Student {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private String course;

    // getters and setters
}

2Ô∏è‚É£ Repository Interface
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.rest.core.annotation.RepositoryRestResource;

@RepositoryRestResource(path = "students")
public interface StudentRepository extends JpaRepository<Student, Long> {
}
‚úÖ The @RepositoryRestResource(path = "students") annotation tells Spring Data REST to expose this repository as a REST resource under /students.

3Ô∏è‚É£ Run the Application
When you start your Spring Boot app, Spring Data REST automatically generates endpoints like:
| HTTP Method | Endpoint         | Description                        |
| ----------- | ---------------- | ---------------------------------- |
| GET     | `/students`      | Get all students (with pagination) |
| GET     | `/students/{id}` | Get student by ID                  |
| POST    | `/students`      | Create a new student               |
| PUT     | `/students/{id}` | Update an existing student         |
| DELETE  | `/students/{id}` | Delete student by ID               |

‚úÖ Example Request & Response
üëâ POST Request:
POST /students
Content-Type: application/json
{
  "name": "Ankur Verma",
  "course": "B.Tech IT"
}

üëâ Response:
{
  "id": 1,
  "name": "Ankur Verma",
  "course": "B.Tech IT"
}

üîÑ Customization Options
| Annotation                               | Purpose                                                               |
| ---------------------------------------- | --------------------------------------------------------------------- |
| `@RepositoryRestResource`                | Customize path, collection name, and relation name.                   |
| `@RestResource`                          | Customize endpoint exposure for specific methods.                     |
| `@Projection`                            | Control what fields are shown in REST responses.                      |
| `@ExcerptProjection`                     | Show summarized data when listing entities.                           |
| `@HandleBeforeSave` / `@HandleAfterSave` | Add custom logic (like events) before or after repository operations. |


‚úÖ Example of Customization
@RepositoryRestResource(collectionResourceRel = "learners", path = "students")
public interface StudentRepository extends JpaRepository<Student, Long> {

    @RestResource(path = "byName", rel = "byName")
    List<Student> findByNameContaining(@Param("name") String name);
}
üëâ Now you can access:
For findBy queries we have to add /search to the path, for example:
GET /students/search/byName?name=Ankur

üîÑ Internals & Concepts
‚û§ Spring Data REST uses HAL (Hypertext Application Language) format by default for HATEOAS links.
‚û§ Uses Spring MVC under the hood, but you don‚Äôt need to write controllers.
‚û§ It‚Äôs built on Spring Data Repositories, so all query methods automatically become endpoints.

üîÑ Advantages
‚úÖ No need to write boilerplate controller code.
‚úÖ Automatic CRUD and pagination.
‚úÖ HATEOAS support for navigable APIs.
‚úÖ Integrates easily with JPA, MongoDB, Neo4j, etc.
‚úÖ Easy to customize endpoints and data projections.

üîÑ When Not to Use
‚û§ If your API requires complex business logic or custom response structures.
‚û§ If you need authentication, role-based access, or API versioning ‚Äî then you‚Äôd better write custom controllers.

üîÑ Goal
Restrict or disable specific HTTP methods (like POST, PUT, or DELETE) for certain entities when using Spring Data REST.

1Ô∏è‚É£ Create Configuration Class
You‚Äôll use RepositoryRestConfigurer to customize repository exposure.

package com.example.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.data.rest.core.config.RepositoryRestConfiguration;
import org.springframework.data.rest.webmvc.config.RepositoryRestConfigurer;
import org.springframework.http.HttpMethod;

import com.example.entity.Student;

@Configuration
public class RestRepositoryConfig implements RepositoryRestConfigurer {

    @Override
    public void configureRepositoryRestConfiguration(RepositoryRestConfiguration config) {

        // Disable HTTP methods for Student entity: PUT, POST, DELETE
        HttpMethod[] unsupportedActions = {HttpMethod.PUT, HttpMethod.POST, HttpMethod.DELETE};

        // Apply restrictions
        config.getExposureConfiguration()
                .forDomainType(Student.class)
                .withItemExposure((metadata, httpMethods) ->
                        httpMethods.disable(unsupportedActions))
                .withCollectionExposure((metadata, httpMethods) ->
                        httpMethods.disable(unsupportedActions));
    }
}


üîÑ Apply Restrictions to Multiple Entities
You can restrict multiple repositories easily:

config.getExposureConfiguration()
        .forDomainType(Student.class)
        .withItemExposure((metadata, httpMethods) -> httpMethods.disable(unsupportedActions))
        .withCollectionExposure((metadata, httpMethods) -> httpMethods.disable(unsupportedActions));

config.getExposureConfiguration()
        .forDomainType(Course.class)
        .withItemExposure((metadata, httpMethods) -> httpMethods.disable(unsupportedActions))
        .withCollectionExposure((metadata, httpMethods) -> httpMethods.disable(unsupportedActions));

üîÑ Optional ‚Äî Expose Entity IDs in JSON
By default, Spring Data REST hides entity IDs.
You can expose them in the same config class:

config.exposeIdsFor(Student.class);


=========================================================
üî∑ MongoTemplate, Criteria, and Query in Spring Boot
==========================================================
‚û§ MongoTemplate is a core class in Spring Data MongoDB that provides:
    ‚úîÔ∏è Fine-grained control over queries,
    ‚úîÔ∏è Custom query building (beyond @Query or repository methods),
    ‚úîÔ∏è Access to MongoDB‚Äôs full query and aggregation power.
üëâ It‚Äôs similar to how JdbcTemplate works for relational databases.

‚úÖ Example:
  @Autowired
    private MongoTemplate mongoTemplate;

    public List<User> getUserForSentimentAnalysis() {
        Query query = new Query();
        query.addCriteria(Criteria.where("userName").is("Ram"));
        return mongoTemplate.find(query, User.class);

    }

‚û§ MongoTemplate is auto-configured by Spring Boot if MongoDB connection details exist in application.properties.
‚û§ Using @Autowired injects the template, allowing you to directly interact with the MongoDB database.

Query query = new Query();
üëâ Creates a blank query object that can be configured with filters, sort, projection, etc.

query.addCriteria(Criteria.where("userName").is("Ram"));
üëâ Builds a filter condition using Criteria.

This is equivalent to MongoDB‚Äôs JSON query:
{ "userName": "Ram" }
üëâ You can chain multiple criteria using .and(), .orOperator(), .gt(), etc.

return mongoTemplate.find(query, User.class);
‚û§ Executes the query on the User collection (Spring automatically maps the class to the MongoDB collection).
‚û§ Converts each matching MongoDB document into a User Java object.
‚û§ Returns a List<User>

‚úÖ Extended Examples: Find by multiple fields:
Query query = new Query();
query.addCriteria(Criteria.where("userName").is("Ram").and("age").gte(25));
List<User> users = mongoTemplate.find(query, User.class);

‚úÖ Example: Using OR condition
Query query = new Query();
query.addCriteria(new Criteria().orOperator(
    Criteria.where("userName").is("Ram"),
    Criteria.where("email").is("ram@ram")
));
List<User> users = mongoTemplate.find(query, User.class);

‚ùì Why Use MongoTemplate Instead of MongoRepository?
| Use Case                                        | Prefer            |
| ----------------------------------------------- | ----------------- |
| Simple CRUD, auto queries                       | `MongoRepository` |
| Complex filters, dynamic criteria, aggregations | `MongoTemplate`   |


üî∑ REST API Exception handling
In springboot we can handle exception in 2 ways:
| Type                         | Description                                                                 | Scope               |
| ---------------------------- | --------------------------------------------------------------------------- | ------------------- |
| Global Exception Handler | Handles exceptions across all controllers using `@RestControllerAdvice` | Application-wide    |
| Local Exception Handler  | Handles exceptions within a single controller using `@ExceptionHandler` | Controller-specific |

üîÑ Steps:
‚û§ Create User Defined Exception class
‚û§ Create ExceptionInfo binding class
‚û§ Create Rest Controller Advice to handle global exceptions in our application.

Step 1Ô∏è‚É£ Create User-Defined Exception Class
This is your custom business exception ‚Äî for example, when a student is not found.

package com.example.exception;

public class StudentNotFoundException extends RuntimeException {
    public StudentNotFoundException(String message) {
        super(message);
    }
}

2Ô∏è‚É£ Create ExceptionInfo (Response Model) Class
This class represents the structure of the error response returned to the client.

package com.example.exception;

import java.time.LocalDateTime;
import lombok.AllArgsConstructor;
import lombok.Data;

@AllArgsConstructor
@Data
public class ExceptionInfo {
    private String message;
    private String path;
    private LocalDateTime timestamp;
    private String errorCode;
    
}

üåê 3Ô∏è‚É£ Global Exception Handler ‚Äî @RestControllerAdvice
This handles exceptions for the entire Spring Boot application.
package com.example.exception;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.context.request.WebRequest;

@RestControllerAdvice
public class GlobalExceptionHandler {

    // Handle specific exception
    @ExceptionHandler(StudentNotFoundException.class)
    public ResponseEntity<ExceptionInfo> handleStudentNotFound(StudentNotFoundException ex, WebRequest request) {
        ExceptionInfo info = new ExceptionInfo(
                ex.getMessage(),
                request.getDescription(false),
                "STUDENT_NOT_FOUND"
        );
        return new ResponseEntity<>(info, HttpStatus.NOT_FOUND);
    }

    // Handle all other exceptions (fallback)
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ExceptionInfo> handleGeneralException(Exception ex, WebRequest request) {
        ExceptionInfo info = new ExceptionInfo(
                ex.getMessage(),
                request.getDescription(false),
                "INTERNAL_SERVER_ERROR"
        );
        return new ResponseEntity<>(info, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
üëâ What Happens Here:
‚û§ Whenever StudentNotFoundException is thrown in any controller, this advice class catches it.
‚û§ It returns a JSON response with details like timestamp, error message, and URL


üîÑ Local Exception Handler (Controller-Specific)
This handles exceptions inside a specific controller only.

package com.example.controller;

import com.example.exception.StudentNotFoundException;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/students")
public class StudentController {

    @GetMapping("/{id}")
    public String getStudent(@PathVariable int id) {
        if (id != 1) {
            throw new StudentNotFoundException("Student with ID " + id + " not found!");
        }
        return "Student Found: Ankur";
    }

    // Local handler ‚Äî only works inside this controller
    @ExceptionHandler(StudentNotFoundException.class)
    public String handleLocalException(StudentNotFoundException ex) {
        return "‚ö† Local Handler: " + ex.getMessage();
    }
}
üëâ What Happens:
‚úîÔ∏è When /api/students/5 is called, it throws StudentNotFoundException.
‚úîÔ∏è The local exception handler catches it first (if available).
‚úîÔ∏è If not defined locally, then the global handler catches it.

üßæ 5Ô∏è‚É£ Sample JSON Response (From Global Handler)
{
  "message": "Student with ID 10 not found!",
  "path": "uri=/api/students/10",
  "timestamp": "2025-11-04T15:12:40.305",
  "errorCode": "STUDENT_NOT_FOUND"
}


üî∑ DIFFERENCE BETWEEN @ControllerAdvice AND @RestControllerAdvice
Annotation              | Description / Behavior
---------------------------------------------------------------------------------------
@ControllerAdvice        | Used to handle exceptions globally across controllers.
                         | Returns a view name (HTML/JSP) by default.
                         | Typically used in web MVC applications (non-REST).
                         | Must use @ResponseBody on methods to return JSON.
                         | Combines well with @ExceptionHandler, @ModelAttribute, etc.
                         | Example: returns "error-page" view template.

@RestControllerAdvice    | Introduced as a specialized version of @ControllerAdvice.
                         | It combines @ControllerAdvice + @ResponseBody.
                         | All handler methods return JSON or XML automatically.
                         | Ideal for REST APIs (Spring Boot RESTful services).
                         | No need to explicitly add @ResponseBody on methods.
                         | Example: returns JSON error response instead of a view.

---------------------------------------------------------------------------------------

‚úÖ Example 1 ‚Äî Using @ControllerAdvice (Web MVC)
@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(Exception.class)
    public ModelAndView handleException(Exception ex) {
        ModelAndView mav = new ModelAndView("error");
        mav.addObject("message", ex.getMessage());
        return mav;
    }
}
üîÑ Explanation:
‚û§ Used in normal Spring MVC web apps.
‚û§ Returns a view page (e.g., error.html or error.jsp).
‚û§ If you want JSON, you must manually add @ResponseBody to the method.


‚úÖ Example 2 ‚Äî Using @RestControllerAdvice (REST API)
@RestControllerAdvice
public class GlobalRestExceptionHandler {

    @ExceptionHandler(Exception.class)
    public ResponseEntity<Map<String, String>> handleAll(Exception ex) {
        Map<String, String> error = new HashMap<>();
        error.put("error", ex.getMessage());
        error.put("status", "500");
        return ResponseEntity.status(500).body(error);
    }
}
üîÑ Explanation:
‚û§ Used for REST controllers.
‚û§ Automatically converts return values to JSON (no need for @ResponseBody).
‚û§ Cleaner and preferred for Spring Boot RESTful APIs.


üî∑ REST(Representation State Transfer) Architecture Principles 
1Ô∏è‚É£ Client-Server Architecture  
‚û§ Separation of concerns between client (frontend/UI) and server (backend).  
‚û§ Client handles UI and user interaction; server handles data storage and logic.  
‚û§ Enables scalability, modularity, and independent development.

2Ô∏è‚É£ Statelessness  
‚û§ Each request from client to server must contain all required information.  
‚û§ Server does not store any client session data.  
‚û§ Improves reliability and scalability since each request is independent.

3Ô∏è‚É£ Cacheability  
‚û§ Responses must define themselves as cacheable or non-cacheable.  
‚û§ Reduces client-server interactions, improves performance.  
‚û§ Example: HTTP headers like Cache-Control, ETag.

4Ô∏è‚É£ Uniform Interface  
‚û§ Common standard way to communicate between client and server.  
‚û§ Core of REST design ‚Äî ensures simplicity and decoupling.  
‚û§ Includes:
    ‚úîÔ∏è Resource Identification (using URIs)
    ‚úîÔ∏è Manipulation of Resources through representations (JSON/XML)
    ‚úîÔ∏è Self-descriptive messages (metadata in headers)
    ‚úîÔ∏è HATEOAS (Hypermedia as the Engine of Application State)

5Ô∏è‚É£ Layered System  
‚û§ Architecture composed of hierarchical layers (client, API gateway, server, DB).  
‚û§ Each layer has a specific function and does not need to know others‚Äô details.  
‚û§ Improves scalability and security through load balancers, proxies, etc.

6Ô∏è‚É£ Code-on-Demand (Optional)  
‚û§ Allows server to send executable code (like JavaScript) to client for execution.  
‚û§ Adds flexibility, but rarely used due to security concerns.


üî∑ HATEOAS (Hypermedia As The Engine Of Application State)
‚û§ HATEOAS is a REST principle that allows a client to dynamically navigate a REST API using hyperlinks provided in the responses.  
‚û§ It means that each response from the server includes links (URLs) to related actions or resources ‚Äî guiding the client on what can be done next.

2Ô∏è‚É£ Purpose  
‚û§ Makes REST APIs more discoverable and self-descriptive.  
‚û§ Client does not need hard-coded knowledge of API routes.  
‚û§ Reduces coupling between client and server.  
‚û§ Enables API evolution without breaking clients.

‚úÖ Example  
   ‚û§ Without HATEOAS:
       {
         "id": 1,
         "name": "Ankur",
         "department": "IT"
       }

   ‚û§ With HATEOAS:
       {
         "id": 1,
         "name": "Ankur",
         "department": "IT",
         "_links": {
           "self": { "href": "http://localhost:8080/api/students/1" },
           "all_students": { "href": "http://localhost:8080/api/students" },
           "update": { "href": "http://localhost:8080/api/students/1" },
           "delete": { "href": "http://localhost:8080/api/students/1" }
         }
       } 
üîó _links.self ‚Üí shows the current resource link
üîó _links.update ‚Üí tells where to send a PUT request to update
üîó _links.delete ‚Üí tells where to send a DELETE request
üîó _links.all-students ‚Üí provides link to fetch all students


4Ô∏è‚É£ Key Components  
‚û§ Resource Representation ‚Üí The actual data (like student details).  
‚û§ Hypermedia Links ‚Üí Embedded links to related resources/actions.  
‚û§ Relation Types ‚Üí Describe purpose of each link (self, update, delete, etc.)

5Ô∏è‚É£ Implementation In Spring Boot  
‚û§ Spring provides support via `spring-hateoas` library.  
‚û§ You can use classes like:
         ‚úîÔ∏è EntityModel<T> : wraps a resource and adds links.
         ‚úîÔ∏è WebMvcLinkBuilder : used to build links to controller methods.

‚úÖ Example:
         Student student = new Student(1, "Ankur");
         EntityModel<Student> model = EntityModel.of(student);
         model.add(linkTo(methodOn(StudentController.class)
             .getStudentById(1)).withSelfRel());
         model.add(linkTo(methodOn(StudentController.class)
             .getAllStudents()).withRel("all_students"));


üîÑ Benefits of HATEOAS
1Ô∏è‚É£ Discoverability
‚û§ Clients can discover available actions dynamically through links in the response.
‚û§ No need for clients to hardcode URLs ‚Äî they just follow links provided by the server.

2Ô∏è‚É£ Reduced Coupling
‚û§ Client and server are loosely coupled.
‚û§ If server endpoints change, clients still work as long as links in responses are updated.
‚û§ Makes APIs easier to evolve without breaking old clients.

3Ô∏è‚É£ Self-Descriptive APIs
‚û§ Each response contains both data and the available next actions.
‚û§ Clients can understand what to do next without additional documentation.

4Ô∏è‚É£ Easier Navigation
‚û§ Just like browsing a website, the client navigates the API using provided links.
‚û§ Example: From a student resource, client can directly get links to update or delete that student.

5Ô∏è‚É£ Better Maintainability
‚û§ Since clients depend on links, not hardcoded URIs, server changes cause minimal impact.
‚û§ Makes long-term maintenance and versioning simpler.

6Ô∏è‚É£ Improved Usability
‚û§ Helps build intelligent clients that can automatically discover and consume new features.
‚û§ Especially useful for large-scale or evolving APIs.


üî∑ working of HATEOAS with REST API in springboot

Dependency for HATEOAS project:
spring data jpa
lombok
MySQL Driver
Spring HATEOAS

üîÑ Add Dependency
Add this to your pom.xml:

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-hateoas</artifactId>
</dependency>

üîÑ Create a Simple Entity (Example: Student) Work without extending RepresentationModel class
public class Student {
    private Long id;
    private String name;
    private String course;

    // Constructors, Getters, Setters
}

üîÑ Create a JpaRepository 
package com.example.spring_rest_demo.repository;

import com.example.spring_rest_demo.entity.Student;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.rest.core.annotation.RepositoryRestResource;


@RepositoryRestResource(collectionResourceRel = "students", path = "students")
public interface StudentRepository extends JpaRepository<Student, Long> {}

üîÑ Create a Controller with HATEOAS Support
package com.example.spring_rest_demo.controller;

import com.example.spring_rest_demo.entity.Student;
import com.example.spring_rest_demo.repository.StudentRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.hateoas.EntityModel;
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
@RequestMapping("/students")
@RequiredArgsConstructor
public class StudentController {
    
    private final StudentRepository studentRepository;
    
    @GetMapping("/{id}")
    public EntityModel<Student> getStudents(@PathVariable Long id){
        Student student = studentRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Student not found"));
        EntityModel<Student> studentEntityModel = EntityModel.of(student);


        //Add a self link
        studentEntityModel.add(WebMvcLinkBuilder.linkTo(
                WebMvcLinkBuilder.methodOn(StudentController.class)
                        .getStudents(id)).
                        withSelfRel());

        studentEntityModel.add(WebMvcLinkBuilder.linkTo(WebMvcLinkBuilder.methodOn(
                StudentController.class
        ).
                getAllStudents()).withRel("all-students"));

        return studentEntityModel;
    }

    @GetMapping
    public List<Student> getAllStudents(){
        return studentRepository.findAll();
    }
}


‚úÖ Example JSON Response
When you hit
üëâ GET http://localhost:8080/students/1

You‚Äôll get this:

{
    "id": 1,
    "name": "Ankur",
    "course": "Java",
    "_links": {
        "self": {
            "href": "http://localhost:8080/students/1"
        },
        "all-students": {
            "href": "http://localhost:8080/students"
        }
    }
}

üîÑ What Happened Here
‚û§ EntityModel<Student> wraps your Student object.
‚û§ _links section shows possible navigation options (self, all-students).
‚û§ Client doesn‚Äôt need to know URL structure ‚Äî it just follows these links.



==================================
üî∑ Logging in Spring Boot: SLF4J
==================================
‚û§ Logging is an essential aspect of the application development that allows developers to monitor and troubleshoot their applications.

‚û§ Spring Boot supports various logging frameworks, such as Logback, Log4J2, and Java Util Logging (JUL) out of the box.

üîÑ understanding frameworks:
1Ô∏è‚É£ Logback: A popular logging framework that serves as default in many SpringBoot applications. It offers a flexible configuration and good performance.

2Ô∏è‚É£ Log4J2: A logging framework similar to Logback with features such as asynchronous logging and support various output formats.

3Ô∏è‚É£ Java Util Logging (JUL): A logging framework that is a part of the Java platform. While it's less feature rich than some third-party frameworks, it is straightforward to use.

4Ô∏è‚É£ Log Monitoring Tools
1. Putty -- CLI tool
2. WinScp -- GUI tool
   ‚û§ Using WinScp we can upload and download files from windows to linux or vice versa using the file explorer.
3. ELK -- GUI tool
    ‚û§ E = Elasticsearch, L = Logstash, K = Kibana     
4. Splunk(Licensed) -- GUI tool

üîÑ How to Connect to Putty
1Ô∏è‚É£ Open Putty CLI in your machine
2Ô∏è‚É£ Enter the IP address of your server
4Ô∏è‚É£ Enter the port number
5Ô∏è‚É£ Enter the username
6Ô∏è‚É£ Enter the password
7Ô∏è‚É£ Connect
 
Enter the keypair file in Auth --> Credentials and enter the username and password for authentication on linux server and access the log file.

‚úîÔ∏è Spring Boot uses Logback as the default logging framework provides a good balance between simplicity and performance.
‚úîÔ∏è The default configuration is embedded within the Spring Boot libraries, and it may not be visible in your application's source code.
‚úîÔ∏è If you want to customize the logging configuration, you can create your own logback-spring.xml or logback.xml file in the src/main/resources directory.
‚úîÔ∏è When SpringBoot detects this file in your project, it will use it instead of the default configuration.

üîÑ Logging Levels
Spring Boot supports the following logging levels:
| Level     | Description             | Example                |
| --------- | ----------------------- | ---------------------- |
| TRACE     | Detailed debugging info | Fine-grained flow logs |
| DEBUG     | Useful for debugging    | Dev-time logs          |
| INFO      | General app flow        | Startup, shutdown      |
| WARN      | Potential issues        | Deprecated method used |
| ERROR     | Errors & exceptions     | DB connection failed   |
| OFF       | Turns off logging       | ‚Äî                      |

We can set the desired logging levels for specific packages or classes, allowing them to control the amount of information logged at runtime.

Spring Boot provides annotations like @Slf4j and @Log4j2 to help with logging, that can be used to automatically inject logger instance


üî∑ SLF4J
‚û§ SLF4J (Simple Logging Facade for Java) is a logging abstraction layer.
‚û§ It provides a common interface for various logging frameworks (Logback, Log4j2, JUL, etc.).
‚û§ Spring Boot internally uses SLF4J + Logback by default.
‚û§ Think of SLF4J as a ‚Äúuniversal adapter‚Äù that lets you switch logging backends easily without changing your application code.

‚ùì Why Use SLF4J 
‚û§ Abstraction layer: decouples logging framework from code.
‚û§ Better performance: lazy evaluation of log messages ({} placeholders).
‚û§ Integration: widely supported in Spring, Hibernate, etc.
‚û§ Flexibility: easily switch from Logback ‚Üí Log4j2 without code changes.

‚ùì How Logging Works in Spring Boot
‚û§ By defaultSLF4J API is used in code.
‚û§ Logback is the underlying implementation.
‚û§ Configurations are auto-loaded from:
  ‚úîÔ∏è application.properties or
  ‚úîÔ∏è logback-spring.xml

‚úÖExample:
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

@Service
public class UserService {
    private static final Logger logger = LoggerFactory.getLogger(UserService.class);

    public void createUser(String name) {
        logger.info("Creating user: {}", name); 
        logger.debug("Debug info while creating user");
        logger.warn("This is a warning message");
        logger.error("Error occurred while creating user");
    }
}
‚úÖ Output:
Creating user: Mike
Debug info while creating user
This is a warning message
Error occurred while creating user

üß† Why {} ?
Because SLF4J supports parameterized logging ‚Äî efficient and avoids string concatenation.

üëâ We have to write:
 private static final Logger logger = LoggerFactory.getLogger(UserService.class);
 to use this line of code for every class for logging in Spring Boot.
 ‚ö° We have to write log instead of logger in the code as well

 instead of this we can use:
 @Slf4j // annotation provided by lambok library
 @Service
 public class UserService {
     public void createUser(String name) {
         log.info("Creating user: {}", name);
         log.debug("Debug info while creating user");
         log.warn("This is a warning message");
         log.error("Error occurred while creating user");
     }
 }

üîÑ Configure Logging in application.properties

üîó Code Example:
# Root logging level
logging.level.root=INFO 
üëâ this gives logs for all packages and classes of level info or severe than info i.e trace and debug will never get printed.

# Package-specific level
logging.level.net.engineeringdigest.journalApp=DEBUG

# Log file output
logging.file.name=app.log
logging.file.path=logs/

# Pattern for console output
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n

üîÑ Logging with Profiles
You can set different logging levels for each Spring profile:

üîó Code Example:
# application-dev.properties
logging.level.root=DEBUG

# application-prod.properties
logging.level.root=ERROR

And activate profile:
spring.profiles.active=dev

üîÑ  Access Logs in Code
You can print the active profile in your logs:

üîó Code Example:
import org.springframework.core.env.Environment;
import org.springframework.beans.factory.annotation.Autowired;

@Autowired
private Environment env;

@PostConstruct
public void init() {
    String activeProfile = env.getActiveProfiles()[0];
    logger.info("Active profile: {}", activeProfile);
}

üîÑ Logback Architecture (Default in Spring Boot)
üîó Logger ‚Üí Appender ‚Üí Layout ‚Üí Destination

‚û§ Logger: The entry point in your code (LoggerFactory.getLogger(...))
‚û§ Appender: Defines where to send logs (console, file, socket)
‚û§ Layout / Encoder: Defines how the log message looks
‚û§ Destination: Final output (file, stdout,+ Database etc.)

üîÑ Configure in logback-spring.xml (Advanced)
When we have application.properties, we should use logback-spring.xml for logging configuration specifically.

üîó Code Example:
<configuration>

üëâ Console Appender 
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder> // encoder is a formatter for the output 
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger - %msg%n</pattern>
        </encoder>
    </appender>

üëâ File appender
    <appender name="FILE" class="ch.qos.logback.core.FileAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
        <file>PAth_of_the_file</file>
    </appender>
üëâ  Database appender use jdbcAppender

üëâ Set the root level and attach the console appender
    <root level="INFO">
        <appender-ref ref="CONSOLE"/>
        <appender-ref ref="FILE"/>
    </root>

üëâ Set the log level for a specific package or classes
    <logger name="net.engineeringdigest.journalApp" level="DEBUG"/>

</configuration>

Understanding structure:
1Ô∏è‚É£ <configuration>
<!-- Appender and Logger configuration go here -->
</configuration>
‚û§ The <configuration> elements is the root element of the logback.xml file. All logback configuration is enclosed within this element.

üîÑ Patter Syntax:
  ‚úîÔ∏è %d{yyyy-MM-dd HH:mm:ss} - date and time
  ‚úîÔ∏è [%thread] - thread name
  ‚úîÔ∏è %-5level - logging level(left justified text with atmost 5 characters)
  ‚úîÔ∏è %logger{36} - logger name upto 36 characters
  ‚úîÔ∏è %msg  %n - message and new line

üîÑ Rolling FileAppender Based on Time
‚úÖExample:

<configuration>
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>logs/application-%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>10</maxHistory>
        </rollingPolicy>
    </appender>
</configuration>


üîÑ Rolling FileAppender Based on Size of File
‚úÖExample:
<configuration>
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
        <rollingPolicy class="ch.qos.logback.core.rolling.SizeBasedRollingPolicy">
            <maxFileSize>10MB</maxFileSize>
            <maxHistory>10</maxHistory>
        </rollingPolicy>
    </appender>
</configuration>
üëâ Rolling based of size and time can be used at the same time whatever happens first will make logs accordingly.



üî∑ SpringBoot Acuators
Spring Boot Actuator is a module provided by Spring Boot that adds production-ready features to your application.
It allows you to monitor and manage your application by exposing endpoints that provide insights into:
‚úîÔ∏è Application health
‚úîÔ∏è Metrics (like memory usage, HTTP requests, database status)
‚úîÔ∏è Environment properties
‚úîÔ∏è Logging levels
‚úîÔ∏è Thread dumps

Actuators help you observe and manage your Spring Boot application in production or development without writing additional monitoring code.


‚ö° Key Features of Actuator
1Ô∏è‚É£ Health Checks
‚úîÔ∏è /actuator/health endpoint tells whether the application is up or down.
‚úîÔ∏è Can include custom checks (database connection, disk space, etc.).

2Ô∏è‚É£ Metrics
‚úîÔ∏è /actuator/metrics endpoint shows JVM stats, HTTP requests, memory usage, garbage collection, etc.
‚úîÔ∏è Useful for performance monitoring.

3Ô∏è‚É£ Environment Info
/actuator/env endpoint shows environment variables, system properties, and application configuration properties.

4Ô∏è‚É£ Application Info
/actuator/info endpoint allows you to add custom metadata like version, description, or author.

5Ô∏è‚É£ Loggers
/actuator/loggers endpoint lets you view and modify logging levels at runtime.

6Ô∏è‚É£ Thread Dumps
/actuator/threaddump provides a thread dump of the JVM for debugging purposes.

7Ô∏è‚É£ HTTP Tracing
Tracks recent HTTP requests and responses.

8Ô∏è‚É£ Integration with Monitoring Tools
Works with Prometheus, Grafana, New Relic, or Spring Boot Admin for full monitoring dashboards.

‚úîÔ∏è All these actuators endpoints are predefined and they are binded to HTTP GET requests.
‚úîÔ∏è In Actuator we have a special endpoint called /shutdown which is used to shutdown the application.
‚úîÔ∏è This endpoint is binded to HTTP POST requests.

üîÑ Why Use Spring Boot Actuator‚ùì
1Ô∏è‚É£ Production-Ready Monitoring
Helps detect problems early in production.

2Ô∏è‚É£ Simplifies Maintenance
No need to manually write monitoring code for common checks.

3Ô∏è‚É£ Customizable
You can add your own health indicators, metrics, and info details.

4Ô∏è‚É£ Secure
Endpoints can be restricted using Spring Security.


üîÑ How to Add Actuator to a Spring Boot Project
1Ô∏è‚É£ Add Dependency in pom.xml:
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>

2Ô∏è‚É£ Configure Endpoints (Optional)
By default, only a few endpoints are exposed (/health and /info).
You can expose more endpoints in application.properties or application.yml:

# Expose all actuator endpoints
management.endpoints.web.exposure.include=*

# Exclude health endpoint
management.endpoints.web.exposure.exclude=health

# Customize server port for actuator
management.server.port=8081

# Show detailed info in health endpoint
management.endpoint.health.show-details=always

# Enable shutdown endpoint
management.endpoint.shutdown.enabled=true


3Ô∏è‚É£ Access Actuator Endpoints
| Endpoint               | Purpose                         |
| ---------------------- | ------------------------------- |
| `/actuator/health`     | Shows application health status |
| `/actuator/info`       | Shows custom app info           |
| `/actuator/metrics`    | Shows JVM and HTTP metrics      |
| `/actuator/env`        | Shows environment properties    |
| `/actuator/loggers`    | View/change log levels          |
| `/actuator/threaddump` | Thread dump of JVM              |
| `/actuator/httptrace`  | Recent HTTP requests            |


4Ô∏è‚É£ Customizing Health Indicator
You can create a custom health check by implementing HealthIndicator:
import org.springframework.boot.actuate.health.Health;
import org.springframework.boot.actuate.health.HealthIndicator;
import org.springframework.stereotype.Component;

@Component
public class DatabaseHealthCheck implements HealthIndicator {

    @Override
    public Health health() {
        // Imagine checking database connection
        boolean dbUp = checkDatabaseConnection();
        if (dbUp) {
            return Health.up().withDetail("Database", "Available").build();
        } else {
            return Health.down().withDetail("Database", "Not Available").build();
        }
    }

    private boolean checkDatabaseConnection() {
        // Logic to check DB connectivity
        return true;
    }
}
Now, when you hit /actuator/health, it will show something like:
{
  "status": "UP",
  "components": {
    "db": {
      "status": "UP",
      "details": {
        "database": "MySQL",
        "validationQuery": "isValid()"
      }
    },
    "diskSpace": {
      "status": "UP",
      "details": {
        "total": 131071995904,
        "free": 104784420864,
        "threshold": 10485760,
        "path": "D:\\Microservices_practice\\.",
        "exists": true
      }
    },
    "ping": {
      "status": "UP"
    },
    "ssl": {
      "status": "UP",
      "details": {
        "validChains": [],
        "invalidChains": []
      }
    }
  }
}


5Ô∏è‚É£ Security Consideration
‚û§ Actuator endpoints are sensitive (they expose internal info).
‚û§ Secure them using Spring Security:

# Require authentication for all actuator endpoints
management.endpoints.web.exposure.include=*

# Require authentication for health endpoint 
management.endpoint.health.show-details=when-authorized 
üëâ without adding security when we access /actuator/health we will only:
{
    status: "UP"
}

