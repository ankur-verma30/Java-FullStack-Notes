=============
ğŸ”· Monolith
=============
â¤ A monolith is a single deployable unit that contain the entire application(business logic, database interactions, UI etc.).
â¤ Common misconception: Monolith not equals to single machine.
1. A monolith can scale horizontally over multiple servers.
2. Still, it is a single codebase, tightly coupled and deployed together.


âœ… Advantages of Monoliths
| Benefit                    | Explanation                                                                         |
| ---------------------------| ----------------------------------------------------------------------------------- |
| ğŸ‘¥ Ideal for Small Teams  | Easier to manage with limited developers. Lower overhead in coordination.           |
| âš™ï¸ Fewer Moving Parts     | No need to manage separate services, APIs, networking layers.                       |
| ğŸš€ Simpler Deployment     | One package to test, deploy, and monitor. No version mismatch between services.     |
| ğŸ§ª Centralized Setup Code | Shared utilities, setup/configuration code don't need duplication.                  |
| âš¡ Performance            | In-process function calls are faster than inter-service communication over network. |


âŒ Disadvantages of Monoliths
| Drawback                      | Explanation                                                                  |
| ------------------------------| ---------------------------------------------------------------------------- |
| ğŸ“š Onboarding is Hard        | New developers need to understand the full system. High cognitive load.      |
| ğŸ§© Tight Coupling            | Changes in one part can unintentionally affect other areas. Hard to isolate. |
| ğŸš§ Harder Testing            | Everything touches everything; unit tests require full context.              |
| ğŸ”„ Frequent Full Deployments | Any change redeploys the whole system, increasing deployment risk.           |
| ğŸ›‘ Single Point of Failure   | If one part crashes (e.g., profile service), entire app might go down.       |


===================
ğŸ”· Microservices
===================
â¤ A microservice encapsulates a single business capability, along with its own data and logic.
â¤ Each service is independently deployable, loosely coupled, and may have its own database.
â¤ Clients often interact with an API Gateway, not directly with each microservice.


âœ… Advantages of Microservices
| Benefit                          | Explanation                                                                         |
| -------------------------------- | ----------------------------------------------------------------------------------- |
| ğŸ“ Scalable Architecture        | Each microservice can scale independently based on its own load.                    |
| ğŸ” Parallel Development         | Different teams can work on different services without stepping on each other.      |
| ğŸ§  Easier Onboarding            | New engineers need to learn only their microservice domain.                         |
| ğŸ“Š Resource Optimization        | Easily identify and scale only the parts of system under load (e.g., chat service). |
| ğŸ§¼ Clear Separation of Concerns | Encourages modular, maintainable design.                                            |


âŒ Disadvantages of Microservices
| Drawback                  | Explanation                                                                               |
| ------------------------- | ----------------------------------------------------------------------------------------- |
| ğŸ§  Complex Design        | Good microservices require smart architectural planning.                                  |
| ğŸ”— Over-Engineering Risk | If two services talk only to each other, they probably shouldn't be separate.             |
| ğŸ”„ RPC Overhead          | Communication between services is over the network, adding latency and points of failure. |
| ğŸ” Distributed Debugging | Tracing bugs across services becomes harder (needs observability tools).                  |
| ğŸ› ï¸ DevOps Complexity     | Needs containerization, service discovery, load balancing, CI/CD pipelines, etc.          |
| Lots of configuration    | Each service needs to be configured separately.                                            |
| Visibility               | Each microservice is a black box to the rest of the system.                                |
| Pack of Cards problems   | If the crucial microservice collapse then it will collapse the whole system                |


ğŸ§  Design Takeaways
Start with Monolith if:
1. Small Teams
2. MVP/Prototype
3. Rapid iteration needed
4. Tight integration between features.

Choose Microservices if:
1. System is large-scale or enterprise level.
2. Many teams contributing
3. Performance bottlenecks isolated to domains
4. High availability and independent deployment are important

ğŸ’¡ In a system design, you're often expected to go with microservices for large systems, but justify it:
â¤ Independent scalability
â¤ Parallel team development
â¤ Better fault isolation


In Most of the projects we will be using microservices and below mentioned components:
1ï¸âƒ£ Service Registry (Eureka Server)
2ï¸âƒ£ Services (REST APIs)
3ï¸âƒ£ Interservice Communication (Feign Client)
4ï¸âƒ£ API Gateway (Zuul Proxy (Outdated)) or Spring Cloud Gateway(recommended)
5ï¸âƒ£ Circuit Breaker (Hystrix)
6ï¸âƒ£ Resillience (Resilliance4j)
7ï¸âƒ£ Admin Server
8ï¸âƒ£ Zipkin Server


=====================
ğŸ”· Service Registry
=====================
â¤ A Service Registry is a centralized database or server that keeps track of all the services in a distributed system or microservices architecture.
    âœ”ï¸ Each service registers itself with the registry when it starts.
    âœ”ï¸ Services can then discover other services dynamically using the registry, instead of hardcoding URLs or IP addresses.
â¤ Think of it like a phone directory for services â€” if you want to call someone, you look up their current number in the directory.


ğŸ”„ Why is Service Registry Needed?
In a microservices architecture:
1ï¸âƒ£ Services are dynamic â€” they can scale up/down, restart, or change locations.
2ï¸âƒ£ Hardcoding service URLs leads to tight coupling and is not feasible in a dynamic environment.
3ï¸âƒ£ Service Registry solves this by providing:
    âœ”ï¸ Service Discovery â€” services can find each other at runtime.
    âœ”ï¸ Load Balancing â€” clients can distribute requests among multiple instances of a service.
    âœ”ï¸ Fault Tolerance â€” if a service instance fails, the registry can remove it from the list.


ğŸ”„ How it Works
1ï¸âƒ£ Service Registration
â¤ Each microservice registers itself with the Service Registry on startup.
â¤ Registration includes:
    âœ”ï¸ Service name
    âœ”ï¸ Host/IP
    âœ”ï¸ Port
    âœ”ï¸ Metadata (optional: version, environment, etc.)

âœ… Example: UserService registers itself with registry at http://localhost:8761.

2ï¸âƒ£ Service Discovery
â¤ When a client or another service needs a service (e.g., OrderService wants UserService), it queries the registry.
â¤ The registry returns available instances and their network locations.

3ï¸âƒ£ Heartbeats & Health Checks
â¤ Services periodically send heartbeat signals to the registry.
â¤ If a service fails to send heartbeats, the registry marks it unavailable.


ğŸ”„ Popular Service Registry
| Registry             | Description                                  | Features                                                 |
| ---------------------| -------------------------------------------- | -------------------------------------------------------- |
| Eureka (Netflix OSS) | Popular in Spring Cloud ecosystem            | Auto-registration, client-side load balancing, dashboard |
| Consul (HashiCorp)   | Service discovery + health checks + KV store | Multi-datacenter, DNS-based discovery, health checks     |
| Zookeeper (Apache)   | Distributed coordination + service discovery | High availability, consistency, hierarchical namespace   |
| etcd                 | Distributed key-value store                  | Lightweight, used in Kubernetes for service discovery    |

ğŸ”„ Project Starter dependency
spring-web
Eureka server

Spring Cloud + Eureka Example
1ï¸âƒ£ Add Dependencies (pom.xml)

ğŸ”— For Eureka Server:
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
</dependency>

ğŸ”— For Eureka Client (a microservice):
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>


2ï¸âƒ£ Eureka Server Setup
@SpringBootApplication
@EnableEurekaServer
public class EurekaServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(EurekaServerApplication.class, args);
    }
}

ğŸ”— application.properties:
âš¡ server.port=8761
â¤ If service registry starts on port 8761 then clients can discover service-registry and will register automatically with service-registry.
â¤ If service-registry project running on any other port number then we haae to register clients with service-registry manually.

âš¡ eureka.client.register-with-eureka=false
We make it false so that service-registry does not register with itself as a client to itself.
âš¡ eureka.client.fetch-registry=false


3ï¸âƒ£ Eureka Client Setup
@SpringBootApplication
@EnableEurekaClient
public class UserServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(UserServiceApplication.class, args);
    }
}

ğŸ”— application.properties:
spring.application.name=user-service
server.port=8081
eureka.client.service-url.defaultZone=http://localhost:8761/eureka/
âœ”ï¸ When UserService starts, it registers with Eureka.
âœ”ï¸ Other microservices can now discover UserService dynamically.


ğŸ”„ Benefits of Service Registry
âœ”ï¸ Dynamic Discovery â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ no hardcoded URLs needed.
âœ”ï¸ Load Balancing â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ clients can choose instances intelligently.
âœ”ï¸ Fault Tolerance â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ unhealthy instances are automatically removed.
âœ”ï¸ Scalability â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ supports microservices scaling up/down.
âœ”ï¸ Centralized Monitoring â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ registry dashboards show all registered services.
 

================
ğŸ”· API Gateway
================
â¤ An API Gateway is a server that acts as an entry point for all client requests to a set of backend microservices.
    âœ”ï¸ Instead of the client calling each microservice individually, it calls the API Gateway.
    âœ”ï¸ The API Gateway then routes the requests to the appropriate microservice.
    âœ”ï¸ It also provides additional functionalities like security, rate limiting, load balancing, and logging.
â¤ Think of it as a single door to your microservices, which controls, monitors, and manages traffic.


ğŸ”„ Why API Gateway is Needed
1ï¸âƒ£ In a microservices architecture:
â¤ Clients may need to call multiple services for a single operation.
â¤ Exposing multiple microservice URLs to clients is complex and insecure.
â¤ Clients would have to handle service discovery, authentication, and load balancing on their own.

2ï¸âƒ£ API Gateway solves these problems by:
â¤ Aggregating multiple calls into a single request.
â¤ Acting as a security layer (authentication, SSL termination).
â¤ Enabling rate limiting, caching, logging, and monitoring.


ğŸ”„ Key Responsibilities of an API Gateway
| Responsibility                 | Description                                                                            |
| -------------------------------| -------------------------------------------------------------------------------------- |
| Request Routing                | Routes incoming requests to the appropriate microservice based on the URL or headers.  |
| Request Aggregation            | Aggregates results from multiple services and returns a single response to the client. |
| Authentication & Authorization | Validates tokens (e.g., JWT, OAuth2) before forwarding requests.                       |
| Rate Limiting / Throttling     | Limits the number of requests from clients to prevent overload.                        |
| Caching                        | Stores responses for frequently accessed data to reduce backend calls.                 |
| Load Balancing                 | Distributes requests among multiple instances of a microservice.                       |
| Logging & Monitoring           | Tracks incoming requests, response times, errors, etc.                                 |
| Protocol Translation           | Can convert protocols (e.g., HTTP to WebSocket or gRPC).                               |


ğŸ”„ How it Works
1ï¸âƒ£ Client sends request â†’ always goes to API Gateway.
2ï¸âƒ£ Gateway authenticates the request (if required).
3ï¸âƒ£ Gateway routes request to one or more backend services.
4ï¸âƒ£ Backend service processes request and returns response.
5ï¸âƒ£ Gateway aggregates responses (if multiple services) and sends final response to client.

Client
   â”‚
   â–¼
API Gateway
   â”‚
   â”œâ”€â”€â–º Microservice 1
   â”œâ”€â”€â–º Microservice 2
   â”œâ”€â”€â–º Microservice 3
   â”‚
   â—„â”€â”€ Aggregated Response
   â”‚
   â–¼
Client


ğŸ”„ API Gateway in Spring Cloud
In the Spring ecosystem, you can use:
1ï¸âƒ£ Spring Cloud Gateway (modern, reactive, recommended)
2ï¸âƒ£ Spring Cloud Zuul (Netflix OSS) (older, now in maintenance mode)

ğŸ‘‰ For creating the gateway we need:
â¤ web-starter
â¤ eureka-client
â¤ cloud-gateway
â¤ devtools

ğŸ”„ Step-by-Step Configuration
1ï¸âƒ£: Add Dependencies
In the Gateway projectâ€™s pom.xml:

<dependencies>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-gateway</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
    </dependency>
</dependencies>


2ï¸âƒ£: Register Gateway with Eureka
ğŸ”— application.properties

spring.application.name=api-gateway
server.port=8080

# Eureka registration
eureka.client.service-url.defaultZone=http://localhost:8761/eureka/

# Enable Discovery Locator
spring.cloud.gateway.discovery.locator.enabled=true
spring.cloud.gateway.discovery.locator.lower-case-service-id=true


3ï¸âƒ£: Enable Gateway Discovery Routing
ğŸ”— By setting
spring.cloud.gateway.discovery.locator.enabled=true
You allow Gateway to automatically detect all services registered in Eureka.
ğŸ‘‰ Then you donâ€™t need to manually define routes for each service.

4ï¸âƒ£: How Automatic Routing Works
Once you enable discovery, the Gateway automatically exposes endpoints in the format:
http://localhost:8080/{service-name}/ 

âœ… For example:
| Service       | Call through Gateway                                                                     |
| ------------- | ---------------------------------------------------------------------------------------- |
| greet-service | [http://localhost:8080/greet-service/greet](http://localhost:8080/greet-service/greet)   |
| user-service  | [http://localhost:8080/user-service/users](http://localhost:8080/user-service/users)     |
| order-service | [http://localhost:8080/order-service/orders](http://localhost:8080/order-service/orders) |
ğŸ‘‰ Gateway internally fetches service instances from Eureka,
applies Spring Cloud LoadBalancer,and routes the request accordingly.

5ï¸âƒ£(Optional): Define Manual Routes
If you want custom paths instead of /service-name/,
you can define them manually:

spring.cloud.gateway.routes[0].id=greet-service
spring.cloud.gateway.routes[0].uri=lb://greet-service
spring.cloud.gateway.routes[0].predicates[0]=Path=/api/greet/

spring.cloud.gateway.routes[1].id=user-service
spring.cloud.gateway.routes[1].uri=lb://user-service ---> lb stands for load balancer
spring.cloud.gateway.routes[1].predicates[0]=Path=/api/user/

ğŸ‘‰ Here:
ğŸ”— lb:// prefix = use LoadBalancer (Eureka + Feign-like resolution)
ğŸ”— /api/greet/ = any request starting with /api/greet/ will go to greet-service

Step 6ï¸âƒ£: Service-Level Configurations
In each microservice (for example, greet-service):

spring.application.name=greet-service
server.port=8081
eureka.client.service-url.defaultZone=http://localhost:8761/eureka/
Similarly for user-service, order-service, etc.


7ï¸âƒ£: Run Services
Run in this order:
â¤ Eureka Server
â¤ All microservices (greet, user, order)
â¤ API Gateway

Then visit:
http://localhost:8080/greet-service/greet
or
http://localhost:8080/api/greet/hello
(depending on your route setup)


ğŸ”„ Benefits of Using API Gateway
âœ”ï¸ Single Entry Point â€” clients only need one endpoint.
âœ”ï¸ Security â€” central place to implement auth & SSL.
âœ”ï¸ Simplified Client Logic â€” clients donâ€™t need to call multiple services.
âœ”ï¸ Cross-Cutting Features â€” caching, logging, metrics, rate limiting applied centrally.
âœ”ï¸ Service Decoupling â€” microservices can evolve independently.


ğŸ”„ API Gateway vs Service Registry
| Feature             | API Gateway                              | Service Registry                       |
| ------------------- | ---------------------------------------- | -------------------------------------- |
| Purpose             | Routes, secures, and aggregates requests | Tracks available services & instances  |
| Client Interaction  | Client talks to gateway                  | Client talks to registry for discovery |
| Added Functionality | Auth, rate limiting, logging, caching    | Service discovery, health checks       |
| Focus               | Request management                       | Service availability 
                  |


ğŸ”· Global Filter in Spring Cloud Gateway?
A Global Filter is a filter that:
â¤ Applies to every request passing through the Gateway.
â¤ Runs before or after the route filters.
â¤ Used for cross-cutting concerns, such as:
    âœ”ï¸ Logging
    âœ”ï¸ Authentication
    âœ”ï¸ Header modification
    âœ”ï¸ Request timing
    âœ”ï¸ Tracing
It implements the GlobalFilter and Ordered interfaces.

ğŸ”„ Key Concepts
1ï¸âƒ£ GlobalFilter Interface:
ğŸ”— Defines a single method:
Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain);

ğŸ‘‰ Here:
âœ”ï¸ ServerWebExchange = contains the HTTP request & response
âœ”ï¸ GatewayFilterChain = represents the next filter in the chain
ğŸ‘‰ Ordered Interface:
Allows you to define filter execution order using getOrder().

âœ… Sample Global Filter Example (Logging + Header Injection)
package com.gateway.filters;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.core.Ordered;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

import java.time.LocalDateTime;

@Component
public class GlobalRequestFilter implements GlobalFilter, Ordered {

    private static final Logger logger = LoggerFactory.getLogger(GlobalRequestFilter.class);

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {

        // Extract request details
        String path = exchange.getRequest().getPath().toString();
        String method = exchange.getRequest().getMethod().toString();

        logger.info("ğŸŒ Incoming Request => Method: {} | Path: {} | Time: {}", method, path, LocalDateTime.now());

        // Add a custom header to outgoing request
        exchange.getRequest()
                .mutate()
                .header("X-Gateway-Request", "Processed-By-API-Gateway")
                .build();

        // Continue with next filter in chain
        return chain.filter(exchange)
                .then(Mono.fromRunnable(() -> {
                    // Post-processing after response
                    logger.info("âœ… Response Sent for Path: {} | Status: {}", path,
                            exchange.getResponse().getStatusCode());
                }));
    }

    @Override
    public int getOrder() {
        // Lower value = higher priority
        return -1;
    }
}


ğŸ”„ Key Points
| Section                         | Purpose                                                      |
| ------------------------------- | ------------------------------------------------------------ |
| `@Component`                    | Makes the filter automatically discoverable by Spring        |
| `filter()`                      | Executes logic before and after request processing           |
| `exchange.getRequest()`         | Accesses request object                                      |
| `chain.filter(exchange)`        | Passes control to the next filter                            |
| `.then(Mono.fromRunnable(...))` | Executes logic after the response is sent                |
| `getOrder()`                    | Defines order; use `-1` for high priority, or `0` for normal |

âœ… Logs Output
When you hit a route through the Gateway:
ğŸŒ Incoming Request => Method: GET | Path: /user-service/users | Time: 2025-11-06T10:30:21
âœ… Response Sent for Path: /user-service/users | Status: 200 OK


ğŸ”„ Optional â€“ Add Authentication Check
You can expand the same filter to block unauthorized requests before they reach downstream services:

if (!exchange.getRequest().getHeaders().containsKey("Authorization")) {
    logger.warn("âŒ Missing Authorization Header. Request blocked.");
    exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
    return exchange.getResponse().setComplete();
}
ğŸ‘‰ This will short-circuit and stop the filter chain if the header is missing.

ğŸ”· Admin Server
An Admin Server is a centralized management and monitoring tool for multiple Spring Boot applications (or microservices).
â¤ It collects information from client applications (services) and displays it in a web dashboard.
â¤ Essentially, itâ€™s like a control panel for all your microservices.
â¤ In the Spring ecosystem, this is usually implemented using Spring Boot Admin.


ğŸ”„ How It Works
â¤ Admin Server acts as a central web application.
â¤ Client applications (Spring Boot apps) register themselves with the Admin Server using Spring Boot Actuator endpoints.
â¤ Admin Server polls or receives push notifications from clients to get:
    âœ”ï¸ Health
    âœ”ï¸ Metrics
    âœ”ï¸ Logs
    âœ”ï¸ Custom info
Admin Server presents this in a web UI dashboard.
[Microservices] --> [Actuator Endpoints] --> [Admin Server Dashboard] --> [Admin User]

ğŸ”„Add to configure Admin Server Project
spring-web
Codecentric's Spring Boot Admin (Server)

ğŸ”„ Setting Up Spring Boot Admin
1ï¸âƒ£ Admin Server
Add dependencies (pom.xml):
<dependency>
    <groupId>de.codecentric</groupId>
    <artifactId>spring-boot-admin-starter-server</artifactId>
    <version>3.0.0</version>
</dependency>

ğŸ”„ Enable Admin Server in the main class:
import de.codecentric.boot.admin.server.config.EnableAdminServer;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
@EnableAdminServer
public class AdminServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(AdminServerApplication.class, args);
    }
}

ğŸ”— application.properties:
server.port=1111
spring.application.name=admin-server
âœ”ï¸ Now the Admin Server runs on port 1111.
âœ”ï¸ Web UI will be accessible at: http://localhost:1111.

2ï¸âƒ£ Client Applications
ğŸ”— Add dependencies (pom.xml):
<dependency>
    <groupId>de.codecentric</groupId>
    <artifactId>spring-boot-admin-starter-client</artifactId>
    <version>3.0.0</version>
</dependency>

ğŸ”— application.properties for client:
spring.application.name=user-service
server.port=8081

# Register with admin server
spring.boot.admin.client.url=http://localhost:8080
management.endpoints.web.exposure.include=*

âœ”ï¸ When UserService starts, it registers with Admin Server at http://localhost:8080.
âœ”ï¸ Admin Server now shows UserService in the dashboard.


ğŸ”„ Features in Admin Dashboard
| Feature              | Description                                                        |
| -------------------- | ------------------------------------------------------------------ |
| Application List | Shows all registered client applications.                          |
| Health Status    | UP, DOWN, or OFFLINE status of each app.                           |
| Metrics          | CPU, memory, HTTP requests, DB stats, etc.                         |
| Logs             | View and download logs from services.                              |
| Custom Endpoints | Trigger actuator endpoints like `/shutdown` or `/restart`.         |
| Notifications    | Can integrate with Slack or email alerts when a service goes DOWN. |


ğŸ”„ Benefits of Admin Server
âœ”ï¸ Centralized Monitoring â€“ Monitor multiple services in one place.
âœ”ï¸ Quick Health Checks â€“ Identify failing services instantly.
âœ”ï¸ Improved Maintenance â€“ Restart, shutdown, or trigger custom endpoints from dashboard.
âœ”ï¸ Integration with Actuators â€“ Leverages existing Spring Boot actuator endpoints.
âœ”ï¸ Alerting â€“ Notifies admins about critical failures or unhealthy services.


ğŸ”„ Order of Startup / Dependency
â¤ Eureka Server â€“ must start first (so microservices can register).
â¤ Microservices â€“ register themselves with Eureka.
â¤ API Gateway â€“ queries Eureka for routing information.
â¤ Admin Server â€“ collects metrics and health info from microservices (can also use Eureka to find them).

 
ğŸ”· Zipkin Server
Zipkin is a distributed tracing system used to monitor and troubleshoot latency problems in microservices.
    âœ”ï¸ It helps track requests as they flow through multiple microservices.
    âœ”ï¸ Zipkin collects timing data for each request (called a span) and organizes it into traces.
    âœ”ï¸ A Zipkin Server is the central service that collects, stores, and visualizes these traces.
Think of Zipkin as a flight tracker for requests across your microservices


ğŸ”„ Why Zipkin is Needed
â¤ In microservices architectures:
1ï¸âƒ£ Requests often pass through multiple services (e.g., Gateway â†’ UserService â†’ OrderService â†’ PaymentService).
2ï¸âƒ£ Latency issues or errors can occur at any microservice.
3ï¸âƒ£ Hard to know which service caused the delay or failure.

â¤ Zipkin solves this by:
1ï¸âƒ£ Collecting trace data from all microservices
2ï¸âƒ£ Showing end-to-end request flow
3ï¸âƒ£ Highlighting slow services or failed calls


ğŸ”„ Zipkin Terminology
| Concept          | Description                                                                           |
| ---------------- | ------------------------------------------------------------------------------------- |
| Trace        | Represents the entire journey of a single request through all services.           |
| Span         | A single unit of work within a trace, e.g., an HTTP request to a service.         |
| Annotation   | Marks an event or timestamp in a span (like request received, response sent). |
| Service Name | Name of the microservice generating the span.                                         |


ğŸ”„ How Zipkin Works
1ï¸âƒ£ Microservice Instrumentation
â¤ Each microservice sends trace data (spans) to Zipkin.
â¤ In Spring Boot, this is done using Spring Cloud Sleuth.

2ï¸âƒ£ Trace Propagation
â¤ Sleuth adds unique trace IDs and span IDs to HTTP headers.
â¤ Each microservice adds its span data to the trace.

3ï¸âƒ£ Central Collection
â¤ Spans are sent to Zipkin Server via HTTP or messaging.
â¤ Zipkin stores spans in its storage backend (like in-memory, MySQL, Cassandra, Elasticsearch).

4ï¸âƒ£ Visualization
â¤ Zipkin Web UI shows traces, spans, duration, and service dependencies.
â¤ You can quickly identify slow services or errors.

Client --> API Gateway --> UserService --> OrderService --> PaymentService
    |           |                |                 |
    v           v                v                 v
 Zipkin collects spans from all services
          Centralized view in Zipkin UI


ğŸ”„ Setting Up Zipkin Server
1ï¸âƒ£ Add Zipkin Dependency (Spring Boot) on Each microservice

 <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
    <dependency>
      <groupId>io.micrometer</groupId>
      <artifactId>micrometer-tracing-bridge-brave</artifactId>
    </dependency>
    <dependency>
      <groupId>io.zipkin.reporter2</groupId>
      <artifactId>zipkin-reporter-brave</artifactId>
    </dependency>

ğŸ”„ Where to add dependencies
â¤ Add the Zipkin/Micrometer dependencies to each microservice that you want to trace.
âœ… Example: UserService, OrderService, PaymentService â€” each one needs the tracing dependencies in its own pom.xml.
â¤ Do not add it to a new "Zipkin microservice". That would not do anything; Zipkin itself is just a collector, not a Spring Boot microservice you need to build.


in application.properties
spring.application.name=user-service
spring.zipkin.base-url=http://localhost:9411
spring.sleuth.sampler.probability=1.0

3ï¸âƒ£ Run Zipkin Server
ğŸ‘‰ Option 1: Docker
docker run -d -p 9411:9411 openzipkin/zipkin

ğŸ‘‰ Option 2: Spring Boot App
Run this in cmd: java -jar zipkin.jar

Then automatically all services will access Zipkin Server at http://localhost:9411


ğŸ”„ How it Works in a Microservice
â¤ UserService receives request: Sleuth generates trace ID & span ID.
â¤ OrderService receives forwarded request: Sleuth continues same trace ID.
â¤ PaymentService does the same.
â¤ All spans are sent to Zipkin Server â†’ Zipkin shows end-to-end trace with duration and dependencies.


ğŸ”„ Key Features
| Benefit                    | Description                                            |
| -------------------------- | ------------------------------------------------------ |
| Distributed Tracing    | See request flow across multiple services.             |
| Latency Analysis       | Identify slow services or bottlenecks.                 |
| Error Detection        | Pinpoint which service caused failure.                 |
| Visualization          | Trace timelines, duration, and dependencies.           |
| Supports Microservices | Works with Spring Cloud, Sleuth, and other frameworks. |


ğŸ”„ Placement in Architecture
â¤ Zipkin Server â†’ Centralized, independent service.
â¤ Microservices â†’ Each instrumented with Sleuth, sends data to Zipkin.
â¤ API Gateway â†’ Also optionally instrumented.
â¤ Admin Server / Eureka â†’ Can be used alongside Zipkin but serve different purposes:
    âœ”ï¸ Admin Server â†’ monitoring, health, logs
    âœ”ï¸ Zipkin â†’ request tracing

Client --> API Gateway --> Microservices
         \-> Zipkin Server (collects traces)
Admin Server monitors health, logs, and metrics
Eureka handles service registry


=================
ğŸ”· Feign Client
=================
â¤ Feign Client is a declarative REST Client provided by Spring Cloud that allows microservices to communicate with each other easily â€” without writing boilerplate REST API calling code using RestTemplate or WebClient.

â¤ Feign is like a shortcut that lets one microservice call anotherâ€™s REST API just by writing a Java interface â€” no need to manually handle HTTP requests or JSON conversion.


âœ… Example Analogy
ğŸ‘‰ Without Feign:
Youâ€™d use RestTemplate to call another serviceâ€™s endpoint manually:

ResponseEntity<Student> response = restTemplate.getForEntity("http://student-service/api/students/1", Student.class);


ğŸ‘‰ With Feign:
You simply declare an interface:

@FeignClient(name = "student-service")
public interface StudentClient {
    @GetMapping("/api/students/{id}")
    Student getStudentById(@PathVariable("id") Long id);
}
â¤ Spring handles everything else â€” creating the HTTP client, sending the request, deserializing the response, and even applying load balancing if integrated with Eureka.


ğŸ”„ Why Use Feign Client
| Problem                                                     | Feign Solution                             |
| ----------------------------------------------------------- | ------------------------------------------ |
| Writing repetitive `RestTemplate` code                      | Define API calls declaratively             |
| Manual URL and parameter handling                           | Done automatically via annotations         |
| Difficult error handling                                    | Feign provides error decoders              |
| No service discovery                                        | Integrates with Eureka                     |
| Hard to maintain microservice-to-microservice communication | Simple, clean, and maintainable interfaces |


ğŸ”„ How Feign Works Internally
1ï¸âƒ£ Interface Declaration â€“ You define an interface annotated with @FeignClient.
2ï¸âƒ£ Dynamic Proxy â€“ Spring Cloud creates a runtime proxy implementation of that interface.
3ï¸âƒ£ Service Discovery â€“ If Eureka is used, Feign automatically resolves the service name to the actual URL.
4ï¸âƒ£ Request Handling â€“ The proxy makes HTTP calls (using OpenFeign under the hood).
5ï¸âƒ£ Response Mapping â€“ Feign automatically converts the JSON response to the Java object type declared in your interface.


ğŸ”„ How to Setup Feign Client in Spring Boot
1ï¸âƒ£ Add Dependency
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>

Also, include Spring Cloud BOM in your pom.xml to manage versions:
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>2023.0.3</version> <!-- change as per Spring Boot version -->
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>

2ï¸âƒ£ Enable Feign Clients
Add @EnableFeignClients to your main Spring Boot application class:

@SpringBootApplication
@EnableFeignClients
public class ApiGatewayApplication {
    public static void main(String[] args) {
        SpringApplication.run(ApiGatewayApplication.class, args);
    }
}

3ï¸âƒ£ Create a Feign Client Interface
Suppose OrderService needs to call StudentService:

@FeignClient(name = "student-service")  // Name registered in Eureka always use hyphen between words not underscore otherwise it will throw error
public interface StudentClient {

    @GetMapping("/api/students/{id}")
    Student getStudentById(@PathVariable("id") Long id);
}


4ï¸âƒ£ Use Feign Client in Your Service Class
@Service
public class OrderService {

    private final StudentClient studentClient;

    public OrderService(StudentClient studentClient) {
        this.studentClient = studentClient;
    }

    public String placeOrder(Long studentId) {
        Student student = studentClient.getStudentById(studentId);
        return "Order placed for student: " + student.getName();
    }
}

5ï¸âƒ£ Configure Eureka (Optional but Recommended)
If using Eureka Server, register both services (student-service, order-service) with it:

spring.application.name=student-service
eureka.client.service-url.defaultZone=http://localhost:8761/eureka/
Now Feign automatically discovers student-service via its name instead of a hardcoded URL.

6ï¸âƒ£ (Optional) Add Custom Configuration
You can customize timeouts, error handling, or logging:

feign.client.config.default.connectTimeout=5000
feign.client.config.default.readTimeout=5000
feign.client.config.default.loggerLevel=full


ğŸ”„ Key Annotations
| Annotation                                         | Description                                                                   |
| -------------------------------------------------- | ----------------------------------------------------------------------------- |
| `@EnableFeignClients`                              | Enables Feign client functionality in the Spring Boot application.            |
| `@FeignClient(name = "service-name", url = "...")` | Defines a Feign client interface for a specific service.                      |
| `@GetMapping`, `@PostMapping`, etc.                | Maps HTTP methods inside the Feign interface, similar to a normal controller. |
| `@PathVariable`, `@RequestBody`, `@RequestParam`   | Used to map parameters in Feign client methods.                               |


ğŸ”„ Feign + Eureka + Gateway Architecture
             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
             â”‚      API Gateway       â”‚
             â”‚ (uses Feign to call MS)â”‚
             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚                  â”‚                   â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Order MS   â”‚ ---> â”‚ Student MS â”‚ ---> â”‚ Payment MS â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ Eureka Serverâ”‚  (Service Registry)
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â¤ Feign Client simplifies API calls between OrderService â†’ StudentService.
â¤ Eureka resolves service names dynamically.
â¤ API Gateway routes external requests.


ğŸ”„ Advantages of Feign Client
| Benefit                     | Explanation                                                  |
| --------------------------- | ------------------------------------------------------------ |
| Declarative & Clean     | Define REST calls via interfaces; no boilerplate code.       |
| Integration with Eureka | Resolves service names dynamically without hardcoding URLs.  |
| Load Balancing (Ribbon) | Automatically distributes requests across service instances. |
| Error Handling & Retry  | Built-in retry mechanisms and error decoders.                |
| Easy Testing            | Mock interfaces easily for unit tests.
                       |

ğŸ”„ Limitations
| Limitation              | Description                                               |
| ----------------------- |  --------------------------------------------------------- |
| Overhead            | Slightly higher latency than lightweight HTTP clients.    |
| Less Control        | Less granular control than `RestTemplate` or `WebClient`. |
| Needs Configuration | Must be properly integrated with Eureka for full power.   |



ğŸ”· Load Balancer
A Load Balancer is a mechanism that distributes incoming requests across multiple instances of a service to:
    âœ”ï¸ Prevent overloading a single instance
    âœ”ï¸ Achieve fault tolerance and high availability
    âœ”ï¸ Improve performance and scalability

In microservices, multiple instances of the same service often run (e.g., multiple â€œGreetâ€ services).
A load balancer ensures requests are distributed evenly among them.


In Spring Boot, the Environment object represents the current runtime environment â€” including:
    âœ”ï¸ Active profiles (dev, test, prod)
    âœ”ï¸ Configuration properties (from application.properties, application.yml, system vars, command-line args, etc.)
    âœ”ï¸ Environment variables

ğŸ”„ Autowiring the Environment variables
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.env.Environment;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class InfoController {

    @Autowired
    private Environment env;

    @GetMapping("/info")
    public String getInfo() {
        return "Running on port: " + env.getProperty("server.port");
    }
}
ğŸ‘‰ What happens here:
â¤ Environment gives you access to all loaded properties.
â¤ You can get any property like:
env.getProperty("spring.application.name");
env.getProperty("eureka.client.service-url.defaultZone");
env.getProperty("management.endpoints.web.exposure.include");

âœ”ï¸ This is especially useful when you run multiple instances of the same app, each with a different port or profile.

2ï¸âƒ£ Running Multiple Instances (Using Run Configurations)
Letâ€™s now move to how to run multiple instances of the same microservice locally â€” this is critical for testing load balancing.

Each microservice instance:
âœ”ï¸ Has the same codebase
âœ”ï¸ Has a different port
âœ”ï¸ Registers as the same service name in Eureka
âœ… Example:
| Instance   | Port | Eureka Registered Name |
| ---------- | ---- | ---------------------- |
| Instance 1 | 8081 | greet-api              |
| Instance 2 | 8082 | greet-api              |
| Instance 3 | 8083 | greet-api              |


ğŸ”„ How to Do It (in IntelliJ or Eclipse)
Option 1ï¸âƒ£: Using Run Configurations
â¤ Open your project (e.g., GreetApiApplication).
â¤ Go to Run â†’ Edit Configurations.
â¤ Click â€œ+â€ â†’ Application.
â¤ Name it â†’ Greet-Instance-1.
â¤ Select your main class â†’ com.example.GreetApiApplication.
â¤ In VM options or Program arguments, add:
--server.port=8081


â¤ Copy that configuration â†’ name it Greet-Instance-2.
Add argument:
--server.port=8082

Similarly create another one for 8083.
Now, run all three configurations simultaneously.

âœ… Each one will:
Run on a different port
Register in Eureka as the same spring.application.name
Be load-balanced by the Feign client

Option 2ï¸âƒ£: Using Terminal (Quickest)
If you have built your JAR file:

java -jar target/greet-api.jar --server.port=8081
java -jar target/greet-api.jar --server.port=8082
java -jar target/greet-api.jar --server.port=8083
ğŸ‘‰ Each command starts a new instance with a different port.


ğŸ”· How Feign Client Does Load Balancing Internally
1ï¸âƒ£ Historical Context â€” Ribbon + Feign (Old Stack)
Earlier, in Spring Cloud Netflix (pre-2021):
Feign used Ribbon under the hood for client-side load balancing.

ğŸ‘‰ Architecture looked like this:
Feign Client â†’ Ribbon â†’ Eureka â†’ Target Service

âœ… Example flow:
â¤ You make a Feign call to a service name, say @FeignClient("user-service").
â¤ Feign delegates to Ribbon.
â¤ Ribbon asks Eureka for all instances of user-service (like ports 8081, 8082).
â¤ Ribbon uses a load-balancing strategy (Round Robin by default) to pick one instance.
â¤ The HTTP request is sent to that chosen instance.

âœ… Pros:
â¤ Automatic discovery + load balancing.
â¤ Easy integration with Eureka.

âŒ Cons:
â¤ Netflix deprecated Ribbon in 2021.
â¤ It was not actively maintained.
â¤ Memory leaks and configuration complexity were common.


2ï¸âƒ£ Modern Stack â€” Spring Cloud LoadBalancer (New Replacement)
Since Spring Cloud 2020+, Ribbon was removed and replaced by:
âš¡ Spring Cloud LoadBalancer
Now Feign integrates with Spring Cloud LoadBalancer instead of Ribbon.

ğŸ‘‰ Architecture now:
Feign Client â†’ Spring Cloud LoadBalancer â†’ Eureka â†’ Target Service

ğŸ”„ So What Changed Internally between Ribbons and Spring Cloud LoadBalancer?
| Feature        | Ribbon (Old)                      | Spring Cloud LoadBalancer (New) |
| -------------- | --------------------------------- | ------------------------------- |
| Maintenance    | Deprecated                        | Actively maintained             |
| Integration    | Tight Netflix coupling            | Spring-native                   |
| Algorithm      | Round Robin / Random              | Pluggable, customizable         |
| Configuration  | Complex YAML                      | Simple Spring config            |
| Future Support | âŒ Removed after Spring Cloud 2020 | âœ… Actively evolving             |

When Feign client is used with Spring Cloud Eureka and Spring Cloud LoadBalancer, this happens under the hood:
Step 1ï¸âƒ£ â€” You make a Feign call:
String response = greetClient.getGreeting();

Step 2ï¸âƒ£ â€” Feign looks for the service name:
The Feign proxy sees:
@FeignClient(name = "greet-api")
ğŸ‘‰ So it knows it has to contact service ID = greet-api.

Step 3ï¸âƒ£ â€” Feign asks Spring Cloud LoadBalancer for an instance
Feign is automatically configured with a LoadBalancerClient (thanks to the dependency spring-cloud-starter-loadbalancer).

ğŸ‘‰ It calls:
ServiceInstance instance = loadBalancer.choose("greet-api");

Step 4ï¸âƒ£ â€” LoadBalancer queries Eureka Server
Eureka keeps a registry of all service instances.

âœ… Example registry response:

greet-api â†’ [http://localhost:8081, http://localhost:8082, http://localhost:8083]

Step 5ï¸âƒ£ â€” LoadBalancer applies a strategy
Spring Cloud LoadBalancer applies its algorithm (default: Round Robin):
1st request â†’ 8081
2nd request â†’ 8082
3rd request â†’ 8083
4th â†’ back to 8081

ğŸ”„ Dependency Configuration of LoadBalancer 
âš¡ Dependencies Required

To enable Feign + LoadBalancer:
<dependencies>
    <!-- Eureka Client -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
    </dependency>

    <!-- Feign Client -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-openfeign</artifactId>
    </dependency>

    <!-- LoadBalancer -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-loadbalancer</artifactId>
    </dependency>
</dependencies>

ğŸ‘‰ Then enable Feign:
@SpringBootApplication
@EnableFeignClients
public class WelcomeApiApplication {
    public static void main(String[] args) {
        SpringApplication.run(WelcomeApiApplication.class, args);
    }
}

ğŸ”„ Custom Load-Balancing Strategy
By default, Spring Cloud LoadBalancer uses Round Robin.
You can customize it by creating a bean:

import org.springframework.cloud.loadbalancer.core.RandomLoadBalancer;
import org.springframework.cloud.loadbalancer.core.ServiceInstanceListSupplier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import reactor.core.publisher.Reactor;

@Configuration
public class LoadBalancerConfig {
    
    @Bean
    public Reactor.ServiceInstanceLoadBalancer randomLoadBalancer(
            ServiceInstanceListSupplier supplier) {
        return new RandomLoadBalancer(Reactor.getInstance(), supplier);
    }
}
ğŸ‘‰ Now requests will go to random service instances instead of round robin.

Step 6ï¸âƒ£ â€” Feign sends HTTP request
Once the target instance is chosen, Feign creates and sends an HTTP request to:
http://localhost:8082/greet

Step 7ï¸âƒ£ â€” The response is returned
Feign gets the HTTP response and maps it back to the Java return type (String, DTO, etc.).


ğŸ”„ Internal Component Interaction
[Welcome API] --FeignClient-->
   [Spring Cloud LoadBalancer] --calls--> [Eureka Server]
         |                                 |
         |------ Chooses one instance ---->|
         |                                 |
         |---> Makes HTTP call to selected service instance


 
ğŸ”· Cloud Config Server
â¤ Spring Cloud Config Server is a centralized configuration management system for microservices.

â¤ It allows you to store all configuration files (application.properties / application.yml) for multiple services in one place â€” typically a Git repository â€” and lets each microservice fetch its configuration dynamically from the Config Server.

â¤ Instead of having 10 microservices each with its own hardcoded application.properties, you keep all those config files in one centralized Git repo, and each service pulls its config from the Config Server at startup (and even at runtime).


ğŸ”„ Why Use Config Server
| Problem                                                          | Solution (with Config Server)                                                          |
| ---------------------------------------------------------------- | -------------------------------------------------------------------------------------- |
| Each service has its own configuration file scattered everywhere | Store all configurations centrally                                                     |
| Changing config means rebuilding and redeploying each service    | Update one config file in Git, and all services can auto-refresh                       |
| Hard to manage environment configs (dev, test, prod)             | Config Server supports profiles like `application-dev.yml`, `application-prod.yml` |
| Security issues from keeping credentials in services             | Keep them centralized, possibly encrypted                                              |


ğŸ”„ How It Works
               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
               â”‚  Git Repository (Config Repo)â”‚
               â”‚  â”€ application.yml           â”‚
               â”‚  â”€ student-service.yml       â”‚
               â”‚  â”€ order-service-dev.yml     â”‚
               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                     (reads configuration)
                              â”‚
             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
             â”‚        Config Server              â”‚
             â”‚ (centralized configuration center)â”‚
             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                 (serves configuration via HTTP)
                              â”‚
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚                  â”‚            â”‚            â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Student MS â”‚     â”‚ Order MS   â”‚  â”‚ Payment MS â”‚  â”‚ Auth MS    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                 â”‚                â”‚             â”‚
        â–¼                 â–¼                â–¼             â–¼
  Fetch configs from Config Server via HTTP calls


ğŸ”„ Architecture Components
| Component          | Role                                                                                    |
| ------------------ | --------------------------------------------------------------------------------------- |
| Config Server  | A Spring Boot application that provides configuration files to all services.            |
| Config Client  | Any microservice that fetches its configuration from the Config Server.                 |
| Git Repository | The storage location for configuration files (could also be filesystem, SVN, or Vault). |


ğŸ”„ Setting Up Config Server
Create Git Repository and keep yml/properties files required
1ï¸âƒ£ Create a New Spring Boot Application â€” Config Server
ğŸ‘‰ Add the dependency in pom.xml:

<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-config-server</artifactId>
</dependency>


ğŸ‘‰ Also, include the Spring Cloud BOM (version depends on Spring Boot version):
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>2023.0.3</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>

2ï¸âƒ£ Enable Config Server
In the main application class:

@SpringBootApplication
@EnableConfigServer
public class ConfigServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(ConfigServerApplication.class, args);
    }
}

3ï¸âƒ£ Configure Git Repository Location
ğŸ‘‰ In application.properties (or application.yml):
server.port=8888
spring.application.name=config-server

# Git repository where all configs are stored
spring.cloud.config.server.git.uri=https://github.com/ankur-verma30/microservice-config-repo
spring.cloud.config.server.git.default-label=main
spring.cloud.config.server.git.clone-on-start=true


ğŸ“ Example Git Repository Structure
microservice-config-repo/
â”‚
â”œâ”€â”€ application.yml                 # Common config for all services
â”œâ”€â”€ student-service.yml             # Config specific to student microservice
â”œâ”€â”€ order-service.yml               # Config specific to order microservice
â”œâ”€â”€ payment-service.yml             # Config specific to payment microservice
â””â”€â”€ student-service-dev.yml         # Environment-specific configs

ğŸ”— Testing the Config Server
After running the Config Server, you can test it in the browser:
http://localhost:8888/student-service/default
or
http://localhost:8888/default/student-service

âœ… This returns JSON:
{
  "name": "student-service",
  "profiles": ["default"],
  "propertySources": [
    {
      "name": "https://github.com/ankur-verma30/microservice-config-repo/student-service.yml",
      "source": {
        "server.port": 8081,
        "spring.datasource.url": "jdbc:mysql://localhost:3306/studentdb"
      }
    }
  ]
}
âœ… This means your config server is reading and serving configurations successfully.

ğŸ”„ Connecting a Microservice (Config Client)
ğŸ‘‰ In each microservice (like student-service), add the dependency:

<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-config</artifactId>
</dependency>

ğŸ‘‰ Then in application.properties (or application.yml):
spring.application.name=student-service
spring.cloud.config.uri=http://localhost:8888
spring.profiles.active=dev

ğŸ‘‰ Now, when the service starts, it fetches its configuration automatically from the Config Serverâ€™s Git repo.

ğŸ” Auto Refresh Configuration
If you also add Spring Boot Actuator, you can refresh configs at runtime without restarting:
ğŸ‘‰ Add dependency:
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>

ğŸ‘‰ Add in application.properties:
management.endpoints.web.exposure.include=refresh

ğŸ‘‰ Send POST request:
POST http://localhost:8081/actuator/refresh

â¡ï¸ The URL POST http://localhost:8081/actuator/refresh
is the URL of the microservice (Config Client) â€” NOT the Config Server.
âœ”ï¸ This reloads the latest configuration from the Config Server dynamically.

ğŸ” Secure Config Server
â¤ Use Spring Security to protect access to configuration endpoints.
â¤ Encrypt sensitive data using:
spring.cloud.config.server.encrypt.enabled=true

ğŸ”„ Advantages of Using Spring Cloud Config Server
| Benefit                                  | Description                                                   |
| ---------------------------------------- | ------------------------------------------------------------- |
| Centralized Configuration Management | All configs are managed from one repository.                  |
| Environment-Specific Configs         | Supports multiple profiles like dev, test, prod.              |
| Dynamic Refresh                      | Configs can be reloaded at runtime using `/actuator/refresh`. |
| Version Control Integration          | Git provides version history, rollback, and collaboration.    |
| Consistency Across Microservices     | Ensures uniform configuration across all services.            |
| Secure & Scalable                    | Supports encryption, Vault, and multiple environments.        |

ğŸ”„ Where Config Server Fits in Microservice Architecture
                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                      â”‚   Config Server (Port 8888) â”‚
                      â”‚   Centralized Configuration â”‚
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚
                    (Fetch configs via HTTP)
                                  â”‚
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚ Student MS  â”‚   â”‚ Order MS    â”‚   â”‚ Payment MS  â”‚
 â”‚ Port 8081   â”‚   â”‚ Port 8082   â”‚   â”‚ Port 8083   â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                 â”‚                â”‚
        â–¼                 â–¼                â–¼
  Eureka Server   â”€â”€â”€â”€â”€â”€> API Gateway â”€â”€â”€â”€â”€> Clients
Every microservice (client) fetches its configuration from the Config Server instead of a local file.


ğŸ”· Circuit Breaker
â¤ A Circuit Breaker is a resilience pattern used to prevent one failing microservice from crashing or slowing down the entire system.

ğŸ‘‰ Think of it as an electric circuit fuse â€”
â¤ when thereâ€™s a fault in one part, it â€œbreaksâ€ the connection temporarily to protect the rest.
 
ğŸ”„ Goal
To stop making repeated calls to a service that is already failing,
and allow it to recover gracefully while maintaining system stability.

ğŸ”„ Real-World Analogy
ğŸ‘‰ Imagine:
âœ”ï¸ You have a Payment Service calling a Bank API.
âœ”ï¸ The Bank API is slow or down.

Without a circuit breaker, your Payment Service keeps sending requests again and again, wasting resources and possibly crashing under load.

A circuit breaker detects this repeated failure and â€œopensâ€ the circuit:
âœ”ï¸ Future requests are blocked immediately (fail fast),
âœ”ï¸ Instead of waiting and retrying,
âœ”ï¸ Optionally returns a fallback response (like â€œService Temporarily Unavailableâ€).

ğŸ”„ Circuit Breaker States
| State            | Meaning                                                            | Behavior                                           |
| ---------------- | ------------------------------------------------------------------ | -------------------------------------------------- |
| ğŸ”´  Closed    | Everything is normal                                               | All requests pass through                          |
| ğŸŸ¢ Open      | Service is failing repeatedly                                      | Requests are stopped immediately (fail fast)       |
| ğŸŸ¡ Half-Open | After a cooldown, circuit allows limited requests to test recovery | If successful â†’ go to Closed; if fails â†’ stay Open |

ğŸ”„ Implementation in Spring Boot

Spring Boot uses Resilience4j for Circuit Breaker support
(previously Netflix Hystrix was popular but is now deprecated).

ğŸ”„ Steps to Implement Circuit Breaker (using Resilience4j)
1ï¸âƒ£ Add Dependency
<dependency>
    <groupId>io.github.resilience4j</groupId>
    <artifactId>resilience4j-spring-boot3</artifactId>
    <version>2.2.0</version>
</dependency>

2ï¸âƒ£ Enable Circuit Breaker in Configuration
resilience4j.circuitbreaker.instances.studentService.register-health-indicator=true
resilience4j.circuitbreaker.instances.studentService.sliding-window-size=5
resilience4j.circuitbreaker.instances.studentService.failure-rate-threshold=50
resilience4j.circuitbreaker.instances.studentService.wait-duration-in-open-state=10s

3ï¸âƒ£ Use Circuit Breaker Annotation in Service Layer
import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

@Service
public class StudentService {

    private final RestTemplate restTemplate = new RestTemplate();

    @CircuitBreaker(name = "studentService", fallbackMethod = "fallbackGetStudent")
    public String getStudentDetails() {
        // Simulate calling another microservice
        return restTemplate.getForObject("http://localhost:8082/student/info", String.class);
    }

    // Fallback method
    public String fallbackGetStudent(Exception ex) {
        return "Student Service is temporarily unavailable. Please try again later.";
    }
}

4ï¸âƒ£ Create Controller
@RestController
@RequestMapping("/api")
public class StudentController {

    private final StudentService studentService;

    public StudentController(StudentService studentService) {
        this.studentService = studentService;
    }

    @GetMapping("/get-student")
    public String fetchStudent() {
        return studentService.getStudentDetails();
    }
}


ğŸ”„ How it Works
1ï¸âƒ£ Normal flow: Calls pass through normally (Circuit Closed).
2ï¸âƒ£ If the target service fails repeatedly (e.g., 3 out of 5 requests fail): Circuit opens â†’ blocks further calls for 10 seconds.
3ï¸âƒ£ After 10 seconds: Circuit enters Half-Open state â†’ allows a few test calls.
4ï¸âƒ£ If those calls succeed â†’ Closed again (normal). If they fail â†’ stays Open (still blocking).


ğŸ”„ Benefits of Circuit Breaker
| Benefit            | Description                                   |
| ------------------ | --------------------------------------------- |
| âš¡ Fail Fast       | Prevents waiting for timeouts repeatedly      |
| ğŸ§± Isolation       | Keeps one serviceâ€™s failure from cascading    |
| ğŸ” Recovery        | Allows service to heal automatically          |
| ğŸ” Monitoring      | Helps observe and analyze service reliability |
| ğŸš¦ Controlled Load | Prevents overloading a struggling service     |

ğŸ”„ Common Use Cases
â¤ API Gateway calling multiple microservices
â¤ Payment / Order services calling external APIs
â¤ Notification services using 3rd-party SMS or Email APIs


ğŸ”„ Add Monitoring Dashboard
Resilience4j integrates with Actuator and Micrometer so you can monitor circuit breaker metrics (like failure count, open time, etc.).

management.endpoints.web.exposure.include=health,metrics

ğŸ‘‰ Then access metrics at:
http://localhost:8080/actuator/metrics/resilience4j.circuitbreaker.calls




ğŸ”· Send Email Using Spring Boot
1ï¸âƒ£ Add Dependency

If youâ€™re using Maven:
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-mail</artifactId>
</dependency>

2ï¸âƒ£ Configure application.properties

For Gmail SMTP:
spring.mail.host=smtp.gmail.com
spring.mail.port=587
spring.mail.username=your_email@gmail.com
spring.mail.password=your_app_password
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true
spring.mail.properties.mail.debug=true
spring.mail.default-encoding=UTF-8

âš ï¸ Use an App Password for Gmail, not your normal password.

3ï¸âƒ£ Create a Mail Service
Plain Text Email
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.stereotype.Service;

@Service
public class MailService {

    @Autowired
    private JavaMailSender mailSender;

    public void sendSimpleEmail(String to, String subject, String body) {
        SimpleMailMessage message = new SimpleMailMessage();
        message.setTo(to);
        message.setSubject(subject);
        message.setText(body);
        message.setFrom("your_email@gmail.com");

        mailSender.send(message);
        System.out.println("âœ… Email sent successfully to " + to);
    }
}

HTML Email with Attachment
import org.springframework.core.io.FileSystemResource;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.stereotype.Service;

import jakarta.mail.MessagingException;
import jakarta.mail.internet.MimeMessage;
import java.io.File;

@Service
public class AdvancedMailService {

    private final JavaMailSender mailSender;

    public AdvancedMailService(JavaMailSender mailSender) {
        this.mailSender = mailSender;
    }

    public void sendHtmlEmailWithAttachment(String to, String subject, String htmlBody, String filePath) throws MessagingException {
        MimeMessage message = mailSender.createMimeMessage();
        MimeMessageHelper helper = new MimeMessageHelper(message, true);

        helper.setTo(to);
        helper.setSubject(subject);
        helper.setText(htmlBody, true); // true = HTML
        helper.setFrom("your_email@gmail.com");

        FileSystemResource file = new FileSystemResource(new File(filePath));
        helper.addAttachment(file.getFilename(), file);

        mailSender.send(message);
        System.out.println("âœ… HTML Email with attachment sent to " + to);
    }
}



ğŸ”· Scheduling Tasks with Cron Jobs in Spring Boot
ğŸ”„ Enabling Scheduling
Before you can schedule tasks, you must enable scheduling in your Spring Boot application.

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableScheduling  // âœ… Enables Springâ€™s scheduling capability
public class SchedulerApplication {
    public static void main(String[] args) {
        SpringApplication.run(SchedulerApplication.class, args);
    }
}

ğŸ”„ Creating a Scheduled Task
You can schedule any method to run automatically using the @Scheduled annotation.

import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

@Component
public class EmailScheduler {

    // Runs every 10 seconds
    @Scheduled(fixedRate = 10000)
    public void sendEmailReminder() {
        System.out.println("Sending reminder email at: " + java.time.LocalTime.now());
    }
}

ğŸ”„ Using Cron Expressions
For more flexible scheduling, you can use a cron expression.

@Component
public class CronJobScheduler {

    // Runs every day at 10:30 AM
    @Scheduled(cron = "0 30 10 * * ?")
    public void runDailyReport() {
        System.out.println("Running daily report at: " + java.time.LocalTime.now());
    }
}

ğŸ”„ Cron Expression Format
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ second (0â€“59)
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ minute (0â€“59)
â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ hour (0â€“23)
â”‚ â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ day of month (1â€“31)
â”‚ â”‚ â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ month (1â€“12)
â”‚ â”‚ â”‚ â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ day of week (0â€“6) (Sunday=0 or 7)
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚
* * * * * *

âœ… Examples
Cron Expression	Meaning
| Cron Expression      | Meaning                               |
| -------------------- | ------------------------------------- |
| `0 * * * * *`        | Every minute                          |
| `0 0 * * * *`        | Every hour                            |
| `0 0 10 * * *`       | Every day at 10 AM                    |
| `0 0 10 * * MON-FRI` | Every weekday at 10 AM                |
| `0 */5 * * * *`      | Every 5 minutes                       |
| `0 0 0 1 * *`        | On the 1st of every month at midnight |


ğŸ”„ Scheduling with Zone and Initial Delay
You can specify time zones or add a delay before execution.

@Component
public class ReportScheduler {

    // Runs at 9 AM in IST time zone
    @Scheduled(cron = "0 0 9 * * *", zone = "Asia/Kolkata")
    public void generateReport() {
        System.out.println("Generating report at: " + java.time.ZonedDateTime.now());
    }

    // Runs 10 seconds after startup, then every 30 seconds
    @Scheduled(initialDelay = 10000, fixedRate = 30000)
    public void sendStartupNotification() {
        System.out.println("Running after startup: " + java.time.LocalTime.now());
    }
}

ğŸ”„ Use Cases
â¤ Sending periodic emails (daily reports, reminders)
â¤ Cleaning up database logs
â¤ Generating reports
â¤ Triggering backup jobs
â¤ Running batch processes


ğŸ”· Spring Boot With Redis Cache Integration
1ï¸âƒ£ Redis
Redis (Remote Dictionary Server) is an in-memory keyâ€“value data store.
Itâ€™s fast, lightweight, and supports caching, session storage, pub/sub messaging, leaderboard data, etc.


2ï¸âƒ£ Why Redis is used for Caching in Spring Boot
| Reason                          | Explanation                                                    |
| ------------------------------- | -------------------------------------------------------------- |
| ğŸš€ In-memory storage        | Redis stores data in RAM, giving nanosecond-level access times |
| ğŸ§  Persistent option        | Can optionally persist data to disk                            |
| âš–ï¸ Scalable                 | Works well in distributed/microservices systems                |
| ğŸ§© Supports data structures | Strings, Hashes, Lists, Sets, Sorted Sets                      |
| ğŸ•’ TTL (Time To Live)       | Keys can expire automatically after a time                     |
| ğŸ§± Stateless Microservices  | Perfect for caching results shared across instances            |


3ï¸âƒ£ Redis Architecture (Simple Flow)
Client (Spring Boot App)
        |
        |   cache request
        v
   Redis Cache (in-memory)
        |
        |   if not found (cache miss)
        v
   Database (MySQL, etc)
âœ… Cache Hit â†’ value found in Redis â†’ fast response
âŒ Cache Miss â†’ fetch from DB â†’ store result in Redis â†’ serve response


4ï¸âƒ£ Spring Boot Caching Abstraction (Important)
Spring provides a simple caching abstraction via annotations.
| Annotation       | Description                                     |
| ---------------- | ----------------------------------------------- |
| `@EnableCaching` | Enables caching support in Spring Boot          |
| `@Cacheable`     | Stores method result in cache                   |
| `@CachePut`      | Updates cache without skipping method execution |
| `@CacheEvict`    | Removes entry from cache                        |
| `@CacheConfig`   | Defines common cache properties for a class     |


5ï¸âƒ£ How Caching Works Internally
1ï¸âƒ£ When a method annotated with @Cacheable is called:
    â¤ Spring first checks the cache (Redis)
    â¤ If result is found â†’ return cached value
    â¤ If not found â†’ execute method â†’ save result to cache â†’ return result

ğŸ”„ Integrate Redis Cache in Spring Boot
1ï¸âƒ£ Add Dependencies
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-redis</artifactId>
    </dependency>

    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-cache</artifactId>
    </dependency>

    <dependency>
        <groupId>org.apache.commons</groupId>
        <artifactId>commons-pool2</artifactId>
    </dependency>
</dependencies>


2ï¸âƒ£ Install Redis Locally
ğŸ‘‰ Windows:
Use Redis from https://github.com/microsoftarchive/redis/releases

ğŸ‘‰ Start server:
redis-server

ğŸ‘‰ Verify connection:
redis-cli
> ping
PONG

ğŸ‘‰ Stop server:
redis-cli
> shutdown

3ï¸âƒ£ Configure Redis in application.yml
spring:
  cache:
    type: redis
  data:
    redis:
      host: localhost
      port: 6379


ğŸ”„ Method 1ï¸âƒ£: Manual Redis Caching using RedisTemplate
This gives full control â€” you manually define keys, expiry, and log cache hits/misses yourself.

1ï¸âƒ£ Configuration
package com.example.redis.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;

@Configuration
public class RedisConfig {

    @Bean
    public LettuceConnectionFactory redisConnectionFactory() {
        return new LettuceConnectionFactory();
    }

    @Bean
    public RedisTemplate<String, Object> redisTemplate(LettuceConnectionFactory connectionFactory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(connectionFactory);
        return template;
    }
}

2ï¸âƒ£ Model Class
package com.example.redis.model;

import java.io.Serializable;

public class Student implements Serializable {
    private Long id;
    private String name;
    private String branch;

    public Student(Long id, String name, String branch) {
        this.id = id;
        this.name = name;
        this.branch = branch;
    }

    public Long getId() { return id; }
    public String getName() { return name; }
    public String getBranch() { return branch; }

    @Override
    public String toString() {
        return "Student{id=" + id + ", name='" + name + "', branch='" + branch + "'}";
    }
}

3ï¸âƒ£ Service Using RedisTemplate
package com.example.redis.service;

import com.example.redis.model.Student;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;

import java.time.Duration;

@Service
public class StudentServiceManual {

    private static final String CACHE_PREFIX = "STUDENT_";

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    public Student getStudent(Long id) {
        String key = CACHE_PREFIX + id;

        // ğŸ”¹ 1. Try fetching from Redis cache
        Object cachedData = redisTemplate.opsForValue().get(key);
        if (cachedData != null) {
            System.out.println("âœ… [CACHE-HIT] Data fetched from Redis â†’ " + cachedData);
            return (Student) cachedData;
        }

        // ğŸ”¹ 2. Cache miss â†’ fetch from database
        System.out.println("ğŸš€ [CACHE-MISS] Fetching from database for ID: " + id);
        Student student = fetchFromDatabase(id);

        // ğŸ”¹ 3. Store in cache with 5-minute expiry
        redisTemplate.opsForValue().set(key, student, Duration.ofMinutes(5));
        System.out.println("ğŸ§  [CACHE-STORE] Data cached in Redis for 5 minutes â†’ " + student);

        return student;
    }

    public void deleteStudent(Long id) {
        String key = CACHE_PREFIX + id;
        redisTemplate.delete(key);
        System.out.println("ğŸ—‘ï¸ [CACHE-EVICT] Deleted student from Redis cache: " + id);
    }

    private Student fetchFromDatabase(Long id) {
        // Simulate DB call
        return new Student(id, "Ankur Verma", "IT");
    }
}

4ï¸âƒ£ Controller
package com.example.redis.controller;

import com.example.redis.model.Student;
import com.example.redis.service.StudentServiceManual;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/manual")
public class StudentManualController {

    @Autowired
    private StudentServiceManual studentService;

    @GetMapping("/{id}")
    public Student getStudent(@PathVariable Long id) {
        return studentService.getStudent(id);
    }

    @DeleteMapping("/{id}")
    public String deleteStudent(@PathVariable Long id) {
        studentService.deleteStudent(id);
        return "Cache deleted for ID: " + id;
    }
}

ğŸ‘‰ Console Logs
First Request:
ğŸš€ [CACHE-MISS] Fetching from database for ID: 1
ğŸ§  [CACHE-STORE] Data cached in Redis for 5 minutes â†’ Student{id=1, name='Ankur Verma', branch='IT'}

ğŸ‘‰ Second Request:
âœ… [CACHE-HIT] Data fetched from Redis â†’ Student{id=1, name='Ankur Verma', branch='IT'}

ğŸ”„ Pros and Cons
| Pros                                                | Cons                                   |
| --------------------------------------------------- | -------------------------------------- |
| Full control over keys, TTL, eviction               | Manual implementation for every entity |
| Can add custom logics (like custom TTLs per object) | More boilerplate code                  |
| Works independently of Spring Cache abstraction     | Harder to maintain for large apps      |


2ï¸âƒ£: Annotation-Based Caching using @Cacheable, @CacheEvict, and @CachePut
This is the Spring abstraction layer over Redis caching â€” very clean, declarative, and maintainable.

1ï¸âƒ£ Enable Caching
package com.example.redis;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching;

@SpringBootApplication
@EnableCaching
public class RedisAnnotationApp {
    public static void main(String[] args) {
        SpringApplication.run(RedisAnnotationApp.class, args);
    }
}

2ï¸âƒ£ Configuration with TTL (Expiry)

Unlike RedisTemplate, TTL is not directly set in @Cacheable,
so we define TTL at the cache manager level ğŸ‘‡

package com.example.redis.config;

import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.cache.interceptor.SimpleCacheErrorHandler;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.cache.RedisCacheConfiguration;
import org.springframework.data.redis.cache.RedisCacheManager;
import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.RedisSerializationContext;

import java.time.Duration;

@Configuration
@EnableCaching
public class RedisCacheConfig {

    @Bean
    public CacheManager cacheManager(LettuceConnectionFactory connectionFactory) {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofMinutes(5))  // Set global expiry for all caches
                .disableCachingNullValues()
                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer()));

        return RedisCacheManager.builder(connectionFactory)
                .cacheDefaults(config)
                .build();
    }

    @Bean
    public SimpleCacheErrorHandler errorHandler() {
        return new SimpleCacheErrorHandler();
    }
}

3ï¸âƒ£ Service Layer
package com.example.redis.service;

import com.example.redis.model.Student;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.CachePut;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Service;

@Service
public class StudentServiceAnnotation {

    @Cacheable(value = "students", key = "#id")
    public Student getStudent(Long id) {
        System.out.println("ğŸš€ [CACHE-MISS] Fetching student from DB for ID: " + id);
        return fetchFromDatabase(id);
    }

    @CachePut(value = "students", key = "#student.id")
    public Student updateStudent(Student student) {
        System.out.println("â™»ï¸ [CACHE-UPDATE] Updated student in cache â†’ " + student);
        return student;
    }

    @CacheEvict(value = "students", key = "#id")
    public void deleteStudent(Long id) {
        System.out.println("ğŸ—‘ï¸ [CACHE-EVICT] Deleted student from cache ID: " + id);
    }

    private Student fetchFromDatabase(Long id) {
        return new Student(id, "Ankur Verma", "IT");
    }
}

4ï¸âƒ£ Controller
package com.example.redis.controller;

import com.example.redis.model.Student;
import com.example.redis.service.StudentServiceAnnotation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/annotation")
public class StudentAnnotationController {

    @Autowired
    private StudentServiceAnnotation studentService;

    @GetMapping("/{id}")
    public Student getStudent(@PathVariable Long id) {
        return studentService.getStudent(id);
    }

    @PutMapping("/")
    public Student updateStudent(@RequestBody Student student) {
        return studentService.updateStudent(student);
    }

    @DeleteMapping("/{id}")
    public String deleteStudent(@PathVariable Long id) {
        studentService.deleteStudent(id);
        return "Cache deleted for ID: " + id;
    }
}

âœ… Console Output
ğŸ‘‰ First request:
ğŸš€ [CACHE-MISS] Fetching student from DB for ID: 1

ğŸ‘‰ Second request (same ID within TTL):
âœ… [CACHE-HIT] Student fetched from Redis automatically (no DB log)

ğŸ‘‰ On update:
â™»ï¸ [CACHE-UPDATE] Updated student in cache â†’ Student{id=1, name='Ankur Updated', branch='IT'}

ğŸ‘‰ On delete:
ğŸ—‘ï¸ [CACHE-EVICT] Deleted student from cache ID: 1


ğŸ”„ Redis Cache Operations (Conceptually)
| Operation           | Description             | Example            |
| ------------------- | ----------------------- | ------------------ |
| SET key value   | Adds/updates value      | `SET user:1 Ankur` |
| GET key         | Fetch value             | `GET user:1`       |
| DEL key         | Delete key              | `DEL user:1`       |
| EXPIRE key time | Set TTL in seconds      | `EXPIRE user:1 60` |
| TTL key         | Time left before expiry | `TTL user:1`       |


ğŸ”„ Comparison
| Feature          | Method 1: RedisTemplate (Manual) | Method 2: @Cacheable (Annotation)                 |
| ---------------- | ------------------------------------ | ----------------------------------------------------- |
| Control over TTL | Per-entry using `Duration`           | Global TTL via `CacheManager`                         |
| Logging          | Manual (you define hit/miss logs)    | Implicit (you can log inside method to detect misses) |
| Simplicity       | More code                            | Very concise                                          |
| Customization    | Full flexibility                     | Limited (per cache, not per record)                   |
| Ideal for        | Fine-grained caching logic           | Quick declarative caching                             |
| Best Used When   | Complex cache management needed      | Standard read/update/delete caching                   |



ğŸ”· Apache Kafka - Message Broker 
Apache Kafka is a distributed event streaming platform designed to handle high-throughput, real-time data feeds.
It allows different applications or microservices to communicate asynchronously using messages (events).


ğŸ”„ Core Kafka Concepts
| Concept                | Description                                                                                                    |
| ---------------------- | -------------------------------------------------------------------------------------------------------------- |
| Producer           | Publishes messages (events) to a Kafka topic.                                                                  |
| Subscriber           | Subscribes to a topic and processes messages.                                                                | 
| Topic              | A named category or channel where records (messages) are stored and published.                             |
| Partition          | Each topic is divided into partitions for scalability and parallel processing.                                 |
| Offset             | A unique ID for each message in a partition â€” helps track consumer progress.                                   |
| Broker             | A Kafka server that stores messages and handles client requests.                                               |
| Cluster            | A group of brokers working together for scalability and fault tolerance.                                       |
| Consumer Group     | A group of consumers that share the workload â€” each message is processed by only one consumer in the group.    |
| ZooKeeper (Legacy) | Used for managing Kafka cluster provides runtime environment  (replaced by Kafkaâ€™s internal Raft quorum ). |


ğŸ”„ How Kafka Works (Flow)
â¤ Producer sends a message to a topic.
â¤ The topic is divided into partitions stored across brokers.
â¤ Subscribers  (in groups) subscribe to the topic.

â¤ Kafka ensures:
    âœ”ï¸ Each partitionâ€™s messages are ordered.
    âœ”ï¸ Each message is delivered at least once to a consumer group.
    âœ”ï¸ High availability using replication.

ğŸ”„ Why Kafka is Used in Microservices / Spring Boot
| Reason                         | Explanation                                                                                |
| ------------------------------ | ------------------------------------------------------------------------------------------ |
| Decoupling Services        | Producers and consumers donâ€™t need to know each other â€” they communicate via topics.       |
| Asynchronous Communication | Services donâ€™t block each other; producers send messages without waiting for consumers.    |
| Scalability                | Kafka can handle millions of messages per second using partitioning.                       |
| Fault Tolerance            | Kafka replicates data across brokers â€” no message loss if a node fails.                    |
| Replay Capability          | Consumers can reprocess data from any offset â€” useful for debugging or rebuilding systems. |
| Event-Driven Architecture  | Microservices communicate through events instead of direct REST calls.                     |

ğŸ”„ Kafka Architecture Diagram (Conceptually)
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚   Producer 1  â”‚ ---> â”‚               â”‚
 â”‚   Producer 2  â”‚ ---> â”‚   Kafka Topic â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚  (with N partitions)
                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
                       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                       â”‚ Consumer App1 â”‚  (Group A)
                       â”‚ Consumer App2 â”‚  (Group B)
                       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ”„ Kafka Integration with Spring Boot

Spring Boot integrates Kafka using Spring for Apache Kafka (spring-kafka dependency).

1ï¸âƒ£ Add Maven Dependency
<dependency>
    <groupId>org.springframework.kafka</groupId>
    <artifactId>spring-kafka</artifactId>
</dependency>

2ï¸âƒ£ Add Kafka Configuration in application.yml
spring:
  kafka:
    bootstrap-servers: localhost:9092
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.apache.kafka.common.serialization.StringSerializer
    consumer:
      group-id: myGroup
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.apache.kafka.common.serialization.StringDeserializer


3ï¸âƒ£ Create Producer Service
@Service
public class KafkaProducer {

    @Autowired
    private KafkaTemplate<String, String> kafkaTemplate;

    private static final String TOPIC = "test_topic";

    public void sendMessage(String message) {
        kafkaTemplate.send(TOPIC, message);
        System.out.println("Produced message: " + message);
    }
}

4ï¸âƒ£ Create Consumer Listener
@Service
public class KafkaConsumer {

    @KafkaListener(topics = "test_topic", groupId = "myGroup")
    public void consume(String message) {
        System.out.println("Consumed message: " + message);
    }
}


5ï¸âƒ£ Kafka Controller (for testing)
@RestController
@RequestMapping("/kafka")
public class KafkaController {

    @Autowired
    private KafkaProducer producer;

    @GetMapping("/publish/{message}")
    public String sendMessage(@PathVariable String message) {
        producer.sendMessage(message);
        return "Message sent successfully!";
    }
}

ğŸ”„ Architecture Visualization
ğŸ”— Same app (local use)
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚   Spring Boot App    â”‚
 â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
 â”‚  â”‚  Producer    â”‚â”€â”€â”€â”¼â”€â”€â”€â”€â–¶  [ Kafka Broker ]  â—€â”€â”€â”€â”¼â”€â”€â”€â”‚  Consumer Listener â”‚
 â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


Here, both connect to the same broker but serve different purposes.

ğŸ”— Different microservices
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚  Order Service       â”‚      â”‚  Payment Service     â”‚
 â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚      â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
 â”‚  â”‚  Producer    â”‚â”€â”€â”€â”€|â”€â”€â–¶  â”‚  â”‚  Consumer     â”‚    â”‚
 â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚      â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â–²
              â”‚
        [ Kafka Broker ]
        

ğŸ”„ Advanced Kafka Concepts
| Concept                          | Description                                                                         |
| -------------------------------- | ----------------------------------------------------------------------------------- |
| Retention Policy             | Kafka keeps messages for a configurable time (e.g., 7 days) even after consumption. |
| Replication Factor           | Ensures high availability â€” each partitionâ€™s data is replicated across brokers.     |
| Acks (Acknowledgments)       | Controls reliability â€” `acks=0`, `acks=1`, or `acks=all`.                           |
| Idempotent Producer          | Ensures no duplicate messages when retries happen.                                  |
| Transactional Messaging      | Ensures atomicity across multiple Kafka operations.                                 |
| Exactly-Once Semantics (EOS) | Prevents duplicate processing in consumers.                                         |
| Kafka Streams API            | For stream processing â€” transform, aggregate, and process messages in real-time.    |
| Schema Registry (Avro/JSON)  | Manages schemas for structured messages.                                            |
| Offset Management            | Consumer offset can be auto-committed or manually managed.                          |

ğŸ”„ Real-World Use Cases
| Use Case                       | Example                                           |
| ------------------------------ | ------------------------------------------------- |
| Log aggregation            | Collecting logs from multiple servers.            |
| Event sourcing             | Tracking all state changes in microservices.      |
| Stream processing          | Fraud detection, metrics monitoring.              |
| Asynchronous communication | Between order, payment, and inventory services.   |
| Analytics pipelines        | Real-time data ingestion into Spark/Flink/Hadoop. |

