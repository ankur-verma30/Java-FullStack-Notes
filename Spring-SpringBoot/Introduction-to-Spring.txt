ğŸŒ± What is Spring?
â¤ Spring is a lightweight, open-source framework for building enterprise-level Java applications.
â¤ It mainly provides Infrastructure support so developers can focus on business logic instead of boilerplate code.

ğŸ“ Another Definition:
Spring is a framework for dependency-injection (It means outsourcing the task of object creation) which is a pattern that allows to build very decoupled systems.

ğŸ‘‰ Think of it as a toolbox that gives ready-made solutions for common problems in enterprise apps.

â“ Why Spring? (Motivation)
ğŸ”„ Before Spring:
â¤ Java EE (J2EE/EJB) was complex, heavy, and hard to configure.
â¤ Developers wrote lots of boilerplate code (factory classes, object creation, dependency management).

Spring solved this by:
â¤ Providing Dependency Injection (DI) â†’ reduces tight coupling.
â¤ Enabling Aspect-Oriented Programming (AOP) â†’ for cross-cutting concerns (logging, security).
â¤ Offering modularity â†’ use only what you need (not forced to use the whole framework).

ğŸ”„ Key Features
âœ”ï¸ IoC Container â†’ Handles object creation & wiring.
âœ”ï¸ Dependency Injection â†’ Reduces coupling.
âœ”ï¸ AOP â†’ Separates cross-cutting concerns.
âœ”ï¸ Transaction Management â†’ Easy DB transaction handling.
âœ”ï¸ Integration â†’ Works well with Hibernate, JPA, JDBC, JMS, etc.
âœ”ï¸ Testability â†’ Beans are POJOs (Plain Old Java Objects), easy to test with JUnit/Mockito.

âœ… Advantages of Spring
1ï¸âƒ£ Loose Coupling â†’ via DI.
2ï¸âƒ£ Lightweight â†’ No heavy EJB containers.
3ï¸âƒ£ Productivity â†’ Reduces boilerplate code.
4ï¸âƒ£ Flexibility â†’ Modular architecture (choose only needed modules).
5ï¸âƒ£ Community Support â†’ Widely used, rich ecosystem.

ğŸ‘‰ Interview Hack: If asked "What is Spring Boot?" â€” always start by explaining Spring, then contrast with Boot.

âš¡ Adding Spring to a Maven Project
1ï¸âƒ£ Required Dependencies
â¤ To start with basic Spring (IoC + DI + ApplicationContext), you need at least:
â¤ spring-core â†’ contains fundamental classes (IoC, DI).
â¤ spring-context â†’ builds on core, adds ApplicationContext, bean lifecycle, internationalization, etc.

âœ… Maven pom.xml Example

<dependencies>
    <!-- Spring Core -->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-core</artifactId>
        <version>5.3.36</version> <!-- use latest stable -->
    </dependency>

    <!-- Spring Context -->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>5.3.36</version>
    </dependency>
</dependencies>
ğŸ‘‰ If using Spring Boot, you donâ€™t need to add these separately â€” just add spring-boot-starter and Boot manages versions.


ğŸ”„ Spring IoC Container
â¤IoC (Inversion of Control) Container is the core of Spring Framework.
â¤It is responsible for:
    âœ”ï¸ Creating objects (beans)
    âœ”ï¸ Managing their lifecycle (init â†’ use â†’ destroy)
    âœ”ï¸ Injecting dependencies (Dependency Injection)
    âœ”ï¸ Configuring and wiring beans together

ğŸ‘‰ In short: IoC Container is the â€œfactoryâ€ where all Spring-managed objects (beans) live.

â“ How it Works
â¤ You define beans (via XML, annotations, or Java Config).
â¤ The IoC container reads the configuration and creates objects.
â¤ It also wires dependencies automatically (through DI).
â¤ Application code just uses beans instead of creating them manually.

ğŸ”„ Types of IoC Containers in Spring
1ï¸âƒ£ BeanFactory (Interface)
â¤ Basic version of IoC container.
    âœ”ï¸ Basic container â†’ provides DI functionality.
    âœ”ï¸ Lazy initialization (beans are created only when requested).
    âœ”ï¸ Lightweight, good for simple applications or memory-constrained environments.

2ï¸âƒ£ ApplicationContext (Interface)
â¤ Advanced container â†’ superset of BeanFactory.
â¤ Eager initialization (beans are created at startup by default).
â¤ Provides extra features:
    âœ”ï¸ Event propagation
    âœ”ï¸ Internationalization (i18n)
    âœ”ï¸ Bean post-processors
    âœ”ï¸ Easy integration with Spring AOP

ğŸ‘‰ In real-world Spring apps, we mostly use ApplicationContext.

ğŸ“ Common Implementations
â¤ ClassPathXmlApplicationContext â†’ Loads bean definitions from XML in classpath.
â¤ FileSystemXmlApplicationContext â†’ Loads from XML in filesystem.
â¤ AnnotationConfigApplicationContext â†’ Loads from Java-based configuration classes.


ğŸ”· Ways to Configure IoC Container in Spring
The IoC Container (BeanFactory / ApplicationContext) needs to know what beans to create and how to wire them.
We can configure it in 3 main ways:

1ï¸âƒ£ XML-Based Configuration ğŸ“ (Old Style)
Beans and dependencies are declared in an XML file (e.g., beans.xml).

âœ… Example:
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- Bean Definition -->
    <bean id="car" class="com.example.Car">
        <!-- Setter Injection -->
        <property name="engine" ref="engine"/>
    </bean>

    <bean id="engine" class="com.example.Engine"/>
</beans>


ğŸ”— Java code:
ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");
Car car = context.getBean("car", Car.class);

ğŸ‘‰ Interview Angle: XML was common in older projects. Still seen in legacy systems.


2ï¸âƒ£ Annotation-Based Configuration 
â¤ Beans are detected using annotations like @Component, @Service, @Repository, @Controller.
â¤ Dependencies injected with @Autowired, @Qualifier, @Value.
â¤ Component scanning must be enabled in XML or Java config.

âœ… Example:
@Component
class Engine {}

@Component
class Car {
    @Autowired
    private Engine engine;
}

ğŸ”— Java Config to enable scanning:
@Configuration
@ComponentScan("com.example")
class AppConfig {}

ğŸ”— Java code:
ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
Car car = context.getBean(Car.class);
ğŸ‘‰ Interview Tip: Most modern Spring apps use this approach.


3ï¸âƒ£ Java-Based Configuration (JavaConfig) â˜•
â¤ Uses @Configuration and @Bean annotations (no XML required).
â¤ Beans are defined directly inside a config class.

âœ… Example:
@Configuration
class AppConfig {
    @Bean
    public Engine engine() {
        return new Engine();
    }

    @Bean
    public Car car() {
        return new Car(engine());
    }
}

ğŸ”— Java code:
ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
Car car = context.getBean(Car.class);

ğŸ‘‰ Interview Tip: JavaConfig is preferred in Spring Boot and modern projects because itâ€™s type-safe, refactor-friendly, and avoids verbose XML.

// Vechile.java Interface
public interface Vechile {
    String getMilage();
}

Car.java Implementation
public class Car implements Vechile {
    public String getMilage() {
        return "Car Milage is 30km/l";
    }
}

Bus,java Implementation
public class Bus implements Vechile {
    public String getMilage() {
        return "Bus Milage is 20km/l";
    }
}

// Main Application to demonstrate Spring IoC and DI
package vechiles;

import org.springframework.context.support.ClassPathXmlApplicationContext;

public class MySpringApp {

	public static void main(String[] args) {
		//providing application context --> config.xml
		ClassPathXmlApplicationContext context= new ClassPathXmlApplicationContext("config.xml");
		Vechile vechile=context.getBean("myVechile", Vechile.class);
		System.out.println(vechile.getMilage());
	}
}

ğŸ”„ Step 1: Package & Imports
package vechiles;

import org.springframework.context.support.ClassPathXmlApplicationContext;

â¤ Youâ€™ve defined your classes under vechiles package.
â¤ ClassPathXmlApplicationContext â†’ a type of ApplicationContext that loads bean definitions from an XML file located in the classpath.

ğŸ”„ Step 2: Main Method
ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("config.xml");
 
â¤ Here, Spring creates the IoC container (ApplicationContext) and reads the config.xml file.
â¤ What happens internally:
    âœ”ï¸ Spring parses the XML.
    âœ”ï¸ Creates all beans defined in the XML.
    âœ”ï¸ Resolves and injects dependencies (setter, constructor, or autowired).
â¤ From this point, Spring is in control of all your beans.

ğŸ”„ Step 3: Retrieving the Bean
Vechile vechile = context.getBean("myVechile", Vechile.class);

â¤ getBean asks the IoC container: â€œGive me the bean with id myVechile and cast it to Vechile.â€
â¤ Spring returns the singleton instance (default scope) of the bean.
â¤ Now vechile is a fully initialized object with all dependencies injected.

ğŸ”„ Step 4: Using the Bean
â¤ Calls a method (getMilage()) on the Spring-managed object.
â¤ No need to new the object yourself; Spring already created and wired it.


ğŸ”· Dependency Injection (DI) in Spring
â¤ Dependency Injection (DI) is a design pattern in which an object receives its dependencies from an external source rather than creating them itself.
â¤ In Spring, the IoC Container is responsible for injecting these dependencies into beans.

â“ Why DI is Useful
â¤ Loose Coupling â†’ Classes donâ€™t depend on concrete implementations.
â¤ Easier Testing â†’ You can inject mock dependencies.
â¤ Reusability â†’ Classes focus only on business logic.
â¤ Better Maintainability â†’ Changes in one class donâ€™t require changing all dependent classes.

â“ How DI Works in Spring
1ï¸âƒ£ Define beans (objects) in XML, JavaConfig, or annotations.
2ï¸âƒ£ Spring IoC container creates beans.
3ï¸âƒ£ Spring injects the required dependencies (via constructor, setter, or field).
4ï¸âƒ£ Your code uses the beans without creating dependencies manually.

âš¡ Ways to Implement Dependency Injection (DI) in Spring
â¤ Dependency Injection (DI) = letting Spring provide the dependencies to your beans instead of creating them manually.

â¤ There are three main ways to do this:
1ï¸âƒ£ Constructor Injection
â¤ Spring injects dependencies via the class constructor.
â¤ Recommended for mandatory dependencies because the bean cannot be created without them.

âœ… Example:
ğŸ”— DiscountService.java
Interface DiscountService {
    String getDiscountMessage();
}

ğŸ”— FestivalDiscountServiceImpl.java
class FestivalDiscountServiceImpl implements DiscountService {
    public String getDiscountMessage() {
        return "Festival Discount Applied!";
    }
}

ğŸ”— Car.java
class Car {
    private DiscountService discountService;

    // Constructor Injection
    public Car(DiscountService discountService) {
        this.discountService = discountService;
    }
}

ğŸ”— MySpringApp.java
package vechiles;

import org.springframework.context.support.ClassPathXmlApplicationContext;

public class MySpringApp {

	public static void main(String[] args) {
		//providing application context --> config.xml
		ClassPathXmlApplicationContext context= new ClassPathXmlApplicationContext("config.xml");
		Vechile vechile=context.getBean("myVechile", Vechile.class);
		System.out.println(vechile.getMilage());
		System.out.println(vechile.getDiscountMessage());
	}

}
â¤ Spring automatically finds the Engine bean and passes it to the Car constructor.

ğŸ“ Works with XML:
 <bean id="myVechile" class="vechiles.Car">
    <constructor-arg ref="myDiscountService"></constructor-arg>
    </bean>
    <bean id="myDiscountService" class="vechiles.FestivalDiscountServiceImpl"></bean>


2ï¸âƒ£  Setter Injection
â¤ Spring injects dependencies via setter methods.
â¤ Good for optional dependencies or when you want to change dependencies after bean creation.

âœ… Example:
@Component
class Car {
    private Engine engine;

    // Setter Injection
    @Autowired
    public void setEngine(Engine engine) {
        this.engine = engine;
    }
}

ğŸ“ XML equivalent:
<bean id="car" class="vechiles.Car">
    <property name="engine" ref="engine"/>
</bean>
<bean id="engine" class="vechiles.Engine"/>

3ï¸âƒ£  Field Injection
â¤ Spring injects dependencies directly into the field using @Autowired.
â¤ No constructor or setter needed.
â¤ Often used in Spring Boot projects for simplicity, but less testable than constructor injection.
â¤ Cannot be done through XML configuration.

âœ… Example:
@Component
class Car {
    @Autowired
    private Engine engine;
}

ğŸŒ± Bean Scope in Spring
â¤ Bean scope defines how many instances of a bean the Spring Container creates and how long they live inside the container.
â¤ It controls the lifecycle and visibility of a bean.
â¤ Declared using scope attribute (XML) or @Scope annotation.

ğŸŒŸ Types of Bean Scopes
1ï¸âƒ£ Singleton (Default)
â¤ Only one instance per Spring container.
â¤ All requests for this bean return the same object.
â¤ Best for stateless beans (services, DAOs).
â¤ Default scope if you donâ€™t specify anything.

ğŸ”— Code Implementation in XML:
<bean id="myBean" class="com.example.MyClass" scope="singleton"/>

ğŸ”— Using Annotation:
@Component
@Scope("singleton")
public class MyService {}

2ï¸âƒ£ Prototype
â¤ New instance is created every time the bean is requested.
â¤ Best for stateful beans (objects holding user-specific data).
â¤ Spring does not manage full lifecycle â†’ only initialization, no destroy callback.

ğŸ”— Code Implementation:
<bean id="myBean" class="com.example.MyClass" scope="prototype"/>

ğŸ”— Using Annotation:
@Component
@Scope("prototype")
public class MyService {}

3ï¸âƒ£ Request (Web-aware)
â¤One bean per HTTP request.
â¤Valid only in Spring Web Applications.
â¤Each HTTP request â†’ new bean instance.

ğŸ”— Code Implementation:
@Component
@Scope("request")
public class MyControllerBean {}

4ï¸âƒ£ Session (Web-aware)
â¤ One bean per HTTP Session.
â¤ Same user session â†’ same bean.
â¤ Different sessions â†’ different beans.

ğŸ”— Code Implementation:
@Component
@Scope("session")
public class MySessionBean {}

5ï¸âƒ£ Application (Web-aware)
â¤ One bean instance per ServletContext
â¤ Shared across all requests and sessions.

ğŸ”— Code Implementation:
@Component
@Scope("application")
public class MyAppBean {}

6ï¸âƒ£ WebSocket (Spring 4.0+)
â¤ One bean per WebSocket session.
â¤ Used in real-time messaging apps.

ğŸ”— Code Implementation:
@Component
@Scope("websocket")
public class MyWebSocketBean {}


ğŸ”·Java Annotation?
â¤ Java annotations are metadata (extra information) added to code (classes, methods, interface, fields etc.) that provide instructions to the compiler or the runtime (JVM/frameworks like Spring, Hibernate, JUnit, etc.).
â¤ They do not affect the execution of code directly but can be used by tools, frameworks, and compilers.
â¤ Introduced in: Java 5

â“ Why Annotations?
â¤ To reduce XML configuration (esp. in frameworks like Spring, Hibernate).
â¤ To give hints to compiler (e.g., @Override).
â¤ To enable automatic processing (e.g., dependency injection, mapping).

ğŸ”„ Spring @Component Annotation Implementation
package com.tcs.vechiles;

import org.springframework.stereotype.Component;

@Component   // Marks this class as a Spring Bean
public class Car implements Vechile { 

	@Override
	public String getMilage() {
		return "30Kmpl";
	}
}
1ï¸âƒ£ @Component
â¤ This tells Spring: â€œHey, this is a bean. Manage its lifecycle for me.â€
â¤ By default, Spring will create a bean with the class name starting with a lowercase letter.
    âœ”ï¸ Car â†’ bean name = "car".
â¤ Instead of defining the bean in beans.xml, you just use @Component.

âœ… Example:
@Component("myCar")  // Custom bean id
public class Car implements Vechile { ... }

2ï¸âƒ£ Bean Creation
â¤ When Springâ€™s component scan runs, it looks for classes annotated with @Component (and other stereotypes like @Service, @Repository, @Controller).
â¤ It registers them as beans in the ApplicationContext.

3ï¸âƒ£ Interface
public interface Vechile {
    String getMilage();
}
ğŸ‘‰ Since Car implements Vechile, you can inject it wherever a Vechile is required.

âœ… How to enable it?
In your Spring config, you must enable component scanning:

Using XML:
<context:component-scan base-package="com.tcs.vechiles"/>

Using Java Config:
@Configuration
@ComponentScan(basePackages = "com.tcs.vechiles")
public class AppConfig { }


ğŸ”„ Using the Bean
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class Test {
    public static void main(String[] args) {
        ApplicationContext context =
            new AnnotationConfigApplicationContext(AppConfig.class);

        Vechile car = context.getBean(Car.class);
        System.out.println(car.getMilage()); // Output: 30Kmpl
    }
}

ğŸ”„ @Autowired Annotation
â¤ @Autowired is used for dependency injection.
â¤ It tells Spring: â€œFind a matching bean and inject it here automatically.â€
â¤ Spring uses type-based injection by default (looks for a bean with the same type).

ğŸ”· Perfomring Dependency Injection
âš¡Vechile Interface
package com.tcs.vechiles;

public interface Vechile {
public String getMilage();
public String getDiscountMessage();
}

âš¡DiscountService Interface
package com.tcs.vechiles;

public interface DiscountService {
public String getDiscountMessage();
}

âš¡ DiscountServiceImpl class
package com.tcs.vechiles;
import org.springframework.stereotype.Component;

@Component
public class discountServiceImpl implements DiscountService {
public String getDiscountMessage() {
return "Festival Discount Applied!";
    }
}

âš¡ Constructor implementations in Car class
Class Car{
Method 1ï¸âƒ£: Using @Autowired on Field
    @Autowired
private DiscountService discountService;

Method 2ï¸âƒ£: Using @Autowired on Constructor
@Autowired
	public Car(DiscountService discountService) {
		this.discountService=discountService;
	}
     @Override
    public String getMilage() {
        return "30Kmpl";
    }
    @Override
    public String getDiscountMessage() {
        return discountService.getDiscountMessage();
    }

Method 3ï¸âƒ£: Using @Autowired on Setter Method
  @Autowired
	public void setDiscountService(DiscountService discountService) {
		this.discountService = discountService;
	}
}

âš¡ Main Application
public class MySpringApp {

	public static void main(String[] args) {
ClassPathXmlApplicationContext context=new ClassPathXmlApplicationContext("config.xml");
	Vechile bean = context.getBean("car",Vechile.class);
	System.out.println(bean.getMilage());
	System.out.print(bean.getDiscountMessage());
	}
}

ğŸ”· @Qualifier Annotation
â¤ When there are multiple beans of the same type, Spring gets confused which one to inject.
âœ… Example: If you have both Car and Bike implementing Vechile, @Autowired alone will throw an exception.
â¤ @Qualifier tells Spring which bean to inject by bean name.
â¤ @Qualifier("beanName") works with:
    âœ”ï¸ Field Injection
    âœ”ï¸ Constructor Injection
    âœ”ï¸ Setter Injection
beanName is the name of the bean you want to inject. It can be the default name (class name with lowercase first letter) or a custom name set using @Component("customName") or in XML.

ğŸ”„ Field Injection
@Autowired
@Qualifier("beanName")
private Vechile vechile;

ğŸ”„ Setter Injection
@Autowired
public void setVechile(@Qualifier("beanName") Vechile vechile) {
    this.vechile = vechile;
}

ğŸ”„ Constructor Injection
@Autowired
public VehicleService(@Qualifier("beanName") Vechile vechile) {
    this.vechile = vechile;
}

âœ… Example:
@Component("myCar")
class Car implements Vechile { ... }

@Component("myBike")
class Bike implements Vechile { ... }

@Component
class VehicleService {
    @Autowired
    @Qualifier("myCar")  // Specify which bean to inject 
    private Vechile vechile;
}

âš¡ Note: 
â¤ If name of the bean is WWEDiscountServiceImpl then if we make @Qualifier("wWEDiscountServiceImpl") then it will throw an exception.
â¤ So if first letter and second letter is in uppercase then we the bean id remains same as class name.
â¤ So we have to use @Qualifier("WWEDiscountServiceImpl") to avoid exception.


ğŸ”· Working with application.properties in Spring and Spring Boot
â¤ application.properties is a configuration file in Spring Framework / Spring Boot projects.
â¤ It stores keyâ€“value pairs that define the external configuration of the application.
â¤ Instead of hardcoding values in Java code, we put them in application.properties so they can be easily changed without recompiling.
â¤ Spring automatically loads this file from the src/main/resources/ folder.

1ï¸âƒ£ Spring (without Boot)
In Spring (core + context) projects, you need to explicitly load property files.

âœ”ï¸ Step 1: application.properties
car.brand=Honda
car.mileage=30
car.price=850000

âœ”ï¸ Step 2: Enable property file in XML config
<context:property-placeholder location="classpath:application.properties"/>

âœ”ï¸ Step 3: Use @Value in Java class
package com.tcs.vechiles ;

@Component
public class Car {

    @Value("${car.brand}")
    private String brand;

    @Value("${car.mileage}")
    private int mileage;

    @Value("${car.price}")
    private double price;

    public void showDetails() {
        System.out.println("Brand: " + brand);
        System.out.println("Mileage: " + mileage + " kmpl");
        System.out.println("Price: â‚¹" + price);
    }
}

âœ”ï¸ Step 4: Run from main class
âœ… Output:
Brand: Honda
Mileage: 30 kmpl
Price: â‚¹850000.0

2ï¸âƒ£ Spring Boot (Recommended)
In Spring Boot, application.properties is auto-loaded â€” no need for <context:property-placeholder>.

âœ”ï¸ Step 1: src/main/resources/application.properties
car.brand=Toyota
car.mileage=28
car.price=1200000

âœ”ï¸ Step 2: Use @Value
package com.tcs.vechiles;

@Component
public class Car {

    @Value("${car.brand}")
    private String brand;

    @Value("${car.mileage}")
    private int mileage;

    @Value("${car.price}")
    private double price;

    public void showDetails() {
        System.out.println("Brand: " + brand);
        System.out.println("Mileage: " + mileage + " kmpl");
        System.out.println("Price: â‚¹" + price);
    }
}

âœ”ï¸ Step 3: Run from @SpringBootApplication main class
import com.tcs.vechiles.Car;

@SpringBootApplication
public class DemoApplication implements CommandLineRunner {

    @Autowired
    private Car car;

    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }

    @Override
    public void run(String... args) {
        car.showDetails();
    }
}
âœ… Output (from Boot):
Brand: Toyota 
Mileage: 28 kmpl
Price: â‚¹1200000.0

ğŸ”„ Use Case of Value Annotation
â¤ Externalize configuration (DB URLs, API keys, etc.)
â¤ Inject values from property files.


ğŸ”· @ComponentScan Annotation
â¤ Tells Spring where to look for components (@Component, @Service, @Repository, @Controller, etc.). 
â¤ By default, Spring Boot scans the package where your @SpringBootApplication class is located and all its sub-packages.

âœ… Example
@ComponentScan(basePackages = {"com.tcs.vechiles", "com.tcs.services"})
public class DemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}
â¤ Without @ComponentScan, Spring Boot automatically scans the current package of DemoApplication and subpackages.
â¤ With @ComponentScan, you can override and specify custom packages.


ğŸ”· @Configuration in Spring
â¤ Marks a class as a source of bean definitions.
â¤ Typically used with @Bean methods to create and configure beans manually.
â¤ It replaces XML configuration in pure Java-based configuration.

âœ… Example
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan("com.tcs.vechiles")
public class AppConfig {

    @Bean
    public Car myCar() {
        return new Car("Honda", 30);
    }

    @Bean
    public Bike myBike() {
        return new Bike("Yamaha", 45);
    }
}

public class MySpringApp {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext
     context = new AnnotationConfigApplicationContext(AppConfig.class);
        Car car = context.getBean(Car.class);
        System.out.println(car.getDetails());
    }
}
â¤ Here AppConfig acts like a replacement of beans.xml.
â¤ Spring will scan @Configuration classes and register beans in the container.

âœ… Difference from @Component
â¤ @Component â†’ used on a class to auto-detect and register it as a bean.
â¤ @Configuration â†’ used on a class that explicitly defines beans using methods.


ğŸ”· @Bean Annotation
â¤ Declares a Spring bean explicitly inside a @Configuration class.
â¤ Alternative to XML <bean> definition.
â¤ Method annotated with @Bean â†’ Spring will call it and register its return object as a bean in the container.

âœ… Example
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class AppConfig {

    @Bean
    public Car car() {
        return new Car("Honda", 30);  // bean name = "car"
    }

    @Bean(name = "bikeBean")   // custom bean name
    public Bike bike() {
        return new Bike("Yamaha", 45);
    }
}
âš¡Note: If you donâ€™t specify a name, the method name is used as the bean id.

âœ… Usage
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class TestApp {
    public static void main(String[] args) {
        ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);

        Car car = context.getBean(Car.class);
        car.showDetails();

        Bike bike = (Bike) context.getBean("bikeBean");
        bike.showDetails();
    }
}

ğŸ”· @PropertySource Annotation in Spring
Loads properties files into Springâ€™s Environment.
Works with @Value to inject property values into beans.
Alternative to XML <context:property-placeholder>.

âœ… Example
application.properties (in src/main/resources)
car.brand=Toyota
car.mileage=25

Config class
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;
import org.springframework.beans.factory.annotation.Value;

@Configuration
@PropertySource("classpath:application.properties")
public class AppConfig {

    @Value("${car.brand}")
    private String brand;

    @Value("${car.mileage}")
    private int mileage;

    @Bean
    public Car car() {
        return new Car(brand, mileage);
    }
}

ğŸ”—Bean class
public class Car {
    private String brand;
    private int mileage;

    public Car(String brand, int mileage) {
        this.brand = brand;
        this.mileage = mileage;
    }

    public void showDetails() {
        System.out.println("Brand: " + brand + ", Mileage: " + mileage + " kmpl");
    }
}
âœ… Output:
Brand: Toyota, Mileage: 25 kmpl


ğŸŒ¿ Spring MVC (Modelâ€“Viewâ€“Controller)
â¤ Spring MVC is a web framework provided by the Spring Framework to build web applications (both web pages & REST APIs).
â¤ It follows the Modelâ€“Viewâ€“Controller (MVC) design pattern.

ğŸ”‘ Architecture of Spring MVC
1ï¸âƒ£ DispatcherServlet (Front Controller)
â¤ Entry point for all requests.
â¤ Delegates requests to appropriate controllers.

2ï¸âƒ£ Controller
â¤ Handles user requests.
â¤ Interacts with the service layer & returns Model + View.

3ï¸âƒ£ Model
â¤ Stores application data.
â¤ Acts as a container for objects to pass between Controller and View.

4ï¸âƒ£ View
â¤ Presents data (HTML, JSP, Thymeleaf, JSON, etc.)
â¤ Uses model data to render UI.

âš™ï¸ Spring MVC Flow
â¤ User sends request â†’ DispatcherServlet.
â¤ DispatcherServlet â†’ finds handler/controller using HandlerMapping.
â¤ Controller executes â†’ returns ModelAndView (data + view).
â¤ DispatcherServlet â†’ forwards to ViewResolver.
â¤ ViewResolver â†’ selects view (e.g., JSP/Thymeleaf).
â¤ Response â†’ sent back to the user.


ğŸ”‘  @RequestMapping?
â¤ It is an annotation used in Spring MVC and Spring Boot.
â¤ Maps HTTP requests (URL + Method type) to specific controller methods.
â¤ Works at class level (base URL) and method level (specific endpoints).

âœ¨ Basic Usage
@Controller
public class HomeController {

    @RequestMapping("/hello")
    public String sayHello(Model model) {
        model.addAttribute("message", "Hello Spring!");
        return "home"; // resolves to home.jsp or home.html
    }
}

ğŸ‘‰ Visiting http://localhost:8080/hello â†’ calls sayHello().
âš™ï¸ Class-Level + Method-Level Mapping
@Controller
@RequestMapping("/api") // base path
public class UserController {

    @RequestMapping("/users")
    public String getUsers(Model model) {
        model.addAttribute("data", "All Users Data");
        return "users";
    }

    @RequestMapping("/admins")
    public String getAdmins(Model model) {
        model.addAttribute("data", "All Admins Data");
        return "admins";
    }
}
ğŸ‘‰ URLs will be:
/api/users
/api/admins


ğŸ”· @RequestParam?
â¤ Annotation used in Spring MVC (and Spring Boot).
â¤ Binds query parameters (from URL or form data) to method arguments.
â¤ Helps extract values like /search?q=laptop&page=2.

âœ… Example: 
@Controller
public class SearchController {

    @RequestMapping("/search")
    public String search(@RequestParam("q") String query, Model model) {
        model.addAttribute("result", "You searched for: " + query);
        return "searchResult";
    }
}
â¤ Model Attribute "result" will contain the search query.
ğŸ‘‰ URL: /search?q=laptop
âœ” query = "laptop"

âš™ï¸ Multiple Parameters
@Controller
@RequestMapping("/products")
public class ProductController {

    @RequestMapping("/filter")
    public String filterProducts(@RequestParam("category") String category,
                                 @RequestParam("price") int price,
                                 Model model) {
        model.addAttribute("result", "Category: " + category + ", Price: " + price);
        return "filterResult";
    }
}
ğŸ‘‰ URL: /products/filter?category=mobile&price=20000
âœ” category = "mobile", price = 20000

ğŸ”„ Optional Parameters (required=false)
â¤ By default, @RequestParam is required.
â¤ If parameter is missing â†’ Spring throws error.

@RequestMapping("/greet")
public String greet(@RequestParam(value = "name", required = false) String anyName, Model model) {
    if (name == null) name = "Guest";
    model.addAttribute("msg", "Hello " + name);
    return "greet";
}
ğŸ‘‰ /greet â†’ "Hello Guest"
ğŸ‘‰ /greet?name=Ankur â†’ "Hello Ankur"

ğŸ¯ Default Value
@RequestMapping("/page")
public String getPage(@RequestParam(value = "p", defaultValue = "1") int page, Model model) {
    model.addAttribute("pageNumber", page);
    return "pageView";
}
ğŸ‘‰ /page â†’ page = 1
ğŸ‘‰ /page?p=5 â†’ page = 5

ğŸ“¦ Handling Lists
@RequestMapping("/ids")
public String getIds(@RequestParam List<Integer> id, Model model) {
    model.addAttribute("ids", id);
    return "idView";
}
ğŸ‘‰ /ids?id=10&id=20&id=30
âœ” id = [10, 20, 30]