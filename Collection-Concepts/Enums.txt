ðŸ”· Enums in Java 
Enum (short for enumeration) is a special data type in Java used to represent a fixed set of named constants.

Introduced in Java 5.

Syntax:
enum EnumName {
    CONSTANT1, CONSTANT2, CONSTANT3
}

ðŸŒŸCharacteristics
âž¤ Each constant in an enum is public, static, and final by default.
âž¤ Enum extends java.lang.Enum internally.
âž¤ Cannot extend another class because enums already extend Enum.
âž¤ Can implement interfaces.
âž¤ Can have fields, constructors, and methods.
âž¤ Enum constants are singleton objects.

3. When to Use
1. When you have a predefined set of related constants, such as:
   âž¤ Days of the week (MONDAY, TUESDAY, â€¦)
   âž¤ States in a process (STARTED, IN_PROGRESS, COMPLETED)
   âž¤ Severity levels (MINOR, MAJOR, CRITICAL)
2. Avoids "magic numbers" and string literals in code.

ðŸŒŸ Issues Without Enums (Your Current Code Problems)
âž¤ Constants like MINOR=0, MAJOR=1 require manual mapping.
âž¤ Risk of passing invalid values (e.g., 5 for severity).
âž¤ Poor readability: You have to remember what 1 or 2 means.
âž¤ No type safety â€” any int can be passed to methods.
âž¤ Switching over raw numbers is error-prone.
âž¤ Difficult to maintain â€” adding/removing constants requires editing multiple locations.

ðŸŒŸ Benefits of Using Enums
âœ… Type Safety â€” Compiler ensures only valid enum constants are used.
âœ… Readability â€” Constants have meaningful names.
âœ… No invalid values â€” Cannot pass unrelated numbers/strings.
âœ… Easy to maintain â€” Adding new constants is straightforward.
âœ… Can store data & behavior â€” Enums can have fields, constructors, and methods.

âŒ Code without Enums

public class Severity{
    final static int MINOR=0;
    final static int MAJOR=1;
    final static int CRITICAL=2;
}

public class Defect{
    public static int getDefectFixingTime( int severity){
        return switch(severity){
            case 0 -> 1;
            case 1->  3;
            case 2 -> 5;
            default -> thorw new IllegalArgumentException("Unexpected Value);
        }
    }
}

public class ReportDefect {
public static void main(String[] args) {
	int days=Defect.getDefectFixingTime(2);
	System.out.println(days);
}
}

âœ… Rewritten Using Enums
enum Severity {
    MINOR(1), MAJOR(3), CRITICAL(5);

    private final int fixingDays;

    //by default private constructor
    Severity(int fixingDays) {
        this.fixingDays = fixingDays;
    }

    //getter method
    public int getFixingDays() {
        return fixingDays;
    }
}

class Defect {

    public static int getDefectFixingTime(Severity severity) {
        return severity.getFixingDays();
    }
}

public class ReportDefect {
    public static void main(String[] args) {
        int days = Defect.getDefectFixingTime(Severity.CRITICAL);
        System.out.println(days);
    }
}

ðŸ”„How This Works

1. enum Severity:
    âž¤ Represents fixed constants MINOR, MAJOR, and CRITICAL.
    âž¤ Each constant stores an extra value (number of days) using a field.
    âž¤ Constructor assigns this value.
    âž¤ Method getFixingDays() retrieves it.

Defect class:
    âž¤ Accepts only Severity type â€” prevents invalid arguments.

ReportDefect class:
    âž¤ Calls method with an enum constant.
    âž¤ Output for Severity.CRITICAL â†’ 5.

ðŸŒŸKey Enum Features Used Here
âž¤ Parameterized Enums: Storing extra information (fixingDays).
âž¤ Type-Safe Method Parameters: Accepting Severity instead of int.

Built-in Enum Methods:
    âž¤ values() â†’ Returns all constants.
    âž¤ valueOf(String name) â†’ Returns constant by name.
    âž¤ ordinal() â†’ Returns index of constant (0-based).

Example:
for (Severity s : Severity.values()) {
    System.out.println(s + " takes " + s.getFixingDays() + " days");
}

ðŸŒŸEnum Memory & Performance
âž¤ Each enum constant is a singleton instance created at class load time.
âž¤ Performance-friendly â€” Similar to using static final constants but safer and more maintainable.
âž¤ No extra overhead for typical usage.

ðŸŒŸTips
âž¤ Enums in Java are class-like, not just constants.
âž¤ They are more powerful than enums in languages like C/C++.
âž¤ Can override methods for individual constants.
âž¤ Cannot extend other classes but can implement interfaces.
âž¤ Best practice: Use enums instead of int constants for fixed sets of values.    

| Aspect             | Int Constants (final static)                                            Enums                                                                  |
| Readability        | Less clear â€” values appear as numbers, meaning must be remembered or checked in code | Very clear â€” values have meaningful names               |
| Type Safety        | None â€” any integer can be passed accidentally                       | Strong â€” only predefined enum constants can be used                      |
| Maintainability    | Difficult â€” changing values may break multiple places silently      | Easy â€” changes are localized, compiler helps catch errors                |
| Extensibility      | Limited â€” adding new constants requires careful changes everywhere  | Easy â€” just add new enum constants without affecting existing logic much |
| Error Prevention   | Low â€” invalid integers may go unnoticed until runtime               | High â€” compile-time validation prevents most mistakes                    |
| Debugging          | Hard â€” logs show numbers without context                            | Easy â€” logs show constant names directly                                 |
| Refactoring Safety | Risky â€” renaming or reordering constants may cause logical issues   | Safe â€” compiler enforces correct usage                                   |
| Performance        | Slightly better in raw speed (no object creation)                   | Negligible performance difference for most applications                  |
| Business Risk      | Higher â€” more prone to bugs due to wrong values                     | Lower â€” safer to maintain and extend                                     |
| Best Use Case      | When extreme performance or memory constraints demand               | When a fixed set of named values is needed                               |

ðŸ”—Code using Built-in methods of Enums
enum Severity {
    LOW,
    MEDIUM,
    HIGH,
    CRITICAL
}

public class EnumExample {
    public static void main(String[] args) {

        // values()
        System.out.println("All constants:");
        for (Severity s : Severity.values()) {
            System.out.println(s);
        }

        // valueOf()
        Severity sev = Severity.valueOf("HIGH");
        System.out.println("\nValueOf(\"HIGH\") = " + sev);

        // ordinal()
        System.out.println("\nOrdinal positions:");
        for (Severity s : Severity.values()) {
            System.out.println(s + " -> " + s.ordinal());
        }
    }
}

âœ…Output:
All constants:
LOW
MEDIUM
HIGH
CRITICAL

ValueOf("HIGH") = HIGH

Ordinal positions:
LOW -> 0
MEDIUM -> 1
HIGH -> 2
CRITICAL -> 3
