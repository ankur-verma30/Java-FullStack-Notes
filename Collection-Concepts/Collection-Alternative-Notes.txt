ğŸ”· What is Collections?
A collection is simly an Object that represents a group of objects, known as its elements.

ğŸ”· What is Collection Framework?
It provides a set of iterfaces and classes that help in managing groups of objects.

ğŸ§  Before the introduction of Collection Framework in JDK 1.2, Java used to rely on a variety of classes like Vector, Stack, Hashtable, and arrays to store and manipulate groups of objects.

âŒDrawbacks or limitations
1. Inconsistency: Each class had a different way of managing collections, leading to confusion and a steep learning curve.

2. Lack of inter-operability: These classes were not designed to work together seamlessly.

3. No common Interface: There was no common interface for all these classes which meant you couldn't write generic algorithms that could operate on different types of collections.

To solve those problems, the Collection Framework was introduced in JDK 1.2.

ğŸ”„Features of Collection Framework:
âœ… Unified architecture: A consistent set of interfaces for all collections.
âœ… Inter-operability: Collections can be easily interchanged and manipulated.
âœ… Reusability: Generic algorithms can be written that work with any collections.
âœ…Efficiency: The framework provides efficient algorithms for basic operations like searching, sorting, and manipulation.

ğŸ”· Key Interfaces in Collection Framework:
1. Collection: The root interface for all other collection types.
2. List: An ordered collection that can contain duplicate elements.(e.g., ArrayList, LinkedList);
3. Set: A collection that cannot contain duplicate elements (e.g., HashSet, TreeSet);
4. Queue: A collection designed for holding elements prior to processing (e.g., PriorityQueue, LinkedList when used as a queue);
5. Deque: A double-ended queue that allows insertion and removal from both ends (e.g., ArrayDeque);
4. Map: An interface that represents a collection of key-value pairs. (e.g. HashMap, TreeMap);

ğŸ”· Hierarchy of Collection Framework:
Iterable
â””â”€â”€ Collection
    â”œâ”€â”€ List
    â”‚   â”œâ”€â”€ ArrayList
    â”‚   â”œâ”€â”€ LinkedList
    â”‚   â”œâ”€â”€ Vector
    â”‚   â”œâ”€â”€ Stack
    â”‚   â””â”€â”€ CopyOnWriteArrayList
    â”‚
    â”œâ”€â”€ Set
    â”‚   â”œâ”€â”€ HashSet
    â”‚   â”œâ”€â”€ LinkedHashSet
    â”‚   â”œâ”€â”€ TreeSet
    â”‚   â”œâ”€â”€ EnumSet
    â”‚   â”œâ”€â”€ ConcurrentSkipListSet
    â”‚   â”œâ”€â”€ SortedSet
    â”‚   â””â”€â”€ CopyOnWriteArraySet
    â”‚
    â””â”€â”€ Queue
        â”œâ”€â”€ LinkedList
        â”œâ”€â”€ PriorityQueue
        â”œâ”€â”€ Deque
        â”‚   â”œâ”€â”€ ArrayDeque
        â”‚   |â”€â”€ LinkedList (also Deque)
        |   |â”€â”€ ConcurrentLinkedDeque
        â”œâ”€â”€ BlockingQueue
        â”‚   â”œâ”€â”€ ArrayBlockingQueue
        â”‚   â”œâ”€â”€ LinkedBlockingQueue
        â”‚   â”œâ”€â”€ PriorityBlockingQueue
        â”‚   â”œâ”€â”€ SynchronousQueue
        â”‚   â””â”€â”€ DelayQueue
        â””â”€â”€ ConcurrentLinkedQueue

ğŸ”· List Interface
A List is an ordered collection that can contain duplicate elements. It allows positional access and insertion of elements.

âœ… Key Features of the List Interface:
â¤ Ordered
â¤ Index-Based access
â¤ Allows duplicates

ğŸŒŸ ArrayList
An ArrayList is a resizable array implementation of the List interface. 
Unlike arrays in Java, which have a fixed size, ArrayList can change its size dynamically as elements are added or removed.
This flexibility makes it a popular choice when the number of elements in a list isn't known in advance.

âœ…Code Implementation of ArrayList:
package collections;

import java.util.ArrayList;

public class ArrayListIntro {

	public static void main(String[] args) {
		ArrayList<Integer> arr = new ArrayList<>();
		// adding elements
		arr.add(1);
		arr.add(5);
		arr.add(80);
		System.out.println(arr.get(2));// accessing the elements
		System.out.println(arr.size());// accessing the size of the arrayList

		System.out.println("");

		// using pointer to iterate on ArrayList
		for (int i = 0; i < arr.size(); i++) {
			System.out.print(arr.get(i) + " ");
		}

		System.out.println("");

		// Iterating using for-each loop
		for (int x : arr) {
			System.out.print(x + " ");
		}
		
		System.out.println("");

		// check for existence of elements
		System.out.println(arr.contains(5));
	
        // removing elements
		//returns the element that is removed and also remove the element
		int element=arr.remove(0);
		System.out.println(element);
		
        //adding elements at specific index
        arr.add(2,50);
        system.out.println(arr); //[1, 5, 50, 80];

        // setting elements at specific index
        arr.set(2, 100);
		System.out.println(arr); // [1, 5, 100, 80]

        // clearing the ArrayList
        arr.clear();
        System.out.println(arr); // []
	}
}

ğŸ”· Internal Working of ArrayList
â¤ Unlike a regular array, which has a fixed size, an ArrayList can grow and shrink as elements are added or removed. 
â¤ This dynamic resizing is achieved by creating a new array when the current array is full and copying the elements to the new array.
â¤ Internally the ArrayList is implemented as an array of Object references. 
â¤ When you add elements to an ArrayList, you're essentially storing these elements in this internal array.
â¤ When you create an ArrayList, it has an initial capacity(default is 10). The capacity refers to the size of the internal array that holds the elements before needing to resize.

ğŸ”· Adding elements
When we add an element to an ArrayList, the following steps occur:

1. Checking Capacity: Before adding the new element, ArrayList checks if there is enough space in the internal array(elementData). IF the array is full, it needs to be resized.

2. Resize if necessary: If the internal array is full, the ArrayList will create a new array with a larger capacity (usually 1.5 times the current capacity) and copy the existing elements from the old array to the new array.

3. Add the Element: The new element is added to the internal array at the appropriate index, and the size is incremented.

ğŸ”· Resizing the Array
1. Initial Capacity: By default, the initial capacityis 10. This means the internal array can hold 10 elements before it needs to grow.

2. Growth Factor: When the internal array is full, a new array is created with a size 1.5 times the old array. This growth factor balances memory efficiency and resizing cost.

3. Copying Elements: When resizing occurs, all elements from the old array are copied to the new array, which is an O(n) operation, where n is the number of elements in the ArrayList.

ğŸ”· Removing Elements
1. Check Bounds: The ArrayList  checks if the index is within the valid range (0 to size - 1).

2. Remove the Element: The element is removed, and all elements to the right of the removed element are shifted to the left to fill the gap.

3. Reduce Size: The size is decremented by 1.

âœ…Code Implementation:

ArrayList<Integer> arr = new ArrayList<>(1000);// creating an ArrayList with initial capacity of 1000
		// adding elements
		System.out.println(arr.size());// gives 0
		System.out.println(arr.get(0));// IndexOutOfBoundsException because no elements are present

//There is no method to print the capacity of an ArrayList directly.

ğŸ”· Creating an ArrayList
âœ…Method 1. Default constructor, creates an empty ArrayList with an initial capacity of 10
		ArrayList<Integer> list=new ArrayList<>();

âœ…Method 2. List is an interface, ArrayList is a class that implements the List interface.
        List<Integer> list2=new ArrayList<>(); 
		
âœ…Method 3. Creating an ArrayList with a specified initial capacity
		ArrayList<Integer> listWithCapacity=new ArrayList<>(20);
		
âœ…Method 4. Creating an ArrayList from another collection
		List<String> anotherList=Arrays.asList("Apple","Banana");//fixed-size list adding and removing elements is not allowed only replacing is allowed
		ArrayList<String> listFromCollection=new ArrayList<>(anotherList);


ğŸ§  Miscellaneous Ways of Creating ArrayList in Java

1. Normal ArrayList
List<String> list = new ArrayList<>();
System.out.println(list.getClass().getName());

âœ…Output: java.util.ArrayList

â¤ This is the regular ArrayList implementation.
â¤ Backed by a resizable array.
â¤ Fully mutable: you can add, remove, and update elements.

2. Using Arrays.asList() with direct values
List<String> list1 = Arrays.asList("Monday", "Tuesday");
System.out.println(list1.getClass().getName());

âœ…Output: java.util.Arrays$ArrayList

â¤ This is NOT java.util.ArrayList
â¤ It is an inner static class of java.util.Arrays called Arrays$ArrayList.
â¤ Characteristics:
    1. Fixed-size list (backed by the given array).
    2. You can modify elements (set()), but cannot add() or remove().
    3. Trying list1.add("Wednesday") will throw UnsupportedOperationException.

list1.set(1, "Friday");   // Works âœ…
System.out.println(list1.get(1)); // Output: Friday

3. Using Arrays.asList() on an existing array
String[] array = {"Apple", "Banana", "Cherry"};
List<String> list2 = Arrays.asList(array);
System.out.println(list2.getClass().getName());

âœ… Output: java.util.Arrays$ArrayList

â¤ Same as above: backed by the array itself.
â¤ Any changes in list2 are reflected in the original array (because they share memory).

list2.set(0, "Mango"); 
System.out.println(array[0]); // Output: Mango (array updated too!)

4. Using List.of() (Java 9+) // Unmodifiable list can't even replace the elements unlike list made from Arrays.asList()
List<Integer> list3 = List.of(1, 2, 3);
System.out.println(list3.getClass().getName());

âœ… Output: java.util.ImmutableCollections$ListN

âœ… Key Points
â¤ new ArrayList<>() â†’ java.util.ArrayList (fully dynamic, resizable).
â¤ Arrays.asList() â†’ java.util.Arrays$ArrayList (fixed-size, backed by array).
â¤ With an existing array, modifications affect both list and array.
â¤ Arrays$ArrayList is an inner class only meant as a lightweight adapter.

âš¡ Quick Trap Question:
ğŸ‘‰ What happens if you call list1.add("Wednesday") on an Arrays.asList() list?
âœ”ï¸ Answer: Throws UnsupportedOperationException because the list is fixed-size.    

ğŸ”· Adding all elements 
âœ…Method 1. In the list at the end
        List<Integer>arr=new ArrayList<>();
		arr.add(1);
		arr.add(2);
		arr.add(3);
		
		List<Integer>list1=List.of(4,5,6,7,8,9);
		//adding all the elements
		arr.addAll(list1);
		
		System.out.println(arr);//âœ…Output: [1, 2, 3, 4, 5, 6, 7, 8, 9]

âœ…Method 2. In the list at specific index
         arr.addAll(2,list1);
         System.out.println(arr);//âœ…Output: [1, 2, 4, 5, 6, 7, 8, 9,3]        


ğŸ”· Removing elements from ArrayList
âœ…Method 1. By index
        arr.remove(2);//removes the element at index 2
        System.out.println(arr);//âœ…Output: [1, 2, 5, 6, 7, 8, 9,3]

âœ…Method 2. By value
        arr.remove(Integer.valueOf(5));//removes the first occurrence of the value 5        

ğŸ”· Converting List to Array
String [] array = arr.toArray(new String[0]);
ğŸ‘‰ This creates a new array of the same type as the list and copies the elements into it.        
ğŸ‘‰ We pass new String[0] to tell the compiler the type of the array we are passing as a argument (Convention).

ğŸ”· Sorting the List
âœ…Method 1: Collections.sort(arr);
ğŸ‘‰ This sorts the list in ascending order using the natural ordering of the elements.

âœ…Method 2: arr.sort(null);
ğŸ‘‰ This sorts the list in ascending order using the natural ordering of 
the elements.
ğŸ‘‰ null is defined here because no custom comparator is used

ğŸ”· Time Complexity of Operations in List
â¤ Accessing by index (get) is O(1).
â¤ Adding an element is O(n) in the worst case when resizing occurs.
â¤ Removing elements can be O(n) because it may involve shifting elements.
â¤ Iteration is O(n).

ğŸ”· Comparator
It is an interface that defines a method for comparing two objects of the same type.
It is used to sort objects in a custom order.

ğŸ”· How to use Comparator
public class ArrayListIntro {

	public static void main(String[] args) {
		List<Integer>arr=new ArrayList<>();
		arr.add(1);
		arr.add(2);
		arr.add(3);
		
		List<Integer>list1=List.of(4,5,6,7,8,9);
		//adding all the elements
		arr.addAll(2,list1);
		
		arr.sort(new CustomComparator());
		System.out.println(arr); // Output: [9, 8, 7, 6, 5, 4, 3, 2, 1]
	}
}
class CustomComparator implements Comparator<Integer>{

	@Override
	public int compare(Integer o1, Integer o2) {
		return o2-o1;
	}
}
ğŸ‘‰ If we do o1-o2, it will sort in ascending order

ğŸ”· Using lambda expression
âœ… Example 1: Sorting Lexicographically
		List<String>str=Arrays.asList("Apple", "Mango","Banana");
		str.sort((a,b)-> a.compareTo(b));
		//if gives negative then first will come
		System.out.println(str); // Output: [Apple, Banana, Mango]

âœ… Example 2: Sorting by Length		
		List<String>str2=Arrays.asList("Apple", "Plum","Banana");
		str2.sort((a,b)-> a.length()-b.length());
		System.out.println(str2);// Output: [Plum, Apple, Banana]


ğŸŒŸ LinkedList
A LinkedList is a doubly-linked list implementation of the List and Deque interfaces.
It allows for efficient insertion and removal of elements at both ends of the list.

âœ…Custom Made LinkedList Implementation
package collections;

public class LinkedListIntro {

	public static void main(String[] args) {
		Node node1=new Node();
		node1.value=10;
		node1.next=null;
		
		Node node2=new Node();
		node2.value=2;
		node2.next=null;
		node1.next=node2;
		
		Node temp=node1;
		while(temp!=null) {
			System.out.println(temp.value);
			temp=temp.next;
		}
	}
}

class Node{
	public int value;
	public Node next;
}

ğŸ‘‰ A LinkedList is a linear data structure where each element is a seperate object called a node. Each node contains two parts:
1. Data: The value stored in the node.
2. Pointer/Reference: Two Pointers, one points to the next node(next) and the other pointing to the previous node(previous).

âš¡ Performance Considerations
â¤ LinkedList has different performance characteristics compared to ArrayList:

ğŸ”„Insertion and Deletion: LinkedList is better for frequent insertions and deletions in the middle of the list because it does not require shifting elements, as in ArrayList.

ğŸ”„ Random Access: LinkedList has slower random access(get(int index)) compared to ArrayList because it has to traverse the list from the beginning to reach the desired index.

ğŸ”„ Memory Overhead: LinkedList requires more memory than ArrayList because each node in a LinkedList requires extra memory to store references to the next and the previous node.

âœ… Using LinkedList Collection Framework

package collections;

import java.util.LinkedList;

public class LinkedListIntro {

	public static void main(String[] args) {
		LinkedList<Integer>linkedlist=new LinkedList<>();
		âœ…Adding elements and getting elements
		linkedlist.add(1);//O(1)
		linkedlist.add(2);
		linkedlist.add(3);
		
		System.out.println(linkedlist);
		
		//getting the value at 0th index
		System.out.println(linkedlist.get(0)); //O(n)
		
		//adding the value at specific index
		linkedlist.add(2, 5); // O(1)
		
		//adding at the first of the linkedlist
		linkedlist.addFirst(0); // O(1)
		
		//adding at the last of the linkedlist
		linkedlist.addLast(10); // O(1)
		
		System.out.println(linkedlist);
		
		//getting the first element
		System.out.println(linkedlist.getFirst());
		//getting the last element
		System.out.println(linkedlist.getLast());

		âœ…Removing elements
		//removing element on specific index
		int removedElement=linkedlist.remove(0);
		System.out.println(removedElement);
		
		System.out.println(linkedlist);
		
		//removing the first element
		int removed=linkedlist.remove();
		System.out.println(removed);
		
		System.out.println(linkedlist);
		
		//removing first and last element
		int val1=linkedlist.removeFirst();
		int val2=linkedlist.removeLast();
		
		System.out.println(val1+" "+val2);
		System.out.println(linkedlist);
		
		//Java 8 feature
		boolean flag=linkedlist.removeIf(x->x%2!=0);// 5 is removed
		System.out.println(flag); //tells that removal has taken place or not
		
		System.out.println(linkedlist);
		
		LinkedList<String> animals=new LinkedList<>(Arrays.asList("Cat","Dog","Elephant"));
		LinkedList<String> animalsToRemove=new LinkedList<>(Arrays.asList("Dog"));
		
		boolean removedAnimals=animals.removeAll(animalsToRemove);
		System.out.println(removedAnimals);
		System.out.println(animals);// Dog is removed
	}
}

ğŸŒŸ Vectors
â¤ A Vector in Java is a part of the java.util package and is one of the legacy classes in Java that implements the List interface.
â¤ It was introduced in JDK 1.0 before collection framework and is synchronized, making it thread-safe.
â¤ Now it is a part of the collection framework.
â¤ Howeever, due to its synchronization overhead, it's generally recommended to use other modern alternatives like ArrayList in single-threaded scenarios.
â¤ Despite this, vectors is still useful in certain situations, particularly when thread safety is a concern.

ğŸ”· Key Features of Vectors
ğŸ”„ Dynamic Array: Like ArrayList, vector is a dynamic array that grows automatically when more elements are added than its current capacity.

ğŸ”„Synchronized: All the methods in Vector are synchronized, which make it thread-safe. This means multiple thread can work on a Vector without the risk of corrupting the data. However, this can introduce performance overhead in single-threaded environments.

ğŸ”„ Legacy Class: Vector was part of Java's original release and is considered a legacy class. It's generally recommended to use ArrayList in single-threaded environments due to performance Considerations.

ğŸ”„ Resizing Mechanisms: When the current capacity of the vector is excedded, it doubles its size by default(or increases by a specific capacity increment if provided).

ğŸ”„ Random Access: Similary to arrays and ArrayList, Vector allows random access to elements, making it efficient for accessing elements using index.

ğŸ”· Constructor of Vectors
ğŸ‘‰ Vector(): Creates a vector with an initial capacity of 10.
ğŸ‘‰ Vector(int initialCapacity): Creates a vector with specified initial capacity.
ğŸ‘‰ Vector(int initialCapacity, int capacityIncrement): Creates a vector with an initial capacity and capacity increment(how much the vector should grow when its capacity is exceeded).
ğŸ‘‰Vector(<Collections<? extends E>c): Creates a vector containing the elements of the specified collection.

âœ…Code Implementation of Vector
package collections;

import java.util.Vector;

public class VectorDemo {
	public static void main(String[] args) {
		Vector<Integer> vector = new Vector<>(3);

		// can check the initial capacity
		System.out.println(vector.capacity());

		vector.add(1);
		vector.add(1);
		vector.add(1);
		vector.add(1);

		// New capacity=initialCapacity+capacityIncrement;
		// By default capacityIncrement is initalValue it doubles the capacity
		System.out.println(vector.capacity());

	}
}

âœ…Methods of Vector
â¤ add(E e): Add an element to the end of the vector.
â¤ add(int index, E element): Insert an element at a specific index.
â¤ get(int index): Retrieve an element at a specific index.
â¤ set(int index, E element): Replace an element at a specific index.
â¤ remove(int index): Remove an element at a specific index.		
â¤ remove(Object o): Remove the first occurrence of the specified element.
â¤ size(): Return the number of elements in the vector.
â¤ isEmpty(): Check if the vector is empty.
â¤ contains(Object o): Check if the vector contains a specific element.
â¤ clear(): Remove all elements from the vector.

âœ…Code Implementation of Vector Methods
import java.util.Vector;

public class VectorDemo {
    public static void main(String[] args) {
        // Create a Vector of Strings
        Vector<String> vector = new Vector<>();

        // 1. add(E e) - add element at the end
        vector.add("Apple");
        vector.add("Banana");
        vector.add("Cherry");
        System.out.println("After add: " + vector);

        // 2. add(int index, E element) - insert at specific index
        vector.add(1, "Mango");
        System.out.println("After add at index 1: " + vector);

        // 3. get(int index) - retrieve element at index
        System.out.println("Element at index 2: " + vector.get(2));

        // 4. set(int index, E element) - replace element
        vector.set(2, "Orange");
        System.out.println("After set at index 2: " + vector);

        // 5. remove(int index) - remove element by index
        vector.remove(3); // removes element at index 3
        System.out.println("After remove at index 3: " + vector);

        // 6. remove(Object o) - remove by value
        vector.remove("Apple"); 
        System.out.println("After removing 'Apple': " + vector);

        // 7. size() - get number of elements
        System.out.println("Size of vector: " + vector.size());

        // 8. isEmpty() - check if empty
        System.out.println("Is vector empty? " + vector.isEmpty());

        // 9. contains(Object o) - check if element exists
        System.out.println("Contains 'Banana'? " + vector.contains("Banana"));
        System.out.println("Contains 'Apple'? " + vector.contains("Apple"));

        // 10. clear() - remove all elements
        vector.clear();
        System.out.println("After clear: " + vector);
        System.out.println("Is vector empty after clear? " + vector.isEmpty());
    }
}

âœ…Output of above code:
After add: [Apple, Banana, Cherry]
After add at index 1: [Apple, Mango, Banana, Cherry]
Element at index 2: Banana
After set at index 2: [Apple, Mango, Orange, Cherry]
After remove at index 3: [Apple, Mango, Orange]
After removing 'Apple': [Mango, Orange]
Size of vector: 2
Is vector empty? false
Contains 'Banana'? false
Contains 'Apple'? false
After clear: []
Is vector empty after clear? true

ğŸ”· Synchronization and Performance
ğŸ‘‰ Since vector methods are synchronized, it ensures that only one thread can access the vector at a time. This makes it thread-safe but cna introduce performance overhead in single-threaded environments because synchronization adds locking and unlocking costs.

ğŸ‘‰ In moder Java applications, ArrayList is generally preferred over Vector when synchronization isn't required. For thread-safe collections, the CopyOnWriteArrayList or ConcurrentHashMap from the java.util.concurrent package are often recommended.

ğŸŒŸ Stack

