🔷 What is Collections?
A collection is simly an Object that represents a group of objects, known as its elements.

🔷 What is Collection Framework?
It provides a set of iterfaces and classes that help in managing groups of objects.

🧠 Before the introduction of Collection Framework in JDK 1.2, Java used to rely on a variety of classes like Vector, Stack, Hashtable, and arrays to store and manipulate groups of objects.

❌Drawbacks or limitations
1. Inconsistency: Each class had a different way of managing collections, leading to confusion and a steep learning curve.
2. Lack of inter-operability: These classes were not designed to work together seamlessly.
3. No common Interface: There was no common interface for all these classes which meant you couldn't write generic algorithms that could operate on different types of collections.

To solve those problems, the Collection Framework was introduced in JDK 1.2.

🔄Features of Collection Framework:
✅ Unified architecture: A consistent set of interfaces for all collections.
✅ Inter-operability: Collections can be easily interchanged and manipulated.
✅ Reusability: Generic algorithms can be written that work with any collections.
✅ Efficiency: The framework provides efficient algorithms for basic operations like searching, sorting, and manipulation.

🔷 Key Interfaces in Collection Framework:
1. Collection: The root interface for all other collection types.
2. List: An ordered collection that can contain duplicate elements.(e.g., ArrayList, LinkedList);
3. Set: A collection that cannot contain duplicate elements (e.g., HashSet, TreeSet);
4. Queue: A collection designed for holding elements prior to processing (e.g., PriorityQueue, LinkedList when used as a queue);
5. Deque: A double-ended queue that allows insertion and removal from both ends (e.g., ArrayDeque);
4. Map: An interface that represents a collection of key-value pairs. (e.g. HashMap, TreeMap);

🔷 Hierarchy of Collection Framework:
Iterable
└── Collection
    ├── SequencedCollection
            ├── List
            |    ├── ArrayList
            |    ├── LinkedList
            |    ├── Vector
            |    ├── Stack
            |    └── CopyOnWriteArrayList
            │
            ├── Set
            │   ├── HashSet
            │   ├── LinkedHashSet
            │   ├── TreeSet
            │   ├── EnumSet
            │   ├── ConcurrentSkipListSet
            │   ├── SortedSet
            │   └── CopyOnWriteArraySet
            │
            └── Queue
                ├── LinkedList
                ├── PriorityQueue
                ├── Deque
                │   ├── ArrayDeque
                │   |── LinkedList (also Deque)
                |   |── ConcurrentLinkedDeque
                ├── BlockingQueue
                │   ├── ArrayBlockingQueue
                │   ├── LinkedBlockingQueue
                │   ├── PriorityBlockingQueue
                │   ├── SynchronousQueue
                │   └── DelayQueue
                └── ConcurrentLinkedQueue

 The hierarchy flows from Iterable → Collection → SequencedCollection → List → ArrayList.

Let’s break this down step by step:
🧩 1. Iterable<E> (Interface)
➤ Top-most interface in the collection hierarchy.
➤ Introduced in: Java 5

➤ Key Method:
Iterator<T> iterator();

➤ Enables use of the for loop:
Iterator<T> iterator = someCollection.iterator();
✔️ for ( iterator.hasNext()) {
    T element = iterator.next();
    // ...
}

➤ Enables use of the enhanced for-each loop:
✔️ for (String s : someCollection) {
    // ...
}

📚 2. Collection<E> (Interface)
➤ Root interface for all collection types (except maps).
➤ Extends: Iterable<E>
➤ Common Subinterfaces: List, Set, Queue, etc.

➤ Key Methods:
add(E e), remove(Object o), clear(), size(), contains(Object o), etc.

➤ Does not maintain order or index-based access (depends on implementation).

🔄 3. SequencedCollection<E> (Interface – ✅ New in Java 21 / Finalized in Java 24)
➤ Extends: Collection<E>
➤ Purpose: Provides a standardized way to handle ordered collections (like first and last elements).

➤ Key Methods Introduced:
getFirst(), getLast()
addFirst(E e), addLast(E e)
removeFirst(), removeLast()
reversed()

🔸 Applies to: List-like or deque-like structures where order matters.
🔹 This brings better symmetry and consistency in ordered collections.

🔷 List Interface
➤ Extends: SequencedCollection<E>
➤ Represents an ordered collection with index-based access.
➤ Duplicates allowed, insertion order preserved.
➤ Common Implementations: ArrayList, LinkedList, Vector, Stack

➤ Key Methods:
get(int index), set(int index, E e), add(E e), remove(int index),indexOf(Object o), subList(), listIterator()

✅ Key Features of the List Interface:
➤ Ordered
➤ Index-Based access
➤ Allows duplicates

🌟 ArrayList
An ArrayList is a resizable array implementation of the List interface. 
Unlike arrays in Java, which have a fixed size, ArrayList can change its size dynamically as elements are added or removed.
This flexibility makes it a popular choice when the number of elements in a list isn't known in advance.

➤ Implements: List<E>, hence also a SequencedCollection, Collection, and Iterable.

✔️ Ways to Create ArrayList
🔄Default constructor
ArrayList<Integer> list = new ArrayList<>();
System.out.println(list.getClass().getName());
✅Output: java.util.ArrayList
👉 Creates an empty list with default capacity 10.

🔄With Initial Capacity
ArrayList<String> list = new ArrayList<>(20);
👉Useful when you know approx. number of elements.

🔄 From Another Collection
List<Integer> numbers = new ArrayList<>(List.of(1, 2, 3, 4));
👉Copies elements from existing collection.

🔄 Using Arrays.asList (Fixed-size list backed by array)
List<String> names = new ArrayList<>(Arrays.asList("A", "B", "C"));
System.out.println(names.getClass().getName());
✅Output: java.util.Arrays$ArrayList

➤ This is NOT java.util.ArrayList
➤ It is an inner static class of java.util.Arrays called Arrays$ArrayList.
➤ Characteristics:
    1. Fixed-size list (backed by the given array).
    2. You can modify elements (set()), but cannot add() or remove().
    3. Trying list.add("D") will throw UnsupportedOperationException.

🔄 Using Arrays.asList() on an existing array
String[] array = {"Apple", "Banana", "Cherry"};
List<String> list2 = Arrays.asList(array);
System.out.println(list2.getClass().getName());
✅ Output: java.util.Arrays$ArrayList

➤ Same as above: backed by the array itself.
➤ Any changes in list2 are reflected in the original array (because they share memory).

list2.set(0, "Mango"); 
System.out.println(array[0]); // Output: Mango (array updated too!)
0
🔄Immutable List Using List.of() (Java 9+) // Unmodifiable list can't even replace the elements unlike list made from Arrays.asList()
List<Integer> list3 = List.of(1, 2, 3);
System.out.println(list3.getClass().getName());

✅ Output: java.util.ImmutableCollections$ListN

✅ Key Points
➤ new ArrayList<>() → java.util.ArrayList (fully dynamic, resizable).
➤ Arrays.asList() → java.util.Arrays$ArrayList (fixed-size, backed by array).
➤ With an existing array, modifications affect both list and array.
➤ Arrays$ArrayList is an inner class only meant as a lightweight adapter.

✔️ Common Operations on ArrayList
1️⃣ Add Elements
list.add(10);          // add at end
list.add(1, 20);       // add at specific index
list.addAll(otherList); // add all elements

2️⃣ Access Elements
int x = list.get(0);   // get element at index

3️⃣ Update Elements
list.set(1, 50);       // update index 1 to value 50

4️⃣ Remove Elements
list.remove(2);        // remove by index
list.remove(Integer.valueOf(10)); // remove by value
list.clear();          // remove all elements

5️⃣ Search Operations
boolean present = list.contains(30); // check existence
int idx = list.indexOf(50);          // first index
int lastIdx = list.lastIndexOf(50);  // last index

6️⃣ Iteration
// for-each loop
for(Integer val : list) { System.out.println(val); }

// using Iterator
Iterator<Integer> it = list.iterator();
while(it.hasNext()) System.out.println(it.next());

// using ListIterator (forward & backward)
ListIterator<Integer> itr = list.listIterator();
while(itr.hasNext()) System.out.println(itr.next());
while(itr.hasPrevious()) System.out.println(itr.previous());

// using forEach + lambda
list.forEach(System.out::println);

7️⃣ Size & Capacity
int size = list.size();
boolean empty = list.isEmpty();

8️⃣ Conversion
// ArrayList -> Array
Integer[] arr = list.toArray(new Integer[0]);

// Array -> ArrayList
ArrayList<Integer> list2 = new ArrayList<>(Arrays.asList(arr));

🔷 Internal Working of ArrayList
➤ Unlike a regular array, which has a fixed size, an ArrayList can grow and shrink as elements are added or removed. 
➤ This dynamic resizing is achieved by creating a new array when the current array is full and copying the elements to the new array.
➤ Internally the ArrayList is implemented as an array of Object references. 
➤ When you add elements to an ArrayList, you're essentially storing these elements in this internal array.
➤ When you create an ArrayList, it has an initial capacity(default is 10). The capacity refers to the size of the internal array that holds the elements before needing to resize.

🔷 Adding elements
When we add an element to an ArrayList, the following steps occur:

1. Checking Capacity: Before adding the new element, ArrayList checks if there is enough space in the internal array(elementData). IF the array is full, it needs to be resized.
2. Resize if necessary: If the internal array is full, the ArrayList will create a new array with a larger capacity (usually 1.5 times the current capacity) and copy the existing elements from the old array to the new array.
3. Add the Element: The new element is added to the internal array at the appropriate index, and the size is incremented.

🔷 Resizing the Array
1. Initial Capacity: By default, the initial capacityis 10. This means the internal array can hold 10 elements before it needs to grow.
2. Growth Factor: When the internal array is full, a new array is created with a size 1.5 times the old array. This growth factor balances memory efficiency and resizing cost.
3. Copying Elements: When resizing occurs, all elements from the old array are copied to the new array, which is an O(n) operation, where n is the number of elements in the ArrayList.

🔷 Removing Elements
1. Check Bounds: The ArrayList  checks if the index is within the valid range (0 to size - 1).
2. Remove the Element: The element is removed, and all elements to the right of the removed element are shifted to the left to fill the gap.
3. Reduce Size: The size is decremented by 1.

🔷 Converting List to Array
String [] array = arr.toArray(new String[0]);
👉 This creates a new array of the same type as the list and copies the elements into it.        
👉 We pass new String[0] to tell the compiler the type of the array we are passing as a argument (Convention).

🔷 Sorting the List
✅Method 1: Collections.sort(arr);
👉 This sorts the list in ascending order using the natural ordering of the elements.

✅Method 2: arr.sort(null);
👉 This sorts the list in ascending order using the natural ordering of 
the elements.
👉 null is defined here because no custom comparator is used

Collections.sort(list);                   // ascending
list.sort(Collections.reverseOrder());    // descending

🔟 Retain / Remove All
list.removeAll(otherList);   // remove all common elements
list.retainAll(otherList);   // keep only common elements

🔷 Time Complexity of Operations in List
➤ Accessing by index (get) is O(1).
➤ Adding an element is O(n) in the worst case when resizing occurs.
➤ Removing elements can be O(n) because it may involve shifting elements.
➤ Iteration is O(n).

🔷 Comparator
It is an interface that defines a method for comparing two objects of the same type.
It is used to sort objects in a custom order.

🔷 How to use Comparator
public class ArrayListIntro {

	public static void main(String[] args) {
		List<Integer>arr=new ArrayList<>();
		arr.add(1);
		arr.add(2);
		arr.add(3);
		
		List<Integer>list1=List.of(4,5,6,7,8,9);
		//adding all the elements
		arr.addAll(2,list1);
		
		arr.sort(new CustomComparator());
		System.out.println(arr); // Output: [9, 8, 7, 6, 5, 4, 3, 2, 1]
	}
}
class CustomComparator implements Comparator<Integer>{

	@Override
	public int compare(Integer o1, Integer o2) {
		return o2-o1;
	}
}
👉 If we do o1-o2, it will sort in ascending order

🔷 Using lambda expression
✅ Example 1: Sorting Lexicographically
		List<String>str=Arrays.asList("Apple", "Mango","Banana");
		str.sort((a,b)-> a.compareTo(b));
		//if gives negative then first will come
		System.out.println(str); // Output: [Apple, Banana, Mango]

✅ Example 2: Sorting by Length		
		List<String>str2=Arrays.asList("Apple", "Plum","Banana");
		str2.sort((a,b)-> a.length()-b.length());
		System.out.println(str2);// Output: [Plum, Apple, Banana]


🌟 LinkedList
A LinkedList is a doubly-linked list implementation of the List and Deque interfaces.
It allows for efficient insertion and removal of elements at both ends of the list.

✅Custom Made LinkedList Implementation
package collections;

public class LinkedListIntro {

	public static void main(String[] args) {
		Node node1=new Node();
		node1.value=10;
		node1.next=null;
		
		Node node2=new Node();
		node2.value=2;
		node2.next=null;
		node1.next=node2;
		
		Node temp=node1;
		while(temp!=null) {
			System.out.println(temp.value);
			temp=temp.next;
		}
	}
}

class Node{
	public int value;
	public Node next;
}

👉 A LinkedList is a linear data structure where each element is a seperate object called a node. Each node contains two parts:
1. Data: The value stored in the node.
2. Pointer/Reference: Two Pointers, one points to the next node(next) and the other pointing to the previous node(previous).

⚡ Performance Considerations
➤ LinkedList has different performance characteristics compared to ArrayList:

🔄Insertion and Deletion: LinkedList is better for frequent insertions and deletions in the middle of the list because it does not require shifting elements, as in ArrayList.

🔄 Random Access: LinkedList has slower random access(get(int index)) compared to ArrayList because it has to traverse the list from the beginning to reach the desired index.

🔄 Memory Overhead: LinkedList requires more memory than ArrayList because each node in a LinkedList requires extra memory to store references to the next and the previous node.

✅ Using LinkedList Collection Framework

package collections;

import java.util.LinkedList;

public class LinkedListIntro {

	public static void main(String[] args) {
		LinkedList<Integer>linkedlist=new LinkedList<>();
		✅Adding elements and getting elements
		linkedlist.add(1);//O(1)
		linkedlist.add(2);
		linkedlist.add(3);
		
		System.out.println(linkedlist);
		
		//getting the value at 0th index
		System.out.println(linkedlist.get(0)); //O(n)
		
		//adding the value at specific index
		linkedlist.add(2, 5); // O(1)
		
		//adding at the first of the linkedlist
		linkedlist.addFirst(0); // O(1)
		
		//adding at the last of the linkedlist
		linkedlist.addLast(10); // O(1)
		
		System.out.println(linkedlist);
		
		//getting the first element
		System.out.println(linkedlist.getFirst());
		//getting the last element
		System.out.println(linkedlist.getLast());

		✅Removing elements
		//removing element on specific index
		int removedElement=linkedlist.remove(0);
		System.out.println(removedElement);
		
		System.out.println(linkedlist);
		
		//removing the first element
		int removed=linkedlist.remove();
		System.out.println(removed);
		
		System.out.println(linkedlist);
		
		//removing first and last element
		int val1=linkedlist.removeFirst();
		int val2=linkedlist.removeLast();
		
		System.out.println(val1+" "+val2);
		System.out.println(linkedlist);
		
		//Java 8 feature
		boolean flag=linkedlist.removeIf(x->x%2!=0);// 5 is removed
		System.out.println(flag); //tells that removal has taken place or not
		
		System.out.println(linkedlist);
		
		LinkedList<String> animals=new LinkedList<>(Arrays.asList("Cat","Dog","Elephant"));
		LinkedList<String> animalsToRemove=new LinkedList<>(Arrays.asList("Dog"));
		
		boolean removedAnimals=animals.removeAll(animalsToRemove);
		System.out.println(removedAnimals);
		System.out.println(animals);// Dog is removed
	}
}

🌟 Vectors
➤ A Vector in Java is a part of the java.util package and is one of the legacy classes in Java that implements the List interface.
➤ It was introduced in JDK 1.0 before collection framework and is synchronized, making it thread-safe.
➤ Now it is a part of the collection framework.
➤ Howeever, due to its synchronization overhead, it's generally recommended to use other modern alternatives like ArrayList in single-threaded scenarios.
➤ Despite this, vectors is still useful in certain situations, particularly when thread safety is a concern.

🔷 Key Features of Vectors
🔄 Dynamic Array: Like ArrayList, vector is a dynamic array that grows automatically when more elements are added than its current capacity.

🔄Synchronized: All the methods in Vector are synchronized, which make it thread-safe. This means multiple thread can work on a Vector without the risk of corrupting the data. However, this can introduce performance overhead in single-threaded environments.

🔄 Legacy Class: Vector was part of Java's original release and is considered a legacy class. It's generally recommended to use ArrayList in single-threaded environments due to performance Considerations.

🔄 Resizing Mechanisms: When the current capacity of the vector is excedded, it doubles its size by default(or increases by a specific capacity increment if provided).

🔄 Random Access: Similary to arrays and ArrayList, Vector allows random access to elements, making it efficient for accessing elements using index.

🔷 Constructor of Vectors
👉 Vector(): Creates a vector with an initial capacity of 10.
👉 Vector(int initialCapacity): Creates a vector with specified initial capacity.
👉 Vector(int initialCapacity, int capacityIncrement): Creates a vector with an initial capacity and capacity increment(how much the vector should grow when its capacity is exceeded).
👉Vector(<Collections<? extends E>c): Creates a vector containing the elements of the specified collection.

✅Code Implementation of Vector
package collections;

import java.util.Vector;

public class VectorDemo {
	public static void main(String[] args) {
		Vector<Integer> vector = new Vector<>(3);

		// can check the initial capacity
		System.out.println(vector.capacity());

		vector.add(1);
		vector.add(1);
		vector.add(1);
		vector.add(1);

		// New capacity=initialCapacity+capacityIncrement;
		// By default capacityIncrement is initalValue it doubles the capacity
		System.out.println(vector.capacity());

	}
}

✅Methods of Vector
➤ add(E e): Add an element to the end of the vector.
➤ add(int index, E element): Insert an element at a specific index.
➤ get(int index): Retrieve an element at a specific index.
➤ set(int index, E element): Replace an element at a specific index.
➤ remove(int index): Remove an element at a specific index.		
➤ remove(Object o): Remove the first occurrence of the specified element.
➤ size(): Return the number of elements in the vector.
➤ isEmpty(): Check if the vector is empty.
➤ contains(Object o): Check if the vector contains a specific element.
➤ clear(): Remove all elements from the vector.

✅Code Implementation of Vector Methods
import java.util.Vector;

public class VectorDemo {
    public static void main(String[] args) {
        // Create a Vector of Strings
        Vector<String> vector = new Vector<>();

        // 1. add(E e) - add element at the end
        vector.add("Apple");
        vector.add("Banana");
        vector.add("Cherry");
        System.out.println("After add: " + vector);

        // 2. add(int index, E element) - insert at specific index
        vector.add(1, "Mango");
        System.out.println("After add at index 1: " + vector);

        // 3. get(int index) - retrieve element at index
        System.out.println("Element at index 2: " + vector.get(2));

        // 4. set(int index, E element) - replace element
        vector.set(2, "Orange");
        System.out.println("After set at index 2: " + vector);

        // 5. remove(int index) - remove element by index
        vector.remove(3); // removes element at index 3
        System.out.println("After remove at index 3: " + vector);

        // 6. remove(Object o) - remove by value
        vector.remove("Apple"); 
        System.out.println("After removing 'Apple': " + vector);

        // 7. size() - get number of elements
        System.out.println("Size of vector: " + vector.size());

        // 8. isEmpty() - check if empty
        System.out.println("Is vector empty? " + vector.isEmpty());

        // 9. contains(Object o) - check if element exists
        System.out.println("Contains 'Banana'? " + vector.contains("Banana"));
        System.out.println("Contains 'Apple'? " + vector.contains("Apple"));

        // 10. clear() - remove all elements
        vector.clear();
        System.out.println("After clear: " + vector);
        System.out.println("Is vector empty after clear? " + vector.isEmpty());
    }
}

✅Output of above code:
After add: [Apple, Banana, Cherry]
After add at index 1: [Apple, Mango, Banana, Cherry]
Element at index 2: Banana
After set at index 2: [Apple, Mango, Orange, Cherry]
After remove at index 3: [Apple, Mango, Orange]
After removing 'Apple': [Mango, Orange]
Size of vector: 2
Is vector empty? false
Contains 'Banana'? false
Contains 'Apple'? false
After clear: []
Is vector empty after clear? true

🔷 Synchronization and Performance
👉 Since vector methods are synchronized, it ensures that only one thread can access the vector at a time. This makes it thread-safe but cna introduce performance overhead in single-threaded environments because synchronization adds locking and unlocking costs.

👉 In moder Java applications, ArrayList is generally preferred over Vector when synchronization isn't required. For thread-safe collections, the CopyOnWriteArrayList or ConcurrentHashMap from the java.util.concurrent package are often recommended.

🌟 Stack
👉 Stack extends Vector, it is synchronized making it thread-safe.
👉 LIFO structure: Stack follows the Last-In-First-Out(LIFO) principle, where the last element added is the first one to be removed.
👉 Inheritance: Stack is a subclass of Vector, which means it inherits all the features of a dynamic array but is constrained by the stack's LIFO nature.


✅Code Implementation
📝Method 1
package collections;

import java.util.Stack;

public class StackDemo {

	public static void main(String[] args) {
		Stack<Integer> st = new Stack<>();

		// to add the elements in the stack
		st.push(1);
		st.push(2);
		st.push(3);
		st.push(4);
		st.push(5);

		// to remove the top element
		int removedElement = st.pop();
		System.out.println(removedElement);
		System.out.println(st);

		// to see what the top element
		System.out.println(st.peek());

		// to check whether the stack is empty or not
		System.out.println(st.isEmpty());

		// to check the size of the stack
		System.out.println(st.size());

		//to search the element
		//Gives the index from the top
		System.out.println(st);
//		3 is at the 2nd index from the top
		System.out.println(st.search(3));	
	}
}

📝Method 2:
package collections;

import java.util.LinkedList;
import java.util.Stack;

public class StackDemo {

	public static void main(String[] args) {
		LinkedList<Integer> linkedlist = new LinkedList<>();

		// adding element in the LIFO manner
		linkedlist.addLast(1);
		linkedlist.addLast(2);
		linkedlist.addLast(3);
		linkedlist.addLast(4);
		linkedlist.addLast(5);

		// removing elements
		linkedlist.removeLast();

		// peek at the top element
		linkedlist.getLast();

		// return boolean whether the linkedlist is empty or not
		linkedlist.isEmpty();
	}
}

🌟 CopyOnWriteArrayList
👉 Copy on Write means that whenever an element is added or removed from the ArrayList, a new copy is created. This ensures that the ArrayList remains thread-safe even if multiple threads are accessing it concurrently.

👉 Read Operations: Fast and direct, since they happen on a stable list without interference from modifications.
👉 Write Operations: A new copy of the list is created for every modification. 
👉 The reference to the list is then updated so that subsequent reads use this new list.
👉 Useful when read operations are more in comparison to write operations because on writing each time a new copy is created hence memory consumption take place.

❌ Problem with List and ArrayList
package collections;

import java.util.ArrayList;
import java.util.List;

public class CopyOnWriteArrayListDemo {

	public static void main(String[] args) {
List<String>copyArrayList=new ArrayList<>();
		copyArrayList.add("Milk");
		copyArrayList.add("Eggs");
		copyArrayList.add("Bread");
		copyArrayList.add("Meat");
		
		for(String item:copyArrayList) {
			System.out.println(item);
			if(item.equals("Eggs")) {
				copyArrayList.add("Butter");
				System.out.println("Added Butter while Reading");
			}
		}
		System.out.println("The new udpated Array List");
		System.out.println(copyArrayList);
	}
}

❌Output:
Milk
Eggs
Added Butter while Reading
Exception in thread "main" java.util.ConcurrentModificationException
	at java.base/java.util.ArrayList$Itr.checkForComodification(ArrayList.java:1096)
	at java.base/java.util.ArrayList$Itr.next(ArrayList.java:1050)
	at CollectionFramework/collections.CopyOnWriteArrayListDemo.main(CopyOnWriteArrayListDemo.java:15)

While Iterating we cannot modify the list, it will throw an exception.

✅ Using CopyOnWriteArrayList:
List<String>copyArrayList=new CopyOnWriteArrayList<>(); //using this we will get the

⚡Output:
Milk
Eggs
Added Butter while Reading
Bread
Meat
The new udpated Array List
[Milk, Eggs, Bread, Meat, Butter]

🔷 Maps in Java
In Java, a Map is an object that maps keys to values. It cannot contain duplicate keys, and each key can map to at most one value. Thik of it as a dictionary where you look up a word(key ) to find its defintion(value).

Map does not extends collection interface. It extends Map interface.

🌟 Key Characteristics of the Map Interface
➤ Key-Value Pair: Each entry in a Map consists of a key and a value.
➤ Unique Keys: No two entries can have the same key.
➤ One Value per key: Each key maps to a single value.
➤ Order: Some implementations maintain insertion order(LinkedHashMap), nature order(TreeMap), or no order(HashMap).

🌟 HashMap
✅ Code Snippet:
package collections;

import java.util.HashMap;
import java.util.Map.Entry;
import java.util.Set;

public class HashMapDemo {

	public static void main(String[] args) {
		HashMap<Integer, String> hs = new HashMap<>();
		hs.put(1, "Ankur");
		hs.put(2, "Deepak");
		hs.put(3, "Suraj");
		hs.put(4, "Harsh");
		System.out.println(hs);

		System.out.println(hs.get(3));
		// if not present gives null
		System.out.println(hs.get(5));

		if (hs.containsKey(2)) {
			System.out.println("Key is present in the map");
		} else {
			System.out.println("Key is not present in the map");
		}

		if (hs.containsValue("Ankur")) {
			System.out.println("Value is present");
		} else {
			System.out.println("Value is not present");
		}

		// iterating the map Method 1
		System.out.println("Iterating on the map by keySet Method");
		// Set<Integer> keys=hs.keySet();
		for (int i : hs.keySet()) {
			System.out.println(i + " -> " + hs.get(i));
		}

		// Method 2
		System.out.println("Iterating on the map using entrySet Method");
		Set<Entry<Integer, String>> entrySet = hs.entrySet();
		for (Entry<Integer, String> entry : entrySet) {
			System.out.println(entry.getKey() + " -> " + entry.getValue().toUpperCase());
		}

		//hs.remove(1); //removing element based on key
		boolean isRemoved=hs.remove(1, "Deepak"); //removing based on key and value
		System.out.println(isRemoved); //because no entry exist of that type

	}
}

❌Output:
{1=Ankur, 2=Deepak, 3=Suraj, 4=Harsh}
Deepak
null
Key is not present in the map
Value is present
Iterating on the map by keySet Method
1 -> Ankur
2 -> Deepak
3 -> Suraj
4 -> Harsh
Iterating on the map using entrySet Method
1 -> ANKUR
2 -> DEEPAK
3 -> SURAJ	
4 -> HARSH
false

🌟 Key Characteristics of HashMap
➤ Unordered: Does not maintain any order of its elements.
➤ Allows null keys and Values: Can have one null key and multiple null values.
➤ Not Synchhronized: Not thread-safe, requires external synchronization if used in a multi-threaded context.
➤ Performance: Offers constant time performance(O(1)) for basic operations like get and put, assuming the hash function disperses elements properly.

🔄 Internal Structure of HashMap
Basic components:
✔️ Key: The identifer used to retrieve a value.
✔️ Value:The data associated with the key.
✔️ Bucket: A place where key-value paris are stored. Think of buckets as cells in a list(array).
✔️ Hash function: Converts a key into an index(bucket location) for storage.
➤ A hash function is an algorithm that takes an input(or key) and returns a fixed-size string of bytes, typically a numerical value. The output is known as the hash code, hash value or simply hash. The primary purpose of a hash function is to map data of arbitrary size to a fixed-size value.

Characteristics of Hash Function:
✔️ Deterministic: Given the same input, the hash function always produces the same output.
✔️ Fixed Output size: The output of the hash function is a fixed-size string of bytes.
✔️ Efficient Computation: The hash function is fast to compute.

🧠 How Data is Stored in HashMap
⚡ Step 1: Hashing the Key: 
The key is passed through a hash function to generate a unique hash code(an integer number). This hash code helps determine where the key-value pair will be stored in the array(called a "bucket array").

⚡ Step 2: Calculating the Index:
The hash code is then used to calculate an index in the array(bucket location) using
int index= hashCode % array.length;
The index decides which bucket will hold the key-value pair.
✅ For example: If the array size is 16, the key's hash code will be divided by `16, and the remainder will be the index.

⚡ Step 3: Storing in the Bucket:
The key-value pair is stored in the bucket at the calculated index.
Each bucket can hold multiple key-value pairs.
(this is called a collision handling mechanism).

🧠 How HashMap Retrieves Data
When we call get(Key), the HashMap follows the following steps:
⚡ Hashing the key: Similar to insertion, the key is hashed using the same hash function to calculate its hash code.
⚡ Finding the index: The hash code is used to find the index of the bucket where the key-value pair is stored.
⚡ Searching in the Bucket: Once the correct bucket is found, it checks for the key in that bucket. If found, it returns the value associated with the key.	

🆚Handling Collisions
➤ Since different keys can generate the same index(called a collision)
HashMap uses a technique to handle this situation. Java's HashMap uses Linked List(or balanced Red-Black Tree(self balancing binary search tree) after Java 8) to resolve collisions.

➤ If multiple key-value paris map to the same bucket, they are stored i a linked list inside the bucket.
➤ This is called Separate Chaining.

➤ When a key-value pair is retrieved, the HashMap traverse the linked list to find the value associated with the key.

🔄 HashMap Resizing(Rehashing)
➤ HashMap has an internal array size, which is by default is 16.
When the number of elements(key-value pairs) grows and exceeds a certain load factor(default is 0.75), HashMap automatically resizes the array to hold more data. This process is called rehashing.

➤ The default size of the array is 16, so when more than 12 elements(16*0.75) are inserted, the HashMap will resize.

❗During rehashing
➤ The array size is doubled
➤ All existing entries are rehashed(i.e., their positions are recalculated)
and placed in the new array.
➤ This ensures the HashMap continues to work efficiently even after more data is added.

⚡Time Compplexity
➤ Average: O(1) for insertion, deletion, search.
➤ Worst case (all collisions in same bucket): O(logn) (but rare in practice).
But after Java 8, if there are too many elements in the bucket, HashMap switches to a balanced tree instead of a linked list to ensure better performance.
TREEFY_THRESHOLD = 8 for converting linked list to balanced tree.

❗Problem:
➤ When you create a custom class Person with fields like id and name, and put it into a HashMap, then:
➤ By default, Object's implementation of hashCode() and equals() is used.
➤ That implementation uses memory address → so two objects with the same values (id=1, name="Ankur") are considered different keys.

Example (Problem Case):
import java.util.*;

class Person {
    private int id;
    private String name;

    public Person(int id, String name) {
        this.id = id;
        this.name = name;
    }
}

public class Main {
    public static void main(String[] args) {
        Map<Person, String> map = new HashMap<>();

        Person p1 = new Person(1, "Ankur");
        Person p2 = new Person(1, "Ankur");

        map.put(p1, "Developer");
        map.put(p2, "Manager");

        System.out.println("Map size: " + map.size());
        System.out.println(map);
    }
}
👉 Output:
Map size: 2

➤ Even though both objects have the same id and name, they are treated as different keys.

✅ Fix:
To fix this, override hashCode() and equals() in the Person class.
🔄 Correct Implementation:
import java.util.*;

class Person {
    private int id;
    private String name;

    public Person(int id, String name) {
        this.id = id;
        this.name = name;
    }

    // Override equals
    @Override
    public boolean equals(Object o) {
        if (this == o) return true; // same reference
        if (o == null || getClass() != o.getClass()) return false;

        Person person = (Person) o;
        return id == person.id && Objects.equals(name, person.name);
    }

    // Override hashCode
    @Override
    public int hashCode() {
        return Objects.hash(id, name);
    }

    @Override
    public String toString() {
        return "Person{id=" + id + ", name='" + name + "'}";
    }
}

public class Main {
    public static void main(String[] args) {
        Map<Person, String> map = new HashMap<>();

        Person p1 = new Person(1, "Ankur");
        Person p2 = new Person(1, "Ankur");

        map.put(p1, "Developer");
        map.put(p2, "Manager");

        System.out.println("Map size: " + map.size());
        System.out.println(map);
    }
}
👉 Output:
Map size: 1
{Person{id=1, name='Ankur'}=Manager}

➤ Now both objects are considered the same key because hashCode() is same and equals() says they are equal.
➤ The second put() overwrites the value (Manager replaces Developer).

✔️ Key Notes 
➤ Always override both equals() and hashCode() together (not just one).
➤ If you only override equals() but not hashCode(), HashMap may still treat them as different keys.
➤ Use Objects.hash() and Objects.equals() (Java 7+) to simplify.
➤ Consistency rule: if a.equals(b) == true, then a.hashCode() == b.hashCode() must also hold.

✅ Working of getOrDefault() Method:
package collections;

import java.util.HashMap;

public class HashMapDemo {

	public static void main(String[] args) {
		HashMap<String, Integer> hashMap = new HashMap<>();
		hashMap.put("Ankur", 100);
		hashMap.put("Alice", 99);
		hashMap.put("Bob", 101);

		Integer res1 = hashMap.getOrDefault("Ankur", -1);
		if (res1 != -1) {
			System.out.println("Ankur is present in the map");
		} else {
			System.out.println("Ankur Not present");
		}

		Integer res2 = hashMap.getOrDefault("Sam", -1);
		if (res2 != -1) {
			System.out.println("Sam is present in the map");
		} else {
			System.out.println("Sam Not present");
		}

	}
}

✅Output:
Ankur is present in the map
Sam Not present

✅Method: putIfAbsent()
Example:
package collections;

import java.util.HashMap;

public class HashMapDemo {

	public static void main(String[] args) {
		HashMap<String, Integer> hashMap = new HashMap<>();
		hashMap.put("Ankur", 100);
		hashMap.put("Alice", 99);
		hashMap.put("Bob", 101);

		hashMap.putIfAbsent("Ankur", 200);
		hashMap.putIfAbsent("Sam", 201);
		System.out.println(hashMap);
	}
}

✅Output:
{Ankur=200, Alice=99, Bob=101, Sam=201}

🔷 LinkedHashMap
package collections;

import java.util.LinkedHashMap;
import java.util.Map;

public class LinkedHashMapDemo {

	public static void main(String[] args) {
		LinkedHashMap<String, Integer> linkedHashMap = new LinkedHashMap<>();
		linkedHashMap.put("Orange", 10);
		linkedHashMap.put("Apple", 20);
		linkedHashMap.put("Mango", 30);
		
		for(Map.Entry<String, Integer>entry:linkedHashMap.entrySet()) {
			System.out.println(entry.getKey()+" -> "+ entry.getValue());
		}
	}
}

📌 Constructor
LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)

➤ initialCapacity → number of buckets initially.
➤ loadFactor → controls resizing.
➤ accessOrder →
	✔️ false → maintains insertion order.
	✔️ true → maintains access order (order changes when an entry is accessed with get() or put()).

✅ Example 1: accessOrder = false (Insertion Order)
import java.util.*;

public class Main {
    public static void main(String[] args) {
        // Insertion order
        Map<Integer, String> map = new LinkedHashMap<>(16, 0.75f, false);

        map.put(1, "A");
        map.put(2, "B");
        map.put(3, "C");

        // Access element
        map.get(2); // does NOT change order

        System.out.println("Insertion Order: " + map);
    }
}
👉 Output:
Insertion Order: {1=A, 2=B, 3=C}
Even though we accessed key 2, the order remains insertion order.

✅ Example 2: accessOrder = true (Access Order)
import java.util.*;

public class Main {
    public static void main(String[] args) {
        // Access order
        Map<Integer, String> map = new LinkedHashMap<>(16, 0.75f, true);

        map.put(1, "A");
        map.put(2, "B");
        map.put(3, "C");

        // Access element
        map.get(2); // moves 2 to end
        map.get(1); // moves 1 to end

        System.out.println("Access Order: " + map);
    }
}
👉 Output:
Access Order: {3=C, 2=B, 1=A}

First inserted order: {1=A, 2=B, 3=C}
After map.get(2) → 2 moves to end → {1=A, 3=C, 2=B}
After map.get(1) → 1 moves to end → {3=C, 2=B, 1=A}

⚡Tip
✔️ accessOrder = true is often used to implement LRU Cache (Least Recently Used).
✔️ removeEldestEntry() method can be overridden to auto-remove the oldest entry.

LinkedHashMap is a combination of HashMap + Doubly Linked List.

✅ Constructor Method:
LinkedHashMap linkedHashMap= new LinkedHashMap(hashMap);

🔷WeakHashMap
➤ WeakHashMap<K,V> is a special implementation of Map where keys are stored as weak references.
➤ If a key is not strongly referenced elsewhere in the program, the GC (Garbage Collector) can reclaim it.
➤ Once GC collects the key, the corresponding entry is automatically removed from the map.

🔄 Use of WeakHashMap
➤ Commonly used for caches where you don’t want unused objects to prevent GC.
➤ If the key object is no longer in use anywhere else → its entry is automatically removed.

✅ Example
import java.util.WeakHashMap;

public class WeakHashMapDemo {

	public static void main(String[] args) {
		WeakHashMap<String, Image> imageCache = new WeakHashMap<>();
		imageCache.put(new String("img1"), new Image("Image 1"));
		imageCache.put(new String("img2"), new Image("Image 2"));
		imageCache.put(new String("img3"), new Image("Image 3"));
		System.out.println(imageCache);
		System.gc();
		simulation();
		System.out.println("Cache after running(some entries may be cleared): " + imageCache);
	}

	private static void simulation() {
		try {
			System.out.println("Simulating application running...");
			Thread.sleep(10000);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

class Image {
	private String name;

	public Image(String name) {
		this.name = name;
	}

	@Override
	public String toString() {
		return name;
	}
}
✅Output:
{img1=Image 1, img2=Image 2, img3=Image 3}
Simulating application running...
Cache after running(some entries may be cleared): {}

🧠Explaination
👉WeakHashMap<String, Image> imageCache = new WeakHashMap<>();
Creates a WeakHashMap where:
	✔️ Key = String (weakly referenced)
	✔️ Value = Image object (normal strong reference)

👉imageCache.put(new String("img1"), new Image("Image 1"));
➤ Uses new String("img1") → ensures the key is not from String pool (important!).
➤ If we had used "img1" directly, it would come from the string pool (strongly referenced by JVM), and GC wouldn’t clear it.

👉System.gc();
Suggests JVM to run garbage collection (not guaranteed, but usually works in demos).

👉simulation();
Sleeps for 10 seconds → gives JVM time to clear weakly referenced keys.

👉 Class Image
➤ Just a wrapper with a name field.
➤ toString() overridden → so when map is printed, values show as "Image 1", "Image 2", etc.

👉 Output Explaination:
➤ The second print may show {} or partially cleared entries depending on GC.
➤ Because keys (new String("imgX")) are weakly referenced → once GC runs, they vanish.

⚡ Important Points
✔️ WeakHashMap removes entries automatically when keys are weakly referenced and GC runs.
🆚 Difference from HashMap:
➤ HashMap → keys are strongly referenced (never removed unless explicitly).
➤ WeakHashMap → keys are weak references (removed after GC if no strong reference exists).
✔️ Values (Image) are still strongly referenced, but without a strong key reference, they become unreachable.
✔️ Useful for memory-sensitive caching.

🧠 Trap Question
package collections;

import java.util.HashMap;
import java.util.Map;

public class IdentityHashMapDemo {

	public static void main(String[] args) {
		String key1 = new String("Key");
		String key2 = new String("Key");
		Map<String, Integer> map = new HashMap<>();
		map.put(key1, 1);
		map.put(key2, 2);
		System.out.println(map);
	}

}
✅ Output: {key=2};
🧠Explaination: Even though string is made through new keyword, that hashcode will not be generated based on the memory address, as string already has a function to calculate hashcode based on the value stored inside the string so both the values are same. 
Therefore, inside the map it will use the key1.equals(key2) and it will return true so it will return the value of key2 which is 2.

If we want output like {key=1, key=2} then we can use IdentityHashMap.

🔷IdentityHashMap
➤ IdentityHashMap is a special implementation of Map in Java where keys are compared using reference equality (==) instead of equals().
➤ It is part of java.util package.

🌟 Key Features
➤ Uses reference equality (==) for both key comparison and hashing.
➤ Allows null keys and null values.
➤ Performance is similar to HashMap.
➤ Not synchronized (like HashMap).
➤ It breaks the general contract of Map because two logically equal keys (according to .equals()) may not be treated as equal here.

🆚 Difference from HashMap
| Feature        | `HashMap`                     | `IdentityHashMap`                |
| -------------- | ----------------------------- | -------------------------------- |
| Key comparison | Uses `equals()`               | Uses `==` (reference equality)   |
| Hashing        | Uses `hashCode()` of key      | Uses `System.identityHashCode()` |
| Usage          | When logical equality matters | When reference identity matters  |

✅ Example 1:
import java.util.*;

public class IdentityHashMapDemo {
    public static void main(String[] args) {
        Map<String, String> map = new IdentityHashMap<>();

        String a = new String("hello");
        String b = new String("hello");

        map.put(a, "Value A");
        map.put(b, "Value B");

        System.out.println("Size: " + map.size());
        System.out.println(map);
    }
}

✅ Output:
Size: 2
{hello=Value A, hello=Value B}
👉 Even though a.equals(b) is true, IdentityHashMap treats them as different keys because a != b (different objects in memory).

🌟 Use Cases
✔️ When you need object identity instead of equality.
✔️ Caching frameworks (where reference equality is important).
✔️ Serialization/deserialization where temporary objects need unique tracking.
✔️ Graph processing (tracking visited nodes by identity).
✔️ Object pools.

✅ Example: What will happen if you put two equal String objects as keys?
package collections;

import java.util.IdentityHashMap;
import java.util.Map;

public class IdentityHashMapDemo {

	public static void main(String[] args) {
		String key1 = new String("Key");
		String key2 = new String("Key");
		Map<String, Integer> map = new IdentityHashMap<>();
		map.put(key1, 1);
		map.put(key2, 2);
		System.out.println(map);
	}
}
✅Output : {Key=2}

🔷 Comparable
➤ Belongs to java.lang package.
➤ Used to define the natural/default ordering of objects.
➤ A class implements Comparable to provide its own comparison logic.
➤ It has one method:
🔗 public int compareTo(T o):
Returns:
	✔️ 0 → equal
	✔️ <0 → current object < given object
	✔️ >0 → current object > given object

🔸 Example: Student sorting by age (natural order)
class Student implements Comparable<Student> {
    String name;
    int age;

    Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public int compareTo(Student s) {
        return this.age - s.age; // ascending order
    }
}

✅ Comparator (Interface)
➤ Belongs to java.util package.
➤ Used when we want to define multiple sorting strategies or sorting logic outside the class.
➤ It has two main methods Java 8 added comparing() and thenComparing() for chaining.:
	✔️ public int compare(T o1, T o2);
	✔️ public boolean equals(Object obj); // rarely overridden
➤ Can be used with lambda/method references for concise sorting.

🔸 Example: Sorting Student by name
import java.util.*;

class Student {
    String name;
    int age;
    Student(String name, int age) {
        this.name = name;
        this.age = age;
    }
}

class NameComparator implements Comparator<Student> {
    public int compare(Student s1, Student s2) {
        return s1.name.compareTo(s2.name);
    }
}
🔄 Usage: Collections.sort(list, new NameComparator());

🆚 Comparable vs Comparator — Differences
| Feature             | Comparable                              | Comparator                                          |
| ------------------- | --------------------------------------- | --------------------------------------------------- |
| Package             | `java.lang`                             | `java.util`                                         |
| Method              | `compareTo(Object o)`                   | `compare(Object o1, Object o2)`                     |
| Sorting logic       | Defined **inside the class**            | Defined **outside the class**                       |
| Natural Order       | Provides **default (natural)** ordering | Provides **custom/multiple** orderings              |
| Modifies class code | Yes (must implement inside class)       | No (separate comparator class or lambda)            |
| One vs Many         | One natural order only                  | Many possible comparators                           |
| Java 8 support      | No enhancements                         | Added `comparing()`, `thenComparing()` for chaining |

✅ Example with Both
import java.util.*;

class Student implements Comparable<Student> {
    String name;
    int age;
    Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // Natural order: by age
    @Override
    public int compareTo(Student s) {
        return this.age - s.age;
    }

    @Override
    public String toString() {
        return name + " (" + age + ")";
    }
}

public class Main {
    public static void main(String[] args) {
        List<Student> list = new ArrayList<>();
        list.add(new Student("John", 25));
        list.add(new Student("Alice", 22));
        list.add(new Student("Bob", 30));

        // Using Comparable (natural order: by age)
        Collections.sort(list);
        System.out.println("Sorted by age: " + list);

        // Using Comparator (custom order: by name)
        Collections.sort(list, (s1, s2) -> s1.name.compareTo(s2.name));
        System.out.println("Sorted by name: " + list);
    }
}

🌟 Insights
➤ Comparable → "I have a natural order, built inside the class."
➤ Comparator → "I allow multiple sorting logics, outside the class."
➤ Common trick: “Can a class implement both?” → ✅ Yes, a class can have a natural order (Comparable) and also be sorted by different comparators when needed.

🔷 SortedMap
An interface in Java that extends Map and guarantees ordering of keys in ascending order (natural ordering or custom Comparator).

🌟 Key Features:
➤ Maintains elements in sorted order of keys.
➤ Duplicate keys ❌ not allowed.
➤ Backed by implementations like TreeMap.
➤ Provides range-view methods (headMap, tailMap, subMap).

Important Methods:
➤ K firstKey() → returns lowest key.
➤ K lastKey() → returns highest key.
➤ SortedMap<K,V> headMap(K toKey) → view of keys < toKey.
➤ SortedMap<K,V> tailMap(K fromKey) → view of keys >= fromKey.
➤ SortedMap<K,V> subMap(K fromKey, K toKey) → view between fromKey and toKey.
➤ Comparator<? super K> comparator() → returns comparator used, or null if natural ordering.

Use Cases:
✔️ Maintaining sorted dictionaries.
✔️ Range-based operations (e.g., retrieving values within a range of keys).
✔️ Implementing priority-like behavior using keys.

✅Code Implementation:
import java.util.*;

public class SortedMapDemo {
    public static void main(String[] args) {
        // Creating a SortedMap
        SortedMap<Integer, String> sortedMap = new TreeMap<>();

        // Adding elements
        sortedMap.put(3, "Banana");
        sortedMap.put(1, "Apple");
        sortedMap.put(5, "Mango");
        sortedMap.put(2, "Orange");
        sortedMap.put(4, "Grapes");

        // Displaying map (sorted automatically by keys)
        System.out.println("SortedMap: " + sortedMap);

        // Methods of SortedMap
        System.out.println("First Key: " + sortedMap.firstKey());
        System.out.println("Last Key: " + sortedMap.lastKey());
        System.out.println("HeadMap (<3): " + sortedMap.headMap(3));
        System.out.println("TailMap (>=3): " + sortedMap.tailMap(3));
        System.out.println("SubMap (2 to 5): " + sortedMap.subMap(2, 5));
        System.out.println("Comparator Used: " + sortedMap.comparator()); // null → natural ordering
    }
}

✅Output
{1=Apple, 2=Orange, 3=Banana, 4=Grapes, 5=Mango}
First Key: 1
Last Key: 5
HeadMap(<3): {1=Apple, 2=Orange}
TailMap(>=3): {3=Banana, 4=Grapes, 5=Mango}
SubMap(2 to 5): {2=Orange, 3=Banana, 4=Grapes}
Comparator Used: null

🔷 NavigableMap
An interface that extends SortedMap, providing navigation methods for key search and traversal.

🌟 Key Features:
➤ Allows finding closest matches (floorKey, ceilingKey, etc.).
➤ Can return reverse order views of the map.
➤ Common implementation: TreeMap.

🌟 Important Methods:
➤ K lowerKey(K key) → greatest key < key.
➤ K floorKey(K key) → greatest key <= key.
➤ K ceilingKey(K key) → least key >= key.
➤ K higherKey(K key) → least key > key.
➤ Map.Entry<K,V> firstEntry() / lastEntry() → first and last entry.
➤ Map.Entry<K,V> pollFirstEntry() → removes and returns first entry.
➤ NavigableMap<K,V> descendingMap() → reverse order view.

🔄 Use Cases:
➤ Efficient searching for nearest values.
➤ Implementing caches, scheduling systems, range queries.
➤ Situations where ordering + navigation are critical.

✅Code Implementation:
import java.util.*;

public class NavigableMapDemo {
    public static void main(String[] args) {
        // Creating a NavigableMap
        NavigableMap<Integer, String> navMap = new TreeMap<>();

        // Adding elements
        navMap.put(1, "Apple");
        navMap.put(2, "Orange");
        navMap.put(3, "Banana");
        navMap.put(4, "Grapes");
        navMap.put(5, "Mango");

        // Displaying map
        System.out.println("NavigableMap: " + navMap);

        // Methods of NavigableMap
        System.out.println("Lower Key(3): " + navMap.lowerKey(3));    // < 3
        System.out.println("Floor Key(3): " + navMap.floorKey(3));    // <= 3
        System.out.println("Ceiling Key(3): " + navMap.ceilingKey(3));// >= 3
        System.out.println("Higher Key(3): " + navMap.higherKey(3));  // > 3

        System.out.println("First Entry: " + navMap.firstEntry());
        System.out.println("Last Entry: " + navMap.lastEntry());
        System.out.println("Descending Map: " + navMap.descendingMap());

        // Polling entries (removes from map)
        System.out.println("Poll First Entry: " + navMap.pollFirstEntry());
        System.out.println("Poll Last Entry: " + navMap.pollLastEntry());
        System.out.println("Remaining Map: " + navMap);
    }
}
✅Output:
{1=Apple, 2=Orange, 3=Banana, 4=Grapes, 5=Mango}
Lower Key(3): 2
Floor Key(3): 3
Ceiling Key(3): 3
Higher Key(3): 4
Descending Map: {5=Mango, 4=Grapes, 3=Banana, 2=Orange, 1=Apple}
Poll First Entry: 1=Apple
Poll Last Entry: 5=Mango
Remaining Map: {2=Orange, 3=Banana, 4=Grapes}

🔷 Hashtable
A legacy class (from JDK 1.0) that implements Map, storing key-value pairs in hash table form.

🔄 Key Features:
➤ ✅ Thread-safe (all methods synchronized).
➤ ❌ Null keys/values not allowed (unlike HashMap).
➤ Slower than HashMap due to synchronization.
➤ Introduced before Java Collections Framework → considered legacy.
➤ Replaced by ConcurrentHashMap in modern concurrent apps.

🔄 Internal Working:
➤ Uses array of buckets where each bucket stores a linked list of entries.
➤ On collision → new entry appended to linked list of that bucket.
➤ Since Java 8, HashMap/ConcurrentHashMap optimize collision handling with balanced trees, but Hashtable still uses only linked list.

🔄 Important Methods:
➤ V put(K key, V value) → insert key-value.
➤ V get(Object key) → retrieve value.
➤ boolean containsKey(Object key) / containsValue(Object value) → check existence.
➤ Enumeration<K> keys() / elements() → legacy iteration methods.

🔄 Use Cases:
➤ Very limited today — mostly in legacy systems.
➤ For thread-safe maps → use ConcurrentHashMap.

🔄 Comparison with HashMap:
➤ Hashtable → synchronized, no null keys/values, slower.
➤ HashMap → not synchronized, allows one null key & multiple null values, faster.

✅Code Implementation:
import java.util.*;

public class HashtableDemo {
    public static void main(String[] args) {
        // Creating a Hashtable
        Hashtable<Integer, String> hashtable = new Hashtable<>();

        // Adding elements
        hashtable.put(101, "Java");
        hashtable.put(102, "Python");
        hashtable.put(103, "C++");
        hashtable.put(104, "JavaScript");

        // Displaying Hashtable
        System.out.println("Hashtable: " + hashtable);

        // Access methods
        System.out.println("Value at key 102: " + hashtable.get(102));
        System.out.println("Contains key 103? " + hashtable.containsKey(103));
        System.out.println("Contains value 'C#'? " + hashtable.containsValue("C#"));

        // Iterating with Enumeration (legacy style)
        System.out.println("Iterating using Enumeration:");
        Enumeration<Integer> keys = hashtable.keys();
        while (keys.hasMoreElements()) {
            Integer key = keys.nextElement();
            System.out.println(key + " -> " + hashtable.get(key));
        }
    }
}

✅Output:
{104=JavaScript, 103=C++, 102=Python, 101=Java}
Value at key 102: Python
Contains key 103? true
Contains value 'C#'? false
Iterating with Enumeration:
104 -> JavaScript
103 -> C++
102 -> Python
101 -> Java

🔷 ConcurrentHashMap
✅ Java 7
➤ Used segment-based locking (default: 16 segments → 16 smaller hash tables).
➤ Only the segment being modified/read is locked.
➤ Read: doesn’t require locking unless concurrent write is happening.
➤ Write: locks only that segment (better concurrency than Hashtable).

✅ Java 8
➤ Removed segmentation → now uses bucket-level locks.
➤ Uses CAS (Compare-And-Swap) for updates (almost lock-free).
➤ Locking only occurs during resizing or treeification (when collision chains convert to balanced trees).
➤ Much faster than Java 7 implementation.

✅Code Implementation:
import java.util.concurrent.*;

public class ConcurrentHashMapDemo {
    public static void main(String[] args) {
        ConcurrentHashMap<Integer, String> chm = new ConcurrentHashMap<>();

        // Adding elements
        chm.put(1, "Apple");
        chm.put(2, "Banana");
        chm.put(3, "Mango");

        // Retrieving
        System.out.println("ConcurrentHashMap: " + chm);

        // Key already exists → old value replaced
        chm.put(2, "Orange");
        System.out.println("After update: " + chm);

        // Safe iteration during modification
        chm.forEach((k, v) -> System.out.println(k + " -> " + v));
    }
}

✅Output:
ConcurrentHashMap: {1=Apple, 2=Banana, 3=Mango}
After update: {1=Apple, 2=Orange, 3=Mango}
1 -> Apple
2 -> Orange
3 -> Mango

🔷 ConcurrentSkipListMap
➤ Thread-safe, Sorted Map implementation.
➤ Backed by a SkipList, which is a probabilistic data structure with multiple layers (like “express lanes” in a linked list).
➤ Allows logarithmic time search, insert, delete.

✅ Key Features
➤ Maintains sorted order of keys (like TreeMap).
➤ Concurrent access supported.
➤ Non-blocking reads, fine-grained locking on writes.

✅Code Implementation
import java.util.concurrent.*;

public class ConcurrentSkipListMapDemo {
    public static void main(String[] args) {
        ConcurrentSkipListMap<Integer, String> cslm = new ConcurrentSkipListMap<>();

        // Adding elements
        cslm.put(5, "Mango");
        cslm.put(2, "Apple");
        cslm.put(4, "Banana");
        cslm.put(1, "Orange");

        // Sorted automatically
        System.out.println("ConcurrentSkipListMap: " + cslm);

        // Methods
        System.out.println("First Key: " + cslm.firstKey());
        System.out.println("Last Key: " + cslm.lastKey());
        System.out.println("HeadMap (<4): " + cslm.headMap(4));
        System.out.println("TailMap (>=2): " + cslm.tailMap(2));
    }
}

✅Output:
ConcurrentSkipListMap: {1=Orange, 2=Apple, 4=Banana, 5=Mango}
First Key: 1
Last Key: 5
HeadMap (<4): {1=Orange, 2=Apple}
TailMap (>=2): {2=Apple, 4=Banana, 5=Mango}


🔷 EnumMap
➤ A specialized Map implementation where keys must be enum constants.
➤ Internally uses an array of values, indexed by enum’s ordinal().
➤ Very fast (no hashing) and memory-efficient.
➤ Null keys ❌ not allowed.

✅Code Implementation:
import java.util.*;

enum Day { MON, TUE, WED, THU, FRI, SAT, SUN }

public class EnumMapDemo {
    public static void main(String[] args) {
        EnumMap<Day, String> em = new EnumMap<>(Day.class);

        // Adding elements
        em.put(Day.MON, "Start of week");
        em.put(Day.FRI, "Weekend is near");
        em.put(Day.SUN, "Holiday");

        // Displaying map
        System.out.println("EnumMap: " + em);

        // Access
        System.out.println("Message for FRI: " + em.get(Day.FRI));
    }
}

✅Output:
EnumMap: {MON=Start of week, FRI=Weekend is near, SUN=Holiday}
Message for FRI: Weekend is near

🔷 ImmutableMap
➤ Map that cannot be modified once created.
➤ Any attempt to add/remove/update will throw UnsupportedOperationException.

✅ Ways to Create ImmutableMap
1. Guava’s ImmutableMap (Google library):
// Guava ImmutableMap
// ImmutableMap<String, Integer> map1 = ImmutableMap.of("A", 1, "B", 2, "C", 3);

2.Using Collections.unmodifiableMap():
✅Code Implementation:
import java.util.*;

public class ImmutableMapDemo1 {
    public static void main(String[] args) {
        Map<String, Integer> normalMap = new HashMap<>();
        normalMap.put("A", 1);
        normalMap.put("B", 2);

        Map<String, Integer> immutableMap = Collections.unmodifiableMap(normalMap);
        System.out.println("ImmutableMap: " + immutableMap);

        // immutableMap.put("C", 3); // ❌ Throws UnsupportedOperationException
    }
}

✅Output:
ImmutableMap: {A=1, B=2}

3. Using Java 9+ Map.of() (limited to 10 pairs):
✅Code Implementation:
import java.util.*;

public class ImmutableMapDemo2 {
    public static void main(String[] args) {
        Map<String, Integer> map2 = Map.of("A", 1, "B", 2, "C", 3);
        System.out.println("Map.of: " + map2);

        // map2.put("D", 4); // ❌ Throws UnsupportedOperationException
    }
}

✅Output:
Map.of: {A=1, B=2, C=3}

4. Using Map.ofEntries() for larger maps:
✅Code Implementation:
import java.util.*;

public class ImmutableMapDemo3 {
    public static void main(String[] args) {
        Map<String, Integer> map3 = Map.ofEntries(
            Map.entry("A", 1),
            Map.entry("B", 2),
            Map.entry("C", 3),
            Map.entry("D", 4)
        );

        System.out.println("Map.ofEntries: " + map3);

        // map3.remove("A"); // ❌ UnsupportedOperationException
    }
}

✅Output:
Map.ofEntries: {A=1, B=2, C=3, D=4}

 
 🔷 Set
➤ Set is a collection of unique elements (no duplicates).
➤ Unordered by default (HashSet).
➤ Extends Collection interface.
➤ Not thread-safe by default.

🔄 Common Implementations:
➤ HashSet → backed by HashMap, no order guarantee.
➤ LinkedHashSet → maintains insertion order.
➤ TreeSet → maintains sorted order (uses Red-Black Tree).
➤ EnumSet → optimized for enum constants.

👉 For thread-safety, we have special implementations:
➤ Collections.synchronizedSet(set) → synchronized wrapper (rarely used).
➤ ConcurrentSkipListSet → concurrent + sorted.
➤ CopyOnWriteArraySet → concurrent + copy-on-write


🔷 LinkedHashSet
➤ Hash table + doubly linked list implementation.
➤ Maintains insertion order.
➤ Slightly slower than HashSet due to maintaining linked list.

✅ Code Implementation:
import java.util.*;

public class LinkedHashSetDemo {
    public static void main(String[] args) {
        LinkedHashSet<String> lhs = new LinkedHashSet<>();

        lhs.add("Apple");
        lhs.add("Banana");
        lhs.add("Mango");
        lhs.add("Banana"); // duplicate ignored

        System.out.println("LinkedHashSet: " + lhs);
    }
}

✅ Output:
LinkedHashSet: [Apple, Banana, Mango]

🔷 TreeSet
➤ Backed by a Red-Black Tree (self-balancing BST).
➤ Maintains sorted order (ascending by default).
➤ Can accept a Comparator for custom order.

✅ Code Implementation:
import java.util.*;

public class TreeSetDemo {
    public static void main(String[] args) {
        TreeSet<Integer> ts = new TreeSet<>();

        ts.add(30);
        ts.add(10);
        ts.add(20);
        ts.add(40);

        System.out.println("TreeSet: " + ts); // Sorted order
        System.out.println("First: " + ts.first());
        System.out.println("Last: " + ts.last());
        System.out.println("HeadSet(<30): " + ts.headSet(30));
        System.out.println("TailSet(>=20): " + ts.tailSet(20));
        System.out.println("SubSet(10 to 30): " + ts.subSet(10, 30));
    }
}

✅ Output:
TreeSet: [10, 20, 30, 40]
First: 10
Last: 40
HeadSet(<30): [10, 20]
TailSet(>=20): [20, 30, 40]
SubSet(10 to 30): [10, 20]


🔷 ConcurrentSkipListSet
➤ A concurrent, sorted, thread-safe set.
➤ Backed by ConcurrentSkipListMap internally.
➤ Maintains ascending sorted order.
➤ Good for range-based operations (subSet, headSet, tailSet).
➤ Weakly consistent iterators → do not throw ConcurrentModificationException, but may miss new updates.

✅Code Implementation:
import java.util.concurrent.*;

public class ConcurrentSkipListSetDemo {
    public static void main(String[] args) {
        ConcurrentSkipListSet<Integer> csls = new ConcurrentSkipListSet<>();

        csls.add(50);
        csls.add(20);
        csls.add(10);
        csls.add(40);

        System.out.println("ConcurrentSkipListSet: " + csls);
        System.out.println("HeadSet(<40): " + csls.headSet(40));
        System.out.println("TailSet(>=20): " + csls.tailSet(20));
        System.out.println("SubSet(10 to 40): " + csls.subSet(10, 40));
    }
}

✅ Output:
ConcurrentSkipListSet: [10, 20, 40, 50]
HeadSet(<40): [10, 20]
TailSet(>=20): [20, 40, 50]
SubSet(10 to 40): [10, 20]

🔷 CopyOnWriteArraySet
➤ Backed by CopyOnWriteArrayList.
➤ Thread-safe set.
➤ On every write operation (add/remove) → creates a new copy of the underlying array.
➤ Reads are fast (no lock needed), but writes are expensive.
➤ Best suited for:
	✔️ Read-heavy, write-light scenarios.
	✔️ Avoiding ConcurrentModificationException.

🔄 Iterator Behavior
➤ Iterators are fail-safe (don’t throw ConcurrentModificationException).
➤ Iterators work on a snapshot of the array at the time of iteration → modifications made after iterator creation are not reflected.

✅Code Implementation
import java.util.concurrent.*;
import java.util.*;

public class CopyOnWriteArraySetDemo {
    public static void main(String[] args) {
        CopyOnWriteArraySet<String> cowSet = new CopyOnWriteArraySet<>();

        cowSet.add("Java");
        cowSet.add("Python");
        cowSet.add("C++");
        cowSet.add("Java"); // duplicate ignored

        System.out.println("CopyOnWriteArraySet: " + cowSet);

        // Iterating while modifying (safe)
        Iterator<String> it = cowSet.iterator();
        cowSet.add("Go"); // modification after iterator creation

        System.out.println("Iterator Snapshot:");
        while (it.hasNext()) {
            System.out.println(it.next()); // "Go" won’t appear here
        }

        System.out.println("After modification: " + cowSet); // "Go" appears in actual set
    }
}


✅ Output:
CopyOnWriteArraySet: [Java, Python, C++]
Iterator Snapshot:
Java
Python
C++
After modification: [Java, Python, C++, Go]


🔷 Queue Interface
➤ A linear data structure that works on FIFO (First In First Out) principle.
➤ Elements are added at the end (rear) and removed from the front (head).
➤ Declared in java.util package.
➤ Common implementations:
	✔️ LinkedList
	✔️ PriorityQueue
	✔️ ArrayDeque
	✔️ Concurrent Queues (ConcurrentLinkedQueue, BlockingQueue, etc.)

✅ Common Queue Methods
| Method      | Description     | Behavior when queue is empty / full      |
| ----------- | --------------- | ---------------------------------------- |
| `add(e)`    | Inserts element | Throws exception if full                 |
| `offer(e)`  | Inserts element | Returns `false` if full (no exception)   |
| `remove()`  | Removes head    | Throws `NoSuchElementException` if empty |
| `poll()`    | Removes head    | Returns `null` if empty                  |
| `element()` | Retrieves head  | Throws `NoSuchElementException` if empty |
| `peek()`    | Retrieves head  | Returns `null` if empty                  |


✅Code Implementation:
import java.util.*;

public class QueueDemo {
    public static void main(String[] args) {
        Queue<Integer> q = new LinkedList<>();

        // Enqueue (add/offer)
        q.add(10);       // throws exception if fails
        q.offer(20);     // returns false if fails
        q.add(30);

        System.out.println("Queue: " + q);

        // Peek operations
        System.out.println("Peek: " + q.peek());     // returns 10, does not remove
        System.out.println("Element: " + q.element()); // returns 10, throws exception if empty

        // Dequeue (remove/poll)
        System.out.println("Removed using poll: " + q.poll());   // removes 10
        System.out.println("Removed using remove: " + q.remove()); // removes 20

        System.out.println("Queue after removals: " + q);

        // Edge cases
        q.clear(); // empty queue
        System.out.println("Poll on empty: " + q.poll());   // null
        try {
            System.out.println("Remove on empty: " + q.remove()); // exception
        } catch (Exception e) {
            System.out.println("Exception: " + e);
        }
    }
}

✅ Output:
Queue: [10, 20, 30]
Peek: 10
Element: 10
Removed using poll: 10
Removed using remove: 20
Queue after removals: [30]
Poll on empty: null
Remove on empty: java.util.NoSuchElementException


🔷 PriorityQueue in Java
A Queue implementation that orders elements by priority instead of FIFO.
Located in java.util package.
By default:
	✔️ Uses natural ordering (ascending for numbers, alphabetical for strings).
	✔️ Internally implemented as a Min-Heap (binary heap).
Key Features:
	✔️ Does not allow null elements.
	✔️ Duplicate elements are allowed.
	✔️ Can use a custom Comparator to define ordering (e.g., Max-Heap).


🌟 Internal Working
➤ Implemented using a binary heap stored in an array.
➤ For natural ordering → acts as a Min-Heap.
➤ For reverse order (Comparator.reverseOrder()) → acts as a Max-Heap.
➤ Operations like insertion and deletion work in O(log n).
➤ The head element of the queue is always the smallest (min-heap) or largest (max-heap) based on comparator.


🌟Common Methods
| Method                | Description                                       |
| --------------------- | ------------------------------------------------- |
| `add(e)` / `offer(e)` | Insert element                                    |
| `peek()`              | Returns highest-priority element without removing |
| `poll()`              | Removes and returns highest-priority element      |
| `remove()`            | Removes head, throws exception if empty           |
| `size()`              | Returns number of elements                        |

✅Code Implementation 1:Natural Ordering (Min-Heap)
import java.util.*;

public class PriorityQueueMinHeap {
    public static void main(String[] args) {
        PriorityQueue<Integer> pq = new PriorityQueue<>(); // min-heap

        pq.add(40);
        pq.add(10);
        pq.add(30);
        pq.add(20);

        System.out.println("PriorityQueue (Min-Heap): " + pq);
        System.out.println("Peek (smallest): " + pq.peek()); // 10

        while (!pq.isEmpty()) {
            System.out.println("Poll: " + pq.poll());
        }
    }
}

✅ Output:
PriorityQueue (Min-Heap): [10, 20, 30, 40]
Peek (smallest): 10
Poll: 10
Poll: 20
Poll: 30
Poll: 40

✅Code Implementation 2:Reverse Order (Max-Heap)
import java.util.*;

public class PriorityQueueMaxHeap {
    public static void main(String[] args) {
        // Max-Heap using Comparator
        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());

        pq.offer(40);
        pq.offer(10);
        pq.offer(30);
        pq.offer(20);

        System.out.println("PriorityQueue (Max-Heap): " + pq);
        System.out.println("Peek (largest): " + pq.peek()); // 40

        while (!pq.isEmpty()) {
            System.out.println("Poll: " + pq.poll());
        }
    }
}

✅ Code Example 3: PriorityQueue with Custom Objects
import java.util.*;

class Task {
    String name;
    int priority; // smaller value = higher priority

    Task(String name, int priority) {
        this.name = name;
        this.priority = priority;
    }

    @Override
    public String toString() {
        return name + " (priority " + priority + ")";
    }
}

public class PriorityQueueCustom {
    public static void main(String[] args) {
        PriorityQueue<Task> taskQueue = new PriorityQueue<>(
            Comparator.comparingInt(t -> t.priority) // custom comparator
        );

        taskQueue.add(new Task("Write report", 3));
        taskQueue.add(new Task("Fix bug", 1));
        taskQueue.add(new Task("Email client", 2));

        System.out.println("Task Queue: " + taskQueue);

        while (!taskQueue.isEmpty()) {
            System.out.println("Processing: " + taskQueue.poll());
        }
    }
}

✅ Insights
👉 PriorityQueue is not thread-safe → use PriorityBlockingQueue for concurrent cases.
👉 Backed by a binary heap, not a balanced tree.
👉 The iterator of PriorityQueue does not guarantee sorted order → only the head follows priority.
👉 If ordering is important when iterating, use poll() repeatedly or move to a TreeSet/TreeMap.

🔷Deque
Double Ended Queue
Located in java.util package.
Allows insertion and deletion of elements from both ends.
versatile than regular queues and stacks because they support all the operations of both 

Insertion Methods
➤ addFirst(E e): Inesrts the specified element in the front
➤ addLast (E e): Inserts the specified element at the end
➤ offerFirst(E e): Inserts the specified element in the front
➤ offerLast(E e): Inserts the specified element at the end

Removal Methods
removeFirst(): Removes and returns the first element
removeLast(): Removes and returns the last element
➤ They will give exception if the queue is empty

pollFirst(): Removes and returns the first element
pollLast(): Removes and returns the last element

Examination Methods:
getFirst(): Retrieves, but does not remove, the first element
getLast(): Retrieves, but does not remove, the last element

Peeking Methods:
peekFirst(): Retrieves, but does not remove, the first element
peekLast(): Retrieves, but does not remove, the last element