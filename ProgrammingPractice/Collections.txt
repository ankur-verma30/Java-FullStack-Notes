1ï¸âƒ£Write a program to store 10 integers in an ArrayList, remove all even numbers, and print the final list.

ğŸ‘‰ Input: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
ğŸ‘‰ Output: [1, 3, 5, 7, 9]
âœ… Solution:1. Use an Iterator
package collections;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class Program1 {
    public static void main(String[] args) {
        List<Integer> list = new ArrayList<>(List.of(1,2,3,4,5,6,7,8,9,10));

        Iterator<Integer> it = list.iterator();
        while (it.hasNext()) {
            if (it.next() % 2 == 0) {
                it.remove(); // safe removal
            }
        }

        for (int num : list) {
            System.out.println(num);
        }
    }
}

âœ… Solution 2. Use removeIf (Clean & Modern)
package collections;

import java.util.ArrayList;
import java.util.List;

public class Program1 {
    public static void main(String[] args) {
        List<Integer> list = new ArrayList<>(List.of(1,2,3,4,5,6,7,8,9,10));

        list.removeIf(x -> x % 2 == 0);

        list.forEach(System.out::println);
    }
}

2ï¸âƒ£Write a program to accept a list of names (with duplicates), store them in a HashSet, and print only the unique names in sorted order.

ğŸ‘‰ Input: ["John", "Alice", "Bob", "John", "Alice"]
ğŸ‘‰ Output: ["Alice", "Bob", "John"]
âœ… Solution:
package collections;

import java.util.List;
import java.util.Set;
import java.util.TreeSet;

public class Program2 {
    public static void main(String[] args) {
        List<String> names = List.of("Alice","John","Bob","John","Alice");

        Set<String> uniqueNames = new TreeSet<>(names);

        System.out.println(uniqueNames);
    }
}

3ï¸âƒ£ Given a sentence, count the frequency of each word using a HashMap and print the word with the highest frequency.
ğŸ‘‰ Input: "this is a very big sentence and this sentence is for counting words in a hashmap"
ğŸ‘‰ Output: this: 2

package collections;

import java.util.HashMap;
import java.util.Map;

public class Program1 {

    public static void main(String[] args) {
        String sentence = "this is a very big sentence and this sentence is "
                + "for counting words in a hashmap";

        // Map to store frequency of each word
        Map<String, Integer> freq = new HashMap<>();

        // Split sentence into words
        String[] words = sentence.toLowerCase().split("\\W+");

        // Count frequencies
        for (String word : words) {
            freq.put(word, freq.getOrDefault(word, 0) + 1);
        }

        // Find maximum frequency
        int maxFreq = 0;
        for (int value : freq.values()) {
            if (value > maxFreq) {
                maxFreq = value;
            }
        }

        // Print all words with maximum frequency
        System.out.println("Most frequent word(s):");
        for (Map.Entry<String, Integer> entry : freq.entrySet()) {
            if (entry.getValue() == maxFreq) {
                System.out.println(entry.getKey() + " : " + entry.getValue());
            }
        }
    }
}
âœ…Output:
Most frequent word(s):
this : 2
is : 2
sentence : 2


4ï¸âƒ£ Given a list of integers, sort them in descending order using Collections.sort() or Comparator.
âœ… Solution 1: 
list.sort((Integer a, Integer b) -> b - a);

â¤ Uses lambda expression.
â¤ Works fine for small integers.
âš ï¸ Risk: For very large integers, b - a can cause integer overflow.
Safer version is: list.sort((a, b) -> Integer.compare(b, a));

âœ… Solution 2: 
Collections.sort(list, Comparator.reverseOrder());

â¤ Clean and recommended.
â¤ Uses built-in comparator â†’ no overflow issues.
â¤ Works with any type that implements Comparable (not just Integer).


5ï¸âƒ£ Write a program to find the intersection of two sets of integers.
Example: {1,2,3,4} and {3,4,5,6} â†’ Output: {3,4}

âœ… Solution 1 â€“ Using retainAll() (Best for Sets)
Set<Integer> list1 = new HashSet<>(Arrays.asList(1, 2, 3, 4));
Set<Integer> list2 = new HashSet<>(Arrays.asList(3, 4, 5, 6));

list1.retainAll(list2); // modifies list1 to keep only common elements

â¤ Very concise.
â¤ Directly gives the intersection.
âš¡ But note â†’ list1 gets modified.

âœ… Solution 2 â€“ Keep Original Sets Intact
Set<Integer> list1 = new HashSet<>(Arrays.asList(1, 2, 3, 4));
Set<Integer> list2 = new HashSet<>(Arrays.asList(3, 4, 5, 6));

Set<Integer> ans = new HashSet<>(list1);
ans.retainAll(list2);

Keeps the original sets safe.
Recommended in practice.

6ï¸âƒ£ Given a string, count the frequency of each character (ignore spaces) using a HashMap and print the result.

âœ… Solution:
HashMap<Character, Integer> freq = new HashMap<>();

for (int i = 0; i < str.length(); i++) {
    freq.put(str.charAt(i), freq.getOrDefault(str.charAt(i), 0) + 1);
}


7ï¸âƒ£ Given a list of strings, reverse the order using Collections.reverse()
Example: ["A", "B", "C"] â†’ ["C", "B", "A"]

âœ… Solution: Collections.reverse(str);

8ï¸âƒ£ Given two sets of words, find the union (all unique words from both sets).

âœ… Solution 1: set1.addAll(set2); //modify set1

âœ… Solution 2:
Set<String> union = new HashSet<>(set1);
union.addAll(set2);


9ï¸âƒ£Given a map of country â†’ population, sort the map by keys (alphabetical order of countries) and print it.

âœ… Solution 1: Map<String, Integer> isSorted = new TreeMap<>();â¤ 
â¤ TreeMap maintains natural sorted order of keys (alphabetical for Strings, ascending for numbers).

âœ… Solution 2: Alternative (If we had a HashMap and needed to sort manually)
Map<String, Integer> sortedMap = new TreeMap<>(map);


