1Ô∏è‚É£Write a program to store 10 integers in an ArrayList, remove all even numbers, and print the final list.

üëâ Input: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
üëâ Output: [1, 3, 5, 7, 9]
‚úÖ Solution:1. Use an Iterator
package collections;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class Program1 {
    public static void main(String[] args) {
        List<Integer> list = new ArrayList<>(List.of(1,2,3,4,5,6,7,8,9,10));

        Iterator<Integer> it = list.iterator();
        while (it.hasNext()) {
            if (it.next() % 2 == 0) {
                it.remove(); // safe removal
            }
        }

        for (int num : list) {
            System.out.println(num);
        }
    }
}

‚úÖ Solution 2. Use removeIf (Clean & Modern)
package collections;

import java.util.ArrayList;
import java.util.List;

public class Program1 {
    public static void main(String[] args) {
        List<Integer> list = new ArrayList<>(List.of(1,2,3,4,5,6,7,8,9,10));

        list.removeIf(x -> x % 2 == 0);

        list.forEach(System.out::println);
    }
}

2Ô∏è‚É£Write a program to accept a list of names (with duplicates), store them in a HashSet, and print only the unique names in sorted order.

üëâ Input: ["John", "Alice", "Bob", "John", "Alice"]
üëâ Output: ["Alice", "Bob", "John"]
‚úÖ Solution:
package collections;

import java.util.List;
import java.util.Set;
import java.util.TreeSet;

public class Program2 {
    public static void main(String[] args) {
        List<String> names = List.of("Alice","John","Bob","John","Alice");

        Set<String> uniqueNames = new TreeSet<>(names);

        System.out.println(uniqueNames);
    }
}

3Ô∏è‚É£ Given a sentence, count the frequency of each word using a HashMap and print the word with the highest frequency.
üëâ Input: "this is a very big sentence and this sentence is for counting words in a hashmap"
üëâ Output: this: 2

package collections;

import java.util.HashMap;
import java.util.Map;

public class Program1 {

    public static void main(String[] args) {
        String sentence = "this is a very big sentence and this sentence is "
                + "for counting words in a hashmap";

        // Map to store frequency of each word
        Map<String, Integer> freq = new HashMap<>();

        // Split sentence into words
        String[] words = sentence.toLowerCase().split("\\W+");

        // Count frequencies
        for (String word : words) {
            freq.put(word, freq.getOrDefault(word, 0) + 1);
        }

        // Find maximum frequency
        int maxFreq = 0;
        for (int value : freq.values()) {
            if (value > maxFreq) {
                maxFreq = value;
            }
        }

        // Print all words with maximum frequency
        System.out.println("Most frequent word(s):");
        for (Map.Entry<String, Integer> entry : freq.entrySet()) {
            if (entry.getValue() == maxFreq) {
                System.out.println(entry.getKey() + " : " + entry.getValue());
            }
        }
    }
}
‚úÖOutput:
Most frequent word(s):
this : 2
is : 2
sentence : 2


4Ô∏è‚É£ Given a list of integers, sort them in descending order using Collections.sort() or Comparator.
‚úÖ Solution 1: 
list.sort((Integer a, Integer b) -> b - a);

‚û§ Uses lambda expression.
‚û§ Works fine for small integers.
‚ö†Ô∏è Risk: For very large integers, b - a can cause integer overflow.
Safer version is: list.sort((a, b) -> Integer.compare(b, a));

‚úÖ Solution 2: 
Collections.sort(list, Comparator.reverseOrder());

‚û§ Clean and recommended.
‚û§ Uses built-in comparator ‚Üí no overflow issues.
‚û§ Works with any type that implements Comparable (not just Integer).


5Ô∏è‚É£ Write a program to find the intersection of two sets of integers.
Example: {1,2,3,4} and {3,4,5,6} ‚Üí Output: {3,4}

‚úÖ Solution 1 ‚Äì Using retainAll() (Best for Sets)
Set<Integer> list1 = new HashSet<>(Arrays.asList(1, 2, 3, 4));
Set<Integer> list2 = new HashSet<>(Arrays.asList(3, 4, 5, 6));

list1.retainAll(list2); // modifies list1 to keep only common elements

‚û§ Very concise.
‚û§ Directly gives the intersection.
‚ö° But note ‚Üí list1 gets modified.

‚úÖ Solution 2 ‚Äì Keep Original Sets Intact
Set<Integer> list1 = new HashSet<>(Arrays.asList(1, 2, 3, 4));
Set<Integer> list2 = new HashSet<>(Arrays.asList(3, 4, 5, 6));

Set<Integer> ans = new HashSet<>(list1);
ans.retainAll(list2);

Keeps the original sets safe.
Recommended in practice.

6Ô∏è‚É£ Given a string, count the frequency of each character (ignore spaces) using a HashMap and print the result.

‚úÖ Solution:
HashMap<Character, Integer> freq = new HashMap<>();

for (int i = 0; i < str.length(); i++) {
    freq.put(str.charAt(i), freq.getOrDefault(str.charAt(i), 0) + 1);
}


7Ô∏è‚É£ Given a list of strings, reverse the order using Collections.reverse()
Example: ["A", "B", "C"] ‚Üí ["C", "B", "A"]

‚úÖ Solution: Collections.reverse(str);

8Ô∏è‚É£ Given two sets of words, find the union (all unique words from both sets).

‚úÖ Solution 1: set1.addAll(set2); //modify set1

‚úÖ Solution 2:
Set<String> union = new HashSet<>(set1);
union.addAll(set2);


9Ô∏è‚É£Given a map of country ‚Üí population, sort the map by keys (alphabetical order of countries) and print it.

‚úÖ Solution 1: Map<String, Integer> isSorted = new TreeMap<>();‚û§ 
‚û§ TreeMap maintains natural sorted order of keys (alphabetical for Strings, ascending for numbers).

‚úÖ Solution 2: Alternative (If we had a HashMap and needed to sort manually)
Map<String, Integer> sortedMap = new TreeMap<>(map);

1Ô∏è‚É£0Ô∏è‚É£Given a map of student ‚Üí marks, find the student with the highest marks.
Example: {Alice=87, Bob=92, Charlie=78} ‚Üí Output: Bob=92.

‚úÖ Solution:
package collections;

import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

public class Program1 {

	public static void main(String[] args) {
		Map<String,Integer>marks=new HashMap<>();
		marks.put("Alice", 87);
		marks.put("Bob", 92);
		marks.put("Charlie", 78);
		
		int maxMarks=0;
		String topStudent="";
		
		for(Entry<String,Integer>entry:marks.entrySet()) {
			if(entry.getValue()>maxMarks) {
				maxMarks=entry.getValue();
				topStudent=entry.getKey();
			}
		}
		System.out.println(topStudent+"="+ maxMarks);
	}
}  

1Ô∏è‚É£1Ô∏è‚É£Given a list of integers with duplicates, remove duplicates while preserving insertion order.
Example: [1, 2, 2, 3, 1, 4] ‚Üí [1, 2, 3, 4].

‚úÖ Solution:
package collections;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

public class Program1 {

	public static void main(String[] args) {
		List<Integer>newList=new ArrayList<>(Arrays.asList(1,2,2,3,4,1,3,4));
		Set<Integer>outputList=new LinkedHashSet<>(newList);
		
		System.out.println(outputList);
	}
}

‚û§ Sometimes we need to ‚Äúreturn a list instead of a set:
List<Integer> outputList = new ArrayList<>(new LinkedHashSet<>(newList));


1Ô∏è‚É£2Ô∏è‚É£Create a list of employees (id, name, salary) and sort them:
‚û§ First by salary (descending)
‚û§ If salaries are equal, then by name (ascending).

‚úÖ Solution:
package collections;

import java.util.*;

class Employee {
    private int id;
    private String name;
    private double salary;

    public Employee(int id, String name, double salary) {
        this.id = id;
        this.name = name;
        this.salary = salary;
    }

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public double getSalary() {
        return salary;
    }

    @Override
    public String toString() {
        return "Employee { " +
                "id = " + id +
                ", name = '" + name + '\'' +
                ", salary = " + salary +
                " }";
    }
}

class CustomComparator implements Comparator<Employee> {
    @Override
    public int compare(Employee o1, Employee o2) {
        // First compare by salary (descending)
        int salaryCompare = Double.compare(o2.getSalary(), o1.getSalary());
        if (salaryCompare != 0) {
            return salaryCompare;
        }
        // If salaries are equal, compare by name (ascending)
        return o1.getName().compareTo(o2.getName());
    }
}

public class Program3 {
    public static void main(String[] args) {
        List<Employee> employees = new ArrayList<>();
        employees.add(new Employee(1, "Alice", 50000));
        employees.add(new Employee(2, "Bob", 70000));
        employees.add(new Employee(3, "Charlie", 70000));
        employees.add(new Employee(4, "David", 45000));

        System.out.println("Before Sorting:");
        employees.forEach(System.out::println);

        employees.sort(new CustomComparator());

        System.out.println("\nAfter Sorting:");
        employees.forEach(System.out::println);
    }
}

‚úÖ Cleaner with Lambda (Recommended)
employees.sort(
    Comparator.comparingDouble(Employee::getSalary).reversed()
              .thenComparing(Employee::getName)
);
‚û§ First sorts by salary (descending)
‚û§ Then by name (ascending) if salaries are equal
‚û§ Much shorter and idiomatic

1Ô∏è‚É£3Ô∏è‚É£Given a Map<String, Integer> containing items and their quantities, write a program to merge the map with another map of the same type (same keys possible). If a key exists in both maps, the values should be added. Print the final merged map.

‚úÖ Solution:
package collections;

import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;

public class Program1{
	public static void main(String[] args) {
		Map<String, Integer> map1 = new HashMap<>();
		map1.put("Apples", 10);
		map1.put("Bananas", 5);
		map1.put("Oranges", 7);

		Map<String, Integer> map2 = new HashMap<>();
		map2.put("Bananas", 3);
		map2.put("Oranges", 8);
		map2.put("Mangoes", 6);
		
		for(Entry<String, Integer> entry:map1.entrySet()) {
			String key=entry.getKey();
			int value=entry.getValue();
			if(map2.containsKey(key)) {
				int oldValue=map2.get(key);
				map2.put(key, value+oldValue);
			}
			else {
				map2.put(key, value);
			}
		}
		
		map2.entrySet()
		.stream()
		.forEach(x-> System.out.println
				(x.getKey()+" "+ x.getValue()));

	}
}

‚úÖ Soluton 2: Cleaner Version using merge method
package collections;

import java.util.HashMap;
import java.util.Map;

public class Program1 {
    public static void main(String[] args) {
        Map<String, Integer> map1 = new HashMap<>();
        map1.put("Apples", 10);
        map1.put("Bananas", 5);
        map1.put("Oranges", 7);

        Map<String, Integer> map2 = new HashMap<>();
        map2.put("Bananas", 3);
        map2.put("Oranges", 8);
        map2.put("Mangoes", 6);

        for (Map.Entry<String, Integer> entry : map1.entrySet()) {
            map2.merge(entry.getKey(), entry.getValue(), Integer::sum);
        }

        map2.forEach((k, v) -> System.out.println(k + " " + v));
    }
}

1Ô∏è‚É£4Ô∏è‚É£Given a List<Integer>, write a program to find the 3rd largest element using Collections utilities (not sorting manually with loops).

‚úÖ Solution:
package collections;

import java.util.*;

public class Program1 {
    public static void main(String[] args) {
        PriorityQueue<Integer> pq = new PriorityQueue<>(); // min-heap

        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);

        for (int num : numbers) {
            pq.add(num);
            if (pq.size() > 3) {
                pq.poll(); // remove smallest
            }
        }
        System.out.println("3rd largest element = " + pq.peek());
    }
}


1Ô∏è‚É£5Ô∏è‚É£Given a sentence string:
"Java is great and Java is powerful"
Write a program to count the frequency of each word and print it in a TreeMap (so that the words appear in sorted order).

‚úÖ Solution: Without using extra array to store individual strings
package collections;

import java.util.Map;
import java.util.TreeMap;

public class Program1{
	public static void main(String[] args) {
	String str="Java is great and Java is powerful";
	Map<String,Integer>map=new TreeMap<>();
	
	int index=-1,prevIndex=0;
	for(int i=0;i<str.length();i++) {
		if(str.charAt(i)==' ') {
			prevIndex=index+1;
			index=i;
			String word=str.substring(prevIndex, index);
			map.put(word,map.getOrDefault(word, 0)+1);
		}
		
		
	}
	String lastWord=str.substring(index+1,str.length());
	map.put(lastWord, map.getOrDefault(lastWord, 0)+1);
	
	System.out.println(map);
	}	
}

‚úÖ Solution 2: With the help of String array to store the individual strings

package collections;

import java.util.*;

public class Program1 {
    public static void main(String[] args) {
        String str = "Java is great and Java is powerful";
        Map<String, Integer> map = new TreeMap<>();

        String[] words = str.split(" ");
        for (String word : words) {
            map.put(word, map.getOrDefault(word, 0) + 1);
        }

        System.out.println(map);
    }
}


1Ô∏è‚É£6Ô∏è‚É£Given a List<Integer>, find the element that occurs the most number of times. If there are multiple, return the smallest one.

‚úÖ Solution: package collections;

import java.util.*;

class Pair {
    int freq;
    int num;

    Pair(int freq, int num) {
        this.freq = freq;
        this.num = num;
    }
}

public class Program1 {
    public static void main(String[] args) {
        List<Integer> list1 = Arrays.asList(1,2,3,1,1,2,3,4,2,3,4,4,5,3);

        Map<Integer, Integer> mp = new HashMap<>();
        for (int num : list1) {
            mp.put(num, mp.getOrDefault(num, 0) + 1);
        }

        PriorityQueue<Pair> pq = new PriorityQueue<>((o1, o2) -> {
            if (o1.freq == o2.freq) return o1.num - o2.num; // smaller number if tie
            return o2.freq - o1.freq; // higher frequency first
        });

        for (Map.Entry<Integer, Integer> entry : mp.entrySet()) {
            pq.add(new Pair(entry.getValue(), entry.getKey()));
        }

        System.out.println("Most frequent element: " + pq.peek().num);
    }
}


1Ô∏è‚É£7Ô∏è‚É£Given a List<String> such as:
["eat", "tea", "tan", "ate", "nat", "bat"]
Group the words that are anagrams of each other and print them as List<List<String>>.

‚úÖ Solution:
package collections;

import java.util.*;
import java.util.Map.Entry;

public class Program1 {
	public static void main(String[] args) {
		List<String> list = new ArrayList<>(Arrays.asList("eat", "tea", "tan", "ate", "nat", "bat"));
		Map<String, List<String>> map = new HashMap<>();

		for (String l : list) {
			char[] ch = l.toCharArray();
			Arrays.sort(ch);
			String newStr = new String(ch);
			if (!map.containsKey(newStr)) {
				List<String> val = new ArrayList<>(Arrays.asList(l));
				map.put(newStr, val);
			} else {
				map.get(newStr).add(l);
			}
		}

		List<List<String>> ans = new ArrayList<>();

		for (Entry<String, List<String>> entry : map.entrySet()) {
			List<String> temp = entry.getValue();
			if (!temp.isEmpty()) {
				ans.add(temp);
			}
		}

		System.out.println(ans);
	}
}

‚úÖ Solution 2:
package collections;

import java.util.*;

public class Program1 {
    public static void main(String[] args) {
        List<String> list = Arrays.asList("eat", "tea", "tan", "ate", "nat", "bat");
        Map<String, List<String>> map = new HashMap<>();

        // Group words by their sorted character representation
        for (String word : list) {
            char[] ch = word.toCharArray();
            Arrays.sort(ch); // sort characters
            String key = new String(ch); // correct way (instead of ch.toString())

            map.computeIfAbsent(key, k -> new ArrayList<>()).add(word);
        }

        // Collect grouped anagrams into result
        List<List<String>> ans = new ArrayList<>(map.values());

        System.out.println(ans);
    }
}


1Ô∏è‚É£8Ô∏è‚É£Design a simple LRU Cache with a fixed capacity using LinkedHashMap. It should support:
get(key) ‚Üí returns value if exists, else -1.
put(key, value) ‚Üí inserts or updates the key. If capacity is full, remove the least recently used entry.

‚úÖ Solution:
package collections;

import java.util.*;

class LRUCache<K, V> extends LinkedHashMap<K, V> {
    private final int capacity;

    public LRUCache(int capacity) {
        // true = access-order (not insertion order)
        super(capacity, 0.75f, true);
        this.capacity = capacity;
    }

    @Override
    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
        return size() > capacity;
    }
}

public class Program3 {
    public static void main(String[] args) {
        LRUCache<Integer, String> cache = new LRUCache<>(3);

        cache.put(1, "A");
        cache.put(2, "B");
        cache.put(3, "C");
        System.out.println(cache); // {1=A, 2=B, 3=C}

        cache.get(1);              // Access 1 -> makes it most recently used
        cache.put(4, "D");         // Removes 2 (least recently used)
        System.out.println(cache); // {3=C, 1=A, 4=D}

        cache.put(5, "E");         // Removes 3
        System.out.println(cache); // {1=A, 4=D, 5=E}
    }
}


1Ô∏è‚É£9Ô∏è‚É£ Given an array of integers, find the 2 most frequent elements using a HashMap and a heap/priority queue.
‚úÖ Example:
Input: [1,1,1,2,2,3]
Output: [1,2]

package collections;

import java.util.*;

class Pair {
    int freq;
    int num;

    public Pair(int freq, int num) {
        this.freq = freq;
        this.num = num;
    }
}

public class Program1 {
    public static void main(String[] args) {
        List<Integer> list1 = Arrays.asList(1, 1, 1, 2, 2, 3);

        // Count frequencies
        Map<Integer, Integer> freqMap = new HashMap<>();
        for (int num : list1) {
            freqMap.put(num, freqMap.getOrDefault(num, 0) + 1);
        }

        // Max-Heap based on frequency
        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> b.freq - a.freq);

        for (Map.Entry<Integer, Integer> entry : freqMap.entrySet()) {
            pq.add(new Pair(entry.getValue(), entry.getKey()));
        }

        // Get most frequent
        if (!pq.isEmpty()) {
            System.out.println("Most frequent element: " + pq.peek().num);
            pq.poll();
        }

        // Get second most frequent
        if (!pq.isEmpty()) {
            System.out.println("Second most frequent element: " + pq.peek().num);
        }
    }
}


2Ô∏è‚É£0Ô∏è‚É£ Given a list of Employee(id, name, age, salary) objects, sort them by:
salary descending,
if salary is same ‚Üí age ascending,
if age also same ‚Üí name alphabetical.
Print the sorted list.

‚úÖ Solution:
package collections;

import java.util.*;

class Employee{
	int id;
	String name;
	int age;
	int  salary;
	
	public Employee(int id, String name, int age, int  salary) {
		super();
		this.id = id;
		this.name = name;
		this.age = age;
		this.salary = salary;
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}

	public int getSalary() {
		return salary;
	}

	public void setSalary(int salary) {
		this.salary = salary;
	}

	@Override
	public String toString() {
		return "Id "+this.getId()+" "+"Name:"+
	this.getName()+" "+"Age is: "+this.getAge()+" "+
				" Salary is: "+this.getSalary();
	}
	
	
}
public class Program1 {
    public static void main(String[] args) {
    	List<Employee> employees = Arrays.asList(
    		    new Employee(101, "Alice", 28, 70000),
    		    new Employee(102, "Bob", 32, 85000),
    		    new Employee(103, "Charlie", 26, 70000),
    		    new Employee(104, "David", 35, 90000),
    		    new Employee(105, "Eve", 30, 85000),
    		    new Employee(106, "Frank", 29, 60000),
    		    new Employee(107, "Grace", 40, 90000)
    		);
    	employees.sort((e1,e2)->{
    		if(e1.getSalary()==e2.getSalary()) {
    			if(e1.getAge()==e2.getAge()) {
    				return e1.getName().compareTo(e2.getName());
    			}
    			return e1.getAge()-e2.getAge();
    		}
    		return e2.getSalary()-e1.getSalary();
    	});
    	
    	employees.forEach(System.out::println);
    }
}

‚ö° Minor Improvement:
‚úîÔ∏è Use Comparator chaining with Java 8+, which makes it cleaner:

employees.sort(
    Comparator.comparingInt(Employee::getSalary).reversed()
              .thenComparingInt(Employee::getAge)
              .thenComparing(Employee::getName)
);
‚úîÔ∏è This does exactly what your if-else chain is doing, but looks cleaner and is easier to extend


2Ô∏è‚É£1Ô∏è‚É£ Given a list of integers and a target K, find if there exists a subarray whose sum equals K.
Example:

Input: [1, 2, 3, 7, 5], K=12
Output: true   (because 2+3+7 = 12)

‚úÖ Solution:
package collections;

import java.util.*;

public class Program1 {
    public static void main(String[] args) {
        List<Integer> list = Arrays.asList(1, 2, 3, 7, 5);
        int k = 12;

        Set<Integer> prefixSums = new HashSet<>();
        int sum = 0;
        boolean isFound = false;

        for (int num : list) {
            sum += num;

            // Case 1: subarray starts from index 0
            if (sum == k) {
                isFound = true;
                break;
            }

            // Case 2: subarray found in between
            if (prefixSums.contains(sum - k)) {
                isFound = true;
                break;
            }

            // add prefix sum after check
            prefixSums.add(sum);
        }

        if (isFound) {
            System.out.println("Subarray Found");
        } else {
            System.out.println("Not Found");
        }
    }
}

2Ô∏è‚É£2Ô∏è‚É£ You are given a list of strings containing student names.
üëâ Group the students by the first letter of their name using a Map<Character, List<String>>.
‚úÖ Example:
Input: ["Alice", "Ankur", "Bob", "Charlie", "Cathy"]
Output:
A -> [Alice, Ankur]  
B -> [Bob]  
C -> [Charlie, Cathy]

‚úÖ Solution:
	List<String> list = Arrays.asList("Alice", "Ankur", "Bob", "Charlie", "Cathy");

		Map<Character, List<String>> map = new HashMap<>();

		for (String str : list) {
			char c = str.charAt(0);
			if (map.containsKey(c)) {
				List<String> val = map.get(c);
				val.add(str);
				map.put(c, val);
			} else {
				map.put(c, new ArrayList<>(Arrays.asList(str)));
			}

		}

		for (Entry<Character, List<String>> entry : map.entrySet()) {
			char key = entry.getKey();
			List<String> value = entry.getValue();
			System.out.print("Key is: " + key+" Name is: ");
			for (String v : value) {
				System.out.print(v + " ");
			}
			System.out.println();
		}

‚úÖ Solution 2: Minor Improvement
for (String str : list) {
    char c = str.charAt(0);
    map.computeIfAbsent(c, k -> new ArrayList<>()).add(str);
}


2Ô∏è‚É£3Ô∏è‚É£ You are given a list of integers.
üëâ Find the longest consecutive subsequence (numbers appearing consecutively without gaps).
‚úÖ Example:
Input: [100, 4, 200, 1, 3, 2]
Output: Longest consecutive subsequence length = 4 (because 1, 2, 3, 4 is longest)

‚úÖ Solution:
class Solution {
    public int longestConsecutive(int[] nums) {
         Set<Integer> set = new HashSet<>();
        for (int num : nums) {
            set.add(num);
        }

        int longest = 0;

        for (int num : nums) {
            if (!set.contains(num - 1)) {
                int curr = num;
                int count = 1;
                while (set.contains(curr + 1)) {
                    curr++;
                    count++;
                }
                longest = Math.max(longest, count);
            }
        }

        return longest;
    }
}


2Ô∏è‚É£4Ô∏è‚É£ Design a simple Leaderboard System using TreeMap<Integer, List<String>>, where the key is score and value is the list of player names with that score.
‚û§ Insert some sample players with scores.
‚û§ Print the leaderboard in descending order of scores.
‚úÖ Example:
100 -> [Alice]  
90  -> [Bob, Charlie]  
80  -> [David]

‚úÖ Solution:
	TreeMap<Integer, List<String>> leaderboard = new TreeMap<>(Collections.reverseOrder());

		leaderboard.put(100, new ArrayList<>(Arrays.asList("Alice")));
		leaderboard.put(95, new ArrayList<>(Arrays.asList("Eve")));
		leaderboard.put(90, new ArrayList<>(Arrays.asList("Bob", "Charlie")));
		leaderboard.put(85, new ArrayList<>(Arrays.asList("Frank", "Grace")));
		leaderboard.put(80, new ArrayList<>(Arrays.asList("David")));
		leaderboard.put(75, new ArrayList<>(Arrays.asList("Hannah", "Ian")));
		leaderboard.put(70, new ArrayList<>(Arrays.asList("Jack")));
		
		for(Entry<Integer,List<String>>entry:leaderboard.entrySet()) {
			System.out.print("Score is "+entry.getKey());
			System.out.println(" Players are "+entry.getValue());
			
		}


2Ô∏è‚É£5Ô∏è‚É£ Top K Frequent Words
You are given a list of words.
üëâ Find the top K most frequent words using a HashMap (for frequency) and a PriorityQueue (for ordering).
If two words have the same frequency, sort them lexicographically.

‚úÖ Example:
Input: ["i", "love", "leetcode", "i", "love", "coding"], K = 2
Output: ["i", "love"]

2Ô∏è‚É£6Ô∏è‚É£ Sort Employees by Multiple Criteria
You are given a list of Employee objects with fields: id, name, age, salary.
üëâ Sort them in the following order:
Highest salary first
If salary is same ‚Üí youngest age first
If both same ‚Üí name alphabetically

2Ô∏è‚É£7Ô∏è‚É£ Find Duplicate Subarrays of Length K
You are given an array of integers and a value K.
üëâ Find all subarrays of length K that occur more than once.
Use a HashMap<String, Integer> to store subarray frequency (convert subarray to string as a key).

‚úÖ Example:
Input: arr = [1,2,3,1,2,3,4], K = 3
Output: [[1,2,3]]