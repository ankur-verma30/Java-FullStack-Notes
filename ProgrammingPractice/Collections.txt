1Ô∏è‚É£Write a program to store 10 integers in an ArrayList, remove all even numbers, and print the final list.

üëâ Input: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
üëâ Output: [1, 3, 5, 7, 9]
‚úÖ Solution:1. Use an Iterator
package collections;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class Program1 {
    public static void main(String[] args) {
        List<Integer> list = new ArrayList<>(List.of(1,2,3,4,5,6,7,8,9,10));

        Iterator<Integer> it = list.iterator();
        while (it.hasNext()) {
            if (it.next() % 2 == 0) {
                it.remove(); // safe removal
            }
        }

        for (int num : list) {
            System.out.println(num);
        }
    }
}

‚úÖ Solution 2. Use removeIf (Clean & Modern)
package collections;

import java.util.ArrayList;
import java.util.List;

public class Program1 {
    public static void main(String[] args) {
        List<Integer> list = new ArrayList<>(List.of(1,2,3,4,5,6,7,8,9,10));

        list.removeIf(x -> x % 2 == 0);

        list.forEach(System.out::println);
    }
}

2Ô∏è‚É£Write a program to accept a list of names (with duplicates), store them in a HashSet, and print only the unique names in sorted order.

üëâ Input: ["John", "Alice", "Bob", "John", "Alice"]
üëâ Output: ["Alice", "Bob", "John"]
‚úÖ Solution:
package collections;

import java.util.List;
import java.util.Set;
import java.util.TreeSet;

public class Program2 {
    public static void main(String[] args) {
        List<String> names = List.of("Alice","John","Bob","John","Alice");

        Set<String> uniqueNames = new TreeSet<>(names);

        System.out.println(uniqueNames);
    }
}

3Ô∏è‚É£ Given a sentence, count the frequency of each word using a HashMap and print the word with the highest frequency.
üëâ Input: "this is a very big sentence and this sentence is for counting words in a hashmap"
üëâ Output: this: 2

package collections;

import java.util.HashMap;
import java.util.Map;

public class Program1 {

    public static void main(String[] args) {
        String sentence = "this is a very big sentence and this sentence is "
                + "for counting words in a hashmap";

        // Map to store frequency of each word
        Map<String, Integer> freq = new HashMap<>();

        // Split sentence into words
        String[] words = sentence.toLowerCase().split("\\W+");

        // Count frequencies
        for (String word : words) {
            freq.put(word, freq.getOrDefault(word, 0) + 1);
        }

        // Find maximum frequency
        int maxFreq = 0;
        for (int value : freq.values()) {
            if (value > maxFreq) {
                maxFreq = value;
            }
        }

        // Print all words with maximum frequency
        System.out.println("Most frequent word(s):");
        for (Map.Entry<String, Integer> entry : freq.entrySet()) {
            if (entry.getValue() == maxFreq) {
                System.out.println(entry.getKey() + " : " + entry.getValue());
            }
        }
    }
}
‚úÖOutput:
Most frequent word(s):
this : 2
is : 2
sentence : 2


4Ô∏è‚É£ Given a list of integers, sort them in descending order using Collections.sort() or Comparator.
‚úÖ Solution 1: 
list.sort((Integer a, Integer b) -> b - a);

‚û§ Uses lambda expression.
‚û§ Works fine for small integers.
‚ö†Ô∏è Risk: For very large integers, b - a can cause integer overflow.
Safer version is: list.sort((a, b) -> Integer.compare(b, a));

‚úÖ Solution 2: 
Collections.sort(list, Comparator.reverseOrder());

‚û§ Clean and recommended.
‚û§ Uses built-in comparator ‚Üí no overflow issues.
‚û§ Works with any type that implements Comparable (not just Integer).


5Ô∏è‚É£ Write a program to find the intersection of two sets of integers.
Example: {1,2,3,4} and {3,4,5,6} ‚Üí Output: {3,4}

‚úÖ Solution 1 ‚Äì Using retainAll() (Best for Sets)
Set<Integer> list1 = new HashSet<>(Arrays.asList(1, 2, 3, 4));
Set<Integer> list2 = new HashSet<>(Arrays.asList(3, 4, 5, 6));

list1.retainAll(list2); // modifies list1 to keep only common elements

‚û§ Very concise.
‚û§ Directly gives the intersection.
‚ö° But note ‚Üí list1 gets modified.

‚úÖ Solution 2 ‚Äì Keep Original Sets Intact
Set<Integer> list1 = new HashSet<>(Arrays.asList(1, 2, 3, 4));
Set<Integer> list2 = new HashSet<>(Arrays.asList(3, 4, 5, 6));

Set<Integer> ans = new HashSet<>(list1);
ans.retainAll(list2);

Keeps the original sets safe.
Recommended in practice.

6Ô∏è‚É£ Given a string, count the frequency of each character (ignore spaces) using a HashMap and print the result.

‚úÖ Solution:
HashMap<Character, Integer> freq = new HashMap<>();

for (int i = 0; i < str.length(); i++) {
    freq.put(str.charAt(i), freq.getOrDefault(str.charAt(i), 0) + 1);
}


7Ô∏è‚É£ Given a list of strings, reverse the order using Collections.reverse()
Example: ["A", "B", "C"] ‚Üí ["C", "B", "A"]

‚úÖ Solution: Collections.reverse(str);

8Ô∏è‚É£ Given two sets of words, find the union (all unique words from both sets).

‚úÖ Solution 1: set1.addAll(set2); //modify set1

‚úÖ Solution 2:
Set<String> union = new HashSet<>(set1);
union.addAll(set2);


9Ô∏è‚É£Given a map of country ‚Üí population, sort the map by keys (alphabetical order of countries) and print it.

‚úÖ Solution 1: Map<String, Integer> isSorted = new TreeMap<>();‚û§ 
‚û§ TreeMap maintains natural sorted order of keys (alphabetical for Strings, ascending for numbers).

‚úÖ Solution 2: Alternative (If we had a HashMap and needed to sort manually)
Map<String, Integer> sortedMap = new TreeMap<>(map);

1Ô∏è‚É£0Ô∏è‚É£Given a map of student ‚Üí marks, find the student with the highest marks.
Example: {Alice=87, Bob=92, Charlie=78} ‚Üí Output: Bob=92.

‚úÖ Solution:
package collections;

import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

public class Program1 {

	public static void main(String[] args) {
		Map<String,Integer>marks=new HashMap<>();
		marks.put("Alice", 87);
		marks.put("Bob", 92);
		marks.put("Charlie", 78);
		
		int maxMarks=0;
		String topStudent="";
		
		for(Entry<String,Integer>entry:marks.entrySet()) {
			if(entry.getValue()>maxMarks) {
				maxMarks=entry.getValue();
				topStudent=entry.getKey();
			}
		}
		System.out.println(topStudent+"="+ maxMarks);
	}
}  

1Ô∏è‚É£1Ô∏è‚É£Given a list of integers with duplicates, remove duplicates while preserving insertion order.
Example: [1, 2, 2, 3, 1, 4] ‚Üí [1, 2, 3, 4].

‚úÖ Solution:
package collections;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

public class Program1 {

	public static void main(String[] args) {
		List<Integer>newList=new ArrayList<>(Arrays.asList(1,2,2,3,4,1,3,4));
		Set<Integer>outputList=new LinkedHashSet<>(newList);
		
		System.out.println(outputList);
	}
}

‚û§ Sometimes we need to ‚Äúreturn a list instead of a set:
List<Integer> outputList = new ArrayList<>(new LinkedHashSet<>(newList));


1Ô∏è‚É£2Ô∏è‚É£Create a list of employees (id, name, salary) and sort them:
‚û§ First by salary (descending)
‚û§ If salaries are equal, then by name (ascending).

‚úÖ Solution:
package collections;

import java.util.*;

class Employee {
    private int id;
    private String name;
    private double salary;

    public Employee(int id, String name, double salary) {
        this.id = id;
        this.name = name;
        this.salary = salary;
    }

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public double getSalary() {
        return salary;
    }

    @Override
    public String toString() {
        return "Employee { " +
                "id = " + id +
                ", name = '" + name + '\'' +
                ", salary = " + salary +
                " }";
    }
}

class CustomComparator implements Comparator<Employee> {
    @Override
    public int compare(Employee o1, Employee o2) {
        // First compare by salary (descending)
        int salaryCompare = Double.compare(o2.getSalary(), o1.getSalary());
        if (salaryCompare != 0) {
            return salaryCompare;
        }
        // If salaries are equal, compare by name (ascending)
        return o1.getName().compareTo(o2.getName());
    }
}

public class Program3 {
    public static void main(String[] args) {
        List<Employee> employees = new ArrayList<>();
        employees.add(new Employee(1, "Alice", 50000));
        employees.add(new Employee(2, "Bob", 70000));
        employees.add(new Employee(3, "Charlie", 70000));
        employees.add(new Employee(4, "David", 45000));

        System.out.println("Before Sorting:");
        employees.forEach(System.out::println);

        employees.sort(new CustomComparator());

        System.out.println("\nAfter Sorting:");
        employees.forEach(System.out::println);
    }
}

‚úÖ Cleaner with Lambda (Recommended)
employees.sort(
    Comparator.comparingDouble(Employee::getSalary).reversed()
              .thenComparing(Employee::getName)
);
‚û§ First sorts by salary (descending)
‚û§ Then by name (ascending) if salaries are equal
‚û§ Much shorter and idiomatic

1Ô∏è‚É£3Ô∏è‚É£Given a Map<String, Integer> containing items and their quantities, write a program to merge the map with another map of the same type (same keys possible). If a key exists in both maps, the values should be added. Print the final merged map.

‚úÖ Solution:
package collections;

import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;

public class Program1{
	public static void main(String[] args) {
		Map<String, Integer> map1 = new HashMap<>();
		map1.put("Apples", 10);
		map1.put("Bananas", 5);
		map1.put("Oranges", 7);

		Map<String, Integer> map2 = new HashMap<>();
		map2.put("Bananas", 3);
		map2.put("Oranges", 8);
		map2.put("Mangoes", 6);
		
		for(Entry<String, Integer> entry:map1.entrySet()) {
			String key=entry.getKey();
			int value=entry.getValue();
			if(map2.containsKey(key)) {
				int oldValue=map2.get(key);
				map2.put(key, value+oldValue);
			}
			else {
				map2.put(key, value);
			}
		}
		
		map2.entrySet()
		.stream()
		.forEach(x-> System.out.println
				(x.getKey()+" "+ x.getValue()));

	}
}

‚úÖ Soluton 2: Cleaner Version using merge method
package collections;

import java.util.HashMap;
import java.util.Map;

public class Program1 {
    public static void main(String[] args) {
        Map<String, Integer> map1 = new HashMap<>();
        map1.put("Apples", 10);
        map1.put("Bananas", 5);
        map1.put("Oranges", 7);

        Map<String, Integer> map2 = new HashMap<>();
        map2.put("Bananas", 3);
        map2.put("Oranges", 8);
        map2.put("Mangoes", 6);

        for (Map.Entry<String, Integer> entry : map1.entrySet()) {
            map2.merge(entry.getKey(), entry.getValue(), Integer::sum);
        }

        map2.forEach((k, v) -> System.out.println(k + " " + v));
    }
}

1Ô∏è‚É£4Ô∏è‚É£Given a List<Integer>, write a program to find the 3rd largest element using Collections utilities (not sorting manually with loops).

‚úÖ Solution:
package collections;

import java.util.*;

public class Program1 {
    public static void main(String[] args) {
        PriorityQueue<Integer> pq = new PriorityQueue<>(); // min-heap

        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);

        for (int num : numbers) {
            pq.add(num);
            if (pq.size() > 3) {
                pq.poll(); // remove smallest
            }
        }
        System.out.println("3rd largest element = " + pq.peek());
    }
}


1Ô∏è‚É£5Ô∏è‚É£Given a sentence string:
"Java is great and Java is powerful"
Write a program to count the frequency of each word and print it in a TreeMap (so that the words appear in sorted order).

‚úÖ Solution: Without using extra array to store individual strings
package collections;

import java.util.Map;
import java.util.TreeMap;

public class Program1{
	public static void main(String[] args) {
	String str="Java is great and Java is powerful";
	Map<String,Integer>map=new TreeMap<>();
	
	int index=-1,prevIndex=0;
	for(int i=0;i<str.length();i++) {
		if(str.charAt(i)==' ') {
			prevIndex=index+1;
			index=i;
			String word=str.substring(prevIndex, index);
			map.put(word,map.getOrDefault(word, 0)+1);
		}
		
		
	}
	String lastWord=str.substring(index+1,str.length());
	map.put(lastWord, map.getOrDefault(lastWord, 0)+1);
	
	System.out.println(map);
	}	
}

‚úÖ Solution 2: With the help of String array to store the individual strings

package collections;

import java.util.*;

public class Program1 {
    public static void main(String[] args) {
        String str = "Java is great and Java is powerful";
        Map<String, Integer> map = new TreeMap<>();

        String[] words = str.split(" ");
        for (String word : words) {
            map.put(word, map.getOrDefault(word, 0) + 1);
        }

        System.out.println(map);
    }
}


1Ô∏è‚É£6Ô∏è‚É£Given a List<Integer>, find the element that occurs the most number of times. If there are multiple, return the smallest one.

‚úÖ Solution: package collections;

import java.util.*;

class Pair {
    int freq;
    int num;

    Pair(int freq, int num) {
        this.freq = freq;
        this.num = num;
    }
}

public class Program1 {
    public static void main(String[] args) {
        List<Integer> list1 = Arrays.asList(1,2,3,1,1,2,3,4,2,3,4,4,5,3);

        Map<Integer, Integer> mp = new HashMap<>();
        for (int num : list1) {
            mp.put(num, mp.getOrDefault(num, 0) + 1);
        }

        PriorityQueue<Pair> pq = new PriorityQueue<>((o1, o2) -> {
            if (o1.freq == o2.freq) return o1.num - o2.num; // smaller number if tie
            return o2.freq - o1.freq; // higher frequency first
        });

        for (Map.Entry<Integer, Integer> entry : mp.entrySet()) {
            pq.add(new Pair(entry.getValue(), entry.getKey()));
        }

        System.out.println("Most frequent element: " + pq.peek().num);
    }
}


1Ô∏è‚É£7Ô∏è‚É£Given a List<String> such as:
["eat", "tea", "tan", "ate", "nat", "bat"]
Group the words that are anagrams of each other and print them as List<List<String>>.

‚úÖ Solution:
package collections;

import java.util.*;
import java.util.Map.Entry;

public class Program1 {
	public static void main(String[] args) {
		List<String> list = new ArrayList<>(Arrays.asList("eat", "tea", "tan", "ate", "nat", "bat"));
		Map<String, List<String>> map = new HashMap<>();

		for (String l : list) {
			char[] ch = l.toCharArray();
			Arrays.sort(ch);
			String newStr = new String(ch);
			if (!map.containsKey(newStr)) {
				List<String> val = new ArrayList<>(Arrays.asList(l));
				map.put(newStr, val);
			} else {
				map.get(newStr).add(l);
			}
		}

		List<List<String>> ans = new ArrayList<>();

		for (Entry<String, List<String>> entry : map.entrySet()) {
			List<String> temp = entry.getValue();
			if (!temp.isEmpty()) {
				ans.add(temp);
			}
		}

		System.out.println(ans);
	}
}

‚úÖ Solution 2:
package collections;

import java.util.*;

public class Program1 {
    public static void main(String[] args) {
        List<String> list = Arrays.asList("eat", "tea", "tan", "ate", "nat", "bat");
        Map<String, List<String>> map = new HashMap<>();

        // Group words by their sorted character representation
        for (String word : list) {
            char[] ch = word.toCharArray();
            Arrays.sort(ch); // sort characters
            String key = new String(ch); // correct way (instead of ch.toString())

            map.computeIfAbsent(key, k -> new ArrayList<>()).add(word);
        }

        // Collect grouped anagrams into result
        List<List<String>> ans = new ArrayList<>(map.values());

        System.out.println(ans);
    }
}


1Ô∏è‚É£8Ô∏è‚É£Design a simple LRU Cache with a fixed capacity using LinkedHashMap. It should support:
get(key) ‚Üí returns value if exists, else -1.
put(key, value) ‚Üí inserts or updates the key. If capacity is full, remove the least recently used entry.

‚úÖ Solution:
package collections;

import java.util.*;

class LRUCache<K, V> extends LinkedHashMap<K, V> {
    private final int capacity;

    public LRUCache(int capacity) {
        // true = access-order (not insertion order)
        super(capacity, 0.75f, true);
        this.capacity = capacity;
    }

    @Override
    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
        return size() > capacity;
    }
}

public class Program3 {
    public static void main(String[] args) {
        LRUCache<Integer, String> cache = new LRUCache<>(3);

        cache.put(1, "A");
        cache.put(2, "B");
        cache.put(3, "C");
        System.out.println(cache); // {1=A, 2=B, 3=C}

        cache.get(1);              // Access 1 -> makes it most recently used
        cache.put(4, "D");         // Removes 2 (least recently used)
        System.out.println(cache); // {3=C, 1=A, 4=D}

        cache.put(5, "E");         // Removes 3
        System.out.println(cache); // {1=A, 4=D, 5=E}
    }
}


1Ô∏è‚É£9Ô∏è‚É£ Given an array of integers, find the 2 most frequent elements using a HashMap and a heap/priority queue.
‚úÖ Example:
Input: [1,1,1,2,2,3]
Output: [1,2]

package collections;

import java.util.*;

class Pair {
    int freq;
    int num;

    public Pair(int freq, int num) {
        this.freq = freq;
        this.num = num;
    }
}

public class Program1 {
    public static void main(String[] args) {
        List<Integer> list1 = Arrays.asList(1, 1, 1, 2, 2, 3);

        // Count frequencies
        Map<Integer, Integer> freqMap = new HashMap<>();
        for (int num : list1) {
            freqMap.put(num, freqMap.getOrDefault(num, 0) + 1);
        }

        // Max-Heap based on frequency
        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> b.freq - a.freq);

        for (Map.Entry<Integer, Integer> entry : freqMap.entrySet()) {
            pq.add(new Pair(entry.getValue(), entry.getKey()));
        }

        // Get most frequent
        if (!pq.isEmpty()) {
            System.out.println("Most frequent element: " + pq.peek().num);
            pq.poll();
        }

        // Get second most frequent
        if (!pq.isEmpty()) {
            System.out.println("Second most frequent element: " + pq.peek().num);
        }
    }
}


2Ô∏è‚É£0Ô∏è‚É£ Given a list of Employee(id, name, age, salary) objects, sort them by:
salary descending,
if salary is same ‚Üí age ascending,
if age also same ‚Üí name alphabetical.
Print the sorted list.

2Ô∏è‚É£1Ô∏è‚É£ Given a list of integers and a target K, find if there exists a subarray whose sum equals K.
Example:

Input: [1, 2, 3, 7, 5], K=12
Output: true   (because 2+3+7 = 12)
