1ï¸âƒ£ Filtering Even Numbers
Given a list of integers, use Streams to filter only even numbers and collect them into a list.
ğŸ‘‰ Input: [1, 2, 3, 4, 5, 6]
ğŸ‘‰ Output: [2, 4, 6]

âœ… Solution: 
list.stream()
    .filter(x -> x % 2 == 0)
    .forEach(System.out::println);

2ï¸âƒ£ Convert Strings to Uppercase
Given a list of strings, convert each string to uppercase using Streams.
ğŸ‘‰ Input: ["java", "stream", "exercise"]
ğŸ‘‰ Output: ["JAVA", "STREAM", "EXERCISE"]

âœ… Solution:
list1.stream()
    .map(String::toUpperCase)
    .forEach(System.out::println);


3ï¸âƒ£Square and Collect
Given a list of integers, square each number and collect them into a set (to remove duplicates).
ğŸ‘‰ Input: [1, 2, 2, 3]
ğŸ‘‰ Output: [1, 4, 9]

âœ… Solution 1:
Set<Integer> squares = numbers.stream()
                              .map(x -> x * x)
                              .collect(Collectors.toSet());

âœ… Solution 2:If order matters (e.g., interviewer asks for sorted unique squares), you can collect into a TreeSet:
Set<Integer> squares = numbers.stream()
                              .map(x -> x * x)
                              .collect(Collectors.toCollection(TreeSet::new));

âœ… Solution 3: If dealing with large numbers, use mapToInt for efficiency:
Set<Integer> squares = numbers.stream()
                              .mapToInt(x -> x * x)
                              .boxed()
                              .collect(Collectors.toSet());


4ï¸âƒ£Distinct & Sorted Words
Given a list of words, print all distinct words in sorted order using streams.
ğŸ‘‰ Input: ["java", "code", "java", "stream", "code"]
ğŸ‘‰ Output: ["code", "java", "stream"]

âœ… Solution 1:
Set<String> str = list.stream()
                      .collect(Collectors.toCollection(TreeSet::new));

âœ… Solution 2:
Set<String> distinct = list.stream()
                           .distinct()
                           .sorted()
                           .collect(Collectors.toSet());

âœ… Solution 3:ğŸ’¡ For case-insensitive sorting, you can supply a comparator:
Set<String> str = list.stream()
                      .map(String::toLowerCase)
                      .collect(Collectors.toCollection(() -> new TreeSet<>(String.CASE_INSENSITIVE_ORDER)));

5ï¸âƒ£Sum of Squares of Odd Numbers
Given a list of integers, use streams to compute the sum of squares of only odd numbers.
ğŸ‘‰ Input: [1, 2, 3, 4, 5]
ğŸ‘‰ Output: 35 (1^2 + 3^2 + 5^2 = 35)

âœ… Solution:
int sum = numbers.stream()
                 .filter(x -> x % 2 != 0)
                 .map(x -> x * x)
                 .reduce(0, Integer::sum);

âœ… Solution 2:
int sum = list.stream()
              .filter(x -> x % 2 != 0)
              .map(x -> x * x)
              .collect(Collectors.summingInt(Integer::intValue));

âœ… Solution 3:
int sum = list.stream()
              .filter(x -> x % 2 != 0)
              .mapToInt(x -> x * x)
              .sum();


6ï¸âƒ£Find the Longest String
Given a list of strings, use streams to find the longest string.
(If multiple strings have the same length, return any one of them.)
ğŸ‘‰ Input: ["java", "stream", "exercise", "api"]
ğŸ‘‰ Output: "exercise"

âœ… Solution 1: Get any one longest string in the list
String longest = list.stream()
                      .max(Comparator.comparing(String::length))
                      .orElse(null);

âœ… Solution 2:To get all string of maxLength
int maxLength = list.stream()
                    .mapToInt(String::length)
                    .max()
                    .orElse(0);

List<String> longestStrings = list.stream()
                                  .filter(s -> s.length() == maxLength)
                                  .toList();

7ï¸âƒ£ Count Word Occurrences
Given a list of words, use streams to count how many times each word occurs.
ğŸ‘‰ Input: ["apple", "banana", "apple", "orange", "banana", "apple"]
ğŸ‘‰ Output: {apple=3, banana=2, orange=1}

âœ… Solution 1:
Map<Object, Long> freq = fruits.stream()
    .collect(Collectors.groupingBy(w -> w, Collectors.counting()));

â¤ This is correct but unsorted.

âœ… Solution 2: Use TreeMap (Sorted by Key Automatically)
Map<String, Long> freq = fruits.stream()
    .collect(Collectors.groupingBy(w -> w, TreeMap::new, Collectors.counting()));

â¤ Here TreeMap is provided as the map supplier â†’ gives you natural key ordering.

ğŸ‘‰ Output for ["apple", "banana", "apple", "orange", "banana", "apple"]:
{apple=3, banana=2, orange=1} (keys sorted alphabetically).


8ï¸âƒ£Partition Numbers into Even and Odd
Given a list of integers, partition them into evens and odds using streams.
ğŸ‘‰ Input: [1, 2, 3, 4, 5, 6]
ğŸ‘‰ Output: {false=[1, 3, 5], true=[2, 4, 6]}
(where true = even, false = odd)

âœ… Solution 1:
Map<Boolean, List<Integer>> freq = fruits.stream()
        .collect(Collectors.partitioningBy(x -> x % 2 == 0));
âœ…Output: {false=[1, 3, 5], true=[2, 4, 6]}

âœ… Solution 2: If you want counts instead of lists, you can do:
Map<Boolean, Long> partitionedCount = fruits.stream()
        .collect(Collectors.partitioningBy(x -> x % 2 == 0, Collectors.counting()));
âœ…Output: {false=3, true=3}


9ï¸âƒ£ Find the Most Frequent Character in a String
Given a string, use streams to find the character with the maximum frequency.
ğŸ‘‰ Input: "banana"
ğŸ‘‰ Output: a (since a appears 3 times)

âœ… Solution 1:
Character mostFrequent = input.chars() // IntStream of Unicode values
            .mapToObj(c -> (char) c)          // convert int to Character
            .collect(Collectors.groupingBy(Function.identity(), Collectors.counting())) // count frequency
            .entrySet().stream()
            .max(Map.Entry.comparingByValue()) // find entry with max frequency
            .map(Map.Entry::getKey)            // extract the character
            .orElse(null);                     // handle empty string case

1ï¸âƒ£0ï¸âƒ£ Given a list of strings, join them into a single comma-separated string using streams.
ğŸ‘‰ Input: ["apple", "banana", "orange"]
ğŸ‘‰ Output: "apple, banana, orange"

âœ… Solution:
String joinedFruits = fruits.stream()
                   .collect(Collectors.joining(", "));


1ï¸âƒ£1ï¸âƒ£ Given a list of names, group them based on their length.
ğŸ‘‰ Input: ["Tom", "Jerry", "John", "Alex", "Bob"]
ğŸ‘‰ Output: {3=[Tom, Bob], 4=[John, Alex], 5=[Jerry]}

âœ… Solution:
Map<Integer, List<String>> ans = persons.stream()
                                        .collect(Collectors.groupingBy(String::length));

ğŸ‘‰ Improvement (only if you want sorted keys):
Map<Integer, List<String>> ans = persons.stream()
    .collect(Collectors.groupingBy(String::length, TreeMap::new, Collectors.toList()));

1ï¸âƒ£2ï¸âƒ£ You have a list of students with their subject and score. Use streams to find the top scorer per subject.
ğŸ‘‰ Input (Student class with name, subject, score):
[("Alice", "Math", 90), 
 ("Bob", "Math", 85), 
 ("Charlie", "Science", 95), 
 ("David", "Science", 80)]

ğŸ‘‰ Output:{Math=Alice, Science=Charlie}

âœ… Solution:
package stream;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class Student {
 String name;
 String subject;
 int marks;

 public Student(String name, String subject, int marks) {
	this.name = name;
	this.subject = subject;
	this.marks = marks;
}

public String getName() {
	return name;
}
 public void setName(String name) {
	this.name = name;
 }
 public String getSubject() {
	return subject;
 }
 public void setSubject(String subject) {
	this.subject = subject;
 }
 public int getMarks() {
	return marks;
 }
 public void setMarks(int marks) {
	this.marks = marks;
 }

public static void main(String[] args) {
List<Student>student=new ArrayList<>();
student.add(new Student("Alice","Math",90));
student.add(new Student("Bob","Math",85));
student.add(new Student("Charlie","Science",95));
student.add(new Student("David","Science",80));

Map<String, Student> topStudentBySubject = student.stream()
    .collect(Collectors.groupingBy(
        Student::getSubject,
        Collectors.collectingAndThen(
            Collectors.maxBy(Comparator.comparingInt(Student::getMarks)),
            Optional::get
        )
    ));

System.out.println(topStudentBySubject);
}
}


1ï¸âƒ£3ï¸âƒ£Top Performer by Marks
â¤ You are given a list of Student objects (name, subject, marks).
â¤ Find the student with the highest marks overall.

âœ… Solution:
package stream;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

public class Student{
	String name;
	String subject;
	int marks;
	
	public Student(String name, String subject, int marks) {
		super();
		this.name = name;
		this.subject = subject;
		this.marks = marks;
	}
	
	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getSubject() {
		return subject;
	}

	public void setSubject(String subject) {
		this.subject = subject;
	}

	public int getMarks() {
		return marks;
	}

	public void setMarks(int marks) {
		this.marks = marks;
	}

	public static void main(String[] args) {
		List<Student> student=new ArrayList<>();
		student.add(new Student("Ankur","Maths",99));
		student.add(new Student("Deepak","CS",100));
		student.add(new Student("Isha","Chemistry",101));
		
		Optional<Student> topStudent = student.stream().collect(Collectors.maxBy((Student s1,Student s2)->s1.getMarks()-s2.getMarks()));
		if(topStudent.isPresent()) {
			System.out.println(topStudent.get().getName());
		}
		
    }
}

ğŸ”„ Possible Improvements
ğŸ‘‰ Use Comparator.comparingInt â†’ makes code more readable and less error-prone (avoids subtraction overflow in general).

Optional<Student> topStudent = student.stream()
        .collect(Collectors.maxBy(
            java.util.Comparator.comparingInt(Student::getMarks)
        ));

ğŸ‘‰ Print directly with ifPresent (avoids explicit isPresent + get()):
topStudent.ifPresent(s -> System.out.println(s.getName()));


1ï¸âƒ£4ï¸âƒ£Top Student in Each Subject
â¤ From the same Student list, find the student with the maximum marks in each subject.
â¤ (Basically what you attempted yesterday, but now youâ€™ll write the clean final solution).

âœ… Solution:
package stream;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

public class Student{
	String name;
	String subject;
	int marks;
	
	public Student(String name, String subject, int marks) {
		this.name = name;
		this.subject = subject;
		this.marks = marks;
	}
	
	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getSubject() {
		return subject;
	}

	public void setSubject(String subject) {
		this.subject = subject;
	}

	public int getMarks() {
		return marks;
	}

	public void setMarks(int marks) {
		this.marks = marks;
	}

	public static void main(String[] args) {
		List<Student> student=new ArrayList<>();
		student.add(new Student("Ankur","Maths",99));
		student.add(new Student("Deepak","CS",100));
		student.add(new Student("Isha","Chemistry",101));
		
		Map<String, Student> topStudent = student.stream().
		collect(Collectors.groupingBy(Student::getSubject,Collectors.collectingAndThen(Collectors.maxBy(Comparator.comparingInt(Student::getMarks)), Optional::get))
				);
		
		for(Entry<String, Student>s :topStudent.entrySet()) {
			System.out.println("Subject is "+s.getKey() +" marks is "+s.getValue().getMarks());
		}	
	}
}

ğŸ”„ Improvements
âœ”ï¸ Instead of a for loop, you could also use forEach on the map for cleaner code:

topStudent.forEach((subject, stud) -> 
    System.out.println("Subject: " + subject + ", Topper: " + stud.getName() + " with marks " + stud.getMarks())
);

âœ”ï¸ If you ever want to make it null-safe (in case of empty student list), you could avoid Optional::get and handle Optional<Student> directly

1ï¸âƒ£5ï¸âƒ£Average Marks by Subject
â¤ Group students by subject and compute the average marks for each subject.

âœ… Solution:
package stream;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

public class Student{
	String name;
	String subject;
	int marks;
	
	public Student(String name, String subject, int marks) {
		super();
		this.name = name;
		this.subject = subject;
		this.marks = marks;
	}
	
	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getSubject() {
		return subject;
	}

	public void setSubject(String subject) {
		this.subject = subject;
	}

	public int getMarks() {
		return marks;
	}

	public void setMarks(int marks) {
		this.marks = marks;
	}

	public static void main(String[] args) {
		List<Student> student=new ArrayList<>();
		student.add(new Student("Ankur","Maths",99));
		student.add(new Student("Deepak","CS",100));
		student.add(new Student("Isha","Chemistry",101));
		
		Map<String, Double> topStudent = student.stream().
		collect(Collectors.groupingBy(Student::getSubject,Collectors.averagingInt(Student::getMarks)));
		for(Entry<String, Double> s :topStudent.entrySet()) {
			System.out.println("Subject is "+s.getKey() +" marks is "+s.getValue());
		}	
    }	
}

1ï¸âƒ£6ï¸âƒ£You have a list of Student(name, subject, marks).
Find the number of students in each subject.

âœ… Solution:
package stream;

public class Student {
	String name;
	String subject;
	int marks;
	public Student(String name, String subject, int marks) {
		super();
		this.name = name;
		this.subject = subject;
		this.marks = marks;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getSubject() {
		return subject;
	}
	public void setSubject(String subject) {
		this.subject = subject;
	}
	public int getMarks() {
		return marks;
	}
	public void setMarks(int marks) {
		this.marks = marks;
	}
}

public class Solution{
	public static void main(String[] args) {
		List<Student> students = new ArrayList<>();
		students.add(new Student("Ankur", "Maths", 95));
		students.add(new Student("Deepak", "CS", 88));
		students.add(new Student("Isha", "Chemistry", 91));
		students.add(new Student("Ravi", "Maths", 76));
		students.add(new Student("Neha", "CS", 92));
		students.add(new Student("Aman", "Physics", 85));
		students.add(new Student("Pooja", "Chemistry", 99));
		students.add(new Student("Karan", "Maths", 89));
		students.add(new Student("Sneha", "Physics", 94));
		students.add(new Student("Rahul", "CS", 97));
		
		Map<String, Long> studentWithCount = students.stream().collect(Collectors.groupingBy(Student::getSubject,Collectors.counting()));
		
		System.out.println(studentWithCount);
	}
}

1ï¸âƒ£7ï¸âƒ£From the same list, group students by subject and collect only their names into a list.

âœ… Solution:
Map<String, List<String>> namesBySubject = students.stream()
        .collect(Collectors.groupingBy(
            Student::getSubject,
            Collectors.mapping(Student::getName, Collectors.toList())
        ));


1ï¸âƒ£8ï¸âƒ£Find the top 2 students with the highest marks overall (not grouped by subject).

âœ… Solution:
List<String> top2Students = students.stream()
				.sorted(java.util.Comparator.comparing(Student::getMarks)
			    .reversed())
				.limit(2).collect(Collectors.mapping(Student::getName, Collectors.toList()));

âœ…Solution 2: Cleaner Code
List<String> top2Students = students.stream()
        .sorted(Comparator.comparingInt(Student::getMarks).reversed())
        .limit(2)
        .map(Student::getName) 
        .collect(Collectors.toList());

System.out.println(top2Students);


1ï¸âƒ£9ï¸âƒ£ Employees by Department
â¤ You have a list of Employee(name, department, salary).
â¤ Group employees by department and list all employee names in each department.

âœ… Solution:
package stream;

import java.util.*;
import java.util.Map.Entry;
import java.util.stream.Collectors;

class Employee {
    private String name;
    private String department;
    private double salary;

    public Employee(String name, String department, double salary) {
        this.name = name;
        this.department = department;
        this.salary = salary;
    }

    public String getName() {
        return name;
    }
    public String getDepartment() {
        return department;
    }
    public double getSalary() {
        return salary;
    }

    @Override
    public String toString() {
        return name + " (" + department + ", " + salary + ")";
    }
}

public class Solution{
	public static void main(String[] args) {
		List<Employee> employees = Arrays.asList(
			    new Employee("Alice", "IT", 75000),
			    new Employee("Bob", "IT", 82000),
			    new Employee("Charlie", "HR", 60000),
			    new Employee("David", "Finance", 90000),
			    new Employee("Eva", "HR", 65000),
			    new Employee("Frank", "Finance", 88000),
			    new Employee("Grace", "IT", 95000),
			    new Employee("Hannah", "Finance", 70000),
			    new Employee("Ian", "HR", 72000),
			    new Employee("Jack", "IT", 78000)
			);
			
		 employees.stream().collect(Collectors
				 .groupingBy(Employee::getDepartment))
		 .entrySet().forEach(entry->{
			 System.out.println("Department: "+ entry.getKey());
			 entry.getValue().forEach(System.out::println);
		        System.out.println();
		 });	
	}
}

2ï¸âƒ£0ï¸âƒ£ Highest Salary per Department
â¤ From the same list, find the employee with the maximum salary in each department.

âœ… Solution:
employees.stream()
    .collect(Collectors.groupingBy(
        Employee::getDepartment,
        Collectors.collectingAndThen(
            Collectors.maxBy(Comparator.comparing(Employee::getSalary)),
            Optional::get
        )))
    .forEach((dept, emp) -> {
        System.out.println("Department: " + dept);
        System.out.println("Highest Paid: " + emp.getName() + " with salary " + emp.getSalary());
        System.out.println();
    });


2ï¸âƒ£1ï¸âƒ£ Department-wise Average Salary
â¤ Compute the average salary of employees in each department.

âœ… Solution:
employees.stream()
    .collect(Collectors.groupingBy(
        Employee::getDepartment,
        Collectors.averagingDouble(Employee::getSalary)
    ))
    .forEach((dept, avgSalary) -> {
        System.out.println("Department: " + dept + ", Average Salary: " + avgSalary);
    });


2ï¸âƒ£2ï¸âƒ£ Transaction Amounts by Type
â¤ You have a list of Transaction(id, type, amount) where type = "CREDIT" or "DEBIT".
â¤ Compute the total amount of CREDIT and DEBIT transactions separately.

âœ… Solution:
transactions.stream()
    .collect(Collectors.groupingBy(Transaction::getType,
            Collectors.summingDouble(Transaction::getAmount)))
    .forEach((type, amount) -> 
        System.out.println("Type is: " + type + " Amount is: " + amount));


2ï¸âƒ£3ï¸âƒ£ Top 3 Highest Transactions
â¤ Find the top 3 transactions by amount.

âœ… Solution:
 transactions.stream()
        .sorted(Comparator.comparingDouble(Transaction::getAmount)
        		.reversed()).limit(3)
        .forEach(e->System.out.println(e.getAmount()));;

2ï¸âƒ£4ï¸âƒ£ Transactions Above a Threshold
â¤ Given a threshold (e.g., 5000), get the list of transaction IDs whose amount is greater than the threshold.

âœ… Solution:
transactions.stream()
    .filter(e -> e.getAmount() > 5000)                  // keep only transactions > 5000
    .map(e -> e.getCustomerName())                      // extract customer names
    .toList().stream()                                  // convert to list, then stream again âŒ (unnecessary step)
    .distinct()                                         // remove duplicates
    .forEach(System.out::println);                      // print unique customer names


âš ï¸ Minor Improvement
Donâ€™t need .toList().stream(). You can directly chain distinct() after map().

transactions.stream()
    .filter(e -> e.getAmount() > 5000)
    .map(Transaction::getCustomerName)
    .distinct()
    .forEach(System.out::println);


2ï¸âƒ£5ï¸âƒ£ Employee Salary Raise
Given a list of Employee objects (name, department, salary), create a new list of employees where each employee in the "IT" department gets a 10% salary hike, and print the updated list.

âœ… Solution:
List<Employee> employees = Arrays.asList(
    		    new Employee("Alice", "IT", 75000),
    		    new Employee("Bob", "IT", 82000),
    		    new Employee("Charlie", "HR", 60000),
    		    new Employee("David", "Finance", 90000),
    		    new Employee("Eva", "HR", 65000),
    		    new Employee("Frank", "Finance", 88000),
    		    new Employee("Grace", "IT", 95000),
    		    new Employee("Hannah", "Finance", 70000),
    		    new Employee("Ian", "HR", 72000),
    		    new Employee("Jack", "IT", 78000)
    		);

       employees.stream()
       .filter(e->e.getDepartment().contains("IT"))
       .map(e->{
    	   e.setSalary(e.getSalary()+0.1*e.getSalary());
    	   return e;
       }).forEach(System.out::println);  


2ï¸âƒ£6ï¸âƒ£ Longest String in a List
Given a list of strings, use streams to find the longest string in the list. If there are multiple with the same length, return any one of them.

âœ… Solution:
String maxWord = words.stream()
    			.collect(Collectors
    					.maxBy(Comparator.comparing(String::length)))
    			.get();

â¤ Collectors.maxBy(Comparator.comparing(String::length)) is valid.
â¤ .get() gives you the longest string.

âš ï¸ Issues
â¤ .collect(Collectors.maxBy(...)) returns an Optional<String>, and you are calling .get() directly.
â¤ If the list is empty, .get() will throw NoSuchElementException.

ğŸ”„ Minor Improvement
String maxWord = words.stream()
        .max(Comparator.comparing(String::length))
        .orElse("No words found");


2ï¸âƒ£7ï¸âƒ£ Transaction Analysis
Given a list of Transaction objects (id, customerName, type, amount), find the average transaction amount for each transaction type.

âœ… Solution:
  transactions.stream()
        .collect(Collectors.groupingBy(Transaction::getType, Collectors.averagingDouble(Transaction::getAmount)))
        .forEach((type,avgSalary)-> System.out.println("Type is: "+type+" Average Salary is: "+avgSalary));


2ï¸âƒ£8ï¸âƒ£Employee Department Stats
Given a list of Employee objects (name, department, salary), find the average salary per department, and print the result.

âœ… Solution:
employees.stream()
            .collect(Collectors.groupingBy(
                Employee::getDepartment,
                Collectors.averagingDouble(Employee::getSalary)
            ))
            .forEach((department, avgSalary) -> {
                System.out.println("Department: " + department + " | Avg Salary: " + avgSalary);
            });

2ï¸âƒ£9ï¸âƒ£String Frequency (Sorted)
Given a list of strings, count the frequency of each string and return the result sorted by frequency in descending order.

âœ… Solution:
  	words.stream()
        .collect(Collectors.groupingBy(word -> word, Collectors.counting())) // count frequency
        .entrySet().stream()
        .sorted(Map.Entry.<String, Long>comparingByValue(Comparator.reverseOrder())) 
        .forEach(entry -> System.out.println(entry.getKey() + " -> " + entry.getValue()));

3ï¸âƒ£0ï¸âƒ£Top Customer by Transaction Amount
Given a list of Transaction objects (id, customerName, type, amount), find the customer who spent the highest total amount (summing all their transactions).

String key = transactions.stream()
    .collect(Collectors.groupingBy(Transaction::getCustomerName, Collectors.summingDouble(Transaction::getAmount))) // total amount per customer
    .entrySet().stream()
    .sorted(Map.Entry.comparingByValue(Comparator.reverseOrder())) // sort by total amount desc
    .findFirst().get() // pick top customer
    .getKey(); // extract customer name

System.out.println(key);
