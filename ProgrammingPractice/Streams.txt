1️⃣ Filtering Even Numbers
Given a list of integers, use Streams to filter only even numbers and collect them into a list.
👉 Input: [1, 2, 3, 4, 5, 6]
👉 Output: [2, 4, 6]

✅ Solution: 
list.stream()
    .filter(x -> x % 2 == 0)
    .forEach(System.out::println);

2️⃣ Convert Strings to Uppercase
Given a list of strings, convert each string to uppercase using Streams.
👉 Input: ["java", "stream", "exercise"]
👉 Output: ["JAVA", "STREAM", "EXERCISE"]

✅ Solution:
list1.stream()
    .map(String::toUpperCase)
    .forEach(System.out::println);


3️⃣Square and Collect
Given a list of integers, square each number and collect them into a set (to remove duplicates).
👉 Input: [1, 2, 2, 3]
👉 Output: [1, 4, 9]

✅ Solution 1:
Set<Integer> squares = numbers.stream()
                              .map(x -> x * x)
                              .collect(Collectors.toSet());

✅ Solution 2:If order matters (e.g., interviewer asks for sorted unique squares), you can collect into a TreeSet:
Set<Integer> squares = numbers.stream()
                              .map(x -> x * x)
                              .collect(Collectors.toCollection(TreeSet::new));

✅ Solution 3: If dealing with large numbers, use mapToInt for efficiency:
Set<Integer> squares = numbers.stream()
                              .mapToInt(x -> x * x)
                              .boxed()
                              .collect(Collectors.toSet());


4️⃣Distinct & Sorted Words
Given a list of words, print all distinct words in sorted order using streams.
👉 Input: ["java", "code", "java", "stream", "code"]
👉 Output: ["code", "java", "stream"]

✅ Solution 1:
Set<String> str = list.stream()
                      .collect(Collectors.toCollection(TreeSet::new));

✅ Solution 2:
Set<String> distinct = list.stream()
                           .distinct()
                           .sorted()
                           .collect(Collectors.toSet());

✅ Solution 3:💡 For case-insensitive sorting, you can supply a comparator:
Set<String> str = list.stream()
                      .map(String::toLowerCase)
                      .collect(Collectors.toCollection(() -> new TreeSet<>(String.CASE_INSENSITIVE_ORDER)));

5️⃣Sum of Squares of Odd Numbers
Given a list of integers, use streams to compute the sum of squares of only odd numbers.
👉 Input: [1, 2, 3, 4, 5]
👉 Output: 35 (1^2 + 3^2 + 5^2 = 35)

✅ Solution:
int sum = numbers.stream()
                 .filter(x -> x % 2 != 0)
                 .map(x -> x * x)
                 .reduce(0, Integer::sum);

✅ Solution 2:
int sum = list.stream()
              .filter(x -> x % 2 != 0)
              .map(x -> x * x)
              .collect(Collectors.summingInt(Integer::intValue));

✅ Solution 3:
int sum = list.stream()
              .filter(x -> x % 2 != 0)
              .mapToInt(x -> x * x)
              .sum();


6️⃣Find the Longest String
Given a list of strings, use streams to find the longest string.
(If multiple strings have the same length, return any one of them.)
👉 Input: ["java", "stream", "exercise", "api"]
👉 Output: "exercise"

✅ Solution 1: Get any one longest string in the list
String longest = list.stream()
                      .max(Comparator.comparing(String::length))
                      .orElse(null);

✅ Solution 2:To get all string of maxLength
int maxLength = list.stream()
                    .mapToInt(String::length)
                    .max()
                    .orElse(0);

List<String> longestStrings = list.stream()
                                  .filter(s -> s.length() == maxLength)
                                  .toList();

7️⃣ Count Word Occurrences
Given a list of words, use streams to count how many times each word occurs.
👉 Input: ["apple", "banana", "apple", "orange", "banana", "apple"]
👉 Output: {apple=3, banana=2, orange=1}

✅ Solution 1:
Map<Object, Long> freq = fruits.stream()
    .collect(Collectors.groupingBy(w -> w, Collectors.counting()));

➤ This is correct but unsorted.

✅ Solution 2: Use TreeMap (Sorted by Key Automatically)
Map<String, Long> freq = fruits.stream()
    .collect(Collectors.groupingBy(w -> w, TreeMap::new, Collectors.counting()));

➤ Here TreeMap is provided as the map supplier → gives you natural key ordering.

👉 Output for ["apple", "banana", "apple", "orange", "banana", "apple"]:
{apple=3, banana=2, orange=1} (keys sorted alphabetically).


8️⃣Partition Numbers into Even and Odd
Given a list of integers, partition them into evens and odds using streams.
👉 Input: [1, 2, 3, 4, 5, 6]
👉 Output: {false=[1, 3, 5], true=[2, 4, 6]}
(where true = even, false = odd)

✅ Solution 1:
Map<Boolean, List<Integer>> freq = fruits.stream()
        .collect(Collectors.partitioningBy(x -> x % 2 == 0));
✅Output: {false=[1, 3, 5], true=[2, 4, 6]}

✅ Solution 2: If you want counts instead of lists, you can do:
Map<Boolean, Long> partitionedCount = fruits.stream()
        .collect(Collectors.partitioningBy(x -> x % 2 == 0, Collectors.counting()));
✅Output: {false=3, true=3}


9️⃣ Find the Most Frequent Character in a String
Given a string, use streams to find the character with the maximum frequency.
👉 Input: "banana"
👉 Output: a (since a appears 3 times)

✅ Solution 1:
Character mostFrequent = input.chars() // IntStream of Unicode values
            .mapToObj(c -> (char) c)          // convert int to Character
            .collect(Collectors.groupingBy(Function.identity(), Collectors.counting())) // count frequency
            .entrySet().stream()
            .max(Map.Entry.comparingByValue()) // find entry with max frequency
            .map(Map.Entry::getKey)            // extract the character
            .orElse(null);                     // handle empty string case

