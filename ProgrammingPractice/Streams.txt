1ï¸âƒ£ Filtering Even Numbers
Given a list of integers, use Streams to filter only even numbers and collect them into a list.
ğŸ‘‰ Input: [1, 2, 3, 4, 5, 6]
ğŸ‘‰ Output: [2, 4, 6]

âœ… Solution: 
list.stream()
    .filter(x -> x % 2 == 0)
    .forEach(System.out::println);

2ï¸âƒ£ Convert Strings to Uppercase
Given a list of strings, convert each string to uppercase using Streams.
ğŸ‘‰ Input: ["java", "stream", "exercise"]
ğŸ‘‰ Output: ["JAVA", "STREAM", "EXERCISE"]

âœ… Solution:
list1.stream()
    .map(String::toUpperCase)
    .forEach(System.out::println);


3ï¸âƒ£Square and Collect
Given a list of integers, square each number and collect them into a set (to remove duplicates).
ğŸ‘‰ Input: [1, 2, 2, 3]
ğŸ‘‰ Output: [1, 4, 9]

âœ… Solution 1:
Set<Integer> squares = numbers.stream()
                              .map(x -> x * x)
                              .collect(Collectors.toSet());

âœ… Solution 2:If order matters (e.g., interviewer asks for sorted unique squares), you can collect into a TreeSet:
Set<Integer> squares = numbers.stream()
                              .map(x -> x * x)
                              .collect(Collectors.toCollection(TreeSet::new));

âœ… Solution 3: If dealing with large numbers, use mapToInt for efficiency:
Set<Integer> squares = numbers.stream()
                              .mapToInt(x -> x * x)
                              .boxed()
                              .collect(Collectors.toSet());


4ï¸âƒ£Distinct & Sorted Words
Given a list of words, print all distinct words in sorted order using streams.
ğŸ‘‰ Input: ["java", "code", "java", "stream", "code"]
ğŸ‘‰ Output: ["code", "java", "stream"]

âœ… Solution 1:
Set<String> str = list.stream()
                      .collect(Collectors.toCollection(TreeSet::new));

âœ… Solution 2:
Set<String> distinct = list.stream()
                           .distinct()
                           .sorted()
                           .collect(Collectors.toSet());

âœ… Solution 3:ğŸ’¡ For case-insensitive sorting, you can supply a comparator:
Set<String> str = list.stream()
                      .map(String::toLowerCase)
                      .collect(Collectors.toCollection(() -> new TreeSet<>(String.CASE_INSENSITIVE_ORDER)));

5ï¸âƒ£Sum of Squares of Odd Numbers
Given a list of integers, use streams to compute the sum of squares of only odd numbers.
ğŸ‘‰ Input: [1, 2, 3, 4, 5]
ğŸ‘‰ Output: 35 (1^2 + 3^2 + 5^2 = 35)

âœ… Solution:
int sum = numbers.stream()
                 .filter(x -> x % 2 != 0)
                 .map(x -> x * x)
                 .reduce(0, Integer::sum);

âœ… Solution 2:
int sum = list.stream()
              .filter(x -> x % 2 != 0)
              .map(x -> x * x)
              .collect(Collectors.summingInt(Integer::intValue));

âœ… Solution 3:
int sum = list.stream()
              .filter(x -> x % 2 != 0)
              .mapToInt(x -> x * x)
              .sum();


6ï¸âƒ£Find the Longest String
Given a list of strings, use streams to find the longest string.
(If multiple strings have the same length, return any one of them.)
ğŸ‘‰ Input: ["java", "stream", "exercise", "api"]
ğŸ‘‰ Output: "exercise"

âœ… Solution 1: Get any one longest string in the list
String longest = list.stream()
                      .max(Comparator.comparing(String::length))
                      .orElse(null);

âœ… Solution 2:To get all string of maxLength
int maxLength = list.stream()
                    .mapToInt(String::length)
                    .max()
                    .orElse(0);

List<String> longestStrings = list.stream()
                                  .filter(s -> s.length() == maxLength)
                                  .toList();

7ï¸âƒ£ Count Word Occurrences
Given a list of words, use streams to count how many times each word occurs.
ğŸ‘‰ Input: ["apple", "banana", "apple", "orange", "banana", "apple"]
ğŸ‘‰ Output: {apple=3, banana=2, orange=1}

âœ… Solution 1:
Map<Object, Long> freq = fruits.stream()
    .collect(Collectors.groupingBy(w -> w, Collectors.counting()));

â¤ This is correct but unsorted.

âœ… Solution 2: Use TreeMap (Sorted by Key Automatically)
Map<String, Long> freq = fruits.stream()
    .collect(Collectors.groupingBy(w -> w, TreeMap::new, Collectors.counting()));

â¤ Here TreeMap is provided as the map supplier â†’ gives you natural key ordering.

ğŸ‘‰ Output for ["apple", "banana", "apple", "orange", "banana", "apple"]:
{apple=3, banana=2, orange=1} (keys sorted alphabetically).


8ï¸âƒ£Partition Numbers into Even and Odd
Given a list of integers, partition them into evens and odds using streams.
ğŸ‘‰ Input: [1, 2, 3, 4, 5, 6]
ğŸ‘‰ Output: {false=[1, 3, 5], true=[2, 4, 6]}
(where true = even, false = odd)

âœ… Solution 1:
Map<Boolean, List<Integer>> freq = fruits.stream()
        .collect(Collectors.partitioningBy(x -> x % 2 == 0));
âœ…Output: {false=[1, 3, 5], true=[2, 4, 6]}

âœ… Solution 2: If you want counts instead of lists, you can do:
Map<Boolean, Long> partitionedCount = fruits.stream()
        .collect(Collectors.partitioningBy(x -> x % 2 == 0, Collectors.counting()));
âœ…Output: {false=3, true=3}


9ï¸âƒ£ Find the Most Frequent Character in a String
Given a string, use streams to find the character with the maximum frequency.
ğŸ‘‰ Input: "banana"
ğŸ‘‰ Output: a (since a appears 3 times)

âœ… Solution 1:
Character mostFrequent = input.chars() // IntStream of Unicode values
            .mapToObj(c -> (char) c)          // convert int to Character
            .collect(Collectors.groupingBy(Function.identity(), Collectors.counting())) // count frequency
            .entrySet().stream()
            .max(Map.Entry.comparingByValue()) // find entry with max frequency
            .map(Map.Entry::getKey)            // extract the character
            .orElse(null);                     // handle empty string case

1ï¸âƒ£0ï¸âƒ£ Given a list of strings, join them into a single comma-separated string using streams.
ğŸ‘‰ Input: ["apple", "banana", "orange"]
ğŸ‘‰ Output: "apple, banana, orange"

âœ… Solution:
String joinedFruits = fruits.stream()
                   .collect(Collectors.joining(", "));


1ï¸âƒ£1ï¸âƒ£ Given a list of names, group them based on their length.
ğŸ‘‰ Input: ["Tom", "Jerry", "John", "Alex", "Bob"]
ğŸ‘‰ Output: {3=[Tom, Bob], 4=[John, Alex], 5=[Jerry]}

âœ… Solution:
Map<Integer, List<String>> ans = persons.stream()
                                        .collect(Collectors.groupingBy(String::length));

ğŸ‘‰ Improvement (only if you want sorted keys):
Map<Integer, List<String>> ans = persons.stream()
    .collect(Collectors.groupingBy(String::length, TreeMap::new, Collectors.toList()));

1ï¸âƒ£2ï¸âƒ£ You have a list of students with their subject and score. Use streams to find the top scorer per subject.
ğŸ‘‰ Input (Student class with name, subject, score):
[("Alice", "Math", 90), 
 ("Bob", "Math", 85), 
 ("Charlie", "Science", 95), 
 ("David", "Science", 80)]

ğŸ‘‰ Output:{Math=Alice, Science=Charlie}

âœ… Solution:
package stream;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class Student {
 String name;
 String subject;
 int marks;

 public Student(String name, String subject, int marks) {
	this.name = name;
	this.subject = subject;
	this.marks = marks;
}

public String getName() {
	return name;
}
 public void setName(String name) {
	this.name = name;
 }
 public String getSubject() {
	return subject;
 }
 public void setSubject(String subject) {
	this.subject = subject;
 }
 public int getMarks() {
	return marks;
 }
 public void setMarks(int marks) {
	this.marks = marks;
 }

public static void main(String[] args) {
List<Student>student=new ArrayList<>();
student.add(new Student("Alice","Math",90));
student.add(new Student("Bob","Math",85));
student.add(new Student("Charlie","Science",95));
student.add(new Student("David","Science",80));

Map<String, Student> topStudentBySubject = student.stream()
    .collect(Collectors.groupingBy(
        Student::getSubject,
        Collectors.collectingAndThen(
            Collectors.maxBy(Comparator.comparingInt(Student::getMarks)),
            Optional::get
        )
    ));

System.out.println(topStudentBySubject);
}
}


1ï¸âƒ£3ï¸âƒ£Top Performer by Marks
â¤ You are given a list of Student objects (name, subject, marks).
â¤ Find the student with the highest marks overall.

âœ… Solution:
package stream;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

public class Student{
	String name;
	String subject;
	int marks;
	
	public Student(String name, String subject, int marks) {
		super();
		this.name = name;
		this.subject = subject;
		this.marks = marks;
	}
	
	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getSubject() {
		return subject;
	}

	public void setSubject(String subject) {
		this.subject = subject;
	}

	public int getMarks() {
		return marks;
	}

	public void setMarks(int marks) {
		this.marks = marks;
	}

	public static void main(String[] args) {
		List<Student> student=new ArrayList<>();
		student.add(new Student("Ankur","Maths",99));
		student.add(new Student("Deepak","CS",100));
		student.add(new Student("Isha","Chemistry",101));
		
		Optional<Student> topStudent = student.stream().collect(Collectors.maxBy((Student s1,Student s2)->s1.getMarks()-s2.getMarks()));
		if(topStudent.isPresent()) {
			System.out.println(topStudent.get().getName());
		}
		
    }
}

ğŸ”„ Possible Improvements
ğŸ‘‰ Use Comparator.comparingInt â†’ makes code more readable and less error-prone (avoids subtraction overflow in general).

Optional<Student> topStudent = student.stream()
        .collect(Collectors.maxBy(
            java.util.Comparator.comparingInt(Student::getMarks)
        ));

ğŸ‘‰ Print directly with ifPresent (avoids explicit isPresent + get()):
topStudent.ifPresent(s -> System.out.println(s.getName()));


1ï¸âƒ£4ï¸âƒ£Top Student in Each Subject
â¤ From the same Student list, find the student with the maximum marks in each subject.
â¤ (Basically what you attempted yesterday, but now youâ€™ll write the clean final solution).

âœ… Solution:
package stream;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

public class Student{
	String name;
	String subject;
	int marks;
	
	public Student(String name, String subject, int marks) {
		this.name = name;
		this.subject = subject;
		this.marks = marks;
	}
	
	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getSubject() {
		return subject;
	}

	public void setSubject(String subject) {
		this.subject = subject;
	}

	public int getMarks() {
		return marks;
	}

	public void setMarks(int marks) {
		this.marks = marks;
	}

	public static void main(String[] args) {
		List<Student> student=new ArrayList<>();
		student.add(new Student("Ankur","Maths",99));
		student.add(new Student("Deepak","CS",100));
		student.add(new Student("Isha","Chemistry",101));
		
		Map<String, Student> topStudent = student.stream().
		collect(Collectors.groupingBy(Student::getSubject,Collectors.collectingAndThen(Collectors.maxBy(Comparator.comparingInt(Student::getMarks)), Optional::get))
				);
		
		for(Entry<String, Student>s :topStudent.entrySet()) {
			System.out.println("Subject is "+s.getKey() +" marks is "+s.getValue().getMarks());
		}	
	}
}

ğŸ”„ Improvements
âœ”ï¸ Instead of a for loop, you could also use forEach on the map for cleaner code:

topStudent.forEach((subject, stud) -> 
    System.out.println("Subject: " + subject + ", Topper: " + stud.getName() + " with marks " + stud.getMarks())
);

âœ”ï¸ If you ever want to make it null-safe (in case of empty student list), you could avoid Optional::get and handle Optional<Student> directly

1ï¸âƒ£5ï¸âƒ£Average Marks by Subject
â¤ Group students by subject and compute the average marks for each subject.

âœ… Solution:
package stream;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

public class Student{
	String name;
	String subject;
	int marks;
	
	public Student(String name, String subject, int marks) {
		super();
		this.name = name;
		this.subject = subject;
		this.marks = marks;
	}
	
	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getSubject() {
		return subject;
	}

	public void setSubject(String subject) {
		this.subject = subject;
	}

	public int getMarks() {
		return marks;
	}

	public void setMarks(int marks) {
		this.marks = marks;
	}

	public static void main(String[] args) {
		List<Student> student=new ArrayList<>();
		student.add(new Student("Ankur","Maths",99));
		student.add(new Student("Deepak","CS",100));
		student.add(new Student("Isha","Chemistry",101));
		
		Map<String, Double> topStudent = student.stream().
		collect(Collectors.groupingBy(Student::getSubject,Collectors.averagingInt(Student::getMarks)));
		for(Entry<String, Double> s :topStudent.entrySet()) {
			System.out.println("Subject is "+s.getKey() +" marks is "+s.getValue());
		}	
    }	
}
